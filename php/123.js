/**
 * Cesium - https://github.com/AnalyticalGraphicsInc/cesium
 *
 * Copyright 2011-2015 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md for full licensing details.
 */

/**
 @license
 mersenne-twister.js - https://gist.github.com/banksean/300494

 Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:

 1. Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in the
 documentation and/or other materials provided with the distribution.

 3. The names of its contributors may not be used to endorse or promote
 products derived from this software without specific prior written
 permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 @license
 sprintf.js from the php.js project - https://github.com/kvz/phpjs
 Directly from https://github.com/kvz/phpjs/blob/master/functions/strings/sprintf.js

 php.js is copyright 2012 Kevin van Zonneveld.

 Portions copyright Brett Zamir (http://brett-zamir.me), Kevin van Zonneveld
 (http://kevin.vanzonneveld.net), Onno Marsman, Theriault, Michael White
 (http://getsprink.com), Waldo Malqui Silva, Paulo Freitas, Jack, Jonas
 Raoni Soares Silva (http://www.jsfromhell.com), Philip Peterson, Legaev
 Andrey, Ates Goral (http://magnetiq.com), Alex, Ratheous, Martijn Wieringa,
 Rafa? Kukawski (http://blog.kukawski.pl), lmeyrick
 (https://sourceforge.net/projects/bcmath-js/), Nate, Philippe Baumann,
 Enrique Gonzalez, Webtoolkit.info (http://www.webtoolkit.info/), Carlos R.
 L. Rodrigues (http://www.jsfromhell.com), Ash Searle
 (http://hexmen.com/blog/), Jani Hartikainen, travc, Ole Vrijenhoek,
 Erkekjetter, Michael Grier, Rafa? Kukawski (http://kukawski.pl), Johnny
 Mast (http://www.phpvrouwen.nl), T.Wild, d3x,
 http://stackoverflow.com/questions/57803/how-to-convert-decimal-to-hex-in-javascript,
 Rafa? Kukawski (http://blog.kukawski.pl/), stag019, pilus, WebDevHobo
 (http://webdevhobo.blogspot.com/), marrtins, GeekFG
 (http://geekfg.blogspot.com), Andrea Giammarchi
 (http://webreflection.blogspot.com), Arpad Ray (mailto:arpad@php.net),
 gorthaur, Paul Smith, Tim de Koning (http://www.kingsquare.nl), Joris, Oleg
 Eremeev, Steve Hilder, majak, gettimeofday, KELAN, Josh Fraser
 (http://onlineaspect.com/2007/06/08/auto-detect-a-time-zone-with-javascript/),
 Marc Palau, Martin
 (http://www.erlenwiese.de/), Breaking Par Consulting Inc
 (http://www.breakingpar.com/bkp/home.nsf/0/87256B280015193F87256CFB006C45F7),
 Chris, Mirek Slugen, saulius, Alfonso Jimenez
 (http://www.alfonsojimenez.com), Diplom@t (http://difane.com/), felix,
 Mailfaker (http://www.weedem.fr/), Tyler Akins (http://rumkin.com), Caio
 Ariede (http://caioariede.com), Robin, Kankrelune
 (http://www.webfaktory.info/), Karol Kowalski, Imgen Tata
 (http://www.myipdf.com/), mdsjack (http://www.mdsjack.bo.it), Dreamer,
 Felix Geisendoerfer (http://www.debuggable.com/felix), Lars Fischer, AJ,
 David, Aman Gupta, Michael White, Public Domain
 (http://www.json.org/json2.js), Steven Levithan
 (http://blog.stevenlevithan.com), Sakimori, Pellentesque Malesuada,
 Thunder.m, Dj (http://phpjs.org/functions/htmlentities:425#comment_134018),
 Steve Clay, David James, Francois, class_exists, nobbler, T. Wild, Itsacon
 (http://www.itsacon.net/), date, Ole Vrijenhoek (http://www.nervous.nl/),
 Fox, Raphael (Ao RUDLER), Marco, noname, Mateusz "loonquawl" Zalega, Frank
 Forte, Arno, ger, mktime, john (http://www.jd-tech.net), Nick Kolosov
 (http://sammy.ru), marc andreu, Scott Cariss, Douglas Crockford
 (http://javascript.crockford.com), madipta, Slawomir Kaniecki,
 ReverseSyntax, Nathan, Alex Wilson, kenneth, Bayron Guevara, Adam Wallner
 (http://web2.bitbaro.hu/), paulo kuong, jmweb, Lincoln Ramsay, djmix,
 Pyerre, Jon Hohle, Thiago Mata (http://thiagomata.blog.com), lmeyrick
 (https://sourceforge.net/projects/bcmath-js/this.), Linuxworld, duncan,
 Gilbert, Sanjoy Roy, Shingo, sankai, Oskar Larsson H?gfeldt
 (http://oskar-lh.name/), Denny Wardhana, 0m3r, Everlasto, Subhasis Deb,
 josh, jd, Pier Paolo Ramon (http://www.mastersoup.com/), P, merabi, Soren
 Hansen, Eugene Bulkin (http://doubleaw.com/), Der Simon
 (http://innerdom.sourceforge.net/), echo is bad, Ozh, XoraX
 (http://www.xorax.info), EdorFaus, JB, J A R, Marc Jansen, Francesco, LH,
 Stoyan Kyosev (http://www.svest.org/), nord_ua, omid
 (http://phpjs.org/functions/380:380#comment_137122), Brad Touesnard, MeEtc
 (http://yass.meetcweb.com), Peter-Paul Koch
 (http://www.quirksmode.org/js/beat.html), Olivier Louvignes
 (http://mg-crea.com/), T0bsn, Tim Wiel, Bryan Elliott, Jalal Berrami,
 Martin, JT, David Randall, Thomas Beaucourt (http://www.webapp.fr), taith,
 vlado houba, Pierre-Luc Paour, Kristof Coomans (SCK-CEN Belgian Nucleair
 Research Centre), Martin Pool, Kirk Strobeck, Rick Waldron, Brant Messenger
 (http://www.brantmessenger.com/), Devan Penner-Woelk, Saulo Vallory, Wagner
 B. Soares, Artur Tchernychev, Valentina De Rosa, Jason Wong
 (http://carrot.org/), Christoph, Daniel Esteban, strftime, Mick@el, rezna,
 Simon Willison (http://simonwillison.net), Anton Ongson, Gabriel Paderni,
 Marco van Oort, penutbutterjelly, Philipp Lenssen, Bjorn Roesbeke
 (http://www.bjornroesbeke.be/), Bug?, Eric Nagel, Tomasz Wesolowski,
 Evertjan Garretsen, Bobby Drake, Blues (http://tech.bluesmoon.info/), Luke
 Godfrey, Pul, uestla, Alan C, Ulrich, Rafal Kukawski, Yves Sucaet,
 sowberry, Norman "zEh" Fuchs, hitwork, Zahlii, johnrembo, Nick Callen,
 Steven Levithan (stevenlevithan.com), ejsanders, Scott Baker, Brian Tafoya
 (http://www.premasolutions.com/), Philippe Jausions
 (http://pear.php.net/user/jausions), Aidan Lister
 (http://aidanlister.com/), Rob, e-mike, HKM, ChaosNo1, metjay, strcasecmp,
 strcmp, Taras Bogach, jpfle, Alexander Ermolaev
 (http://snippets.dzone.com/user/AlexanderErmolaev), DxGx, kilops, Orlando,
 dptr1988, Le Torbi, James (http://www.james-bell.co.uk/), Pedro Tainha
 (http://www.pedrotainha.com), James, Arnout Kazemier
 (http://www.3rd-Eden.com), Chris McMacken, gabriel paderni, Yannoo,
 FGFEmperor, baris ozdil, Tod Gentille, Greg Frazier, jakes, 3D-GRAF, Allan
 Jensen (http://www.winternet.no), Howard Yeend, Benjamin Lupton, davook,
 daniel airton wermann (http://wermann.com.br), Atli T¨®r, Maximusya, Ryan
 W Tenney (http://ryan.10e.us), Alexander M Beedie, fearphage
 (http://http/my.opera.com/fearphage/), Nathan Sepulveda, Victor, Matteo,
 Billy, stensi, Cord, Manish, T.J. Leahy, Riddler
 (http://www.frontierwebdev.com/), Rafa? Kukawski, FremyCompany, Matt
 Bradley, Tim de Koning, Luis Salazar (http://www.freaky-media.com/), Diogo
 Resende, Rival, Andrej Pavlovic, Garagoth, Le Torbi
 (http://www.letorbi.de/), Dino, Josep Sanz (http://www.ws3.es/), rem,
 Russell Walker (http://www.nbill.co.uk/), Jamie Beck
 (http://www.terabit.ca/), setcookie, Michael, YUI Library:
 http://developer.yahoo.com/yui/docs/YAHOO.util.DateLocale.html, Blues at
 http://hacks.bluesmoon.info/strftime/strftime.js, Ben
 (http://benblume.co.uk/), DtTvB
 (http://dt.in.th/2008-09-16.string-length-in-bytes.html), Andreas, William,
 meo, incidence, Cagri Ekin, Amirouche, Amir Habibi
 (http://www.residence-mixte.com/), Luke Smith (http://lucassmith.name),
 Kheang Hok Chin (http://www.distantia.ca/), Jay Klehr, Lorenzo Pisani,
 Tony, Yen-Wei Liu, Greenseed, mk.keck, Leslie Hoare, dude, booeyOH, Ben
 Bryan

 Licensed under the MIT (MIT-LICENSE.txt) license.

 Permission is hereby granted, free of charge, to any person obtaining a
 copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice shall be included
 in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL KEVIN VAN ZONNEVELD BE LIABLE FOR ANY CLAIM, DAMAGES
 OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 @license
 when.js - https://github.com/cujojs/when

 MIT License (c) copyright B Cavalier & J Hann

 * A lightweight CommonJS Promises/A and when() implementation
 * when is part of the cujo.js family of libraries (http://cujojs.com/)
 *
 * Licensed under the MIT License at:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * @version 1.7.1
 */

/**
 * @license
 *
 * Grauw URI utilities
 *
 * See: http://hg.grauw.nl/grauw-lib/file/tip/src/uri.js
 *
 * @author Laurens Holst (http://www.grauw.nl/)
 *
 *   Copyright 2012 Laurens Holst
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

/*!
 * https://github.com/amd/rest3d/tree/master/server/o3dgc
 *
 * Copyright (c) 2013 Khaled Mammou - Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

// Copyright (c) 2004 Amir Said (said@ieee.org) & William A. Pearlman (pearlw@ecse.rpi.edu)

/*!
 * Autolinker.js
 * 0.17.1
 *
 * Copyright(c) 2015 Gregory Jacobs <greg@greg-jacobs.com>
 * MIT Licensed. http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/gregjacobs/Autolinker.js
 */

/**
 @license
 fontmetrics.js - https://github.com/Pomax/fontmetrics.js

 Copyright (C) 2011 by Mike "Pomax" Kamermans

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 **/

/**
 * @license
 * Knockout JavaScript library v3.2.0
 * (c) Steven Sanderson - http://knockoutjs.com/
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

/**
 * @license
 * Knockout ES5 plugin - https://github.com/SteveSanderson/knockout-es5
 * Copyright (c) Steve Sanderson
 * MIT license
 */

// Copyright 2012 Google Inc., Apache 2.0 license.

/**
 @license
 tween.js - https://github.com/sole/tween.js

 Copyright (c) 2010-2012 Tween.js authors.

 Easing equations Copyright (c) 2001 Robert Penner http://robertpenner.com/easing/

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 */

/**
 * @license
 * Copyright (c) 2011 NVIDIA Corporation. All rights reserved.
 *
 * TO  THE MAXIMUM  EXTENT PERMITTED  BY APPLICABLE  LAW, THIS SOFTWARE  IS PROVIDED
 * *AS IS*  AND NVIDIA AND  ITS SUPPLIERS DISCLAIM  ALL WARRANTIES,  EITHER  EXPRESS
 * OR IMPLIED, INCLUDING, BUT NOT LIMITED  TO, NONINFRINGEMENT,IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL  NVIDIA
 * OR ITS SUPPLIERS BE  LIABLE  FOR  ANY  DIRECT, SPECIAL,  INCIDENTAL,  INDIRECT,  OR
 * CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION,  DAMAGES FOR LOSS
 * OF BUSINESS PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY
 * OTHER PECUNIARY LOSS) ARISING OUT OF THE  USE OF OR INABILITY  TO USE THIS SOFTWARE,
 * EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
 */

/**
 * @license
 * Copyright (c) 2000-2005, Sean O'Neil (s_p_oneil@hotmail.com)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * * Neither the name of the project nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Modifications made by Analytical Graphics, Inc.
 */

/**
 * @license
 * Copyright (c) 2000-2005, Sean O'Neil (s_p_oneil@hotmail.com)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * * Neither the name of the project nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Modifications made by Analytical Graphics, Inc.
 */

/**
 * @license
 *
 * chroma.js - JavaScript library for color conversions
 *
 * Copyright (c) 2011-2015, Gregor Aisch
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * 3. The name Gregor Aisch may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 chroma.js

 Copyright (c) 2011-2013, Gregor Aisch
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this
 list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright notice,
 this list of conditions and the following disclaimer in the documentation
 and/or other materials provided with the distribution.

 * The name Gregor Aisch may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 @source: https://github.com/gka/chroma.js
 */

/**
 chroma.js

 Copyright (c) 2011-2013, Gregor Aisch
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this
 list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright notice,
 this list of conditions and the following disclaimer in the documentation
 and/or other materials provided with the distribution.

 * The name Gregor Aisch may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 @source: https://github.com/gka/chroma.js
 */

/**
 ColorBrewer colors for chroma.js

 Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The
 Pennsylvania State University.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software distributed
 under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 CONDITIONS OF ANY KIND, either express or implied. See the License for the
 specific language governing permissions and limitations under the License.

 @preserve
 */

/*
 chroma.js

 Copyright (c) 2011-2013, Gregor Aisch
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this
 list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright notice,
 this list of conditions and the following disclaimer in the documentation
 and/or other materials provided with the distribution.

 * The name Gregor Aisch may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 @source: https://github.com/gka/chroma.js
 */

/**
 * @license RequireJS text 2.0.12 Copyright (c) 2010-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/text for details
 */

/*!
 * PEP v0.3.0 | https://github.com/jquery/PEP
 * Copyright jQuery Foundation and other contributors | http://jquery.org/license
 */

!function () {
    define("Cesium/Core/defined", [], function () {
        "use strict";
        var e = function (e) {
            return void 0 !== e
        };
        return e
    }), define("Cesium/Core/BingMapsApi", ["./defined"], function (e) {
        "use strict";
        var t = {};
        t.defaultKey = void 0;
        var i = !1;
        return t.getKey = function (n) {
            return e(n) ? n : e(t.defaultKey) ? t.defaultKey : (i || (console.log("This application is using Cesium's default Bing Maps key.  Please create a new key for the application as soon as possible and prior to deployment by visiting https://www.bingmapsportal.com/, and provide your key to Cesium by setting the Cesium.BingMapsApi.defaultKey property before constructing the CesiumWidget or any other object that uses the Bing Maps API."), i = !0), "Aj1ony_-Typ-KjG9SJWiKSHY23U1KmK7yAmZa9lDmuF2osXWkcZ22VPsqmCt0TCt")
        }, t
    }), define("Cesium/Core/freezeObject", ["./defined"], function (e) {
        "use strict";
        var t = Object.freeze;
        return e(t) || (t = function (e) {
            return e
        }), t
    }), define("Cesium/Core/defaultValue", ["./freezeObject"], function (e) {
        "use strict";
        var t = function (e, t) {
            return void 0 !== e ? e : t
        };
        return t.EMPTY_OBJECT = e({}), t
    }), define("Cesium/Core/DeveloperError", ["./defined"], function (e) {
        "use strict";
        var t = function (e) {
            this.name = "DeveloperError", this.message = e;
            var t;
            try {
                throw new Error
            } catch (i) {
                t = i.stack
            }
            this.stack = t
        };
        return t.prototype.toString = function () {
            var t = this.name + ": " + this.message;
            return e(this.stack) && (t += "\n" + this.stack.toString()), t
        }, t.throwInstantiationError = function () {
            throw new t("This function defines an interface and should not be called directly.")
        }, t
    }), define("Cesium/ThirdParty/mersenne-twister", [], function () {
        var e = function (e) {
            void 0 == e && (e = (new Date).getTime()), this.N = 624, this.M = 397, this.MATRIX_A = 2567483615, this.UPPER_MASK = 2147483648, this.LOWER_MASK = 2147483647, this.mt = new Array(this.N), this.mti = this.N + 1, this.init_genrand(e)
        };
        return e.prototype.init_genrand = function (e) {
            for (this.mt[0] = e >>> 0, this.mti = 1; this.mti < this.N; this.mti++) {
                var e = this.mt[this.mti - 1] ^ this.mt[this.mti - 1] >>> 30;
                this.mt[this.mti] = (1812433253 * ((4294901760 & e) >>> 16) << 16) + 1812433253 * (65535 & e) + this.mti, this.mt[this.mti] >>>= 0
            }
        }, e.prototype.genrand_int32 = function () {
            var e, t = new Array(0, this.MATRIX_A);
            if (this.mti >= this.N) {
                var i;
                for (this.mti == this.N + 1 && this.init_genrand(5489), i = 0; i < this.N - this.M; i++)e = this.mt[i] & this.UPPER_MASK | this.mt[i + 1] & this.LOWER_MASK, this.mt[i] = this.mt[i + this.M] ^ e >>> 1 ^ t[1 & e];
                for (; i < this.N - 1; i++)e = this.mt[i] & this.UPPER_MASK | this.mt[i + 1] & this.LOWER_MASK, this.mt[i] = this.mt[i + (this.M - this.N)] ^ e >>> 1 ^ t[1 & e];
                e = this.mt[this.N - 1] & this.UPPER_MASK | this.mt[0] & this.LOWER_MASK, this.mt[this.N - 1] = this.mt[this.M - 1] ^ e >>> 1 ^ t[1 & e], this.mti = 0
            }
            return e = this.mt[this.mti++], e ^= e >>> 11, e ^= e << 7 & 2636928640, e ^= e << 15 & 4022730752, e ^= e >>> 18, e >>> 0
        }, e.prototype.random = function () {
            return this.genrand_int32() * (1 / 4294967296)
        }, e
    }), define("Cesium/Core/Math", ["../ThirdParty/mersenne-twister", "./defaultValue", "./defined", "./DeveloperError"], function (e, t, i, n) {
        "use strict";
        var r = {};
        r.EPSILON1 = .1, r.EPSILON2 = .01, r.EPSILON3 = .001, r.EPSILON4 = 1e-4, r.EPSILON5 = 1e-5, r.EPSILON6 = 1e-6, r.EPSILON7 = 1e-7, r.EPSILON8 = 1e-8, r.EPSILON9 = 1e-9, r.EPSILON10 = 1e-10, r.EPSILON11 = 1e-11, r.EPSILON12 = 1e-12, r.EPSILON13 = 1e-13, r.EPSILON14 = 1e-14, r.EPSILON15 = 1e-15, r.EPSILON16 = 1e-16, r.EPSILON17 = 1e-17, r.EPSILON18 = 1e-18, r.EPSILON19 = 1e-19, r.EPSILON20 = 1e-20, r.GRAVITATIONALPARAMETER = 3986004418e5, r.SOLAR_RADIUS = 6955e5, r.LUNAR_RADIUS = 1737400, r.SIXTY_FOUR_KILOBYTES = 65536, r.sign = function (e) {
            return e > 0 ? 1 : 0 > e ? -1 : 0
        }, r.signNotZero = function (e) {
            return 0 > e ? -1 : 1
        }, r.toSNorm = function (e) {
            return Math.round(255 * (.5 * r.clamp(e, -1, 1) + .5))
        }, r.fromSNorm = function (e) {
            return r.clamp(e, 0, 255) / 255 * 2 - 1
        }, r.sinh = function (e) {
            var t = Math.pow(Math.E, e), i = Math.pow(Math.E, -1 * e);
            return .5 * (t - i)
        }, r.cosh = function (e) {
            var t = Math.pow(Math.E, e), i = Math.pow(Math.E, -1 * e);
            return .5 * (t + i)
        }, r.lerp = function (e, t, i) {
            return (1 - i) * e + i * t
        }, r.PI = Math.PI, r.ONE_OVER_PI = 1 / Math.PI, r.PI_OVER_TWO = .5 * Math.PI, r.PI_OVER_THREE = Math.PI / 3, r.PI_OVER_FOUR = Math.PI / 4, r.PI_OVER_SIX = Math.PI / 6, r.THREE_PI_OVER_TWO = 3 * Math.PI * .5, r.TWO_PI = 2 * Math.PI, r.ONE_OVER_TWO_PI = 1 / (2 * Math.PI), r.RADIANS_PER_DEGREE = Math.PI / 180, r.DEGREES_PER_RADIAN = 180 / Math.PI, r.RADIANS_PER_ARCSECOND = r.RADIANS_PER_DEGREE / 3600, r.toRadians = function (e) {
            return e * r.RADIANS_PER_DEGREE
        }, r.toDegrees = function (e) {
            return e * r.DEGREES_PER_RADIAN
        }, r.convertLongitudeRange = function (e) {
            var t = r.TWO_PI, i = e - Math.floor(e / t) * t;
            return i < -Math.PI ? i + t : i >= Math.PI ? i - t : i
        }, r.negativePiToPi = function (e) {
            return r.zeroToTwoPi(e + r.PI) - r.PI
        }, r.zeroToTwoPi = function (e) {
            var t = r.mod(e, r.TWO_PI);
            return Math.abs(t) < r.EPSILON14 && Math.abs(e) > r.EPSILON14 ? r.TWO_PI : t
        }, r.mod = function (e, t) {
            return (e % t + t) % t
        }, r.equalsEpsilon = function (e, i, n, r) {
            r = t(r, n);
            var o = Math.abs(e - i);
            return r >= o || o <= n * Math.max(Math.abs(e), Math.abs(i))
        };
        var o = [1];
        r.factorial = function (e) {
            var t = o.length;
            if (e >= t)for (var i = o[t - 1], n = t; e >= n; n++)o.push(i * n);
            return o[e]
        }, r.incrementWrap = function (e, i, n) {
            return n = t(n, 0), ++e, e > i && (e = n), e
        }, r.isPowerOfTwo = function (e) {
            return 0 !== e && 0 === (e & e - 1)
        }, r.nextPowerOfTwo = function (e) {
            return --e, e |= e >> 1, e |= e >> 2, e |= e >> 4, e |= e >> 8, e |= e >> 16, ++e, e
        }, r.clamp = function (e, t, i) {
            return t > e ? t : e > i ? i : e
        };
        var a = new e;
        return r.setRandomNumberSeed = function (t) {
            a = new e(t)
        }, r.nextRandomNumber = function () {
            return a.random()
        }, r.acosClamped = function (e) {
            return Math.acos(r.clamp(e, -1, 1))
        }, r.asinClamped = function (e) {
            return Math.asin(r.clamp(e, -1, 1))
        }, r.chordLength = function (e, t) {
            return 2 * t * Math.sin(.5 * e)
        }, r
    }), define("Cesium/Core/Cartesian3", ["./defaultValue", "./defined", "./DeveloperError", "./freezeObject", "./Math"], function (e, t, i, n, r) {
        "use strict";
        var o = function (t, i, n) {
            this.x = e(t, 0), this.y = e(i, 0), this.z = e(n, 0)
        };
        o.fromSpherical = function (i, n) {
            t(n) || (n = new o);
            var r = i.clock, a = i.cone, s = e(i.magnitude, 1), u = s * Math.sin(a);
            return n.x = u * Math.cos(r), n.y = u * Math.sin(r), n.z = s * Math.cos(a), n
        }, o.fromElements = function (e, i, n, r) {
            return t(r) ? (r.x = e, r.y = i, r.z = n, r) : new o(e, i, n)
        }, o.clone = function (e, i) {
            return t(e) ? t(i) ? (i.x = e.x, i.y = e.y, i.z = e.z, i) : new o(e.x, e.y, e.z) : void 0
        }, o.fromCartesian4 = o.clone, o.packedLength = 3, o.pack = function (t, i, n) {
            n = e(n, 0), i[n++] = t.x, i[n++] = t.y, i[n] = t.z
        }, o.unpack = function (i, n, r) {
            return n = e(n, 0), t(r) || (r = new o), r.x = i[n++], r.y = i[n++], r.z = i[n], r
        }, o.fromArray = o.unpack, o.maximumComponent = function (e) {
            return Math.max(e.x, e.y, e.z)
        }, o.minimumComponent = function (e) {
            return Math.min(e.x, e.y, e.z)
        }, o.minimumByComponent = function (e, t, i) {
            return i.x = Math.min(e.x, t.x), i.y = Math.min(e.y, t.y), i.z = Math.min(e.z, t.z), i
        }, o.maximumByComponent = function (e, t, i) {
            return i.x = Math.max(e.x, t.x), i.y = Math.max(e.y, t.y), i.z = Math.max(e.z, t.z), i
        }, o.magnitudeSquared = function (e) {
            return e.x * e.x + e.y * e.y + e.z * e.z
        }, o.magnitude = function (e) {
            return Math.sqrt(o.magnitudeSquared(e))
        };
        var a = new o;
        o.distance = function (e, t) {
            return o.subtract(e, t, a), o.magnitude(a)
        }, o.distanceSquared = function (e, t) {
            return o.subtract(e, t, a), o.magnitudeSquared(a)
        }, o.normalize = function (e, t) {
            var i = o.magnitude(e);
            return t.x = e.x / i, t.y = e.y / i, t.z = e.z / i, t
        }, o.dot = function (e, t) {
            return e.x * t.x + e.y * t.y + e.z * t.z
        }, o.multiplyComponents = function (e, t, i) {
            return i.x = e.x * t.x, i.y = e.y * t.y, i.z = e.z * t.z, i
        }, o.add = function (e, t, i) {
            return i.x = e.x + t.x, i.y = e.y + t.y, i.z = e.z + t.z, i
        }, o.subtract = function (e, t, i) {
            return i.x = e.x - t.x, i.y = e.y - t.y, i.z = e.z - t.z, i
        }, o.multiplyByScalar = function (e, t, i) {
            return i.x = e.x * t, i.y = e.y * t, i.z = e.z * t, i
        }, o.divideByScalar = function (e, t, i) {
            return i.x = e.x / t, i.y = e.y / t, i.z = e.z / t, i
        }, o.negate = function (e, t) {
            return t.x = -e.x, t.y = -e.y, t.z = -e.z, t
        }, o.abs = function (e, t) {
            return t.x = Math.abs(e.x), t.y = Math.abs(e.y), t.z = Math.abs(e.z), t
        };
        var s = new o;
        o.lerp = function (e, t, i, n) {
            return o.multiplyByScalar(t, i, s), n = o.multiplyByScalar(e, 1 - i, n), o.add(s, n, n)
        };
        var u = new o, l = new o;
        o.angleBetween = function (e, t) {
            o.normalize(e, u), o.normalize(t, l);
            var i = o.dot(u, l), n = o.magnitude(o.cross(u, l, u));
            return Math.atan2(n, i)
        };
        var c = new o;
        o.mostOrthogonalAxis = function (e, t) {
            var i = o.normalize(e, c);
            return o.abs(i, i), t = i.x <= i.y ? i.x <= i.z ? o.clone(o.UNIT_X, t) : o.clone(o.UNIT_Z, t) : i.y <= i.z ? o.clone(o.UNIT_Y, t) : o.clone(o.UNIT_Z, t)
        }, o.equals = function (e, i) {
            return e === i || t(e) && t(i) && e.x === i.x && e.y === i.y && e.z === i.z
        }, o.equalsArray = function (e, t, i) {
            return e.x === t[i] && e.y === t[i + 1] && e.z === t[i + 2]
        }, o.equalsEpsilon = function (e, i, n, o) {
            return e === i || t(e) && t(i) && r.equalsEpsilon(e.x, i.x, n, o) && r.equalsEpsilon(e.y, i.y, n, o) && r.equalsEpsilon(e.z, i.z, n, o)
        }, o.cross = function (e, t, i) {
            var n = e.x, r = e.y, o = e.z, a = t.x, s = t.y, u = t.z, l = r * u - o * s, c = o * a - n * u, h = n * s - r * a;
            return i.x = l, i.y = c, i.z = h, i
        }, o.fromDegrees = function (e, t, i, n, a) {
            var s = r.toRadians(e), u = r.toRadians(t);
            return o.fromRadians(s, u, i, n, a)
        };
        var h = new o, d = new o, m = new o(40680631590769, 40680631590769, 40408299984661.445);
        return o.fromRadians = function (i, n, r, a, s) {
            r = e(r, 0);
            var u = t(a) ? a.radiiSquared : m, l = Math.cos(n);
            h.x = l * Math.cos(i), h.y = l * Math.sin(i), h.z = Math.sin(n), h = o.normalize(h, h), o.multiplyComponents(u, h, d);
            var c = Math.sqrt(o.dot(h, d));
            return d = o.divideByScalar(d, c, d), h = o.multiplyByScalar(h, r, h), t(s) || (s = new o), o.add(d, h, s)
        }, o.fromDegreesArray = function (e, t, i) {
            for (var n = new Array(e.length), a = 0; a < e.length; a++)n[a] = r.toRadians(e[a]);
            return o.fromRadiansArray(n, t, i)
        }, o.fromRadiansArray = function (e, i, n) {
            var r = e.length;
            t(n) ? n.length = r / 2 : n = new Array(r / 2);
            for (var a = 0; r > a; a += 2) {
                var s = e[a], u = e[a + 1];
                n[a / 2] = o.fromRadians(s, u, 0, i, n[a / 2])
            }
            return n
        }, o.fromDegreesArrayHeights = function (e, t, i) {
            for (var n = new Array(e.length), a = 0; a < e.length; a += 3)n[a] = r.toRadians(e[a]), n[a + 1] = r.toRadians(e[a + 1]), n[a + 2] = e[a + 2];
            return o.fromRadiansArrayHeights(n, t, i)
        }, o.fromRadiansArrayHeights = function (e, i, n) {
            var r = e.length;
            t(n) ? n.length = r / 3 : n = new Array(r / 3);
            for (var a = 0; r > a; a += 3) {
                var s = e[a], u = e[a + 1], l = e[a + 2];
                n[a / 3] = o.fromRadians(s, u, l, i, n[a / 3])
            }
            return n
        }, o.ZERO = n(new o(0, 0, 0)), o.UNIT_X = n(new o(1, 0, 0)), o.UNIT_Y = n(new o(0, 1, 0)), o.UNIT_Z = n(new o(0, 0, 1)), o.prototype.clone = function (e) {
            return o.clone(this, e)
        }, o.prototype.equals = function (e) {
            return o.equals(this, e)
        }, o.prototype.equalsEpsilon = function (e, t, i) {
            return o.equalsEpsilon(this, e, t, i)
        }, o.prototype.toString = function () {
            return "(" + this.x + ", " + this.y + ", " + this.z + ")"
        }, o
    }), define("Cesium/Core/Cartographic", ["./defaultValue", "./defined", "./DeveloperError", "./freezeObject", "./Math"], function (e, t, i, n, r) {
        "use strict";
        var o = function (t, i, n) {
            this.longitude = e(t, 0), this.latitude = e(i, 0), this.height = e(n, 0)
        };
        return o.fromRadians = function (i, n, r, a) {
            return r = e(r, 0), t(a) ? (a.longitude = i, a.latitude = n, a.height = r, a) : new o(i, n, r)
        }, o.fromDegrees = function (e, t, i, n) {
            return e = r.toRadians(e), t = r.toRadians(t), o.fromRadians(e, t, i, n)
        }, o.clone = function (e, i) {
            return t(e) ? t(i) ? (i.longitude = e.longitude, i.latitude = e.latitude, i.height = e.height, i) : new o(e.longitude, e.latitude, e.height) : void 0
        }, o.equals = function (e, i) {
            return e === i || t(e) && t(i) && e.longitude === i.longitude && e.latitude === i.latitude && e.height === i.height
        }, o.equalsEpsilon = function (e, i, n) {
            return e === i || t(e) && t(i) && Math.abs(e.longitude - i.longitude) <= n && Math.abs(e.latitude - i.latitude) <= n && Math.abs(e.height - i.height) <= n
        }, o.ZERO = n(new o(0, 0, 0)), o.prototype.clone = function (e) {
            return o.clone(this, e)
        }, o.prototype.equals = function (e) {
            return o.equals(this, e)
        }, o.prototype.equalsEpsilon = function (e, t) {
            return o.equalsEpsilon(this, e, t)
        }, o.prototype.toString = function () {
            return "(" + this.longitude + ", " + this.latitude + ", " + this.height + ")"
        }, o
    }), define("Cesium/Core/deprecationWarning", ["./defined", "./DeveloperError"], function (e, t) {
        "use strict";
        var i = {}, n = function (t, n) {
            e(i[t]) || (i[t] = !0, console.log(n))
        };
        return n
    }), define("Cesium/Core/defineProperties", ["./defined"], function (e) {
        "use strict";
        var t = function () {
            try {
                return "x"in Object.defineProperty({}, "x", {})
            } catch (e) {
                return !1
            }
        }(), i = Object.defineProperties;
        return t && e(i) || (i = function (e) {
            return e
        }), i
    }), define("Cesium/Core/Ellipsoid", ["./Cartesian3", "./Cartographic", "./defaultValue", "./defined", "./defineProperties", "./DeveloperError", "./freezeObject", "./Math"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        function u(t, n, r, o) {
            n = i(n, 0), r = i(r, 0), o = i(o, 0), t._radii = new e(n, r, o), t._radiiSquared = new e(n * n, r * r, o * o), t._radiiToTheFourth = new e(n * n * n * n, r * r * r * r, o * o * o * o), t._oneOverRadii = new e(0 === n ? 0 : 1 / n, 0 === r ? 0 : 1 / r, 0 === o ? 0 : 1 / o), t._oneOverRadiiSquared = new e(0 === n ? 0 : 1 / (n * n), 0 === r ? 0 : 1 / (r * r), 0 === o ? 0 : 1 / (o * o)), t._minimumRadius = Math.min(n, r, o), t._maximumRadius = Math.max(n, r, o), t._centerToleranceSquared = s.EPSILON1
        }

        var l = function (e, t, i) {
            this._radii = void 0, this._radiiSquared = void 0, this._radiiToTheFourth = void 0, this._oneOverRadii = void 0, this._oneOverRadiiSquared = void 0, this._minimumRadius = void 0, this._maximumRadius = void 0, this._centerToleranceSquared = void 0, u(this, e, t, i)
        };
        r(l.prototype, {
            radii: {
                get: function () {
                    return this._radii
                }
            }, radiiSquared: {
                get: function () {
                    return this._radiiSquared
                }
            }, radiiToTheFourth: {
                get: function () {
                    return this._radiiToTheFourth
                }
            }, oneOverRadii: {
                get: function () {
                    return this._oneOverRadii
                }
            }, oneOverRadiiSquared: {
                get: function () {
                    return this._oneOverRadiiSquared
                }
            }, minimumRadius: {
                get: function () {
                    return this._minimumRadius
                }
            }, maximumRadius: {
                get: function () {
                    return this._maximumRadius
                }
            }
        }), l.clone = function (t, i) {
            if (!n(t))return void 0;
            var r = t._radii;
            return n(i) ? (e.clone(r, i._radii), e.clone(t._radiiSquared, i._radiiSquared), e.clone(t._radiiToTheFourth, i._radiiToTheFourth), e.clone(t._oneOverRadii, i._oneOverRadii), e.clone(t._oneOverRadiiSquared, i._oneOverRadiiSquared), i._minimumRadius = t._minimumRadius, i._maximumRadius = t._maximumRadius, i._centerToleranceSquared = t._centerToleranceSquared, i) : new l(r.x, r.y, r.z)
        }, l.fromCartesian3 = function (e, t) {
            return n(t) || (t = new l), n(e) ? (u(t, e.x, e.y, e.z), t) : t
        }, l.WGS84 = a(new l(6378137, 6378137, 6356752.314245179)), l.UNIT_SPHERE = a(new l(1, 1, 1)), l.MOON = a(new l(s.LUNAR_RADIUS, s.LUNAR_RADIUS, s.LUNAR_RADIUS)), l.prototype.clone = function (e) {
            return l.clone(this, e)
        }, l.packedLength = e.packedLength, l.pack = function (t, n, r) {
            r = i(r, 0), e.pack(t._radii, n, r)
        }, l.unpack = function (t, n, r) {
            n = i(n, 0);
            var o = e.unpack(t, n);
            return l.fromCartesian3(o, r)
        }, l.prototype.geocentricSurfaceNormal = e.normalize, l.prototype.geodeticSurfaceNormalCartographic = function (t, i) {
            var r = t.longitude, o = t.latitude, a = Math.cos(o), s = a * Math.cos(r), u = a * Math.sin(r), l = Math.sin(o);
            return n(i) || (i = new e), i.x = s, i.y = u, i.z = l, e.normalize(i, i)
        }, l.prototype.geodeticSurfaceNormal = function (t, i) {
            return n(i) || (i = new e), i = e.multiplyComponents(t, this._oneOverRadiiSquared, i), e.normalize(i, i)
        };
        var c = new e, h = new e;
        l.prototype.cartographicToCartesian = function (t, i) {
            var r = c, o = h;
            this.geodeticSurfaceNormalCartographic(t, r), e.multiplyComponents(this._radiiSquared, r, o);
            var a = Math.sqrt(e.dot(r, o));
            return e.divideByScalar(o, a, o), e.multiplyByScalar(r, t.height, r), n(i) || (i = new e), e.add(o, r, i)
        }, l.prototype.cartographicArrayToCartesianArray = function (e, t) {
            var i = e.length;
            n(t) ? t.length = i : t = new Array(i);
            for (var r = 0; i > r; r++)t[r] = this.cartographicToCartesian(e[r], t[r]);
            return t
        };
        var d = new e, m = new e, p = new e;
        l.prototype.cartesianToCartographic = function (i, r) {
            var o = this.scaleToGeodeticSurface(i, m);
            if (!n(o))return void 0;
            var a = this.geodeticSurfaceNormal(o, d), u = e.subtract(i, o, p), l = Math.atan2(a.y, a.x), c = Math.asin(a.z), h = s.sign(e.dot(u, i)) * e.magnitude(u);
            return n(r) ? (r.longitude = l, r.latitude = c, r.height = h, r) : new t(l, c, h)
        }, l.prototype.cartesianArrayToCartographicArray = function (e, t) {
            var i = e.length;
            n(t) ? t.length = i : t = new Array(i);
            for (var r = 0; i > r; ++r)t[r] = this.cartesianToCartographic(e[r], t[r]);
            return t
        };
        var f = new e, _ = new e;
        return l.prototype.scaleToGeodeticSurface = function (t, i) {
            var r = t.x, o = t.y, a = t.z, u = this._oneOverRadii, l = u.x, c = u.y, h = u.z, d = r * r * l * l, m = o * o * c * c, p = a * a * h * h, v = d + m + p, g = Math.sqrt(1 / v), y = e.multiplyByScalar(t, g, f);
            if (v < this._centerToleranceSquared)return isFinite(g) ? e.clone(y, i) : void 0;
            var C = this._oneOverRadiiSquared, E = C.x, S = C.y, T = C.z, b = _;
            b.x = y.x * E * 2, b.y = y.y * S * 2, b.z = y.z * T * 2;
            var w, x, A, P, I, D, M, O, R, N, L, F = (1 - g) * e.magnitude(t) / (.5 * e.magnitude(b)), B = 0;
            do {
                F -= B, A = 1 / (1 + F * E), P = 1 / (1 + F * S), I = 1 / (1 + F * T), D = A * A, M = P * P, O = I * I, R = D * A, N = M * P, L = O * I, w = d * D + m * M + p * O - 1, x = d * R * E + m * N * S + p * L * T;
                var z = -2 * x;
                B = w / z
            } while (Math.abs(w) > s.EPSILON12);
            return n(i) ? (i.x = r * A, i.y = o * P, i.z = a * I, i) : new e(r * A, o * P, a * I)
        }, l.prototype.scaleToGeocentricSurface = function (t, i) {
            n(i) || (i = new e);
            var r = t.x, o = t.y, a = t.z, s = this._oneOverRadiiSquared, u = 1 / Math.sqrt(r * r * s.x + o * o * s.y + a * a * s.z);
            return e.multiplyByScalar(t, u, i)
        }, l.prototype.transformPositionToScaledSpace = function (t, i) {
            return n(i) || (i = new e), e.multiplyComponents(t, this._oneOverRadii, i)
        }, l.prototype.transformPositionFromScaledSpace = function (t, i) {
            return n(i) || (i = new e), e.multiplyComponents(t, this._radii, i)
        }, l.prototype.equals = function (t) {
            return this === t || n(t) && e.equals(this._radii, t._radii)
        }, l.prototype.toString = function () {
            return this._radii.toString()
        }, l
    }), define("Cesium/Core/GeographicProjection", ["./Cartesian3", "./Cartographic", "./defaultValue", "./defined", "./defineProperties", "./DeveloperError", "./Ellipsoid"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = function (e) {
            this._ellipsoid = i(e, a.WGS84), this._semimajorAxis = this._ellipsoid.maximumRadius, this._oneOverSemimajorAxis = 1 / this._semimajorAxis
        };
        return r(s.prototype, {
            ellipsoid: {
                get: function () {
                    return this._ellipsoid
                }
            }
        }), s.prototype.project = function (t, i) {
            var r = this._semimajorAxis, o = t.longitude * r, a = t.latitude * r, s = t.height;
            return n(i) ? (i.x = o, i.y = a, i.z = s, i) : new e(o, a, s)
        }, s.prototype.unproject = function (e, i) {
            var r = this._oneOverSemimajorAxis, o = e.x * r, a = e.y * r, s = e.z;
            return n(i) ? (i.longitude = o, i.latitude = a, i.height = s, i) : new t(o, a, s)
        }, s
    }), define("Cesium/Core/Intersect", ["./freezeObject"], function (e) {
        "use strict";
        var t = {OUTSIDE: -1, INTERSECTING: 0, INSIDE: 1};
        return e(t)
    }), define("Cesium/Core/Interval", ["./defaultValue"], function (e) {
        "use strict";
        var t = function (t, i) {
            this.start = e(t, 0), this.stop = e(i, 0)
        };
        return t
    }), define("Cesium/Core/Cartesian4", ["./defaultValue", "./defined", "./DeveloperError", "./freezeObject", "./Math"], function (e, t, i, n, r) {
        "use strict";
        var o = function (t, i, n, r) {
            this.x = e(t, 0), this.y = e(i, 0), this.z = e(n, 0), this.w = e(r, 0)
        };
        o.fromElements = function (e, i, n, r, a) {
            return t(a) ? (a.x = e, a.y = i, a.z = n, a.w = r, a) : new o(e, i, n, r)
        }, o.fromColor = function (e, i) {
            return t(i) ? (i.x = e.red, i.y = e.green, i.z = e.blue, i.w = e.alpha, i) : new o(e.red, e.green, e.blue, e.alpha)
        }, o.clone = function (e, i) {
            return t(e) ? t(i) ? (i.x = e.x, i.y = e.y, i.z = e.z, i.w = e.w, i) : new o(e.x, e.y, e.z, e.w) : void 0
        }, o.packedLength = 4, o.pack = function (t, i, n) {
            n = e(n, 0), i[n++] = t.x, i[n++] = t.y, i[n++] = t.z, i[n] = t.w
        }, o.unpack = function (i, n, r) {
            return n = e(n, 0), t(r) || (r = new o), r.x = i[n++], r.y = i[n++], r.z = i[n++], r.w = i[n], r
        }, o.fromArray = o.unpack, o.maximumComponent = function (e) {
            return Math.max(e.x, e.y, e.z, e.w)
        }, o.minimumComponent = function (e) {
            return Math.min(e.x, e.y, e.z, e.w)
        }, o.minimumByComponent = function (e, t, i) {
            return i.x = Math.min(e.x, t.x), i.y = Math.min(e.y, t.y), i.z = Math.min(e.z, t.z), i.w = Math.min(e.w, t.w), i
        }, o.maximumByComponent = function (e, t, i) {
            return i.x = Math.max(e.x, t.x), i.y = Math.max(e.y, t.y), i.z = Math.max(e.z, t.z), i.w = Math.max(e.w, t.w), i
        }, o.magnitudeSquared = function (e) {
            return e.x * e.x + e.y * e.y + e.z * e.z + e.w * e.w
        }, o.magnitude = function (e) {
            return Math.sqrt(o.magnitudeSquared(e))
        };
        var a = new o;
        o.distance = function (e, t) {
            return o.subtract(e, t, a), o.magnitude(a)
        }, o.distanceSquared = function (e, t) {
            return o.subtract(e, t, a), o.magnitudeSquared(a)
        }, o.normalize = function (e, t) {
            var i = o.magnitude(e);
            return t.x = e.x / i, t.y = e.y / i, t.z = e.z / i, t.w = e.w / i, t
        }, o.dot = function (e, t) {
            return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w
        }, o.multiplyComponents = function (e, t, i) {
            return i.x = e.x * t.x, i.y = e.y * t.y, i.z = e.z * t.z, i.w = e.w * t.w, i
        }, o.add = function (e, t, i) {
            return i.x = e.x + t.x, i.y = e.y + t.y, i.z = e.z + t.z, i.w = e.w + t.w, i
        }, o.subtract = function (e, t, i) {
            return i.x = e.x - t.x, i.y = e.y - t.y, i.z = e.z - t.z, i.w = e.w - t.w, i
        }, o.multiplyByScalar = function (e, t, i) {
            return i.x = e.x * t, i.y = e.y * t, i.z = e.z * t, i.w = e.w * t, i
        }, o.divideByScalar = function (e, t, i) {
            return i.x = e.x / t, i.y = e.y / t, i.z = e.z / t, i.w = e.w / t, i
        }, o.negate = function (e, t) {
            return t.x = -e.x, t.y = -e.y, t.z = -e.z, t.w = -e.w, t
        }, o.abs = function (e, t) {
            return t.x = Math.abs(e.x), t.y = Math.abs(e.y), t.z = Math.abs(e.z), t.w = Math.abs(e.w), t
        };
        var s = new o;
        o.lerp = function (e, t, i, n) {
            return o.multiplyByScalar(t, i, s), n = o.multiplyByScalar(e, 1 - i, n), o.add(s, n, n)
        };
        var u = new o;
        return o.mostOrthogonalAxis = function (e, t) {
            var i = o.normalize(e, u);
            return o.abs(i, i), t = i.x <= i.y ? i.x <= i.z ? i.x <= i.w ? o.clone(o.UNIT_X, t) : o.clone(o.UNIT_W, t) : i.z <= i.w ? o.clone(o.UNIT_Z, t) : o.clone(o.UNIT_W, t) : i.y <= i.z ? i.y <= i.w ? o.clone(o.UNIT_Y, t) : o.clone(o.UNIT_W, t) : i.z <= i.w ? o.clone(o.UNIT_Z, t) : o.clone(o.UNIT_W, t)
        }, o.equals = function (e, i) {
            return e === i || t(e) && t(i) && e.x === i.x && e.y === i.y && e.z === i.z && e.w === i.w
        }, o.equalsArray = function (e, t, i) {
            return e.x === t[i] && e.y === t[i + 1] && e.z === t[i + 2] && e.w === t[i + 3]
        }, o.equalsEpsilon = function (e, i, n, o) {
            return e === i || t(e) && t(i) && r.equalsEpsilon(e.x, i.x, n, o) && r.equalsEpsilon(e.y, i.y, n, o) && r.equalsEpsilon(e.z, i.z, n, o) && r.equalsEpsilon(e.w, i.w, n, o)
        }, o.ZERO = n(new o(0, 0, 0, 0)), o.UNIT_X = n(new o(1, 0, 0, 0)), o.UNIT_Y = n(new o(0, 1, 0, 0)), o.UNIT_Z = n(new o(0, 0, 1, 0)), o.UNIT_W = n(new o(0, 0, 0, 1)), o.prototype.clone = function (e) {
            return o.clone(this, e)
        }, o.prototype.equals = function (e) {
            return o.equals(this, e)
        }, o.prototype.equalsEpsilon = function (e, t, i) {
            return o.equalsEpsilon(this, e, t, i)
        }, o.prototype.toString = function () {
            return "(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")"
        }, o
    }), define("Cesium/Core/Matrix3", ["./Cartesian3", "./defaultValue", "./defined", "./DeveloperError", "./freezeObject", "./Math"], function (e, t, i, n, r, o) {
        "use strict";
        function a(e) {
            for (var t = 0, i = 0; 9 > i; ++i) {
                var n = e[i];
                t += n * n
            }
            return Math.sqrt(t)
        }

        function s(e) {
            for (var t = 0, i = 0; 3 > i; ++i) {
                var n = e[l.getElementIndex(m[i], d[i])];
                t += 2 * n * n
            }
            return Math.sqrt(t)
        }

        function u(e, t) {
            for (var i = o.EPSILON15, n = 0, r = 1, a = 0; 3 > a; ++a) {
                var s = Math.abs(e[l.getElementIndex(m[a], d[a])]);
                s > n && (r = a, n = s)
            }
            var u = 1, c = 0, h = d[r], p = m[r];
            if (Math.abs(e[l.getElementIndex(p, h)]) > i) {
                var f, _ = e[l.getElementIndex(p, p)], v = e[l.getElementIndex(h, h)], g = e[l.getElementIndex(p, h)], y = (_ - v) / 2 / g;
                f = 0 > y ? -1 / (-y + Math.sqrt(1 + y * y)) : 1 / (y + Math.sqrt(1 + y * y)), u = 1 / Math.sqrt(1 + f * f), c = f * u
            }
            return t = l.clone(l.IDENTITY, t), t[l.getElementIndex(h, h)] = t[l.getElementIndex(p, p)] = u, t[l.getElementIndex(p, h)] = c, t[l.getElementIndex(h, p)] = -c, t
        }

        var l = function (e, i, n, r, o, a, s, u, l) {
            this[0] = t(e, 0), this[1] = t(r, 0), this[2] = t(s, 0), this[3] = t(i, 0), this[4] = t(o, 0), this[5] = t(u, 0), this[6] = t(n, 0), this[7] = t(a, 0), this[8] = t(l, 0)
        };
        l.packedLength = 9, l.pack = function (e, i, n) {
            n = t(n, 0), i[n++] = e[0], i[n++] = e[1], i[n++] = e[2], i[n++] = e[3], i[n++] = e[4], i[n++] = e[5], i[n++] = e[6], i[n++] = e[7], i[n++] = e[8]
        }, l.unpack = function (e, n, r) {
            return n = t(n, 0), i(r) || (r = new l), r[0] = e[n++], r[1] = e[n++], r[2] = e[n++], r[3] = e[n++], r[4] = e[n++], r[5] = e[n++], r[6] = e[n++], r[7] = e[n++], r[8] = e[n++], r
        }, l.clone = function (e, t) {
            return i(e) ? i(t) ? (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t) : new l(e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8]) : void 0
        }, l.fromArray = function (e, n, r) {
            return n = t(n, 0), i(r) || (r = new l), r[0] = e[n], r[1] = e[n + 1], r[2] = e[n + 2], r[3] = e[n + 3], r[4] = e[n + 4], r[5] = e[n + 5], r[6] = e[n + 6], r[7] = e[n + 7], r[8] = e[n + 8], r
        }, l.fromColumnMajorArray = function (e, t) {
            return l.clone(e, t)
        }, l.fromRowMajorArray = function (e, t) {
            return i(t) ? (t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], t) : new l(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8])
        }, l.fromQuaternion = function (e, t) {
            var n = e.x * e.x, r = e.x * e.y, o = e.x * e.z, a = e.x * e.w, s = e.y * e.y, u = e.y * e.z, c = e.y * e.w, h = e.z * e.z, d = e.z * e.w, m = e.w * e.w, p = n - s - h + m, f = 2 * (r - d), _ = 2 * (o + c), v = 2 * (r + d), g = -n + s - h + m, y = 2 * (u - a), C = 2 * (o - c), E = 2 * (u + a), S = -n - s + h + m;
            return i(t) ? (t[0] = p, t[1] = v, t[2] = C, t[3] = f, t[4] = g, t[5] = E, t[6] = _, t[7] = y, t[8] = S, t) : new l(p, f, _, v, g, y, C, E, S)
        }, l.fromScale = function (e, t) {
            return i(t) ? (t[0] = e.x, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = e.y, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = e.z, t) : new l(e.x, 0, 0, 0, e.y, 0, 0, 0, e.z)
        }, l.fromUniformScale = function (e, t) {
            return i(t) ? (t[0] = e, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = e, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = e, t) : new l(e, 0, 0, 0, e, 0, 0, 0, e)
        }, l.fromCrossProduct = function (e, t) {
            return i(t) ? (t[0] = 0, t[1] = e.z, t[2] = -e.y, t[3] = -e.z, t[4] = 0, t[5] = e.x, t[6] = e.y, t[7] = -e.x, t[8] = 0, t) : new l(0, -e.z, e.y, e.z, 0, -e.x, -e.y, e.x, 0)
        }, l.fromRotationX = function (e, t) {
            var n = Math.cos(e), r = Math.sin(e);
            return i(t) ? (t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = n, t[5] = r, t[6] = 0, t[7] = -r, t[8] = n, t) : new l(1, 0, 0, 0, n, -r, 0, r, n)
        }, l.fromRotationY = function (e, t) {
            var n = Math.cos(e), r = Math.sin(e);
            return i(t) ? (t[0] = n, t[1] = 0, t[2] = -r, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = r, t[7] = 0, t[8] = n, t) : new l(n, 0, r, 0, 1, 0, -r, 0, n)
        }, l.fromRotationZ = function (e, t) {
            var n = Math.cos(e), r = Math.sin(e);
            return i(t) ? (t[0] = n, t[1] = r, t[2] = 0, t[3] = -r, t[4] = n, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t) : new l(n, -r, 0, r, n, 0, 0, 0, 1)
        }, l.toArray = function (e, t) {
            return i(t) ? (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t) : [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]]
        }, l.getElementIndex = function (e, t) {
            return 3 * e + t
        }, l.getColumn = function (e, t, i) {
            var n = 3 * t, r = e[n], o = e[n + 1], a = e[n + 2];
            return i.x = r, i.y = o, i.z = a, i
        }, l.setColumn = function (e, t, i, n) {
            n = l.clone(e, n);
            var r = 3 * t;
            return n[r] = i.x, n[r + 1] = i.y, n[r + 2] = i.z, n
        }, l.getRow = function (e, t, i) {
            var n = e[t], r = e[t + 3], o = e[t + 6];
            return i.x = n, i.y = r, i.z = o, i
        }, l.setRow = function (e, t, i, n) {
            return n = l.clone(e, n), n[t] = i.x, n[t + 3] = i.y, n[t + 6] = i.z, n
        };
        var c = new e;
        l.getScale = function (t, i) {
            return i.x = e.magnitude(e.fromElements(t[0], t[1], t[2], c)), i.y = e.magnitude(e.fromElements(t[3], t[4], t[5], c)), i.z = e.magnitude(e.fromElements(t[6], t[7], t[8], c)), i
        };
        var h = new e;
        l.getMaximumScale = function (t) {
            return l.getScale(t, h), e.maximumComponent(h)
        }, l.multiply = function (e, t, i) {
            var n = e[0] * t[0] + e[3] * t[1] + e[6] * t[2], r = e[1] * t[0] + e[4] * t[1] + e[7] * t[2], o = e[2] * t[0] + e[5] * t[1] + e[8] * t[2], a = e[0] * t[3] + e[3] * t[4] + e[6] * t[5], s = e[1] * t[3] + e[4] * t[4] + e[7] * t[5], u = e[2] * t[3] + e[5] * t[4] + e[8] * t[5], l = e[0] * t[6] + e[3] * t[7] + e[6] * t[8], c = e[1] * t[6] + e[4] * t[7] + e[7] * t[8], h = e[2] * t[6] + e[5] * t[7] + e[8] * t[8];
            return i[0] = n, i[1] = r, i[2] = o, i[3] = a, i[4] = s, i[5] = u, i[6] = l, i[7] = c, i[8] = h, i
        }, l.add = function (e, t, i) {
            return i[0] = e[0] + t[0], i[1] = e[1] + t[1], i[2] = e[2] + t[2], i[3] = e[3] + t[3], i[4] = e[4] + t[4], i[5] = e[5] + t[5], i[6] = e[6] + t[6], i[7] = e[7] + t[7], i[8] = e[8] + t[8], i
        }, l.subtract = function (e, t, i) {
            return i[0] = e[0] - t[0], i[1] = e[1] - t[1], i[2] = e[2] - t[2], i[3] = e[3] - t[3], i[4] = e[4] - t[4], i[5] = e[5] - t[5], i[6] = e[6] - t[6], i[7] = e[7] - t[7], i[8] = e[8] - t[8], i
        }, l.multiplyByVector = function (e, t, i) {
            var n = t.x, r = t.y, o = t.z, a = e[0] * n + e[3] * r + e[6] * o, s = e[1] * n + e[4] * r + e[7] * o, u = e[2] * n + e[5] * r + e[8] * o;
            return i.x = a, i.y = s, i.z = u, i
        }, l.multiplyByScalar = function (e, t, i) {
            return i[0] = e[0] * t, i[1] = e[1] * t, i[2] = e[2] * t, i[3] = e[3] * t, i[4] = e[4] * t, i[5] = e[5] * t, i[6] = e[6] * t, i[7] = e[7] * t, i[8] = e[8] * t, i
        }, l.multiplyByScale = function (e, t, i) {
            return i[0] = e[0] * t.x, i[1] = e[1] * t.x, i[2] = e[2] * t.x, i[3] = e[3] * t.y, i[4] = e[4] * t.y, i[5] = e[5] * t.y, i[6] = e[6] * t.z, i[7] = e[7] * t.z, i[8] = e[8] * t.z, i
        }, l.negate = function (e, t) {
            return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = -e[3], t[4] = -e[4], t[5] = -e[5], t[6] = -e[6], t[7] = -e[7], t[8] = -e[8], t
        }, l.transpose = function (e, t) {
            var i = e[0], n = e[3], r = e[6], o = e[1], a = e[4], s = e[7], u = e[2], l = e[5], c = e[8];
            return t[0] = i, t[1] = n, t[2] = r, t[3] = o, t[4] = a, t[5] = s, t[6] = u, t[7] = l, t[8] = c, t
        };
        var d = [1, 0, 0], m = [2, 2, 1], p = new l, f = new l;
        return l.computeEigenDecomposition = function (e, t) {
            var n = o.EPSILON20, r = 10, c = 0, h = 0;
            i(t) || (t = {});
            for (var d = t.unitary = l.clone(l.IDENTITY, t.unitary), m = t.diagonal = l.clone(e, t.diagonal), _ = n * a(m); r > h && s(m) > _;)u(m, p), l.transpose(p, f), l.multiply(m, p, m), l.multiply(f, m, m), l.multiply(d, p, d), ++c > 2 && (++h, c = 0);
            return t
        }, l.abs = function (e, t) {
            return t[0] = Math.abs(e[0]), t[1] = Math.abs(e[1]), t[2] = Math.abs(e[2]), t[3] = Math.abs(e[3]), t[4] = Math.abs(e[4]), t[5] = Math.abs(e[5]), t[6] = Math.abs(e[6]), t[7] = Math.abs(e[7]), t[8] = Math.abs(e[8]), t
        }, l.determinant = function (e) {
            var t = e[0], i = e[3], n = e[6], r = e[1], o = e[4], a = e[7], s = e[2], u = e[5], l = e[8];
            return t * (o * l - u * a) + r * (u * n - i * l) + s * (i * a - o * n)
        }, l.inverse = function (e, t) {
            var i = e[0], r = e[1], a = e[2], s = e[3], u = e[4], c = e[5], h = e[6], d = e[7], m = e[8], p = l.determinant(e);
            if (Math.abs(p) <= o.EPSILON15)throw new n("matrix is not invertible");
            t[0] = u * m - d * c, t[1] = d * a - r * m, t[2] = r * c - u * a, t[3] = h * c - s * m, t[4] = i * m - h * a, t[5] = s * a - i * c, t[6] = s * d - h * u, t[7] = h * r - i * d, t[8] = i * u - s * r;
            var f = 1 / p;
            return l.multiplyByScalar(t, f, t)
        }, l.equals = function (e, t) {
            return e === t || i(e) && i(t) && e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8]
        }, l.equalsEpsilon = function (e, t, n) {
            return e === t || i(e) && i(t) && Math.abs(e[0] - t[0]) <= n && Math.abs(e[1] - t[1]) <= n && Math.abs(e[2] - t[2]) <= n && Math.abs(e[3] - t[3]) <= n && Math.abs(e[4] - t[4]) <= n && Math.abs(e[5] - t[5]) <= n && Math.abs(e[6] - t[6]) <= n && Math.abs(e[7] - t[7]) <= n && Math.abs(e[8] - t[8]) <= n
        }, l.IDENTITY = r(new l(1, 0, 0, 0, 1, 0, 0, 0, 1)), l.ZERO = r(new l(0, 0, 0, 0, 0, 0, 0, 0, 0)), l.COLUMN0ROW0 = 0, l.COLUMN0ROW1 = 1, l.COLUMN0ROW2 = 2, l.COLUMN1ROW0 = 3, l.COLUMN1ROW1 = 4, l.COLUMN1ROW2 = 5, l.COLUMN2ROW0 = 6, l.COLUMN2ROW1 = 7, l.COLUMN2ROW2 = 8, l.prototype.clone = function (e) {
            return l.clone(this, e)
        }, l.prototype.equals = function (e) {
            return l.equals(this, e)
        }, l.equalsArray = function (e, t, i) {
            return e[0] === t[i] && e[1] === t[i + 1] && e[2] === t[i + 2] && e[3] === t[i + 3] && e[4] === t[i + 4] && e[5] === t[i + 5] && e[6] === t[i + 6] && e[7] === t[i + 7] && e[8] === t[i + 8]
        }, l.prototype.equalsEpsilon = function (e, t) {
            return l.equalsEpsilon(this, e, t)
        }, l.prototype.toString = function () {
            return "(" + this[0] + ", " + this[3] + ", " + this[6] + ")\n(" + this[1] + ", " + this[4] + ", " + this[7] + ")\n(" + this[2] + ", " + this[5] + ", " + this[8] + ")"
        }, l
    }), define("Cesium/Core/RuntimeError", ["./defined"], function (e) {
        "use strict";
        var t = function (e) {
            this.name = "RuntimeError", this.message = e;
            var t;
            try {
                throw new Error
            } catch (i) {
                t = i.stack
            }
            this.stack = t
        };
        return t.prototype.toString = function () {
            var t = this.name + ": " + this.message;
            return e(this.stack) && (t += "\n" + this.stack.toString()), t
        }, t
    }), define("Cesium/Core/Matrix4", ["./Cartesian3", "./Cartesian4", "./defaultValue", "./defined", "./DeveloperError", "./freezeObject", "./Math", "./Matrix3", "./RuntimeError"], function (e, t, i, n, r, o, a, s, u) {
        "use strict";
        var l = function (e, t, n, r, o, a, s, u, l, c, h, d, m, p, f, _) {
            this[0] = i(e, 0), this[1] = i(o, 0), this[2] = i(l, 0), this[3] = i(m, 0), this[4] = i(t, 0), this[5] = i(a, 0), this[6] = i(c, 0), this[7] = i(p, 0), this[8] = i(n, 0), this[9] = i(s, 0), this[10] = i(h, 0), this[11] = i(f, 0), this[12] = i(r, 0), this[13] = i(u, 0), this[14] = i(d, 0), this[15] = i(_, 0)
        };
        l.packedLength = 16, l.pack = function (e, t, n) {
            n = i(n, 0), t[n++] = e[0], t[n++] = e[1], t[n++] = e[2], t[n++] = e[3], t[n++] = e[4], t[n++] = e[5], t[n++] = e[6], t[n++] = e[7], t[n++] = e[8], t[n++] = e[9], t[n++] = e[10], t[n++] = e[11], t[n++] = e[12], t[n++] = e[13], t[n++] = e[14], t[n] = e[15]
        }, l.unpack = function (e, t, r) {
            return t = i(t, 0), n(r) || (r = new l), r[0] = e[t++], r[1] = e[t++], r[2] = e[t++], r[3] = e[t++], r[4] = e[t++], r[5] = e[t++], r[6] = e[t++], r[7] = e[t++], r[8] = e[t++], r[9] = e[t++], r[10] = e[t++], r[11] = e[t++], r[12] = e[t++], r[13] = e[t++], r[14] = e[t++], r[15] = e[t], r
        }, l.clone = function (e, t) {
            return n(e) ? n(t) ? (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t) : new l(e[0], e[4], e[8], e[12], e[1], e[5], e[9], e[13], e[2], e[6], e[10], e[14], e[3], e[7], e[11], e[15]) : void 0
        }, l.fromArray = l.unpack, l.fromColumnMajorArray = function (e, t) {
            return l.clone(e, t)
        }, l.fromRowMajorArray = function (e, t) {
            return n(t) ? (t[0] = e[0], t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = e[1], t[5] = e[5], t[6] = e[9], t[7] = e[13], t[8] = e[2], t[9] = e[6], t[10] = e[10], t[11] = e[14], t[12] = e[3], t[13] = e[7], t[14] = e[11], t[15] = e[15], t) : new l(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15])
        }, l.fromRotationTranslation = function (t, r, o) {
            return r = i(r, e.ZERO), n(o) ? (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = 0, o[4] = t[3], o[5] = t[4], o[6] = t[5], o[7] = 0, o[8] = t[6], o[9] = t[7], o[10] = t[8], o[11] = 0, o[12] = r.x, o[13] = r.y, o[14] = r.z, o[15] = 1, o) : new l(t[0], t[3], t[6], r.x, t[1], t[4], t[7], r.y, t[2], t[5], t[8], r.z, 0, 0, 0, 1)
        }, l.fromTranslationQuaternionRotationScale = function (e, t, i, r) {
            n(r) || (r = new l);
            var o = i.x, a = i.y, s = i.z, u = t.x * t.x, c = t.x * t.y, h = t.x * t.z, d = t.x * t.w, m = t.y * t.y, p = t.y * t.z, f = t.y * t.w, _ = t.z * t.z, v = t.z * t.w, g = t.w * t.w, y = u - m - _ + g, C = 2 * (c - v), E = 2 * (h + f), S = 2 * (c + v), T = -u + m - _ + g, b = 2 * (p - d), w = 2 * (h - f), x = 2 * (p + d), A = -u - m + _ + g;
            return r[0] = y * o, r[1] = S * o, r[2] = w * o, r[3] = 0, r[4] = C * a, r[5] = T * a, r[6] = x * a, r[7] = 0, r[8] = E * s, r[9] = b * s, r[10] = A * s, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, r
        }, l.fromTranslation = function (e, t) {
            return l.fromRotationTranslation(s.IDENTITY, e, t)
        }, l.fromScale = function (e, t) {
            return n(t) ? (t[0] = e.x, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e.y, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e.z, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t) : new l(e.x, 0, 0, 0, 0, e.y, 0, 0, 0, 0, e.z, 0, 0, 0, 0, 1)
        }, l.fromUniformScale = function (e, t) {
            return n(t) ? (t[0] = e, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t) : new l(e, 0, 0, 0, 0, e, 0, 0, 0, 0, e, 0, 0, 0, 0, 1)
        };
        var c = new e, h = new e, d = new e;
        l.fromCamera = function (t, i) {
            var r = t.eye, o = t.target, a = t.up;
            e.normalize(e.subtract(o, r, c), c), e.normalize(e.cross(c, a, h), h), e.normalize(e.cross(h, c, d), d);
            var s = h.x, u = h.y, m = h.z, p = c.x, f = c.y, _ = c.z, v = d.x, g = d.y, y = d.z, C = r.x, E = r.y, S = r.z, T = s * -C + u * -E + m * -S, b = v * -C + g * -E + y * -S, w = p * C + f * E + _ * S;
            return n(i) ? (i[0] = s, i[1] = v, i[2] = -p, i[3] = 0, i[4] = u, i[5] = g, i[6] = -f, i[7] = 0, i[8] = m, i[9] = y, i[10] = -_, i[11] = 0, i[12] = T, i[13] = b, i[14] = w, i[15] = 1, i) : new l(s, u, m, T, v, g, y, b, -p, -f, -_, w, 0, 0, 0, 1)
        }, l.computePerspectiveFieldOfView = function (e, t, i, n, r) {
            var o = Math.tan(.5 * e), a = 1 / o, s = a / t, u = (n + i) / (i - n), l = 2 * n * i / (i - n);
            return r[0] = s, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = a, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = u, r[11] = -1, r[12] = 0, r[13] = 0, r[14] = l, r[15] = 0, r
        }, l.computeOrthographicOffCenter = function (e, t, i, n, r, o, a) {
            var s = 1 / (t - e), u = 1 / (n - i), l = 1 / (o - r), c = -(t + e) * s, h = -(n + i) * u, d = -(o + r) * l;
            return s *= 2, u *= 2, l *= -2, a[0] = s, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = u, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = l, a[11] = 0, a[12] = c, a[13] = h, a[14] = d, a[15] = 1, a
        }, l.computePerspectiveOffCenter = function (e, t, i, n, r, o, a) {
            var s = 2 * r / (t - e), u = 2 * r / (n - i), l = (t + e) / (t - e), c = (n + i) / (n - i), h = -(o + r) / (o - r), d = -1, m = -2 * o * r / (o - r);
            return a[0] = s, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = u, a[6] = 0, a[7] = 0, a[8] = l, a[9] = c, a[10] = h, a[11] = d, a[12] = 0, a[13] = 0, a[14] = m, a[15] = 0, a
        }, l.computeInfinitePerspectiveOffCenter = function (e, t, i, n, r, o) {
            var a = 2 * r / (t - e), s = 2 * r / (n - i), u = (t + e) / (t - e), l = (n + i) / (n - i), c = -1, h = -1, d = -2 * r;
            return o[0] = a, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = s, o[6] = 0, o[7] = 0, o[8] = u, o[9] = l, o[10] = c, o[11] = h, o[12] = 0, o[13] = 0, o[14] = d, o[15] = 0, o
        }, l.computeViewportTransformation = function (e, t, n, r) {
            e = i(e, i.EMPTY_OBJECT);
            var o = i(e.x, 0), a = i(e.y, 0), s = i(e.width, 0), u = i(e.height, 0);
            t = i(t, 0), n = i(n, 1);
            var l = .5 * s, c = .5 * u, h = .5 * (n - t), d = l, m = c, p = h, f = o + l, _ = a + c, v = t + h, g = 1;
            return r[0] = d, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = m, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = p, r[11] = 0, r[12] = f, r[13] = _, r[14] = v, r[15] = g, r
        }, l.toArray = function (e, t) {
            return n(t) ? (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t) : [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]]
        }, l.getElementIndex = function (e, t) {
            return 4 * e + t
        }, l.getColumn = function (e, t, i) {
            var n = 4 * t, r = e[n], o = e[n + 1], a = e[n + 2], s = e[n + 3];
            return i.x = r, i.y = o, i.z = a, i.w = s, i
        }, l.setColumn = function (e, t, i, n) {
            n = l.clone(e, n);
            var r = 4 * t;
            return n[r] = i.x, n[r + 1] = i.y, n[r + 2] = i.z, n[r + 3] = i.w, n
        }, l.setTranslation = function (e, t, i) {
            return i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = e[3], i[4] = e[4], i[5] = e[5], i[6] = e[6], i[7] = e[7], i[8] = e[8], i[9] = e[9], i[10] = e[10], i[11] = e[11], i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = e[15], i
        }, l.getRow = function (e, t, i) {
            var n = e[t], r = e[t + 4], o = e[t + 8], a = e[t + 12];
            return i.x = n, i.y = r, i.z = o, i.w = a, i
        }, l.setRow = function (e, t, i, n) {
            return n = l.clone(e, n), n[t] = i.x, n[t + 4] = i.y, n[t + 8] = i.z, n[t + 12] = i.w, n
        };
        var m = new e;
        l.getScale = function (t, i) {
            return i.x = e.magnitude(e.fromElements(t[0], t[1], t[2], m)), i.y = e.magnitude(e.fromElements(t[4], t[5], t[6], m)), i.z = e.magnitude(e.fromElements(t[8], t[9], t[10], m)), i
        };
        var p = new e;
        l.getMaximumScale = function (t) {
            return l.getScale(t, p), e.maximumComponent(p)
        }, l.multiply = function (e, t, i) {
            var n = e[0], r = e[1], o = e[2], a = e[3], s = e[4], u = e[5], l = e[6], c = e[7], h = e[8], d = e[9], m = e[10], p = e[11], f = e[12], _ = e[13], v = e[14], g = e[15], y = t[0], C = t[1], E = t[2], S = t[3], T = t[4], b = t[5], w = t[6], x = t[7], A = t[8], P = t[9], I = t[10], D = t[11], M = t[12], O = t[13], R = t[14], N = t[15], L = n * y + s * C + h * E + f * S, F = r * y + u * C + d * E + _ * S, B = o * y + l * C + m * E + v * S, z = a * y + c * C + p * E + g * S, V = n * T + s * b + h * w + f * x, U = r * T + u * b + d * w + _ * x, k = o * T + l * b + m * w + v * x, G = a * T + c * b + p * w + g * x, H = n * A + s * P + h * I + f * D, W = r * A + u * P + d * I + _ * D, q = o * A + l * P + m * I + v * D, j = a * A + c * P + p * I + g * D, Y = n * M + s * O + h * R + f * N, X = r * M + u * O + d * R + _ * N, Z = o * M + l * O + m * R + v * N, K = a * M + c * O + p * R + g * N;
            return i[0] = L, i[1] = F, i[2] = B, i[3] = z, i[4] = V, i[5] = U, i[6] = k, i[7] = G, i[8] = H, i[9] = W, i[10] = q, i[11] = j, i[12] = Y, i[13] = X, i[14] = Z, i[15] = K, i
        }, l.add = function (e, t, i) {
            return i[0] = e[0] + t[0], i[1] = e[1] + t[1], i[2] = e[2] + t[2], i[3] = e[3] + t[3], i[4] = e[4] + t[4], i[5] = e[5] + t[5], i[6] = e[6] + t[6], i[7] = e[7] + t[7], i[8] = e[8] + t[8], i[9] = e[9] + t[9], i[10] = e[10] + t[10], i[11] = e[11] + t[11], i[12] = e[12] + t[12], i[13] = e[13] + t[13], i[14] = e[14] + t[14], i[15] = e[15] + t[15], i
        }, l.subtract = function (e, t, i) {
            return i[0] = e[0] - t[0], i[1] = e[1] - t[1], i[2] = e[2] - t[2], i[3] = e[3] - t[3], i[4] = e[4] - t[4], i[5] = e[5] - t[5], i[6] = e[6] - t[6], i[7] = e[7] - t[7], i[8] = e[8] - t[8], i[9] = e[9] - t[9], i[10] = e[10] - t[10], i[11] = e[11] - t[11], i[12] = e[12] - t[12], i[13] = e[13] - t[13], i[14] = e[14] - t[14], i[15] = e[15] - t[15], i
        }, l.multiplyTransformation = function (e, t, i) {
            var n = e[0], r = e[1], o = e[2], a = e[4], s = e[5], u = e[6], l = e[8], c = e[9], h = e[10], d = e[12], m = e[13], p = e[14], f = t[0], _ = t[1], v = t[2], g = t[4], y = t[5], C = t[6], E = t[8], S = t[9], T = t[10], b = t[12], w = t[13], x = t[14], A = n * f + a * _ + l * v, P = r * f + s * _ + c * v, I = o * f + u * _ + h * v, D = n * g + a * y + l * C, M = r * g + s * y + c * C, O = o * g + u * y + h * C, R = n * E + a * S + l * T, N = r * E + s * S + c * T, L = o * E + u * S + h * T, F = n * b + a * w + l * x + d, B = r * b + s * w + c * x + m, z = o * b + u * w + h * x + p;
            return i[0] = A, i[1] = P, i[2] = I, i[3] = 0, i[4] = D, i[5] = M, i[6] = O, i[7] = 0, i[8] = R, i[9] = N, i[10] = L, i[11] = 0, i[12] = F, i[13] = B, i[14] = z, i[15] = 1, i
        }, l.multiplyByMatrix3 = function (e, t, i) {
            var n = e[0], r = e[1], o = e[2], a = e[4], s = e[5], u = e[6], l = e[8], c = e[9], h = e[10], d = t[0], m = t[1], p = t[2], f = t[3], _ = t[4], v = t[5], g = t[6], y = t[7], C = t[8], E = n * d + a * m + l * p, S = r * d + s * m + c * p, T = o * d + u * m + h * p, b = n * f + a * _ + l * v, w = r * f + s * _ + c * v, x = o * f + u * _ + h * v, A = n * g + a * y + l * C, P = r * g + s * y + c * C, I = o * g + u * y + h * C;
            return i[0] = E, i[1] = S, i[2] = T, i[3] = 0, i[4] = b, i[5] = w, i[6] = x, i[7] = 0, i[8] = A, i[9] = P, i[10] = I, i[11] = 0, i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = e[15], i
        }, l.multiplyByTranslation = function (e, t, i) {
            var n = t.x, r = t.y, o = t.z, a = n * e[0] + r * e[4] + o * e[8] + e[12], s = n * e[1] + r * e[5] + o * e[9] + e[13], u = n * e[2] + r * e[6] + o * e[10] + e[14];
            return i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = e[3], i[4] = e[4], i[5] = e[5], i[6] = e[6], i[7] = e[7], i[8] = e[8], i[9] = e[9], i[10] = e[10], i[11] = e[11], i[12] = a, i[13] = s, i[14] = u, i[15] = e[15], i
        };
        var f = new e;
        l.multiplyByUniformScale = function (e, t, i) {
            return f.x = t, f.y = t, f.z = t, l.multiplyByScale(e, f, i)
        }, l.multiplyByScale = function (e, t, i) {
            var n = t.x, r = t.y, o = t.z;
            return 1 === n && 1 === r && 1 === o ? l.clone(e, i) : (i[0] = n * e[0], i[1] = n * e[1], i[2] = n * e[2], i[3] = 0, i[4] = r * e[4], i[5] = r * e[5], i[6] = r * e[6], i[7] = 0, i[8] = o * e[8], i[9] = o * e[9], i[10] = o * e[10], i[11] = 0, i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = 1, i)
        }, l.multiplyByVector = function (e, t, i) {
            var n = t.x, r = t.y, o = t.z, a = t.w, s = e[0] * n + e[4] * r + e[8] * o + e[12] * a, u = e[1] * n + e[5] * r + e[9] * o + e[13] * a, l = e[2] * n + e[6] * r + e[10] * o + e[14] * a, c = e[3] * n + e[7] * r + e[11] * o + e[15] * a;
            return i.x = s, i.y = u, i.z = l, i.w = c, i
        }, l.multiplyByPointAsVector = function (e, t, i) {
            var n = t.x, r = t.y, o = t.z, a = e[0] * n + e[4] * r + e[8] * o, s = e[1] * n + e[5] * r + e[9] * o, u = e[2] * n + e[6] * r + e[10] * o;
            return i.x = a, i.y = s, i.z = u, i
        }, l.multiplyByPoint = function (e, t, i) {
            var n = t.x, r = t.y, o = t.z, a = e[0] * n + e[4] * r + e[8] * o + e[12], s = e[1] * n + e[5] * r + e[9] * o + e[13], u = e[2] * n + e[6] * r + e[10] * o + e[14];
            return i.x = a, i.y = s, i.z = u, i
        }, l.multiplyByScalar = function (e, t, i) {
            return i[0] = e[0] * t, i[1] = e[1] * t, i[2] = e[2] * t, i[3] = e[3] * t, i[4] = e[4] * t, i[5] = e[5] * t, i[6] = e[6] * t, i[7] = e[7] * t, i[8] = e[8] * t, i[9] = e[9] * t, i[10] = e[10] * t, i[11] = e[11] * t, i[12] = e[12] * t, i[13] = e[13] * t, i[14] = e[14] * t, i[15] = e[15] * t, i
        }, l.negate = function (e, t) {
            return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = -e[3], t[4] = -e[4], t[5] = -e[5], t[6] = -e[6], t[7] = -e[7], t[8] = -e[8], t[9] = -e[9], t[10] = -e[10], t[11] = -e[11], t[12] = -e[12], t[13] = -e[13], t[14] = -e[14], t[15] = -e[15], t
        }, l.transpose = function (e, t) {
            var i = e[1], n = e[2], r = e[3], o = e[6], a = e[7], s = e[11];
            return t[0] = e[0], t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = i, t[5] = e[5], t[6] = e[9], t[7] = e[13], t[8] = n, t[9] = o, t[10] = e[10], t[11] = e[14], t[12] = r, t[13] = a, t[14] = s, t[15] = e[15], t
        }, l.abs = function (e, t) {
            return t[0] = Math.abs(e[0]), t[1] = Math.abs(e[1]), t[2] = Math.abs(e[2]), t[3] = Math.abs(e[3]), t[4] = Math.abs(e[4]), t[5] = Math.abs(e[5]), t[6] = Math.abs(e[6]), t[7] = Math.abs(e[7]), t[8] = Math.abs(e[8]), t[9] = Math.abs(e[9]), t[10] = Math.abs(e[10]), t[11] = Math.abs(e[11]), t[12] = Math.abs(e[12]), t[13] = Math.abs(e[13]), t[14] = Math.abs(e[14]), t[15] = Math.abs(e[15]), t
        }, l.equals = function (e, t) {
            return e === t || n(e) && n(t) && e[12] === t[12] && e[13] === t[13] && e[14] === t[14] && e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[8] === t[8] && e[9] === t[9] && e[10] === t[10] && e[3] === t[3] && e[7] === t[7] && e[11] === t[11] && e[15] === t[15]
        }, l.equalsEpsilon = function (e, t, i) {
            return e === t || n(e) && n(t) && Math.abs(e[0] - t[0]) <= i && Math.abs(e[1] - t[1]) <= i && Math.abs(e[2] - t[2]) <= i && Math.abs(e[3] - t[3]) <= i && Math.abs(e[4] - t[4]) <= i && Math.abs(e[5] - t[5]) <= i && Math.abs(e[6] - t[6]) <= i && Math.abs(e[7] - t[7]) <= i && Math.abs(e[8] - t[8]) <= i && Math.abs(e[9] - t[9]) <= i && Math.abs(e[10] - t[10]) <= i && Math.abs(e[11] - t[11]) <= i && Math.abs(e[12] - t[12]) <= i && Math.abs(e[13] - t[13]) <= i && Math.abs(e[14] - t[14]) <= i && Math.abs(e[15] - t[15]) <= i
        }, l.getTranslation = function (e, t) {
            return t.x = e[12], t.y = e[13], t.z = e[14], t
        }, l.getRotation = function (e, t) {
            return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[4], t[4] = e[5], t[5] = e[6], t[6] = e[8], t[7] = e[9], t[8] = e[10], t
        };
        var _ = new s, v = new s, g = new t, y = new t(0, 0, 0, 1);
        return l.inverse = function (e, i) {
            if (s.equalsEpsilon(l.getRotation(e, _), v, a.EPSILON7) && t.equals(l.getRow(e, 3, g), y))return i[0] = 0, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 0, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 0, i[11] = 0, i[12] = -e[12], i[13] = -e[13], i[14] = -e[14], i[15] = 1, i;
            var n = e[0], r = e[4], o = e[8], c = e[12], h = e[1], d = e[5], m = e[9], p = e[13], f = e[2], C = e[6], E = e[10], S = e[14], T = e[3], b = e[7], w = e[11], x = e[15], A = E * x, P = S * w, I = C * x, D = S * b, M = C * w, O = E * b, R = f * x, N = S * T, L = f * w, F = E * T, B = f * b, z = C * T, V = A * d + D * m + M * p - (P * d + I * m + O * p), U = P * h + R * m + F * p - (A * h + N * m + L * p), k = I * h + N * d + B * p - (D * h + R * d + z * p), G = O * h + L * d + z * m - (M * h + F * d + B * m), H = P * r + I * o + O * c - (A * r + D * o + M * c), W = A * n + N * o + L * c - (P * n + R * o + F * c), q = D * n + R * r + z * c - (I * n + N * r + B * c), j = M * n + F * r + B * o - (O * n + L * r + z * o);
            A = o * p, P = c * m, I = r * p, D = c * d, M = r * m, O = o * d, R = n * p, N = c * h, L = n * m, F = o * h, B = n * d, z = r * h;
            var Y = A * b + D * w + M * x - (P * b + I * w + O * x), X = P * T + R * w + F * x - (A * T + N * w + L * x), Z = I * T + N * b + B * x - (D * T + R * b + z * x), K = O * T + L * b + z * w - (M * T + F * b + B * w), J = I * E + O * S + P * C - (M * S + A * C + D * E), Q = L * S + A * f + N * E - (R * E + F * S + P * f), $ = R * C + z * S + D * f - (B * S + I * f + N * C), ee = B * E + M * f + F * C - (L * C + z * E + O * f), te = n * V + r * U + o * k + c * G;
            if (Math.abs(te) < a.EPSILON20)throw new u("matrix is not invertible because its determinate is zero.");
            return te = 1 / te, i[0] = V * te, i[1] = U * te, i[2] = k * te, i[3] = G * te, i[4] = H * te, i[5] = W * te, i[6] = q * te, i[7] = j * te, i[8] = Y * te, i[9] = X * te, i[10] = Z * te, i[11] = K * te, i[12] = J * te, i[13] = Q * te, i[14] = $ * te, i[15] = ee * te, i
        }, l.inverseTransformation = function (e, t) {
            var i = e[0], n = e[1], r = e[2], o = e[4], a = e[5], s = e[6], u = e[8], l = e[9], c = e[10], h = e[12], d = e[13], m = e[14], p = -i * h - n * d - r * m, f = -o * h - a * d - s * m, _ = -u * h - l * d - c * m;
            return t[0] = i, t[1] = o, t[2] = u, t[3] = 0, t[4] = n, t[5] = a, t[6] = l, t[7] = 0, t[8] = r, t[9] = s, t[10] = c, t[11] = 0, t[12] = p, t[13] = f, t[14] = _, t[15] = 1, t
        }, l.IDENTITY = o(new l(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)), l.ZERO = o(new l(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)), l.COLUMN0ROW0 = 0, l.COLUMN0ROW1 = 1, l.COLUMN0ROW2 = 2, l.COLUMN0ROW3 = 3, l.COLUMN1ROW0 = 4, l.COLUMN1ROW1 = 5, l.COLUMN1ROW2 = 6, l.COLUMN1ROW3 = 7, l.COLUMN2ROW0 = 8, l.COLUMN2ROW1 = 9, l.COLUMN2ROW2 = 10, l.COLUMN2ROW3 = 11, l.COLUMN3ROW0 = 12, l.COLUMN3ROW1 = 13, l.COLUMN3ROW2 = 14, l.COLUMN3ROW3 = 15, l.prototype.clone = function (e) {
            return l.clone(this, e)
        }, l.prototype.equals = function (e) {
            return l.equals(this, e)
        }, l.equalsArray = function (e, t, i) {
            return e[0] === t[i] && e[1] === t[i + 1] && e[2] === t[i + 2] && e[3] === t[i + 3] && e[4] === t[i + 4] && e[5] === t[i + 5] && e[6] === t[i + 6] && e[7] === t[i + 7] && e[8] === t[i + 8] && e[9] === t[i + 9] && e[10] === t[i + 10] && e[11] === t[i + 11] && e[12] === t[i + 12] && e[13] === t[i + 13] && e[14] === t[i + 14] && e[15] === t[i + 15]
        }, l.prototype.equalsEpsilon = function (e, t) {
            return l.equalsEpsilon(this, e, t)
        }, l.prototype.toString = function () {
            return "(" + this[0] + ", " + this[4] + ", " + this[8] + ", " + this[12] + ")\n(" + this[1] + ", " + this[5] + ", " + this[9] + ", " + this[13] + ")\n(" + this[2] + ", " + this[6] + ", " + this[10] + ", " + this[14] + ")\n(" + this[3] + ", " + this[7] + ", " + this[11] + ", " + this[15] + ")"
        }, l
    }), define("Cesium/Core/Plane", ["./Cartesian3", "./defined", "./DeveloperError", "./freezeObject"], function (e, t, i, n) {
        "use strict";
        var r = function (t, i) {
            this.normal = e.clone(t), this.distance = i
        };
        r.fromPointNormal = function (i, n, o) {
            var a = -e.dot(n, i);
            return t(o) ? (e.clone(n, o.normal), o.distance = a, o) : new r(n, a)
        };
        var o = new e;
        return r.fromCartesian4 = function (i, n) {
            var a = e.fromCartesian4(i, o), s = i.w;
            return t(n) ? (e.clone(a, n.normal), n.distance = s, n) : new r(a, s)
        }, r.getPointDistance = function (t, i) {
            return e.dot(t.normal, i) + t.distance
        }, r.ORIGIN_XY_PLANE = n(new r(e.UNIT_Z, 0)), r.ORIGIN_YZ_PLANE = n(new r(e.UNIT_X, 0)), r.ORIGIN_ZX_PLANE = n(new r(e.UNIT_Y, 0)), r
    }), define("Cesium/Core/Rectangle", ["./Cartographic", "./defaultValue", "./defined", "./defineProperties", "./DeveloperError", "./Ellipsoid", "./freezeObject", "./Math"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        var u = function (e, i, n, r) {
            this.west = t(e, 0), this.south = t(i, 0), this.east = t(n, 0), this.north = t(r, 0)
        };
        n(u.prototype, {
            width: {
                get: function () {
                    return u.computeWidth(this)
                }
            }, height: {
                get: function () {
                    return u.computeHeight(this)
                }
            }
        }), u.packedLength = 4, u.pack = function (e, i, n) {
            n = t(n, 0), i[n++] = e.west, i[n++] = e.south, i[n++] = e.east, i[n] = e.north
        }, u.unpack = function (e, n, r) {
            return n = t(n, 0), i(r) || (r = new u), r.west = e[n++], r.south = e[n++], r.east = e[n++], r.north = e[n], r
        }, u.computeWidth = function (e) {
            var t = e.east, i = e.west;
            return i > t && (t += s.TWO_PI), t - i
        }, u.computeHeight = function (e) {
            return e.north - e.south
        }, u.fromDegrees = function (e, n, r, o, a) {
            return e = s.toRadians(t(e, 0)), n = s.toRadians(t(n, 0)), r = s.toRadians(t(r, 0)), o = s.toRadians(t(o, 0)), i(a) ? (a.west = e, a.south = n, a.east = r, a.north = o, a) : new u(e, n, r, o)
        }, u.fromCartographicArray = function (e, t) {
            for (var n = Number.MAX_VALUE, r = -Number.MAX_VALUE, o = Number.MAX_VALUE, a = -Number.MAX_VALUE, s = 0, l = e.length; l > s; s++) {
                var c = e[s];
                n = Math.min(n, c.longitude), r = Math.max(r, c.longitude), o = Math.min(o, c.latitude), a = Math.max(a, c.latitude)
            }
            return i(t) ? (t.west = n, t.south = o, t.east = r, t.north = a, t) : new u(n, o, r, a)
        }, u.packedLength = 4, u.pack = function (e, i, n) {
            n = t(n, 0), i[n++] = e.west, i[n++] = e.south, i[n++] = e.east, i[n] = e.north
        }, u.unpack = function (e, n, r) {
            return n = t(n, 0), i(r) || (r = new u), r.west = e[n++], r.south = e[n++], r.east = e[n++], r.north = e[n], r
        }, u.clone = function (e, t) {
            return i(e) ? i(t) ? (t.west = e.west, t.south = e.south, t.east = e.east, t.north = e.north, t) : new u(e.west, e.south, e.east, e.north) : void 0
        }, u.prototype.clone = function (e) {
            return u.clone(this, e)
        }, u.prototype.equals = function (e) {
            return u.equals(this, e)
        }, u.equals = function (e, t) {
            return e === t || i(e) && i(t) && e.west === t.west && e.south === t.south && e.east === t.east && e.north === t.north
        }, u.prototype.equalsEpsilon = function (e, t) {
            return i(e) && Math.abs(this.west - e.west) <= t && Math.abs(this.south - e.south) <= t && Math.abs(this.east - e.east) <= t && Math.abs(this.north - e.north) <= t
        }, u.validate = function (e) {
        }, u.southwest = function (t, n) {
            return i(n) ? (n.longitude = t.west, n.latitude = t.south, n.height = 0, n) : new e(t.west, t.south)
        }, u.northwest = function (t, n) {
            return i(n) ? (n.longitude = t.west, n.latitude = t.north, n.height = 0, n) : new e(t.west, t.north)
        }, u.northeast = function (t, n) {
            return i(n) ? (n.longitude = t.east, n.latitude = t.north, n.height = 0, n) : new e(t.east, t.north)
        }, u.southeast = function (t, n) {
            return i(n) ? (n.longitude = t.east, n.latitude = t.south, n.height = 0, n) : new e(t.east, t.south)
        }, u.center = function (t, n) {
            var r = t.east, o = t.west;
            o > r && (r += s.TWO_PI);
            var a = s.negativePiToPi(.5 * (o + r)), u = .5 * (t.south + t.north);
            return i(n) ? (n.longitude = a, n.latitude = u, n.height = 0, n) : new e(a, u)
        }, u.intersection = function (e, t, n) {
            var r = e.east, o = e.west, a = t.east, l = t.west;
            o > r && a > 0 ? r += s.TWO_PI : l > a && r > 0 && (a += s.TWO_PI), o > r && 0 > l ? l += s.TWO_PI : l > a && 0 > o && (o += s.TWO_PI);
            var c = s.negativePiToPi(Math.max(o, l)), h = s.negativePiToPi(Math.min(r, a));
            if ((e.west < e.east || t.west < t.east) && c >= h)return void 0;
            var d = Math.max(e.south, t.south), m = Math.min(e.north, t.north);
            return d >= m ? void 0 : i(n) ? (n.west = c, n.south = d, n.east = h, n.north = m, n) : new u(c, d, h, m)
        }, u.contains = function (e, t) {
            var i = t.longitude, n = t.latitude, r = e.west, o = e.east;
            return r > o && (o += s.TWO_PI, 0 > i && (i += s.TWO_PI)), (i > r || s.equalsEpsilon(i, r, s.EPSILON14)) && (o > i || s.equalsEpsilon(i, o, s.EPSILON14)) && n >= e.south && n <= e.north
        };
        var l = new e;
        return u.subsample = function (e, n, r, a) {
            n = t(n, o.WGS84), r = t(r, 0), i(a) || (a = []);
            var c = 0, h = e.north, d = e.south, m = e.east, p = e.west, f = l;
            f.height = r, f.longitude = p, f.latitude = h, a[c] = n.cartographicToCartesian(f, a[c]), c++, f.longitude = m, a[c] = n.cartographicToCartesian(f, a[c]), c++, f.latitude = d, a[c] = n.cartographicToCartesian(f, a[c]), c++, f.longitude = p, a[c] = n.cartographicToCartesian(f, a[c]), c++, 0 > h ? f.latitude = h : d > 0 ? f.latitude = d : f.latitude = 0;
            for (var _ = 1; 8 > _; ++_)f.longitude = -Math.PI + _ * s.PI_OVER_TWO, u.contains(e, f) && (a[c] = n.cartographicToCartesian(f, a[c]), c++);
            return 0 === f.latitude && (f.longitude = p, a[c] = n.cartographicToCartesian(f, a[c]), c++, f.longitude = m, a[c] = n.cartographicToCartesian(f, a[c]), c++), a.length = c, a
        }, u.MAX_VALUE = a(new u(-Math.PI, -s.PI_OVER_TWO, Math.PI, s.PI_OVER_TWO)), u
    }), define("Cesium/Core/BoundingSphere", ["./Cartesian3", "./Cartographic", "./defaultValue", "./defined", "./deprecationWarning", "./DeveloperError", "./Ellipsoid", "./GeographicProjection", "./Intersect", "./Interval", "./Matrix4", "./Plane", "./Rectangle"], function (e, t, i, n, r, o, a, s, u, l, c, h, d) {
        "use strict";
        var m = function (t, n) {
            this.center = e.clone(i(t, e.ZERO)), this.radius = i(n, 0)
        }, p = new e, f = new e, _ = new e, v = new e, g = new e, y = new e, C = new e, E = new e, S = new e, T = new e, b = new e, w = new e;
        m.fromPoints = function (t, i) {
            if (n(i) || (i = new m), !n(t) || 0 === t.length)return i.center = e.clone(e.ZERO, i.center), i.radius = 0, i;
            for (var r = e.clone(t[0], C), o = e.clone(r, p), a = e.clone(r, f), s = e.clone(r, _), u = e.clone(r, v), l = e.clone(r, g), c = e.clone(r, y), h = t.length, d = 1; h > d; d++) {
                e.clone(t[d], r);
                var x = r.x, A = r.y, P = r.z;
                x < o.x && e.clone(r, o), x > u.x && e.clone(r, u), A < a.y && e.clone(r, a), A > l.y && e.clone(r, l), P < s.z && e.clone(r, s), P > c.z && e.clone(r, c)
            }
            var I = e.magnitudeSquared(e.subtract(u, o, E)), D = e.magnitudeSquared(e.subtract(l, a, E)), M = e.magnitudeSquared(e.subtract(c, s, E)), O = o, R = u, N = I;
            D > N && (N = D, O = a, R = l), M > N && (N = M, O = s, R = c);
            var L = S;
            L.x = .5 * (O.x + R.x), L.y = .5 * (O.y + R.y), L.z = .5 * (O.z + R.z);
            var F = e.magnitudeSquared(e.subtract(R, L, E)), B = Math.sqrt(F), z = T;
            z.x = o.x, z.y = a.y, z.z = s.z;
            var V = b;
            V.x = u.x, V.y = l.y, V.z = c.z;
            var U = e.multiplyByScalar(e.add(z, V, E), .5, w), k = 0;
            for (d = 0; h > d; d++) {
                e.clone(t[d], r);
                var G = e.magnitude(e.subtract(r, U, E));
                G > k && (k = G);
                var H = e.magnitudeSquared(e.subtract(r, L, E));
                if (H > F) {
                    var W = Math.sqrt(H);
                    B = .5 * (B + W), F = B * B;
                    var q = W - B;
                    L.x = (B * L.x + q * r.x) / W, L.y = (B * L.y + q * r.y) / W, L.z = (B * L.z + q * r.z) / W
                }
            }
            return k > B ? (e.clone(L, i.center), i.radius = B) : (e.clone(U, i.center), i.radius = k), i
        };
        var x = new s, A = new e, P = new e, I = new t, D = new t;
        m.fromRectangle2D = function (e, t, i) {
            return m.fromRectangleWithHeights2D(e, t, 0, 0, i)
        }, m.fromRectangleWithHeights2D = function (t, r, o, a, s) {
            if (n(s) || (s = new m), !n(t))return s.center = e.clone(e.ZERO, s.center), s.radius = 0, s;
            r = i(r, x), d.southwest(t, I), I.height = o, d.northeast(t, D), D.height = a;
            var u = r.project(I, A), l = r.project(D, P), c = l.x - u.x, h = l.y - u.y, p = l.z - u.z;
            s.radius = .5 * Math.sqrt(c * c + h * h + p * p);
            var f = s.center;
            return f.x = u.x + .5 * c, f.y = u.y + .5 * h, f.z = u.z + .5 * p, s
        };
        var M = [];
        m.fromRectangle3D = function (e, t, r, o) {
            t = i(t, a.WGS84), r = i(r, 0);
            var s;
            return n(e) && (s = d.subsample(e, t, r, M)), m.fromPoints(s, o)
        }, m.fromVertices = function (t, r, o, a) {
            if (n(a) || (a = new m), !n(t) || 0 === t.length)return a.center = e.clone(e.ZERO, a.center), a.radius = 0, a;
            r = i(r, e.ZERO), o = i(o, 3);
            var s = C;
            s.x = t[0] + r.x, s.y = t[1] + r.y, s.z = t[2] + r.z;
            for (var u = e.clone(s, p), l = e.clone(s, f), c = e.clone(s, _), h = e.clone(s, v), d = e.clone(s, g), x = e.clone(s, y), A = t.length, P = 0; A > P; P += o) {
                var I = t[P] + r.x, D = t[P + 1] + r.y, M = t[P + 2] + r.z;
                s.x = I, s.y = D, s.z = M, I < u.x && e.clone(s, u), I > h.x && e.clone(s, h), D < l.y && e.clone(s, l), D > d.y && e.clone(s, d), M < c.z && e.clone(s, c), M > x.z && e.clone(s, x)
            }
            var O = e.magnitudeSquared(e.subtract(h, u, E)), R = e.magnitudeSquared(e.subtract(d, l, E)), N = e.magnitudeSquared(e.subtract(x, c, E)), L = u, F = h, B = O;
            R > B && (B = R, L = l, F = d), N > B && (B = N, L = c, F = x);
            var z = S;
            z.x = .5 * (L.x + F.x), z.y = .5 * (L.y + F.y), z.z = .5 * (L.z + F.z);
            var V = e.magnitudeSquared(e.subtract(F, z, E)), U = Math.sqrt(V), k = T;
            k.x = u.x, k.y = l.y, k.z = c.z;
            var G = b;
            G.x = h.x, G.y = d.y, G.z = x.z;
            var H = e.multiplyByScalar(e.add(k, G, E), .5, w), W = 0;
            for (P = 0; A > P; P += o) {
                s.x = t[P] + r.x, s.y = t[P + 1] + r.y, s.z = t[P + 2] + r.z;
                var q = e.magnitude(e.subtract(s, H, E));
                q > W && (W = q);
                var j = e.magnitudeSquared(e.subtract(s, z, E));
                if (j > V) {
                    var Y = Math.sqrt(j);
                    U = .5 * (U + Y), V = U * U;
                    var X = Y - U;
                    z.x = (U * z.x + X * s.x) / Y, z.y = (U * z.y + X * s.y) / Y, z.z = (U * z.z + X * s.z) / Y
                }
            }
            return W > U ? (e.clone(z, a.center), a.radius = U) : (e.clone(H, a.center), a.radius = W), a
        }, m.fromCornerPoints = function (t, i, r) {
            n(r) || (r = new m);
            var o = r.center;
            return e.add(t, i, o), e.multiplyByScalar(o, .5, o), r.radius = e.distance(o, i), r
        }, m.fromEllipsoid = function (t, i) {
            return n(i) || (i = new m), e.clone(e.ZERO, i.center), i.radius = t.maximumRadius, i
        };
        var O = new e;
        m.fromBoundingSpheres = function (t, i) {
            if (n(i) || (i = new m), !n(t) || 0 === t.length)return i.center = e.clone(e.ZERO, i.center), i.radius = 0, i;
            var r = t.length;
            if (1 === r)return m.clone(t[0], i);
            if (2 === r)return m.union(t[0], t[1], i);
            for (var o = [], a = 0; r > a; a++)o.push(t[a].center);
            i = m.fromPoints(o, i);
            var s = i.center, u = i.radius;
            for (a = 0; r > a; a++) {
                var l = t[a];
                u = Math.max(u, e.distance(s, l.center, O) + l.radius)
            }
            return i.radius = u, i
        }, m.clone = function (t, i) {
            return n(t) ? n(i) ? (i.center = e.clone(t.center, i.center), i.radius = t.radius, i) : new m(t.center, t.radius) : void 0
        }, m.packedLength = 4, m.pack = function (e, t, n) {
            n = i(n, 0);
            var r = e.center;
            t[n++] = r.x, t[n++] = r.y, t[n++] = r.z, t[n] = e.radius
        }, m.unpack = function (e, t, r) {
            t = i(t, 0), n(r) || (r = new m);
            var o = r.center;
            return o.x = e[t++], o.y = e[t++], o.z = e[t++], r.radius = e[t], r
        };
        var R = new e, N = new e;
        m.union = function (t, i, r) {
            n(r) || (r = new m);
            var o = t.center, a = t.radius, s = i.center, u = i.radius, l = e.subtract(s, o, R), c = e.magnitude(l);
            if (a >= c + u)return t.clone(r), r;
            if (u >= c + a)return i.clone(r), r;
            var h = .5 * (a + c + u), d = e.multiplyByScalar(l, (-a + h) / c, N);
            return e.add(d, o, d), e.clone(d, r.center), r.radius = h, r
        };
        var L = new e;
        m.expand = function (t, i, n) {
            n = m.clone(t, n);
            var r = e.magnitude(e.subtract(i, n.center, L));
            return r > n.radius && (n.radius = r), n
        }, m.intersectPlane = function (t, i) {
            var n = t.center, r = t.radius, o = i.normal, a = e.dot(o, n) + i.distance;
            return -r > a ? u.OUTSIDE : r > a ? u.INTERSECTING : u.INSIDE
        }, m.transform = function (e, t, i) {
            return n(i) || (i = new m), i.center = c.multiplyByPoint(t, e.center, i.center), i.radius = c.getMaximumScale(t) * e.radius, i
        };
        var F = new e;
        m.distanceSquaredTo = function (t, i) {
            var n = e.subtract(t.center, i, F);
            return e.magnitudeSquared(n) - t.radius * t.radius
        }, m.transformWithoutScale = function (e, t, i) {
            return n(i) || (i = new m), i.center = c.multiplyByPoint(t, e.center, i.center), i.radius = e.radius, i
        };
        var B = new e;
        m.computePlaneDistances = function (t, i, r, o) {
            n(o) || (o = new l);
            var a = e.subtract(t.center, i, B), s = e.dot(r, a);
            return o.start = s - t.radius, o.stop = s + t.radius, o
        };
        for (var z = new e, V = new e, U = new e, k = new e, G = new e, H = new t, W = new Array(8), q = 0; 8 > q; ++q)W[q] = new e;
        var j = new s;
        return m.projectTo2D = function (t, n, r) {
            n = i(n, j);
            var o = n.ellipsoid, a = t.center, s = t.radius, u = o.geodeticSurfaceNormal(a, z), l = e.cross(e.UNIT_Z, u, V);
            e.normalize(l, l);
            var c = e.cross(u, l, U);
            e.normalize(c, c), e.multiplyByScalar(u, s, u), e.multiplyByScalar(c, s, c), e.multiplyByScalar(l, s, l);
            var h = e.negate(c, G), d = e.negate(l, k), p = W, f = p[0];
            e.add(u, c, f), e.add(f, l, f), f = p[1], e.add(u, c, f), e.add(f, d, f), f = p[2], e.add(u, h, f), e.add(f, d, f), f = p[3], e.add(u, h, f), e.add(f, l, f), e.negate(u, u), f = p[4], e.add(u, c, f), e.add(f, l, f), f = p[5], e.add(u, c, f), e.add(f, d, f), f = p[6], e.add(u, h, f), e.add(f, d, f), f = p[7], e.add(u, h, f), e.add(f, l, f);
            for (var _ = p.length, v = 0; _ > v; ++v) {
                var g = p[v];
                e.add(a, g, g);
                var y = o.cartesianToCartographic(g, H);
                n.project(y, g)
            }
            r = m.fromPoints(p, r), a = r.center;
            var C = a.x, E = a.y, S = a.z;
            return a.x = S, a.y = C, a.z = E, r
        }, m.isOccluded = function (e, t) {
            return !t.isBoundingSphereVisible(e)
        }, m.equals = function (t, i) {
            return t === i || n(t) && n(i) && e.equals(t.center, i.center) && t.radius === i.radius
        }, m.prototype.intersectPlane = function (e) {
            return m.intersectPlane(this, e)
        }, m.prototype.distanceSquaredTo = function (e) {
            return m.distanceSquaredTo(this, e)
        }, m.prototype.computePlaneDistances = function (e, t, i) {
            return m.computePlaneDistances(this, e, t, i)
        }, m.prototype.isOccluded = function (e) {
            return m.isOccluded(this, e)
        }, m.prototype.equals = function (e) {
            return m.equals(this, e)
        }, m.prototype.clone = function (e) {
            return m.clone(this, e)
        }, m
    }), define("Cesium/Core/clone", ["./defaultValue"], function (e) {
        "use strict";
        var t = function (i, n) {
            if (null === i || "object" != typeof i)return i;
            n = e(n, !1);
            var r = new i.constructor;
            for (var o in i)if (i.hasOwnProperty(o)) {
                var a = i[o];
                n && (a = t(a, n)), r[o] = a
            }
            return r
        };
        return t
    }), define("Cesium/Core/Fullscreen", ["./defined", "./defineProperties"], function (e, t) {
        "use strict";
        var i, n = {
            requestFullscreen: void 0,
            exitFullscreen: void 0,
            fullscreenEnabled: void 0,
            fullscreenElement: void 0,
            fullscreenchange: void 0,
            fullscreenerror: void 0
        }, r = {};
        return t(r, {
            element: {
                get: function () {
                    return r.supportsFullscreen() ? document[n.fullscreenElement] : void 0
                }
            }, changeEventName: {
                get: function () {
                    return r.supportsFullscreen() ? n.fullscreenchange : void 0
                }
            }, errorEventName: {
                get: function () {
                    return r.supportsFullscreen() ? n.fullscreenerror : void 0
                }
            }, enabled: {
                get: function () {
                    return r.supportsFullscreen() ? document[n.fullscreenEnabled] : void 0
                }
            }, fullscreen: {
                get: function () {
                    return r.supportsFullscreen() ? null !== r.element : void 0
                }
            }
        }), r.supportsFullscreen = function () {
            if (e(i))return i;
            i = !1;
            var t = document.body;
            if ("function" == typeof t.requestFullscreen)return n.requestFullscreen = "requestFullscreen", n.exitFullscreen = "exitFullscreen", n.fullscreenEnabled = "fullscreenEnabled", n.fullscreenElement = "fullscreenElement", n.fullscreenchange = "fullscreenchange", n.fullscreenerror = "fullscreenerror", i = !0;
            for (var r, o = ["webkit", "moz", "o", "ms", "khtml"], a = 0, s = o.length; s > a; ++a) {
                var u = o[a];
                r = u + "RequestFullscreen", "function" == typeof t[r] ? (n.requestFullscreen = r, i = !0) : (r = u + "RequestFullScreen", "function" == typeof t[r] && (n.requestFullscreen = r, i = !0)), r = u + "ExitFullscreen", "function" == typeof document[r] ? n.exitFullscreen = r : (r = u + "CancelFullScreen", "function" == typeof document[r] && (n.exitFullscreen = r)), r = u + "FullscreenEnabled", e(document[r]) ? n.fullscreenEnabled = r : (r = u + "FullScreenEnabled", e(document[r]) && (n.fullscreenEnabled = r)), r = u + "FullscreenElement", e(document[r]) ? n.fullscreenElement = r : (r = u + "FullScreenElement", e(document[r]) && (n.fullscreenElement = r)), r = u + "fullscreenchange", e(document["on" + r]) && ("ms" === u && (r = "MSFullscreenChange"), n.fullscreenchange = r), r = u + "fullscreenerror", e(document["on" + r]) && ("ms" === u && (r = "MSFullscreenError"), n.fullscreenerror = r)
            }
            return i
        }, r.requestFullscreen = function (e) {
            r.supportsFullscreen() && e[n.requestFullscreen]()
        }, r.exitFullscreen = function () {
            r.supportsFullscreen() && document[n.exitFullscreen]()
        }, r
    }), define("Cesium/Core/FeatureDetection", ["./defaultValue", "./defined", "./Fullscreen"], function (e, t, i) {
        "use strict";
        function n(e) {
            for (var t = e.split("."), i = 0, n = t.length; n > i; ++i)t[i] = parseInt(t[i], 10);
            return t
        }

        function r() {
            if (!t(_)) {
                _ = !1;
                var e = / Chrome\/([\.0-9]+)/.exec(navigator.userAgent);
                null !== e && (_ = !0, v = n(e[1]))
            }
            return _
        }

        function o() {
            return r() && v
        }

        function a() {
            if (!t(g) && (g = !1, !r() && / Safari\/[\.0-9]+/.test(navigator.userAgent))) {
                var e = / Version\/([\.0-9]+)/.exec(navigator.userAgent);
                null !== e && (g = !0, y = n(e[1]))
            }
            return g
        }

        function s() {
            return a() && y
        }

        function u() {
            if (!t(C)) {
                C = !1;
                var e = / AppleWebKit\/([\.0-9]+)(\+?)/.exec(navigator.userAgent);
                null !== e && (C = !0, E = n(e[1]), E.isNightly = !!e[2])
            }
            return C
        }

        function l() {
            return u() && E
        }

        function c() {
            if (!t(S)) {
                S = !1;
                var e;
                "Microsoft Internet Explorer" === navigator.appName ? (e = /MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(navigator.userAgent), null !== e && (S = !0, T = n(e[1]))) : "Netscape" === navigator.appName && (e = /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(navigator.userAgent), null !== e && (S = !0, T = n(e[1])))
            }
            return S
        }

        function h() {
            return c() && T
        }

        function d() {
            if (!t(b)) {
                b = !1;
                var e = /Firefox\/([\.0-9]+)/.exec(navigator.userAgent);
                null !== e && (b = !0, w = n(e[1]))
            }
            return b
        }

        function m() {
            return t(x) || (x = /Windows/i.test(navigator.appVersion)), x
        }

        function p() {
            return d() && w
        }

        function f() {
            return t(A) || (A = t(window.PointerEvent) && (!t(window.navigator.pointerEnabled) || window.navigator.pointerEnabled)), A
        }

        var _, v, g, y, C, E, S, T, b, w, x, A, P = {
            isChrome: r,
            chromeVersion: o,
            isSafari: a,
            safariVersion: s,
            isWebkit: u,
            webkitVersion: l,
            isInternetExplorer: c,
            internetExplorerVersion: h,
            isFirefox: d,
            firefoxVersion: p,
            isWindows: m,
            hardwareConcurrency: e(navigator.hardwareConcurrency, 3),
            supportsPointerEvents: f
        };
        return P.supportsFullscreen = function () {
            return i.supportsFullscreen()
        }, P.supportsTypedArrays = function () {
            return "undefined" != typeof ArrayBuffer
        }, P.supportsWebWorkers = function () {
            return "undefined" != typeof Worker
        }, P
    }), define("Cesium/Core/Color", ["./defaultValue", "./defined", "./DeveloperError", "./FeatureDetection", "./freezeObject", "./Math"], function (e, t, i, n, r, o) {
        "use strict";
        function a(e, t, i) {
            return 0 > i && (i += 1), i > 1 && (i -= 1), 1 > 6 * i ? e + 6 * (t - e) * i : 1 > 2 * i ? t : 2 > 3 * i ? e + (t - e) * (2 / 3 - i) * 6 : e
        }

        var s = function (t, i, n, r) {
            this.red = e(t, 1), this.green = e(i, 1), this.blue = e(n, 1), this.alpha = e(r, 1)
        };
        s.fromCartesian4 = function (e, i) {
            return t(i) ? (i.red = e.x, i.green = e.y, i.blue = e.z, i.alpha = e.w, i) : new s(e.x, e.y, e.z, e.w)
        }, s.fromBytes = function (i, n, r, o, a) {
            return i = s.byteToFloat(e(i, 255)), n = s.byteToFloat(e(n, 255)), r = s.byteToFloat(e(r, 255)), o = s.byteToFloat(e(o, 255)), t(a) ? (a.red = i, a.green = n, a.blue = r, a.alpha = o, a) : new s(i, n, r, o)
        }, s.fromAlpha = function (e, i, n) {
            return t(n) ? (n.red = e.red, n.green = e.green, n.blue = e.blue, n.alpha = i, n) : new s(e.red, e.green, e.blue, i)
        };
        var u, l, c;
        n.supportsTypedArrays() && (u = new ArrayBuffer(4), l = new Uint32Array(u), c = new Uint8Array(u)), s.fromRgba = function (e) {
            return l[0] = e, s.fromBytes(c[0], c[1], c[2], c[3])
        }, s.fromHsl = function (t, i, n, r) {
            t = e(t, 0) % 1, i = e(i, 0), n = e(n, 0), r = e(r, 1);
            var o = n, u = n, l = n;
            if (0 !== i) {
                var c;
                c = .5 > n ? n * (1 + i) : n + i - n * i;
                var h = 2 * n - c;
                o = a(h, c, t + 1 / 3), u = a(h, c, t), l = a(h, c, t - 1 / 3)
            }
            return new s(o, u, l, r)
        }, s.fromRandom = function (i, n) {
            i = e(i, e.EMPTY_OBJECT);
            var r = i.red;
            if (!t(r)) {
                var a = e(i.minimumRed, 0), u = e(i.maximumRed, 1);
                r = a + o.nextRandomNumber() * (u - a)
            }
            var l = i.green;
            if (!t(l)) {
                var c = e(i.minimumGreen, 0), h = e(i.maximumGreen, 1);
                l = c + o.nextRandomNumber() * (h - c)
            }
            var d = i.blue;
            if (!t(d)) {
                var m = e(i.minimumBlue, 0), p = e(i.maximumBlue, 1);
                d = m + o.nextRandomNumber() * (p - m)
            }
            var f = i.alpha;
            if (!t(f)) {
                var _ = e(i.minimumAlpha, 0), v = e(i.maximumAlpha, 1);
                f = _ + o.nextRandomNumber() * (v - _)
            }
            return t(n) ? (n.red = r, n.green = l, n.blue = d, n.alpha = f, n) : new s(r, l, d, f)
        };
        var h = /^#([0-9a-f])([0-9a-f])([0-9a-f])$/i, d = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i, m = /^rgba?\(\s*([0-9.]+%?)\s*,\s*([0-9.]+%?)\s*,\s*([0-9.]+%?)(?:\s*,\s*([0-9.]+))?\s*\)$/i, p = /^hsla?\(\s*([0-9.]+)\s*,\s*([0-9.]+%)\s*,\s*([0-9.]+%)(?:\s*,\s*([0-9.]+))?\s*\)$/i;
        return s.fromCssColorString = function (i) {
            var n = s[i.toUpperCase()];
            if (t(n))return s.clone(n);
            var r = h.exec(i);
            return null !== r ? new s(parseInt(r[1], 16) / 15, parseInt(r[2], 16) / 15, parseInt(r[3], 16) / 15) : (r = d.exec(i), null !== r ? new s(parseInt(r[1], 16) / 255, parseInt(r[2], 16) / 255, parseInt(r[3], 16) / 255) : (r = m.exec(i), null !== r ? new s(parseFloat(r[1]) / ("%" === r[1].substr(-1) ? 100 : 255), parseFloat(r[2]) / ("%" === r[2].substr(-1) ? 100 : 255), parseFloat(r[3]) / ("%" === r[3].substr(-1) ? 100 : 255), parseFloat(e(r[4], "1.0"))) : (r = p.exec(i), null !== r ? s.fromHsl(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, parseFloat(e(r[4], "1.0"))) : void 0)))
        }, s.packedLength = 4, s.pack = function (t, i, n) {
            n = e(n, 0), i[n++] = t.red, i[n++] = t.green, i[n++] = t.blue, i[n] = t.alpha
        }, s.unpack = function (i, n, r) {
            return n = e(n, 0), t(r) || (r = new s), r.red = i[n++], r.green = i[n++], r.blue = i[n++], r.alpha = i[n], r
        }, s.byteToFloat = function (e) {
            return e / 255
        }, s.floatToByte = function (e) {
            return 1 === e ? 255 : 256 * e | 0
        }, s.clone = function (e, i) {
            return t(e) ? t(i) ? (i.red = e.red, i.green = e.green, i.blue = e.blue, i.alpha = e.alpha, i) : new s(e.red, e.green, e.blue, e.alpha) : void 0
        }, s.equals = function (e, i) {
            return e === i || t(e) && t(i) && e.red === i.red && e.green === i.green && e.blue === i.blue && e.alpha === i.alpha
        }, s.equalsArray = function (e, t, i) {
            return e.red === t[i] && e.green === t[i + 1] && e.blue === t[i + 2] && e.alpha === t[i + 3]
        }, s.prototype.clone = function (e) {
            return s.clone(this, e)
        }, s.prototype.equals = function (e) {
            return s.equals(this, e)
        }, s.prototype.equalsEpsilon = function (e, i) {
            return this === e || t(e) && Math.abs(this.red - e.red) <= i && Math.abs(this.green - e.green) <= i && Math.abs(this.blue - e.blue) <= i && Math.abs(this.alpha - e.alpha) <= i
        }, s.prototype.toString = function () {
            return "(" + this.red + ", " + this.green + ", " + this.blue + ", " + this.alpha + ")"
        }, s.prototype.toCssColorString = function () {
            var e = s.floatToByte(this.red), t = s.floatToByte(this.green), i = s.floatToByte(this.blue);
            return 1 === this.alpha ? "rgb(" + e + "," + t + "," + i + ")" : "rgba(" + e + "," + t + "," + i + "," + this.alpha + ")"
        }, s.prototype.toBytes = function (e) {
            var i = s.floatToByte(this.red), n = s.floatToByte(this.green), r = s.floatToByte(this.blue), o = s.floatToByte(this.alpha);
            return t(e) ? (e[0] = i, e[1] = n, e[2] = r, e[3] = o, e) : [i, n, r, o]
        }, s.prototype.toRgba = function () {
            return c[0] = s.floatToByte(this.red), c[1] = s.floatToByte(this.green), c[2] = s.floatToByte(this.blue), c[3] = s.floatToByte(this.alpha), l[0]
        }, s.prototype.brighten = function (e, t) {
            return e = 1 - e, t.red = 1 - (1 - this.red) * e, t.green = 1 - (1 - this.green) * e, t.blue = 1 - (1 - this.blue) * e, t.alpha = this.alpha, t
        }, s.prototype.darken = function (e, t) {
            return e = 1 - e, t.red = this.red * e, t.green = this.green * e, t.blue = this.blue * e, t.alpha = this.alpha, t
        }, s.prototype.withAlpha = function (e, t) {
            return s.fromAlpha(this, e, t)
        }, s.ALICEBLUE = r(s.fromCssColorString("#F0F8FF")), s.ANTIQUEWHITE = r(s.fromCssColorString("#FAEBD7")), s.AQUA = r(s.fromCssColorString("#00FFFF")), s.AQUAMARINE = r(s.fromCssColorString("#7FFFD4")), s.AZURE = r(s.fromCssColorString("#F0FFFF")), s.BEIGE = r(s.fromCssColorString("#F5F5DC")),
            s.BISQUE = r(s.fromCssColorString("#FFE4C4")), s.BLACK = r(s.fromCssColorString("#000000")), s.BLANCHEDALMOND = r(s.fromCssColorString("#FFEBCD")), s.BLUE = r(s.fromCssColorString("#0000FF")), s.BLUEVIOLET = r(s.fromCssColorString("#8A2BE2")), s.BROWN = r(s.fromCssColorString("#A52A2A")), s.BURLYWOOD = r(s.fromCssColorString("#DEB887")), s.CADETBLUE = r(s.fromCssColorString("#5F9EA0")), s.CHARTREUSE = r(s.fromCssColorString("#7FFF00")), s.CHOCOLATE = r(s.fromCssColorString("#D2691E")), s.CORAL = r(s.fromCssColorString("#FF7F50")), s.CORNFLOWERBLUE = r(s.fromCssColorString("#6495ED")), s.CORNSILK = r(s.fromCssColorString("#FFF8DC")), s.CRIMSON = r(s.fromCssColorString("#DC143C")), s.CYAN = r(s.fromCssColorString("#00FFFF")), s.DARKBLUE = r(s.fromCssColorString("#00008B")), s.DARKCYAN = r(s.fromCssColorString("#008B8B")), s.DARKGOLDENROD = r(s.fromCssColorString("#B8860B")), s.DARKGRAY = r(s.fromCssColorString("#A9A9A9")), s.DARKGREEN = r(s.fromCssColorString("#006400")), s.DARKGREY = s.DARKGRAY, s.DARKKHAKI = r(s.fromCssColorString("#BDB76B")), s.DARKMAGENTA = r(s.fromCssColorString("#8B008B")), s.DARKOLIVEGREEN = r(s.fromCssColorString("#556B2F")), s.DARKORANGE = r(s.fromCssColorString("#FF8C00")), s.DARKORCHID = r(s.fromCssColorString("#9932CC")), s.DARKRED = r(s.fromCssColorString("#8B0000")), s.DARKSALMON = r(s.fromCssColorString("#E9967A")), s.DARKSEAGREEN = r(s.fromCssColorString("#8FBC8F")), s.DARKSLATEBLUE = r(s.fromCssColorString("#483D8B")), s.DARKSLATEGRAY = r(s.fromCssColorString("#2F4F4F")), s.DARKSLATEGREY = s.DARKSLATEGRAY, s.DARKTURQUOISE = r(s.fromCssColorString("#00CED1")), s.DARKVIOLET = r(s.fromCssColorString("#9400D3")), s.DEEPPINK = r(s.fromCssColorString("#FF1493")), s.DEEPSKYBLUE = r(s.fromCssColorString("#00BFFF")), s.DIMGRAY = r(s.fromCssColorString("#696969")), s.DIMGREY = s.DIMGRAY, s.DODGERBLUE = r(s.fromCssColorString("#1E90FF")), s.FIREBRICK = r(s.fromCssColorString("#B22222")), s.FLORALWHITE = r(s.fromCssColorString("#FFFAF0")), s.FORESTGREEN = r(s.fromCssColorString("#228B22")), s.FUSCHIA = r(s.fromCssColorString("#FF00FF")), s.GAINSBORO = r(s.fromCssColorString("#DCDCDC")), s.GHOSTWHITE = r(s.fromCssColorString("#F8F8FF")), s.GOLD = r(s.fromCssColorString("#FFD700")), s.GOLDENROD = r(s.fromCssColorString("#DAA520")), s.GRAY = r(s.fromCssColorString("#808080")), s.GREEN = r(s.fromCssColorString("#008000")), s.GREENYELLOW = r(s.fromCssColorString("#ADFF2F")), s.GREY = s.GRAY, s.HONEYDEW = r(s.fromCssColorString("#F0FFF0")), s.HOTPINK = r(s.fromCssColorString("#FF69B4")), s.INDIANRED = r(s.fromCssColorString("#CD5C5C")), s.INDIGO = r(s.fromCssColorString("#4B0082")), s.IVORY = r(s.fromCssColorString("#FFFFF0")), s.KHAKI = r(s.fromCssColorString("#F0E68C")), s.LAVENDER = r(s.fromCssColorString("#E6E6FA")), s.LAVENDAR_BLUSH = r(s.fromCssColorString("#FFF0F5")), s.LAWNGREEN = r(s.fromCssColorString("#7CFC00")), s.LEMONCHIFFON = r(s.fromCssColorString("#FFFACD")), s.LIGHTBLUE = r(s.fromCssColorString("#ADD8E6")), s.LIGHTCORAL = r(s.fromCssColorString("#F08080")), s.LIGHTCYAN = r(s.fromCssColorString("#E0FFFF")), s.LIGHTGOLDENRODYELLOW = r(s.fromCssColorString("#FAFAD2")), s.LIGHTGRAY = r(s.fromCssColorString("#D3D3D3")), s.LIGHTGREEN = r(s.fromCssColorString("#90EE90")), s.LIGHTGREY = s.LIGHTGRAY, s.LIGHTPINK = r(s.fromCssColorString("#FFB6C1")), s.LIGHTSEAGREEN = r(s.fromCssColorString("#20B2AA")), s.LIGHTSKYBLUE = r(s.fromCssColorString("#87CEFA")), s.LIGHTSLATEGRAY = r(s.fromCssColorString("#778899")), s.LIGHTSLATEGREY = s.LIGHTSLATEGRAY, s.LIGHTSTEELBLUE = r(s.fromCssColorString("#B0C4DE")), s.LIGHTYELLOW = r(s.fromCssColorString("#FFFFE0")), s.LIME = r(s.fromCssColorString("#00FF00")),s.LIMEGREEN = r(s.fromCssColorString("#32CD32")),s.LINEN = r(s.fromCssColorString("#FAF0E6")),s.MAGENTA = r(s.fromCssColorString("#FF00FF")),s.MAROON = r(s.fromCssColorString("#800000")),s.MEDIUMAQUAMARINE = r(s.fromCssColorString("#66CDAA")),s.MEDIUMBLUE = r(s.fromCssColorString("#0000CD")),s.MEDIUMORCHID = r(s.fromCssColorString("#BA55D3")),s.MEDIUMPURPLE = r(s.fromCssColorString("#9370DB")),s.MEDIUMSEAGREEN = r(s.fromCssColorString("#3CB371")),s.MEDIUMSLATEBLUE = r(s.fromCssColorString("#7B68EE")),s.MEDIUMSPRINGGREEN = r(s.fromCssColorString("#00FA9A")),s.MEDIUMTURQUOISE = r(s.fromCssColorString("#48D1CC")),s.MEDIUMVIOLETRED = r(s.fromCssColorString("#C71585")),s.MIDNIGHTBLUE = r(s.fromCssColorString("#191970")),s.MINTCREAM = r(s.fromCssColorString("#F5FFFA")),s.MISTYROSE = r(s.fromCssColorString("#FFE4E1")),s.MOCCASIN = r(s.fromCssColorString("#FFE4B5")),s.NAVAJOWHITE = r(s.fromCssColorString("#FFDEAD")),s.NAVY = r(s.fromCssColorString("#000080")),s.OLDLACE = r(s.fromCssColorString("#FDF5E6")),s.OLIVE = r(s.fromCssColorString("#808000")),s.OLIVEDRAB = r(s.fromCssColorString("#6B8E23")),s.ORANGE = r(s.fromCssColorString("#FFA500")),s.ORANGERED = r(s.fromCssColorString("#FF4500")),s.ORCHID = r(s.fromCssColorString("#DA70D6")),s.PALEGOLDENROD = r(s.fromCssColorString("#EEE8AA")),s.PALEGREEN = r(s.fromCssColorString("#98FB98")),s.PALETURQUOISE = r(s.fromCssColorString("#AFEEEE")),s.PALEVIOLETRED = r(s.fromCssColorString("#DB7093")),s.PAPAYAWHIP = r(s.fromCssColorString("#FFEFD5")),s.PEACHPUFF = r(s.fromCssColorString("#FFDAB9")),s.PERU = r(s.fromCssColorString("#CD853F")),s.PINK = r(s.fromCssColorString("#FFC0CB")),s.PLUM = r(s.fromCssColorString("#DDA0DD")),s.POWDERBLUE = r(s.fromCssColorString("#B0E0E6")),s.PURPLE = r(s.fromCssColorString("#800080")),s.RED = r(s.fromCssColorString("#FF0000")),s.ROSYBROWN = r(s.fromCssColorString("#BC8F8F")),s.ROYALBLUE = r(s.fromCssColorString("#4169E1")),s.SADDLEBROWN = r(s.fromCssColorString("#8B4513")),s.SALMON = r(s.fromCssColorString("#FA8072")),s.SANDYBROWN = r(s.fromCssColorString("#F4A460")),s.SEAGREEN = r(s.fromCssColorString("#2E8B57")),s.SEASHELL = r(s.fromCssColorString("#FFF5EE")),s.SIENNA = r(s.fromCssColorString("#A0522D")),s.SILVER = r(s.fromCssColorString("#C0C0C0")),s.SKYBLUE = r(s.fromCssColorString("#87CEEB")),s.SLATEBLUE = r(s.fromCssColorString("#6A5ACD")),s.SLATEGRAY = r(s.fromCssColorString("#708090")),s.SLATEGREY = s.SLATEGRAY,s.SNOW = r(s.fromCssColorString("#FFFAFA")),s.SPRINGGREEN = r(s.fromCssColorString("#00FF7F")),s.STEELBLUE = r(s.fromCssColorString("#4682B4")),s.TAN = r(s.fromCssColorString("#D2B48C")),s.TEAL = r(s.fromCssColorString("#008080")),s.THISTLE = r(s.fromCssColorString("#D8BFD8")),s.TOMATO = r(s.fromCssColorString("#FF6347")),s.TURQUOISE = r(s.fromCssColorString("#40E0D0")),s.VIOLET = r(s.fromCssColorString("#EE82EE")),s.WHEAT = r(s.fromCssColorString("#F5DEB3")),s.WHITE = r(s.fromCssColorString("#FFFFFF")),s.WHITESMOKE = r(s.fromCssColorString("#F5F5F5")),s.YELLOW = r(s.fromCssColorString("#FFFF00")),s.YELLOWGREEN = r(s.fromCssColorString("#9ACD32")),s.TRANSPARENT = r(new s(0, 0, 0, 0)),s
    }), define("Cesium/Core/Credit", ["./defined", "./defineProperties", "./DeveloperError"], function (e, t, i) {
        "use strict";
        var n = 0, r = {}, o = function (t, i, o) {
            var a = e(o), s = e(i), u = e(t);
            u || s || (t = o), this._text = t, this._imageUrl = i, this._link = o, this._hasLink = a, this._hasImage = s;
            var l, c = JSON.stringify([t, i, o]);
            e(r[c]) ? l = r[c] : (l = n++, r[c] = l), this._id = l
        };
        return t(o.prototype, {
            text: {
                get: function () {
                    return this._text
                }
            }, imageUrl: {
                get: function () {
                    return this._imageUrl
                }
            }, link: {
                get: function () {
                    return this._link
                }
            }, id: {
                get: function () {
                    return this._id
                }
            }
        }), o.prototype.hasImage = function () {
            return this._hasImage
        }, o.prototype.hasLink = function () {
            return this._hasLink
        }, o.equals = function (t, i) {
            return t === i || e(t) && e(i) && t._id === i._id
        }, o.prototype.equals = function (e) {
            return o.equals(this, e)
        }, o
    }), define("Cesium/Core/definedNotNull", [], function () {
        "use strict";
        var e = function (e) {
            return void 0 !== e && null !== e
        };
        return e
    }), define("Cesium/Core/formatError", ["./defined"], function (e) {
        "use strict";
        var t = function (t) {
            var i, n = t.name, r = t.message;
            i = e(n) && e(r) ? n + ": " + r : t.toString();
            var o = t.stack;
            return e(o) && (i += "\n" + o), i
        };
        return t
    }), define("Cesium/ThirdParty/sprintf", [], function () {
        function e() {
            var e = /%%|%(\d+\$)?([-+\'#0 ]*)(\*\d+\$|\*|\d+)?(\.(\*\d+\$|\*|\d+))?([scboxXuideEfFgG])/g, t = arguments, i = 0, n = t[i++], r = function (e, t, i, n) {
                i || (i = " ");
                var r = e.length >= t ? "" : Array(1 + t - e.length >>> 0).join(i);
                return n ? e + r : r + e
            }, o = function (e, t, i, n, o, a) {
                var s = n - e.length;
                return s > 0 && (e = i || !o ? r(e, n, a, i) : e.slice(0, t.length) + r("", s, "0", !0) + e.slice(t.length)), e
            }, a = function (e, t, i, n, a, s, u) {
                var l = e >>> 0;
                return i = i && l && {
                        2: "0b",
                        8: "0",
                        16: "0x"
                    }[t] || "", e = i + r(l.toString(t), s || 0, "0", !1), o(e, i, n, a, u)
            }, s = function (e, t, i, n, r, a) {
                return null != n && (e = e.slice(0, n)), o(e, "", t, i, r, a)
            }, u = function (e, n, u, l, c, h, d) {
                var m, p, f, _, v;
                if ("%%" == e)return "%";
                for (var g = !1, y = "", C = !1, E = !1, S = " ", T = u.length, b = 0; u && T > b; b++)switch (u.charAt(b)) {
                    case" ":
                        y = " ";
                        break;
                    case"+":
                        y = "+";
                        break;
                    case"-":
                        g = !0;
                        break;
                    case"'":
                        S = u.charAt(b + 1);
                        break;
                    case"0":
                        C = !0;
                        break;
                    case"#":
                        E = !0
                }
                if (l = l ? "*" == l ? +t[i++] : "*" == l.charAt(0) ? +t[l.slice(1, -1)] : +l : 0, 0 > l && (l = -l, g = !0), !isFinite(l))throw new Error("sprintf: (minimum-)width must be finite");
                switch (h = h ? "*" == h ? +t[i++] : "*" == h.charAt(0) ? +t[h.slice(1, -1)] : +h : "fFeE".indexOf(d) > -1 ? 6 : "d" == d ? 0 : void 0, v = n ? t[n.slice(0, -1)] : t[i++], d) {
                    case"s":
                        return s(String(v), g, l, h, C, S);
                    case"c":
                        return s(String.fromCharCode(+v), g, l, h, C);
                    case"b":
                        return a(v, 2, E, g, l, h, C);
                    case"o":
                        return a(v, 8, E, g, l, h, C);
                    case"x":
                        return a(v, 16, E, g, l, h, C);
                    case"X":
                        return a(v, 16, E, g, l, h, C).toUpperCase();
                    case"u":
                        return a(v, 10, E, g, l, h, C);
                    case"i":
                    case"d":
                        return m = +v || 0, m = Math.round(m - m % 1), p = 0 > m ? "-" : y, v = p + r(String(Math.abs(m)), h, "0", !1), o(v, p, g, l, C);
                    case"e":
                    case"E":
                    case"f":
                    case"F":
                    case"g":
                    case"G":
                        return m = +v, p = 0 > m ? "-" : y, f = ["toExponential", "toFixed", "toPrecision"]["efg".indexOf(d.toLowerCase())], _ = ["toString", "toUpperCase"]["eEfFgG".indexOf(d) % 2], v = p + Math.abs(m)[f](h), o(v, p, g, l, C)[_]();
                    default:
                        return e
                }
            };
            return n.replace(e, u)
        }

        return e
    }), define("Cesium/Core/binarySearch", ["./defined", "./DeveloperError"], function (e, t) {
        "use strict";
        var i = function (e, t, i) {
            for (var n, r, o = 0, a = e.length - 1; a >= o;)if (n = ~~((o + a) / 2), r = i(e[n], t), 0 > r)o = n + 1; else {
                if (!(r > 0))return n;
                a = n - 1
            }
            return ~(a + 1)
        };
        return i
    }), define("Cesium/Core/GregorianDate", [], function () {
        "use strict";
        var e = function (e, t, i, n, r, o, a, s) {
            this.year = e, this.month = t, this.day = i, this.hour = n, this.minute = r, this.second = o, this.millisecond = a, this.isLeapSecond = s
        };
        return e
    }), define("Cesium/Core/isLeapYear", ["./DeveloperError"], function (e) {
        "use strict";
        function t(e) {
            return e % 4 === 0 && e % 100 !== 0 || e % 400 === 0
        }

        return t
    }), define("Cesium/Core/LeapSecond", [], function () {
        "use strict";
        var e = function (e, t) {
            this.julianDate = e, this.offset = t
        };
        return e
    }), define("Cesium/Core/TimeConstants", ["./freezeObject"], function (e) {
        "use strict";
        var t = {
            SECONDS_PER_MILLISECOND: .001,
            SECONDS_PER_MINUTE: 60,
            MINUTES_PER_HOUR: 60,
            HOURS_PER_DAY: 24,
            SECONDS_PER_HOUR: 3600,
            MINUTES_PER_DAY: 1440,
            SECONDS_PER_DAY: 86400,
            DAYS_PER_JULIAN_CENTURY: 36525,
            PICOSECOND: 1e-9,
            MODIFIED_JULIAN_DATE_DIFFERENCE: 2400000.5
        };
        return e(t)
    }), define("Cesium/Core/TimeStandard", ["./freezeObject"], function (e) {
        "use strict";
        var t = {UTC: 0, TAI: 1};
        return e(t)
    }), define("Cesium/Core/JulianDate", ["../ThirdParty/sprintf", "./binarySearch", "./defaultValue", "./defined", "./DeveloperError", "./GregorianDate", "./isLeapYear", "./LeapSecond", "./TimeConstants", "./TimeStandard"], function (e, t, i, n, r, o, a, s, u, l) {
        "use strict";
        function c(e, t) {
            return I.compare(e.julianDate, t.julianDate)
        }

        function h(e) {
            g.julianDate = e;
            var i = I.leapSeconds, n = t(i, g, c);
            0 > n && (n = ~n), n >= i.length && (n = i.length - 1);
            var r = i[n].offset;
            if (n > 0) {
                var o = I.secondsDifference(i[n].julianDate, e);
                o > r && (n--, r = i[n].offset)
            }
            I.addSeconds(e, r, e)
        }

        function d(e, i) {
            g.julianDate = e;
            var n = I.leapSeconds, r = t(n, g, c);
            if (0 > r && (r = ~r), 0 === r)return I.addSeconds(e, -n[0].offset, i);
            if (r >= n.length)return I.addSeconds(e, -n[r - 1].offset, i);
            var o = I.secondsDifference(n[r].julianDate, e);
            return 0 === o ? I.addSeconds(e, -n[r].offset, i) : 1 >= o ? void 0 : I.addSeconds(e, -n[--r].offset, i)
        }

        function m(e, t, i) {
            var n = t / u.SECONDS_PER_DAY | 0;
            return e += n, t -= u.SECONDS_PER_DAY * n, 0 > t && (e--, t += u.SECONDS_PER_DAY), i.dayNumber = e, i.secondsOfDay = t, i
        }

        function p(e, t, i, n, r, o, a) {
            var s = (t - 14) / 12 | 0, l = e + 4800 + s, c = (1461 * l / 4 | 0) + (367 * (t - 2 - 12 * s) / 12 | 0) - (3 * ((l + 100) / 100 | 0) / 4 | 0) + i - 32075;
            n -= 12, 0 > n && (n += 24);
            var h = o + (n * u.SECONDS_PER_HOUR + r * u.SECONDS_PER_MINUTE + a * u.SECONDS_PER_MILLISECOND);
            return h >= 43200 && (c -= 1), [c, h]
        }

        var f = new o, _ = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], v = 29, g = new s, y = /^(\d{4})$/, C = /^(\d{4})-(\d{2})$/, E = /^(\d{4})-?(\d{3})$/, S = /^(\d{4})-?W(\d{2})-?(\d{1})?$/, T = /^(\d{4})-?(\d{2})-?(\d{2})$/, b = /([Z+\-])?(\d{2})?:?(\d{2})?$/, w = /^(\d{2})(\.\d+)?/.source + b.source, x = /^(\d{2}):?(\d{2})(\.\d+)?/.source + b.source, A = /^(\d{2}):?(\d{2}):?(\d{2})(\.\d+)?/.source + b.source, P = "Invalid ISO 8601 date.", I = function (e, t, n) {
            this.dayNumber = void 0, this.secondsOfDay = void 0, e = i(e, 0), t = i(t, 0), n = i(n, l.UTC);
            var r = 0 | e;
            t += (e - r) * u.SECONDS_PER_DAY, m(r, t, this), n === l.UTC && h(this)
        };
        I.fromDate = function (e, t) {
            var i = p(e.getUTCFullYear(), e.getUTCMonth() + 1, e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds(), e.getUTCMilliseconds());
            return n(t) ? (m(i[0], i[1], t), h(t), t) : new I(i[0], i[1], l.UTC)
        }, I.fromIso8601 = function (e, t) {
            e = e.replace(",", ".");
            var i, o, s, u = e.split("T"), c = 1, d = 1, f = 0, g = 0, b = 0, D = 0, M = u[0], O = u[1];
            if (!n(M))throw new r(P);
            var R;
            if (u = M.match(T), null !== u) {
                if (R = M.split("-").length - 1, R > 0 && 2 !== R)throw new r(P);
                i = +u[1], c = +u[2], d = +u[3]
            } else if (u = M.match(C), null !== u)i = +u[1], c = +u[2]; else if (u = M.match(y), null !== u)i = +u[1]; else {
                var N;
                if (u = M.match(E), null !== u) {
                    if (i = +u[1], N = +u[2], s = a(i), 1 > N || s && N > 366 || !s && N > 365)throw new r(P)
                } else {
                    if (u = M.match(S), null === u)throw new r(P);
                    i = +u[1];
                    var L = +u[2], F = +u[3] || 0;
                    if (R = M.split("-").length - 1, R > 0 && (!n(u[3]) && 1 !== R || n(u[3]) && 2 !== R))throw new r(P);
                    var B = new Date(Date.UTC(i, 0, 4));
                    N = 7 * L + F - B.getUTCDay() - 3
                }
                o = new Date(Date.UTC(i, 0, 1)), o.setUTCDate(N), c = o.getUTCMonth() + 1, d = o.getUTCDate()
            }
            if (s = a(i), 1 > c || c > 12 || 1 > d || (2 !== c || !s) && d > _[c - 1] || s && 2 === c && d > v)throw new r(P);
            var z;
            if (n(O)) {
                if (u = O.match(A), null !== u) {
                    if (R = O.split(":").length - 1, R > 0 && 2 !== R && 3 !== R)throw new r(P);
                    f = +u[1], g = +u[2], b = +u[3], D = 1e3 * +(u[4] || 0), z = 5
                } else if (u = O.match(x), null !== u) {
                    if (R = O.split(":").length - 1, R > 0 && 1 !== R)throw new r(P);
                    f = +u[1], g = +u[2], b = 60 * +(u[3] || 0), z = 4
                } else {
                    if (u = O.match(w), null === u)throw new r(P);
                    f = +u[1], g = 60 * +(u[2] || 0), z = 3
                }
                if (g >= 60 || b >= 61 || f > 24 || 24 === f && (g > 0 || b > 0 || D > 0))throw new r(P);
                var V = u[z], U = +u[z + 1], k = +(u[z + 2] || 0);
                switch (V) {
                    case"+":
                        f -= U, g -= k;
                        break;
                    case"-":
                        f += U, g += k;
                        break;
                    case"Z":
                        break;
                    default:
                        g += new Date(Date.UTC(i, c - 1, d, f, g)).getTimezoneOffset()
                }
            } else g += new Date(i, c - 1, d).getTimezoneOffset();
            var G = 60 === b;
            for (G && b--; g >= 60;)g -= 60, f++;
            for (; f >= 24;)f -= 24, d++;
            for (o = s && 2 === c ? v : _[c - 1]; d > o;)d -= o, c++, c > 12 && (c -= 12, i++), o = s && 2 === c ? v : _[c - 1];
            for (; 0 > g;)g += 60, f--;
            for (; 0 > f;)f += 24, d--;
            for (; 1 > d;)c--, 1 > c && (c += 12, i--), o = s && 2 === c ? v : _[c - 1], d += o;
            var H = p(i, c, d, f, g, b, D);
            return n(t) ? (m(H[0], H[1], t), h(t)) : t = new I(H[0], H[1], l.UTC), G && I.addSeconds(t, 1, t), t
        }, I.now = function (e) {
            return I.fromDate(new Date, e)
        };
        var D = new I(0, 0, l.TAI);
        return I.toGregorianDate = function (e, t) {
            var i = !1, r = d(e, D);
            n(r) || (I.addSeconds(e, -1, D), r = d(D, D), i = !0);
            var a = r.dayNumber, s = r.secondsOfDay;
            s >= 43200 && (a += 1);
            var l = a + 68569 | 0, c = 4 * l / 146097 | 0;
            l = l - ((146097 * c + 3) / 4 | 0) | 0;
            var h = 4e3 * (l + 1) / 1461001 | 0;
            l = l - (1461 * h / 4 | 0) + 31 | 0;
            var m = 80 * l / 2447 | 0, p = l - (2447 * m / 80 | 0) | 0;
            l = m / 11 | 0;
            var f = m + 2 - 12 * l | 0, _ = 100 * (c - 49) + h + l | 0, v = s / u.SECONDS_PER_HOUR | 0, g = s - v * u.SECONDS_PER_HOUR, y = g / u.SECONDS_PER_MINUTE | 0;
            g -= y * u.SECONDS_PER_MINUTE;
            var C = 0 | g, E = (g - C) / u.SECONDS_PER_MILLISECOND;
            return v += 12, v > 23 && (v -= 24), i && (C += 1), n(t) ? (t.year = _, t.month = f, t.day = p, t.hour = v, t.minute = y, t.second = C, t.millisecond = E, t.isLeapSecond = i, t) : new o(_, f, p, v, y, C, E, i)
        }, I.toDate = function (e) {
            var t = I.toGregorianDate(e, f), i = t.second;
            return t.isLeapSecond && (i -= 1), new Date(Date.UTC(t.year, t.month - 1, t.day, t.hour, t.minute, i, t.millisecond))
        }, I.toIso8601 = function (t, i) {
            var r, o = I.toGregorianDate(t, o);
            return n(i) || 0 === o.millisecond ? n(i) && 0 !== i ? (r = (.01 * o.millisecond).toFixed(i).replace(".", "").slice(0, i), e("%04d-%02d-%02dT%02d:%02d:%02d.%sZ", o.year, o.month, o.day, o.hour, o.minute, o.second, r)) : e("%04d-%02d-%02dT%02d:%02d:%02dZ", o.year, o.month, o.day, o.hour, o.minute, o.second) : (r = (.01 * o.millisecond).toString().replace(".", ""), e("%04d-%02d-%02dT%02d:%02d:%02d.%sZ", o.year, o.month, o.day, o.hour, o.minute, o.second, r))
        }, I.clone = function (e, t) {
            return n(e) ? n(t) ? (t.dayNumber = e.dayNumber, t.secondsOfDay = e.secondsOfDay, t) : new I(e.dayNumber, e.secondsOfDay, l.TAI) : void 0
        }, I.compare = function (e, t) {
            var i = e.dayNumber - t.dayNumber;
            return 0 !== i ? i : e.secondsOfDay - t.secondsOfDay
        }, I.equals = function (e, t) {
            return e === t || n(e) && n(t) && e.dayNumber === t.dayNumber && e.secondsOfDay === t.secondsOfDay
        }, I.equalsEpsilon = function (e, t, i) {
            return e === t || n(e) && n(t) && Math.abs(I.secondsDifference(e, t)) <= i
        }, I.totalDays = function (e) {
            return e.dayNumber + e.secondsOfDay / u.SECONDS_PER_DAY
        }, I.secondsDifference = function (e, t) {
            var i = (e.dayNumber - t.dayNumber) * u.SECONDS_PER_DAY;
            return i + (e.secondsOfDay - t.secondsOfDay)
        }, I.daysDifference = function (e, t) {
            var i = e.dayNumber - t.dayNumber, n = (e.secondsOfDay - t.secondsOfDay) / u.SECONDS_PER_DAY;
            return i + n
        }, I.computeTaiMinusUtc = function (e) {
            g.julianDate = e;
            var i = I.leapSeconds, n = t(i, g, c);
            return 0 > n && (n = ~n, --n, 0 > n && (n = 0)), i[n].offset
        }, I.addSeconds = function (e, t, i) {
            return m(e.dayNumber, e.secondsOfDay + t, i)
        }, I.addMinutes = function (e, t, i) {
            var n = e.secondsOfDay + t * u.SECONDS_PER_MINUTE;
            return m(e.dayNumber, n, i)
        }, I.addHours = function (e, t, i) {
            var n = e.secondsOfDay + t * u.SECONDS_PER_HOUR;
            return m(e.dayNumber, n, i)
        }, I.addDays = function (e, t, i) {
            var n = e.dayNumber + t;
            return m(n, e.secondsOfDay, i)
        }, I.lessThan = function (e, t) {
            return I.compare(e, t) < 0
        }, I.lessThanOrEquals = function (e, t) {
            return I.compare(e, t) <= 0
        }, I.greaterThan = function (e, t) {
            return I.compare(e, t) > 0
        }, I.greaterThanOrEquals = function (e, t) {
            return I.compare(e, t) >= 0
        }, I.prototype.clone = function (e) {
            return I.clone(this, e)
        }, I.prototype.equals = function (e) {
            return I.equals(this, e)
        }, I.prototype.equalsEpsilon = function (e, t) {
            return I.equalsEpsilon(this, e, t)
        }, I.prototype.toString = function () {
            return I.toIso8601(this)
        }, I.leapSeconds = [new s(new I(2441317, 43210, l.TAI), 10), new s(new I(2441499, 43211, l.TAI), 11), new s(new I(2441683, 43212, l.TAI), 12), new s(new I(2442048, 43213, l.TAI), 13), new s(new I(2442413, 43214, l.TAI), 14), new s(new I(2442778, 43215, l.TAI), 15), new s(new I(2443144, 43216, l.TAI), 16), new s(new I(2443509, 43217, l.TAI), 17), new s(new I(2443874, 43218, l.TAI), 18), new s(new I(2444239, 43219, l.TAI), 19), new s(new I(2444786, 43220, l.TAI), 20), new s(new I(2445151, 43221, l.TAI), 21), new s(new I(2445516, 43222, l.TAI), 22), new s(new I(2446247, 43223, l.TAI), 23), new s(new I(2447161, 43224, l.TAI), 24), new s(new I(2447892, 43225, l.TAI), 25), new s(new I(2448257, 43226, l.TAI), 26), new s(new I(2448804, 43227, l.TAI), 27), new s(new I(2449169, 43228, l.TAI), 28), new s(new I(2449534, 43229, l.TAI), 29), new s(new I(2450083, 43230, l.TAI), 30), new s(new I(2450630, 43231, l.TAI), 31), new s(new I(2451179, 43232, l.TAI), 32), new s(new I(2453736, 43233, l.TAI), 33), new s(new I(2454832, 43234, l.TAI), 34), new s(new I(2456109, 43235, l.TAI), 35), new s(new I(2457204, 43236, l.TAI), 36)], I
    }), function (e) {
        "use strict";
        e("Cesium/ThirdParty/when", [], function () {
            function e(e, i, n, r) {
                return t(e).then(i, n, r)
            }

            function t(e) {
                var t, i;
                return e instanceof n ? t = e : s(e) ? (i = a(), e.then(function (e) {
                    i.resolve(e)
                }, function (e) {
                    i.reject(e)
                }, function (e) {
                    i.progress(e)
                }), t = i.promise) : t = r(e), t
            }

            function i(t) {
                return e(t, o)
            }

            function n(e) {
                this.then = e
            }

            function r(e) {
                var i = new n(function (i) {
                    try {
                        return t(i ? i(e) : e)
                    } catch (n) {
                        return o(n)
                    }
                });
                return i
            }

            function o(e) {
                var i = new n(function (i, n) {
                    try {
                        return n ? t(n(e)) : o(e)
                    } catch (r) {
                        return o(r)
                    }
                });
                return i
            }

            function a() {
                function e(e, t, i) {
                    return d(e, t, i)
                }

                function i(e) {
                    return p(e)
                }

                function r(e) {
                    return p(o(e))
                }

                function s(e) {
                    return m(e)
                }

                var u, l, c, h, d, m, p;
                return l = new n(e), u = {
                    then: e,
                    resolve: i,
                    reject: r,
                    progress: s,
                    promise: l,
                    resolver: {resolve: i, reject: r, progress: s}
                }, c = [], h = [], d = function (e, t, i) {
                    var n, r;
                    return n = a(), r = "function" == typeof i ? function (e) {
                        try {
                            n.progress(i(e))
                        } catch (t) {
                            n.progress(t)
                        }
                    } : function (e) {
                        n.progress(e)
                    }, c.push(function (i) {
                        i.then(e, t).then(n.resolve, n.reject, r)
                    }), h.push(r), n.promise
                }, m = function (e) {
                    return f(h, e), e
                }, p = function (e) {
                    return e = t(e), d = e.then, p = t, m = v, f(c, e), h = c = E, e
                }, u
            }

            function s(e) {
                return e && "function" == typeof e.then
            }

            function u(t, i, n, r, o) {
                return _(2, arguments), e(t, function (t) {
                    function s(e) {
                        f(e)
                    }

                    function u(e) {
                        p(e)
                    }

                    var l, c, h, d, m, p, f, _, g, y;
                    if (g = t.length >>> 0, l = Math.max(0, Math.min(i, g)), h = [], c = g - l + 1, d = [], m = a(), l)for (_ = m.progress, f = function (e) {
                        d.push(e), --c || (p = f = v, m.reject(d))
                    }, p = function (e) {
                        h.push(e), --l || (p = f = v, m.resolve(h))
                    }, y = 0; g > y; ++y)y in t && e(t[y], u, s, _); else m.resolve(h);
                    return m.then(n, r, o)
                })
            }

            function l(e, t, i, n) {
                function r(e) {
                    return t ? t(e[0]) : e[0]
                }

                return u(e, 1, r, i, n)
            }

            function c(e, t, i, n) {
                return _(1, arguments), d(e, g).then(t, i, n)
            }

            function h() {
                return d(arguments, g)
            }

            function d(t, i) {
                return e(t, function (t) {
                    var n, r, o, s, u, l;
                    if (o = r = t.length >>> 0, n = [], l = a(), o)for (s = function (t, r) {
                        e(t, i).then(function (e) {
                            n[r] = e, --o || l.resolve(n)
                        }, l.reject)
                    }, u = 0; r > u; u++)u in t ? s(t[u], u) : --o; else l.resolve(n);
                    return l.promise
                })
            }

            function m(t, i) {
                var n = C.call(arguments, 1);
                return e(t, function (t) {
                    var r;
                    return r = t.length, n[0] = function (t, n, o) {
                        return e(t, function (t) {
                            return e(n, function (e) {
                                return i(t, e, o, r)
                            })
                        })
                    }, y.apply(t, n)
                })
            }

            function p(t, i, n) {
                var r = arguments.length > 2;
                return e(t, function (e) {
                    return e = r ? n : e, i.resolve(e), e
                }, function (e) {
                    return i.reject(e), o(e)
                }, i.progress)
            }

            function f(e, t) {
                for (var i, n = 0; i = e[n++];)i(t)
            }

            function _(e, t) {
                for (var i, n = t.length; n > e;)if (i = t[--n], null != i && "function" != typeof i)throw new Error("arg " + n + " must be a function")
            }

            function v() {
            }

            function g(e) {
                return e
            }

            var y, C, E;
            return e.defer = a, e.resolve = t, e.reject = i, e.join = h, e.all = c, e.map = d, e.reduce = m, e.any = l, e.some = u, e.chain = p, e.isPromise = s, n.prototype = {
                always: function (e, t) {
                    return this.then(e, e, t)
                }, otherwise: function (e) {
                    return this.then(E, e)
                }, "yield": function (e) {
                    return this.then(function () {
                        return e
                    })
                }, spread: function (e) {
                    return this.then(function (t) {
                        return c(t, function (t) {
                            return e.apply(E, t)
                        })
                    })
                }
            }, C = [].slice, y = [].reduce || function (e) {
                    var t, i, n, r, o;
                    if (o = 0, t = Object(this), r = t.length >>> 0, i = arguments, i.length <= 1)for (; ;) {
                        if (o in t) {
                            n = t[o++];
                            break
                        }
                        if (++o >= r)throw new TypeError
                    } else n = i[1];
                    for (; r > o; ++o)o in t && (n = e(n, t[o], o, t));
                    return n
                }, e
        })
    }("function" == typeof define && define.amd ? define : function (e) {
        "object" == typeof exports ? module.exports = e() : this.when = e()
    }), define("Cesium/Core/parseResponseHeaders", [], function () {
        "use strict";
        var e = function (e) {
            var t = {};
            if (!e)return t;
            for (var i = e.split("\r\n"), n = 0; n < i.length; ++n) {
                var r = i[n], o = r.indexOf(": ");
                if (o > 0) {
                    var a = r.substring(0, o), s = r.substring(o + 2);
                    t[a] = s
                }
            }
            return t
        };
        return e
    }), define("Cesium/Core/RequestErrorEvent", ["./defined", "./parseResponseHeaders"], function (e, t) {
        "use strict";
        var i = function (e, i, n) {
            this.statusCode = e, this.response = i, this.responseHeaders = n, "string" == typeof this.responseHeaders && (this.responseHeaders = t(this.responseHeaders))
        };
        return i.prototype.toString = function () {
            var t = "Request has failed.";
            return e(this.statusCode) && (t += " Status Code: " + this.statusCode), t
        }, i
    }), define("Cesium/Core/loadWithXhr", ["../ThirdParty/when", "./defaultValue", "./defined", "./DeveloperError", "./RequestErrorEvent", "./RuntimeError"], function (e, t, i, n, r, o) {
        "use strict";
        function a(e, t) {
            var i = decodeURIComponent(t);
            return e ? atob(i) : i
        }

        function s(e, t) {
            for (var i = a(e, t), n = new ArrayBuffer(i.length), r = new Uint8Array(n), o = 0; o < i.length; o++)r[o] = i.charCodeAt(o);
            return n
        }

        function u(e, i) {
            i = t(i, "");
            var r = e[1], o = !!e[2], u = e[3];
            switch (i) {
                case"":
                case"text":
                    return a(o, u);
                case"arraybuffer":
                    return s(o, u);
                case"blob":
                    var l = s(o, u);
                    return new Blob([l], {type: r});
                case"document":
                    var c = new DOMParser;
                    return c.parseFromString(a(o, u), r);
                case"json":
                    return JSON.parse(a(o, u));
                default:
                    throw new n("Unhandled responseType: " + i)
            }
        }

        var l = function (i) {
            i = t(i, t.EMPTY_OBJECT);
            var n = i.responseType, r = t(i.method, "GET"), o = i.data, a = i.headers, s = i.overrideMimeType;
            return e(i.url, function (t) {
                var i = e.defer();
                return l.load(t, n, r, o, a, i, s), i.promise
            })
        }, c = /^data:(.*?)(;base64)?,(.*)$/;
        return l.load = function (e, t, n, a, s, l, h) {
            var d = c.exec(e);
            if (null !== d)return void l.resolve(u(d, t));
            var m = new XMLHttpRequest;
            if (i(h) && i(m.overrideMimeType) && m.overrideMimeType(h), m.open(n, e, !0), i(s))for (var p in s)s.hasOwnProperty(p) && m.setRequestHeader(p, s[p]);
            i(t) && (m.responseType = t), m.onload = function () {
                200 === m.status ? i(m.response) ? l.resolve(m.response) : i(m.responseXML) && m.responseXML.hasChildNodes() ? l.resolve(m.responseXML) : i(m.responseText) ? l.resolve(m.responseText) : l.reject(new o("unknown XMLHttpRequest response type.")) : l.reject(new r(m.status, m.response, m.getAllResponseHeaders()))
            }, m.onerror = function (e) {
                l.reject(new r)
            }, m.send(a)
        }, l.defaultLoad = l.load, l
    }), define("Cesium/Core/loadXml", ["./loadWithXhr"], function (e) {
        "use strict";
        var t = function (t, i) {
            return e({url: t, responseType: "document", headers: i, overrideMimeType: "text/xml"})
        };
        return t
    }), define("Cesium/Core/isArray", ["./defined"], function (e) {
        "use strict";
        var t = Array.isArray;
        return e(t) || (t = function (e) {
            return "[object Array]" === Object.prototype.toString.call(e)
        }), t
    }), define("Cesium/Core/objectToQuery", ["./defined", "./DeveloperError", "./isArray"], function (e, t, i) {
        "use strict";
        var n = function (e) {
            var t = "";
            for (var n in e)if (e.hasOwnProperty(n)) {
                var r = e[n], o = encodeURIComponent(n) + "=";
                if (i(r))for (var a = 0, s = r.length; s > a; ++a)t += o + encodeURIComponent(r[a]) + "&"; else t += o + encodeURIComponent(r) + "&"
            }
            return t = t.slice(0, -1)
        };
        return n
    }), define("Cesium/Core/queryToObject", ["./defined", "./DeveloperError", "./isArray"], function (e, t, i) {
        "use strict";
        var n = function (t) {
            var n = {};
            if ("" === t)return n;
            for (var r = t.replace(/\+/g, "%20").split("&"), o = 0, a = r.length; a > o; ++o) {
                var s = r[o].split("="), u = decodeURIComponent(s[0]), l = s[1];
                l = e(l) ? decodeURIComponent(l) : "";
                var c = n[u];
                "string" == typeof c ? n[u] = [c, l] : i(c) ? c.push(l) : n[u] = l
            }
            return n
        };
        return n
    }), define("Cesium/Core/ScreenSpaceEventType", ["./freezeObject"], function (e) {
        "use strict";
        var t = {
            LEFT_DOWN: 0,
            LEFT_UP: 1,
            LEFT_CLICK: 2,
            LEFT_DOUBLE_CLICK: 3,
            RIGHT_DOWN: 5,
            RIGHT_UP: 6,
            RIGHT_CLICK: 7,
            RIGHT_DOUBLE_CLICK: 8,
            MIDDLE_DOWN: 10,
            MIDDLE_UP: 11,
            MIDDLE_CLICK: 12,
            MIDDLE_DOUBLE_CLICK: 13,
            MOUSE_MOVE: 15,
            WHEEL: 16,
            PINCH_START: 17,
            PINCH_END: 18,
            PINCH_MOVE: 19
        };
        return e(t)
    }), define("Cesium/Core/createGuid", [], function () {
        "use strict";
        var e = function () {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (e) {
                var t = 16 * Math.random() | 0, i = "x" === e ? t : 3 & t | 8;
                return i.toString(16)
            })
        };
        return e
    }), define("Cesium/Core/Event", ["./defined", "./defineProperties", "./DeveloperError"], function (e, t, i) {
        "use strict";
        var n = function () {
            this._listeners = [], this._scopes = [], this._toRemove = [], this._insideRaiseEvent = !1
        };
        return t(n.prototype, {
            numberOfListeners: {
                get: function () {
                    return this._listeners.length - this._toRemove.length
                }
            }
        }), n.prototype.addEventListener = function (e, t) {
            this._listeners.push(e), this._scopes.push(t);
            var i = this;
            return function () {
                i.removeEventListener(e, t)
            }
        }, n.prototype.removeEventListener = function (e, t) {
            for (var i = this._listeners, n = this._scopes, r = -1, o = 0; o < i.length; o++)if (i[o] === e && n[o] === t) {
                r = o;
                break
            }
            return -1 !== r ? (this._insideRaiseEvent ? (this._toRemove.push(r), i[r] = void 0, n[r] = void 0) : (i.splice(r, 1), n.splice(r, 1)), !0) : !1
        }, n.prototype.raiseEvent = function () {
            this._insideRaiseEvent = !0;
            var t, i = this._listeners, n = this._scopes, r = i.length;
            for (t = 0; r > t; t++) {
                var o = i[t];
                e(o) && i[t].apply(n[t], arguments)
            }
            var a = this._toRemove;
            for (r = a.length, t = 0; r > t; t++) {
                var s = a[t];
                i.splice(s, 1), n.splice(s, 1)
            }
            a.length = 0, this._insideRaiseEvent = !1
        }, n
    }), define("Cesium/Core/Quaternion", ["./Cartesian3", "./defaultValue", "./defined", "./DeveloperError", "./FeatureDetection", "./freezeObject", "./Math", "./Matrix3"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        var u = function (e, i, n, r) {
            this.x = t(e, 0), this.y = t(i, 0), this.z = t(n, 0), this.w = t(r, 0)
        }, l = new e;
        u.fromAxisAngle = function (t, n, r) {
            var o = n / 2, a = Math.sin(o);
            l = e.normalize(t, l);
            var s = l.x * a, c = l.y * a, h = l.z * a, d = Math.cos(o);
            return i(r) ? (r.x = s, r.y = c, r.z = h, r.w = d, r) : new u(s, c, h, d)
        };
        var c = [1, 2, 0], h = new Array(3);
        u.fromRotationMatrix = function (e, t) {
            var n, r, o, a, l, d = e[s.COLUMN0ROW0], m = e[s.COLUMN1ROW1], p = e[s.COLUMN2ROW2], f = d + m + p;
            if (f > 0)n = Math.sqrt(f + 1), l = .5 * n, n = .5 / n, r = (e[s.COLUMN1ROW2] - e[s.COLUMN2ROW1]) * n, o = (e[s.COLUMN2ROW0] - e[s.COLUMN0ROW2]) * n, a = (e[s.COLUMN0ROW1] - e[s.COLUMN1ROW0]) * n; else {
                var _ = c, v = 0;
                m > d && (v = 1), p > d && p > m && (v = 2);
                var g = _[v], y = _[g];
                n = Math.sqrt(e[s.getElementIndex(v, v)] - e[s.getElementIndex(g, g)] - e[s.getElementIndex(y, y)] + 1);
                var C = h;
                C[v] = .5 * n, n = .5 / n, l = (e[s.getElementIndex(y, g)] - e[s.getElementIndex(g, y)]) * n, C[g] = (e[s.getElementIndex(g, v)] + e[s.getElementIndex(v, g)]) * n, C[y] = (e[s.getElementIndex(y, v)] + e[s.getElementIndex(v, y)]) * n, r = -C[0], o = -C[1], a = -C[2]
            }
            return i(t) ? (t.x = r, t.y = o, t.z = a, t.w = l, t) : new u(r, o, a, l)
        };
        var d = new u;
        u.fromHeadingPitchRoll = function (t, i, n, r) {
            var o = u.fromAxisAngle(e.UNIT_X, n, d), a = u.fromAxisAngle(e.UNIT_Y, -i, r);
            r = u.multiply(a, o, a);
            var s = u.fromAxisAngle(e.UNIT_Z, -t, d);
            return u.multiply(s, r, r)
        };
        var m = new e, p = new e, f = new u, _ = new u, v = new u;
        u.packedLength = 4, u.pack = function (e, i, n) {
            n = t(n, 0), i[n++] = e.x, i[n++] = e.y, i[n++] = e.z, i[n] = e.w
        }, u.unpack = function (e, n, r) {
            return n = t(n, 0), i(r) || (r = new u), r.x = e[n], r.y = e[n + 1], r.z = e[n + 2], r.w = e[n + 3], r
        }, u.packedInterpolationLength = 3, u.convertPackedArrayForInterpolation = function (e, t, i, n) {
            u.unpack(e, 4 * i, v), u.conjugate(v, v);
            for (var r = 0, o = i - t + 1; o > r; r++) {
                var a = 3 * r;
                u.unpack(e, 4 * (t + r), f), u.multiply(f, v, f), f.w < 0 && u.negate(f, f), u.computeAxis(f, m);
                var s = u.computeAngle(f);
                n[a] = m.x * s, n[a + 1] = m.y * s, n[a + 2] = m.z * s
            }
        }, u.unpackInterpolationResult = function (t, n, r, o, a) {
            i(a) || (a = new u), e.fromArray(t, 0, p);
            var s = e.magnitude(p);
            return u.unpack(n, 4 * o, _), 0 === s ? u.clone(u.IDENTITY, f) : u.fromAxisAngle(p, s, f), u.multiply(f, _, a)
        }, u.clone = function (e, t) {
            return i(e) ? i(t) ? (t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t) : new u(e.x, e.y, e.z, e.w) : void 0
        }, u.conjugate = function (e, t) {
            return t.x = -e.x, t.y = -e.y, t.z = -e.z, t.w = e.w, t
        }, u.magnitudeSquared = function (e) {
            return e.x * e.x + e.y * e.y + e.z * e.z + e.w * e.w
        }, u.magnitude = function (e) {
            return Math.sqrt(u.magnitudeSquared(e))
        }, u.normalize = function (e, t) {
            var i = 1 / u.magnitude(e), n = e.x * i, r = e.y * i, o = e.z * i, a = e.w * i;
            return t.x = n, t.y = r, t.z = o, t.w = a, t
        }, u.inverse = function (e, t) {
            var i = u.magnitudeSquared(e);
            return t = u.conjugate(e, t), u.multiplyByScalar(t, 1 / i, t)
        }, u.add = function (e, t, i) {
            return i.x = e.x + t.x, i.y = e.y + t.y, i.z = e.z + t.z, i.w = e.w + t.w, i
        }, u.subtract = function (e, t, i) {
            return i.x = e.x - t.x, i.y = e.y - t.y, i.z = e.z - t.z, i.w = e.w - t.w, i
        }, u.negate = function (e, t) {
            return t.x = -e.x, t.y = -e.y, t.z = -e.z, t.w = -e.w, t
        }, u.dot = function (e, t) {
            return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w
        }, u.multiply = function (e, t, i) {
            var n = e.x, r = e.y, o = e.z, a = e.w, s = t.x, u = t.y, l = t.z, c = t.w, h = a * s + n * c + r * l - o * u, d = a * u - n * l + r * c + o * s, m = a * l + n * u - r * s + o * c, p = a * c - n * s - r * u - o * l;
            return i.x = h, i.y = d, i.z = m, i.w = p, i
        }, u.multiplyByScalar = function (e, t, i) {
            return i.x = e.x * t, i.y = e.y * t, i.z = e.z * t, i.w = e.w * t, i
        }, u.divideByScalar = function (e, t, i) {
            return i.x = e.x / t, i.y = e.y / t, i.z = e.z / t, i.w = e.w / t, i
        }, u.computeAxis = function (e, t) {
            var i = e.w;
            if (Math.abs(i - 1) < a.EPSILON6)return t.x = t.y = t.z = 0, t;
            var n = 1 / Math.sqrt(1 - i * i);
            return t.x = e.x * n, t.y = e.y * n, t.z = e.z * n, t
        }, u.computeAngle = function (e) {
            return Math.abs(e.w - 1) < a.EPSILON6 ? 0 : 2 * Math.acos(e.w)
        };
        var g = new u;
        u.lerp = function (e, t, i, n) {
            return g = u.multiplyByScalar(t, i, g), n = u.multiplyByScalar(e, 1 - i, n), u.add(g, n, n)
        };
        var y = new u, C = new u, E = new u;
        u.slerp = function (e, t, i, n) {
            var r = u.dot(e, t), o = t;
            if (0 > r && (r = -r, o = y = u.negate(t, y)), 1 - r < a.EPSILON6)return u.lerp(e, o, i, n);
            var s = Math.acos(r);
            return C = u.multiplyByScalar(e, Math.sin((1 - i) * s), C), E = u.multiplyByScalar(o, Math.sin(i * s), E), n = u.add(C, E, n), u.multiplyByScalar(n, 1 / Math.sin(s), n)
        }, u.log = function (t, i) {
            var n = a.acosClamped(t.w), r = 0;
            return 0 !== n && (r = n / Math.sin(n)), e.multiplyByScalar(t, r, i)
        }, u.exp = function (t, i) {
            var n = e.magnitude(t), r = 0;
            return 0 !== n && (r = Math.sin(n) / n), i.x = t.x * r, i.y = t.y * r, i.z = t.z * r, i.w = Math.cos(n), i
        };
        var S = new e, T = new e, b = new u, w = new u;
        u.computeInnerQuadrangle = function (t, i, n, r) {
            var o = u.conjugate(i, b);
            u.multiply(o, n, w);
            var a = u.log(w, S);
            u.multiply(o, t, w);
            var s = u.log(w, T);
            return e.add(a, s, a), e.multiplyByScalar(a, .25, a), e.negate(a, a), u.exp(a, b), u.multiply(i, b, r)
        }, u.squad = function (e, t, i, n, r, o) {
            var a = u.slerp(e, t, r, b), s = u.slerp(i, n, r, w);
            return u.slerp(a, s, 2 * r * (1 - r), o)
        };
        for (var x = new u, A = 1.9011074535173003, P = r.supportsTypedArrays() ? new Float32Array(8) : [], I = r.supportsTypedArrays() ? new Float32Array(8) : [], D = r.supportsTypedArrays() ? new Float32Array(8) : [], M = r.supportsTypedArrays() ? new Float32Array(8) : [], O = 0; 7 > O; ++O) {
            var R = O + 1, N = 2 * R + 1;
            P[O] = 1 / (R * N), I[O] = R / N
        }
        return P[7] = A / 136, I[7] = 8 * A / 17, u.fastSlerp = function (e, t, i, n) {
            var r, o = u.dot(e, t);
            o >= 0 ? r = 1 : (r = -1, o = -o);
            for (var a = o - 1, s = 1 - i, l = i * i, c = s * s, h = 7; h >= 0; --h)D[h] = (P[h] * l - I[h]) * a, M[h] = (P[h] * c - I[h]) * a;
            var d = r * i * (1 + D[0] * (1 + D[1] * (1 + D[2] * (1 + D[3] * (1 + D[4] * (1 + D[5] * (1 + D[6] * (1 + D[7])))))))), m = s * (1 + M[0] * (1 + M[1] * (1 + M[2] * (1 + M[3] * (1 + M[4] * (1 + M[5] * (1 + M[6] * (1 + M[7])))))))), p = u.multiplyByScalar(e, m, x);
            return u.multiplyByScalar(t, d, n), u.add(p, n, n)
        }, u.fastSquad = function (e, t, i, n, r, o) {
            var a = u.fastSlerp(e, t, r, b), s = u.fastSlerp(i, n, r, w);
            return u.fastSlerp(a, s, 2 * r * (1 - r), o)
        }, u.equals = function (e, t) {
            return e === t || i(e) && i(t) && e.x === t.x && e.y === t.y && e.z === t.z && e.w === t.w
        }, u.equalsEpsilon = function (e, t, n) {
            return e === t || i(e) && i(t) && Math.abs(e.x - t.x) <= n && Math.abs(e.y - t.y) <= n && Math.abs(e.z - t.z) <= n && Math.abs(e.w - t.w) <= n
        }, u.ZERO = o(new u(0, 0, 0, 0)), u.IDENTITY = o(new u(0, 0, 0, 1)), u.prototype.clone = function (e) {
            return u.clone(this, e)
        }, u.prototype.equals = function (e) {
            return u.equals(this, e)
        }, u.prototype.equalsEpsilon = function (e, t) {
            return u.equalsEpsilon(this, e, t)
        }, u.prototype.toString = function () {
            return "(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")"
        }, u
    }), define("Cesium/Core/Cartesian2", ["./defaultValue", "./defined", "./DeveloperError", "./freezeObject", "./Math"], function (e, t, i, n, r) {
        "use strict";
        var o = function (t, i) {
            this.x = e(t, 0), this.y = e(i, 0)
        };
        o.fromElements = function (e, i, n) {
            return t(n) ? (n.x = e, n.y = i, n) : new o(e, i)
        }, o.clone = function (e, i) {
            return t(e) ? t(i) ? (i.x = e.x, i.y = e.y, i) : new o(e.x, e.y) : void 0
        }, o.fromCartesian3 = o.clone, o.fromCartesian4 = o.clone, o.packedLength = 2, o.pack = function (t, i, n) {
            n = e(n, 0), i[n++] = t.x, i[n] = t.y
        }, o.unpack = function (i, n, r) {
            return n = e(n, 0), t(r) || (r = new o), r.x = i[n++], r.y = i[n], r
        }, o.fromArray = o.unpack, o.maximumComponent = function (e) {
            return Math.max(e.x, e.y)
        }, o.minimumComponent = function (e) {
            return Math.min(e.x, e.y)
        }, o.minimumByComponent = function (e, t, i) {
            return i.x = Math.min(e.x, t.x), i.y = Math.min(e.y, t.y), i
        }, o.maximumByComponent = function (e, t, i) {
            return i.x = Math.max(e.x, t.x), i.y = Math.max(e.y, t.y), i
        }, o.magnitudeSquared = function (e) {
            return e.x * e.x + e.y * e.y
        }, o.magnitude = function (e) {
            return Math.sqrt(o.magnitudeSquared(e))
        };
        var a = new o;
        o.distance = function (e, t) {
            return o.subtract(e, t, a), o.magnitude(a)
        }, o.distanceSquared = function (e, t) {
            return o.subtract(e, t, a), o.magnitudeSquared(a)
        }, o.normalize = function (e, t) {
            var i = o.magnitude(e);
            return t.x = e.x / i, t.y = e.y / i, t
        }, o.dot = function (e, t) {
            return e.x * t.x + e.y * t.y
        }, o.multiplyComponents = function (e, t, i) {
            return i.x = e.x * t.x, i.y = e.y * t.y, i
        }, o.add = function (e, t, i) {
            return i.x = e.x + t.x, i.y = e.y + t.y, i
        }, o.subtract = function (e, t, i) {
            return i.x = e.x - t.x, i.y = e.y - t.y, i
        }, o.multiplyByScalar = function (e, t, i) {
            return i.x = e.x * t, i.y = e.y * t, i
        }, o.divideByScalar = function (e, t, i) {
            return i.x = e.x / t, i.y = e.y / t, i
        }, o.negate = function (e, t) {
            return t.x = -e.x, t.y = -e.y, t
        }, o.abs = function (e, t) {
            return t.x = Math.abs(e.x), t.y = Math.abs(e.y), t
        };
        var s = new o;
        o.lerp = function (e, t, i, n) {
            return o.multiplyByScalar(t, i, s), n = o.multiplyByScalar(e, 1 - i, n), o.add(s, n, n)
        };
        var u = new o, l = new o;
        o.angleBetween = function (e, t) {
            return o.normalize(e, u), o.normalize(t, l), r.acosClamped(o.dot(u, l))
        };
        var c = new o;
        return o.mostOrthogonalAxis = function (e, t) {
            var i = o.normalize(e, c);
            return o.abs(i, i), t = i.x <= i.y ? o.clone(o.UNIT_X, t) : o.clone(o.UNIT_Y, t)
        }, o.equals = function (e, i) {
            return e === i || t(e) && t(i) && e.x === i.x && e.y === i.y
        }, o.equalsArray = function (e, t, i) {
            return e.x === t[i] && e.y === t[i + 1]
        }, o.equalsEpsilon = function (e, i, n, o) {
            return e === i || t(e) && t(i) && r.equalsEpsilon(e.x, i.x, n, o) && r.equalsEpsilon(e.y, i.y, n, o)
        }, o.ZERO = n(new o(0, 0)), o.UNIT_X = n(new o(1, 0)), o.UNIT_Y = n(new o(0, 1)), o.prototype.clone = function (e) {
            return o.clone(this, e)
        }, o.prototype.equals = function (e) {
            return o.equals(this, e)
        }, o.prototype.equalsEpsilon = function (e, t, i) {
            return o.equalsEpsilon(this, e, t, i)
        }, o.prototype.toString = function () {
            return "(" + this.x + ", " + this.y + ")"
        }, o
    }), define("Cesium/Core/EarthOrientationParametersSample", [], function () {
        "use strict";
        var e = function (e, t, i, n, r) {
            this.xPoleWander = e, this.yPoleWander = t, this.xPoleOffset = i, this.yPoleOffset = n, this.ut1MinusUtc = r
        };
        return e
    }), define("Cesium/Core/loadText", ["./loadWithXhr"], function (e) {
        "use strict";
        var t = function (t, i) {
            return e({url: t, headers: i})
        };
        return t
    }), define("Cesium/Core/loadJson", ["./clone", "./defined", "./DeveloperError", "./loadText"], function (e, t, i, n) {
        "use strict";
        var r = {Accept: "application/json,*/*;q=0.01"}, o = function (i, o) {
            return t(o) ? t(o.Accept) || (o = e(o), o.Accept = r.Accept) : o = r, n(i, o).then(function (e) {
                return JSON.parse(e)
            })
        };
        return o
    }), define("Cesium/Core/EarthOrientationParameters", ["../ThirdParty/when", "./binarySearch", "./defaultValue", "./defined", "./EarthOrientationParametersSample", "./freezeObject", "./JulianDate", "./LeapSecond", "./loadJson", "./RuntimeError", "./TimeConstants", "./TimeStandard"], function (e, t, i, n, r, o, a, s, u, l, c, h) {
        "use strict";
        function d(e, t) {
            return a.compare(e.julianDate, t)
        }

        function m(e, i) {
            if (!n(i.columnNames))return void(e._dataError = "Error in loaded EOP data: The columnNames property is required.");
            if (!n(i.samples))return void(e._dataError = "Error in loaded EOP data: The samples property is required.");
            var r = i.columnNames.indexOf("modifiedJulianDateUtc"), o = i.columnNames.indexOf("xPoleWanderRadians"), u = i.columnNames.indexOf("yPoleWanderRadians"), l = i.columnNames.indexOf("ut1MinusUtcSeconds"), m = i.columnNames.indexOf("xCelestialPoleOffsetRadians"), p = i.columnNames.indexOf("yCelestialPoleOffsetRadians"), f = i.columnNames.indexOf("taiMinusUtcSeconds");
            if (0 > r || 0 > o || 0 > u || 0 > l || 0 > m || 0 > p || 0 > f)return void(e._dataError = "Error in loaded EOP data: The columnNames property must include modifiedJulianDateUtc, xPoleWanderRadians, yPoleWanderRadians, ut1MinusUtcSeconds, xCelestialPoleOffsetRadians, yCelestialPoleOffsetRadians, and taiMinusUtcSeconds columns");
            var _ = e._samples = i.samples, v = e._dates = [];
            e._dateColumn = r, e._xPoleWanderRadiansColumn = o, e._yPoleWanderRadiansColumn = u, e._ut1MinusUtcSecondsColumn = l, e._xCelestialPoleOffsetRadiansColumn = m, e._yCelestialPoleOffsetRadiansColumn = p, e._taiMinusUtcSecondsColumn = f, e._columnCount = i.columnNames.length, e._lastIndex = void 0;
            for (var g, y = e._addNewLeapSeconds, C = 0, E = _.length; E > C; C += e._columnCount) {
                var S = _[C + r], T = _[C + f], b = S + c.MODIFIED_JULIAN_DATE_DIFFERENCE, w = new a(b, T, h.TAI);
                if (v.push(w), y) {
                    if (T !== g && n(g)) {
                        var x = a.leapSeconds, A = t(x, w, d);
                        if (0 > A) {
                            var P = new s(w, T);
                            x.splice(~A, 0, P)
                        }
                    }
                    g = T
                }
            }
        }

        function p(e, t, i, n, r) {
            var o = i * n;
            r.xPoleWander = t[o + e._xPoleWanderRadiansColumn], r.yPoleWander = t[o + e._yPoleWanderRadiansColumn], r.xPoleOffset = t[o + e._xCelestialPoleOffsetRadiansColumn], r.yPoleOffset = t[o + e._yCelestialPoleOffsetRadiansColumn], r.ut1MinusUtc = t[o + e._ut1MinusUtcSecondsColumn]
        }

        function f(e, t, i) {
            return t + e * (i - t)
        }

        function _(e, t, i, n, r, o, s) {
            var u = e._columnCount;
            if (o > t.length - 1)return s.xPoleWander = 0, s.yPoleWander = 0, s.xPoleOffset = 0, s.yPoleOffset = 0, s.ut1MinusUtc = 0, s;
            var l = t[r], c = t[o];
            if (l.equals(c) || n.equals(l))return p(e, i, r, u, s), s;
            if (n.equals(c))return p(e, i, o, u, s), s;
            var h = a.secondsDifference(n, l) / a.secondsDifference(c, l), d = r * u, m = o * u, _ = i[d + e._ut1MinusUtcSecondsColumn], v = i[m + e._ut1MinusUtcSecondsColumn], g = v - _;
            if (g > .5 || -.5 > g) {
                var y = i[d + e._taiMinusUtcSecondsColumn], C = i[m + e._taiMinusUtcSecondsColumn];
                y !== C && (c.equals(n) ? _ = v : v -= C - y)
            }
            return s.xPoleWander = f(h, i[d + e._xPoleWanderRadiansColumn], i[m + e._xPoleWanderRadiansColumn]), s.yPoleWander = f(h, i[d + e._yPoleWanderRadiansColumn], i[m + e._yPoleWanderRadiansColumn]), s.xPoleOffset = f(h, i[d + e._xCelestialPoleOffsetRadiansColumn], i[m + e._xCelestialPoleOffsetRadiansColumn]), s.yPoleOffset = f(h, i[d + e._yCelestialPoleOffsetRadiansColumn], i[m + e._yCelestialPoleOffsetRadiansColumn]), s.ut1MinusUtc = f(h, _, v), s
        }

        var v = function (t) {
            if (t = i(t, i.EMPTY_OBJECT), this._dates = void 0, this._samples = void 0, this._dateColumn = -1, this._xPoleWanderRadiansColumn = -1, this._yPoleWanderRadiansColumn = -1, this._ut1MinusUtcSecondsColumn = -1, this._xCelestialPoleOffsetRadiansColumn = -1, this._yCelestialPoleOffsetRadiansColumn = -1, this._taiMinusUtcSecondsColumn = -1, this._columnCount = 0, this._lastIndex = -1, this._downloadPromise = void 0, this._dataError = void 0, this._addNewLeapSeconds = i(t.addNewLeapSeconds, !0), n(t.data))m(this, t.data); else if (n(t.url)) {
                var r = this;
                this._downloadPromise = e(u(t.url), function (e) {
                    m(r, e)
                }, function () {
                    r._dataError = "An error occurred while retrieving the EOP data from the URL " + t.url + "."
                })
            } else m(this, {
                columnNames: ["dateIso8601", "modifiedJulianDateUtc", "xPoleWanderRadians", "yPoleWanderRadians", "ut1MinusUtcSeconds", "lengthOfDayCorrectionSeconds", "xCelestialPoleOffsetRadians", "yCelestialPoleOffsetRadians", "taiMinusUtcSeconds"],
                samples: []
            })
        };
        return v.NONE = o({
            getPromiseToLoad: function () {
                return e()
            }, compute: function (e, t) {
                return n(t) ? (t.xPoleWander = 0, t.yPoleWander = 0, t.xPoleOffset = 0, t.yPoleOffset = 0, t.ut1MinusUtc = 0) : t = new r(0, 0, 0, 0, 0), t
            }
        }), v.prototype.getPromiseToLoad = function () {
            return e(this._downloadPromise)
        }, v.prototype.compute = function (e, i) {
            if (!n(this._samples)) {
                if (n(this._dataError))throw new l(this._dataError);
                return void 0
            }
            if (n(i) || (i = new r(0, 0, 0, 0, 0)), 0 === this._samples.length)return i.xPoleWander = 0, i.yPoleWander = 0, i.xPoleOffset = 0, i.yPoleOffset = 0, i.ut1MinusUtc = 0, i;
            var o = this._dates, s = this._lastIndex, u = 0, c = 0;
            if (n(s)) {
                var h = o[s], d = o[s + 1], m = a.lessThanOrEquals(h, e), p = !n(d), f = p || a.greaterThanOrEquals(d, e);
                if (m && f)return u = s, !p && d.equals(e) && ++u, c = u + 1, _(this, o, this._samples, e, u, c, i), i
            }
            var v = t(o, e, a.compare, this._dateColumn);
            return v >= 0 ? (v < o.length - 1 && o[v + 1].equals(e) && ++v, u = v, c = v) : (c = ~v, u = c - 1, 0 > u && (u = 0)), this._lastIndex = u, _(this, o, this._samples, e, u, c, i), i
        }, v
    }), define("Cesium/ThirdParty/Uri", [], function () {
        function e(t) {
            if (t instanceof e)this.scheme = t.scheme, this.authority = t.authority, this.path = t.path, this.query = t.query, this.fragment = t.fragment; else if (t) {
                var i = n.exec(t);
                this.scheme = i[1], this.authority = i[2], this.path = i[3], this.query = i[4], this.fragment = i[5]
            }
        }

        function t(e) {
            var t = unescape(e);
            return o.test(t) ? t : e.toUpperCase()
        }

        function i(e, t, i, n) {
            return (t || "") + i.toLowerCase() + (n || "")
        }

        e.prototype.scheme = null, e.prototype.authority = null, e.prototype.path = "", e.prototype.query = null, e.prototype.fragment = null;
        var n = new RegExp("^(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?$");
        e.prototype.getScheme = function () {
            return this.scheme
        }, e.prototype.getAuthority = function () {
            return this.authority
        }, e.prototype.getPath = function () {
            return this.path
        }, e.prototype.getQuery = function () {
            return this.query
        }, e.prototype.getFragment = function () {
            return this.fragment
        }, e.prototype.isAbsolute = function () {
            return !!this.scheme && !this.fragment
        }, e.prototype.isSameDocumentAs = function (e) {
            return e.scheme == this.scheme && e.authority == this.authority && e.path == this.path && e.query == this.query
        }, e.prototype.equals = function (e) {
            return this.isSameDocumentAs(e) && e.fragment == this.fragment
        }, e.prototype.normalize = function () {
            this.removeDotSegments(), this.scheme && (this.scheme = this.scheme.toLowerCase()), this.authority && (this.authority = this.authority.replace(a, i).replace(r, t)), this.path && (this.path = this.path.replace(r, t)), this.query && (this.query = this.query.replace(r, t)), this.fragment && (this.fragment = this.fragment.replace(r, t))
        };
        var r = /%[0-9a-z]{2}/gi, o = /[a-zA-Z0-9\-\._~]/, a = /(.*@)?([^@:]*)(:.*)?/;
        return e.prototype.resolve = function (t) {
            var i = new e;
            return this.scheme ? (i.scheme = this.scheme, i.authority = this.authority, i.path = this.path, i.query = this.query) : (i.scheme = t.scheme, this.authority ? (i.authority = this.authority, i.path = this.path, i.query = this.query) : (i.authority = t.authority, "" == this.path ? (i.path = t.path, i.query = this.query || t.query) : ("/" == this.path.charAt(0) ? (i.path = this.path, i.removeDotSegments()) : (t.authority && "" == t.path ? i.path = "/" + this.path : i.path = t.path.substring(0, t.path.lastIndexOf("/") + 1) + this.path, i.removeDotSegments()), i.query = this.query))), i.fragment = this.fragment, i
        }, e.prototype.removeDotSegments = function () {
            var e, t = this.path.split("/"), i = [], n = "" == t[0];
            n && t.shift();
            for ("" == t[0] ? t.shift() : null; t.length;)e = t.shift(), ".." == e ? i.pop() : "." != e && i.push(e);
            ("." == e || ".." == e) && i.push(""), n && i.unshift(""), this.path = i.join("/")
        }, e.prototype.toString = function () {
            var e = "";
            return this.scheme && (e += this.scheme + ":"), this.authority && (e += "//" + this.authority), e += this.path, this.query && (e += "?" + this.query), this.fragment && (e += "#" + this.fragment), e
        }, e
    }), define("Cesium/Core/buildModuleUrl", ["../ThirdParty/Uri", "./defined", "./DeveloperError", "require"], function (e, t, i, n) {
        "use strict";
        function r() {
            for (var e = document.getElementsByTagName("script"), t = 0, i = e.length; i > t; ++t) {
                var n = e[t].getAttribute("src"), r = h.exec(n);
                if (null !== r)return r[1]
            }
            return void 0
        }

        function o() {
            if (t(u))return u;
            var n;
            if (n = "undefined" != typeof CESIUM_BASE_URL ? CESIUM_BASE_URL : r(), !t(n))throw new i("Unable to determine Cesium base URL automatically, try defining a global variable called CESIUM_BASE_URL.");
            return u = new e(n).resolve(new e(document.location.href))
        }

        function a(e) {
            return n.toUrl("../" + e)
        }

        function s(t) {
            return new e(t).resolve(o()).toString()
        }

        var u, l, c, h = /((?:.*\/)|^)cesium[\w-]*\.js(?:\W|$)/i, d = function (e) {
            t(l) || (l = t(n.toUrl) ? a : s), t(c) || (c = document.createElement("a"));
            var i = l(e);
            return c.href = i, c.href = c.href, c.href
        };
        return d._cesiumScriptRegex = h, d.setBaseUrl = function (t) {
            u = new e(t).resolve(new e(document.location.href))
        }, d
    }), define("Cesium/Core/Iau2006XysSample", [], function () {
        "use strict";
        var e = function (e, t, i) {
            this.x = e, this.y = t, this.s = i
        };
        return e
    }), define("Cesium/Core/Iau2006XysData", ["../ThirdParty/when", "./buildModuleUrl", "./defaultValue", "./defined", "./Iau2006XysSample", "./JulianDate", "./loadJson", "./TimeStandard"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        function u(e, t, i) {
            var n = h;
            return n.dayNumber = t, n.secondsOfDay = i, o.daysDifference(n, e._sampleZeroDateTT)
        }

        function l(i, r) {
            if (i._chunkDownloadsInProgress[r])return i._chunkDownloadsInProgress[r];
            var o = e.defer();
            i._chunkDownloadsInProgress[r] = o;
            var s, u = i._xysFileUrlTemplate;
            return s = n(u) ? u.replace("{0}", r) : t("Assets/IAU2006_XYS/IAU2006_XYS_" + r + ".json"), e(a(s), function (e) {
                i._chunkDownloadsInProgress[r] = !1;
                for (var t = i._samples, n = e.samples, a = r * i._samplesPerXysFile * 3, s = 0, u = n.length; u > s; ++s)t[a + s] = n[s];
                o.resolve()
            }), o.promise
        }

        var c = function (e) {
            e = i(e, i.EMPTY_OBJECT), this._xysFileUrlTemplate = e.xysFileUrlTemplate, this._interpolationOrder = i(e.interpolationOrder, 9), this._sampleZeroJulianEphemerisDate = i(e.sampleZeroJulianEphemerisDate, 2442396.5), this._sampleZeroDateTT = new o(this._sampleZeroJulianEphemerisDate, 0, s.TAI), this._stepSizeDays = i(e.stepSizeDays, 1), this._samplesPerXysFile = i(e.samplesPerXysFile, 1e3), this._totalSamples = i(e.totalSamples, 27426), this._samples = new Array(3 * this._totalSamples), this._chunkDownloadsInProgress = [];
            for (var t = this._interpolationOrder, n = this._denominators = new Array(t + 1), r = this._xTable = new Array(t + 1), a = Math.pow(this._stepSizeDays, t), u = 0; t >= u; ++u) {
                n[u] = a, r[u] = u * this._stepSizeDays;
                for (var l = 0; t >= l; ++l)l !== u && (n[u] *= u - l);
                n[u] = 1 / n[u]
            }
            this._work = new Array(t + 1), this._coef = new Array(t + 1)
        }, h = new o(0, 0, s.TAI);
        return c.prototype.preload = function (t, i, n, r) {
            var o = u(this, t, i), a = u(this, n, r), s = o / this._stepSizeDays - this._interpolationOrder / 2 | 0;
            0 > s && (s = 0);
            var c = a / this._stepSizeDays - this._interpolationOrder / 2 | 0 + this._interpolationOrder;
            c >= this._totalSamples && (c = this._totalSamples - 1);
            for (var h = s / this._samplesPerXysFile | 0, d = c / this._samplesPerXysFile | 0, m = [], p = h; d >= p; ++p)m.push(l(this, p));
            return e.all(m)
        }, c.prototype.computeXysRadians = function (e, t, i) {
            var o = u(this, e, t);
            if (0 > o)return void 0;
            var a = o / this._stepSizeDays | 0;
            if (a >= this._totalSamples)return void 0;
            var s = this._interpolationOrder, c = a - (s / 2 | 0);
            0 > c && (c = 0);
            var h = c + s;
            h >= this._totalSamples && (h = this._totalSamples - 1, c = h - s, 0 > c && (c = 0));
            var d = !1, m = this._samples;
            if (n(m[3 * c]) || (l(this, c / this._samplesPerXysFile | 0), d = !0), n(m[3 * h]) || (l(this, h / this._samplesPerXysFile | 0), d = !0), d)return void 0;
            n(i) ? (i.x = 0, i.y = 0, i.s = 0) : i = new r(0, 0, 0);
            var p, f, _ = o - c * this._stepSizeDays, v = this._work, g = this._denominators, y = this._coef, C = this._xTable;
            for (p = 0; s >= p; ++p)v[p] = _ - C[p];
            for (p = 0; s >= p; ++p) {
                for (y[p] = 1, f = 0; s >= f; ++f)f !== p && (y[p] *= v[f]);
                y[p] *= g[p];
                var E = 3 * (c + p);
                i.x += y[p] * m[E++], i.y += y[p] * m[E++], i.s += y[p] * m[E]
            }
            return i
        }, c
    }), define("Cesium/Core/Transforms", ["../ThirdParty/when", "./Cartesian2", "./Cartesian3", "./Cartesian4", "./defaultValue", "./defined", "./DeveloperError", "./EarthOrientationParameters", "./EarthOrientationParametersSample", "./Ellipsoid", "./Iau2006XysData", "./Iau2006XysSample", "./JulianDate", "./Math", "./Matrix3", "./Matrix4", "./Quaternion", "./TimeConstants"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v) {
        "use strict";
        var g = {}, y = new i, C = new i, E = new i;
        g.eastNorthUpToFixedFrame = function (e, t, n) {
            if (m.equalsEpsilon(e.x, 0, m.EPSILON14) && m.equalsEpsilon(e.y, 0, m.EPSILON14)) {
                var a = m.sign(e.z);
                return o(n) ? (n[0] = 0, n[1] = 1, n[2] = 0, n[3] = 0, n[4] = -a, n[5] = 0, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = a, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, n) : new f(0, -a, 0, e.x, 1, 0, 0, e.y, 0, 0, a, e.z, 0, 0, 0, 1)
            }
            var s = y, u = C, c = E;
            return t = r(t, l.WGS84), t.geodeticSurfaceNormal(e, s), u.x = -e.y, u.y = e.x, u.z = 0, i.normalize(u, u), i.cross(s, u, c), o(n) ? (n[0] = u.x, n[1] = u.y, n[2] = u.z, n[3] = 0, n[4] = c.x, n[5] = c.y, n[6] = c.z, n[7] = 0, n[8] = s.x, n[9] = s.y, n[10] = s.z, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, n) : new f(u.x, c.x, s.x, e.x, u.y, c.y, s.y, e.y, u.z, c.z, s.z, e.z, 0, 0, 0, 1)
        };
        var S = new i, T = new i, b = new i;
        g.northEastDownToFixedFrame = function (e, t, n) {
            if (m.equalsEpsilon(e.x, 0, m.EPSILON14) && m.equalsEpsilon(e.y, 0, m.EPSILON14)) {
                var a = m.sign(e.z);
                return o(n) ? (n[0] = -a, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 1, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = -a, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, n) : new f(-a, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, -a, e.z, 0, 0, 0, 1)
            }
            var s = S, u = T, c = b;
            return t = r(t, l.WGS84), t.geodeticSurfaceNormal(e, s), u.x = -e.y, u.y = e.x, u.z = 0, i.normalize(u, u), i.cross(s, u, c), o(n) ? (n[0] = c.x, n[1] = c.y, n[2] = c.z, n[3] = 0, n[4] = u.x, n[5] = u.y, n[6] = u.z, n[7] = 0, n[8] = -s.x, n[9] = -s.y, n[10] = -s.z, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, n) : new f(c.x, u.x, -s.x, e.x, c.y, u.y, -s.y, e.y, c.z, u.z, -s.z, e.z, 0, 0, 0, 1)
        }, g.northUpEastToFixedFrame = function (e, t, n) {
            if (m.equalsEpsilon(e.x, 0, m.EPSILON14) && m.equalsEpsilon(e.y, 0, m.EPSILON14)) {
                var a = m.sign(e.z);
                return o(n) ? (n[0] = -a, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 0, n[6] = a, n[7] = 0, n[8] = 0, n[9] = 1, n[10] = 0, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, n) : new f(-a, 0, 0, e.x, 0, 0, 1, e.y, 0, a, 0, e.z, 0, 0, 0, 1)
            }
            var s = y, u = C, c = E;
            return t = r(t, l.WGS84), t.geodeticSurfaceNormal(e, s), u.x = -e.y, u.y = e.x, u.z = 0, i.normalize(u, u), i.cross(s, u, c), o(n) ? (n[0] = c.x, n[1] = c.y, n[2] = c.z, n[3] = 0, n[4] = s.x, n[5] = s.y, n[6] = s.z, n[7] = 0, n[8] = u.x, n[9] = u.y, n[10] = u.z, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, n) : new f(c.x, s.x, u.x, e.x, c.y, s.y, u.y, e.y, c.z, s.z, u.z, e.z, 0, 0, 0, 1)
        };
        var w = new _, x = new i(1, 1, 1), A = new f;
        g.headingPitchRollToFixedFrame = function (e, t, n, r, o, a) {
            var s = _.fromHeadingPitchRoll(t, n, r, w), u = f.fromTranslationQuaternionRotationScale(i.ZERO, s, x, A);
            return a = g.eastNorthUpToFixedFrame(e, o, a), f.multiply(a, u, a)
        };
        var P = new f, I = new p;
        g.headingPitchRollQuaternion = function (e, t, i, n, r, o) {
            var a = g.headingPitchRollToFixedFrame(e, t, i, n, r, P), s = f.getRotation(a, I);
            return _.fromRotationMatrix(s, o)
        };
        var D = 24110.54841, M = 8640184.812866, O = .093104, R = -62e-7, N = 1.1772758384668e-19, L = 72921158553e-15, F = m.TWO_PI / 86400, B = new d;
        g.computeTemeToPseudoFixedMatrix = function (e, t) {
            B = d.addSeconds(e, -d.computeTaiMinusUtc(e), B);
            var i, n = B.dayNumber, r = B.secondsOfDay, a = n - 2451545;
            i = r >= 43200 ? (a + .5) / v.DAYS_PER_JULIAN_CENTURY : (a - .5) / v.DAYS_PER_JULIAN_CENTURY;
            var s = D + i * (M + i * (O + i * R)), u = s * F % m.TWO_PI, l = L + N * (n - 2451545.5), c = (r + .5 * v.SECONDS_PER_DAY) % v.SECONDS_PER_DAY, h = u + l * c, f = Math.cos(h), _ = Math.sin(h);
            return o(t) ? (t[0] = f, t[1] = -_, t[2] = 0, t[3] = _, t[4] = f, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t) : new p(f, _, 0, -_, f, 0, 0, 0, 1)
        }, g.iau2006XysData = new c, g.earthOrientationParameters = s.NONE;
        var z = 32.184, V = 2451545;
        g.preloadIcrfFixed = function (t) {
            var i = t.start.dayNumber, n = t.start.secondsOfDay + z, r = t.stop.dayNumber, o = t.stop.secondsOfDay + z, a = g.iau2006XysData.preload(i, n, r, o), s = g.earthOrientationParameters.getPromiseToLoad();
            return e.all([a, s])
        }, g.computeIcrfToFixedMatrix = function (e, t) {
            o(t) || (t = new p);
            var i = g.computeFixedToIcrfMatrix(e, t);
            return o(i) ? p.transpose(i, t) : void 0
        };
        var U = new h(0, 0, 0), k = new u(0, 0, 0, 0, 0, 0), G = new p, H = new p;
        g.computeFixedToIcrfMatrix = function (e, t) {
            o(t) || (t = new p);
            var i = g.earthOrientationParameters.compute(e, k);
            if (!o(i))return void 0;
            var n = e.dayNumber, r = e.secondsOfDay + z, a = g.iau2006XysData.computeXysRadians(n, r, U);
            if (!o(a))return void 0;
            var s = a.x + i.xPoleOffset, u = a.y + i.yPoleOffset, l = 1 / (1 + Math.sqrt(1 - s * s - u * u)), c = G;
            c[0] = 1 - l * s * s, c[3] = -l * s * u, c[6] = s, c[1] = -l * s * u, c[4] = 1 - l * u * u, c[7] = u, c[2] = -s, c[5] = -u, c[8] = 1 - l * (s * s + u * u);
            var h = p.fromRotationZ(-a.s, H), f = p.multiply(c, h, G), _ = e.dayNumber, y = e.secondsOfDay - d.computeTaiMinusUtc(e) + i.ut1MinusUtc, C = _ - 2451545, E = y / v.SECONDS_PER_DAY, S = .779057273264 + E + .00273781191135448 * (C + E);
            S = S % 1 * m.TWO_PI;
            var T = p.fromRotationZ(S, H), b = p.multiply(f, T, G), w = Math.cos(i.xPoleWander), x = Math.cos(i.yPoleWander), A = Math.sin(i.xPoleWander), P = Math.sin(i.yPoleWander), I = n - V + r / v.SECONDS_PER_DAY;
            I /= 36525;
            var D = -47e-6 * I * m.RADIANS_PER_DEGREE / 3600, M = Math.cos(D), O = Math.sin(D), R = H;
            return R[0] = w * M, R[1] = w * O, R[2] = A, R[3] = -x * O + P * A * M, R[4] = x * M + P * A * O, R[5] = -P * w, R[6] = -P * O - x * A * M, R[7] = P * M - x * A * O, R[8] = x * w, p.multiply(b, R, t)
        };
        var W = new n;
        g.pointToWindowCoordinates = function (e, t, i, n) {
            return n = g.pointToGLWindowCoordinates(e, t, i, n), n.y = 2 * t[5] - n.y, n
        }, g.pointToGLWindowCoordinates = function (e, i, r, a) {
            o(a) || (a = new t);
            var s = W;
            return f.multiplyByVector(e, n.fromElements(r.x, r.y, r.z, 1, s), s), n.multiplyByScalar(s, 1 / s.w, s), f.multiplyByVector(i, s, s), t.fromCartesian4(s, a)
        };
        var q = new i, j = new i, Y = new i;
        return g.rotationMatrixFromPositionVelocity = function (e, t, n, a) {
            var s = r(n, l.WGS84).geodeticSurfaceNormal(e, q), u = i.cross(t, s, j);
            i.equalsEpsilon(u, i.ZERO, m.EPSILON6) && (u = i.clone(i.UNIT_X, u));
            var c = i.cross(u, t, Y);
            return i.cross(t, c, u), i.negate(u, u), o(a) || (a = new p), a[0] = t.x, a[1] = t.y, a[2] = t.z, a[3] = u.x, a[4] = u.y, a[5] = u.z, a[6] = c.x, a[7] = c.y, a[8] = c.z, a
        }, g
    }), define("Cesium/DataSources/ConstantProperty", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event"], function (e, t, i, n, r) {
        "use strict";
        var o = function (e) {
            this._value = void 0, this._hasClone = !1, this._hasEquals = !1, this._definitionChanged = new r, this.setValue(e)
        };
        return i(o.prototype, {
            isConstant: {value: !0}, definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            }
        }), o.prototype.getValue = function (e, t) {
            return this._hasClone ? this._value.clone(t) : this._value
        }, o.prototype.setValue = function (e) {
            var i = this._value;
            if (i !== e) {
                var n = t(e), r = n && "function" == typeof e.clone, o = n && "function" == typeof e.equals;
                this._hasClone = r, this._hasEquals = o;
                var a = !o || !e.equals(i);
                a && (this._value = r ? e.clone() : e, this._definitionChanged.raiseEvent(this))
            }
        }, o.prototype.equals = function (e) {
            return this === e || e instanceof o && (!this._hasEquals && this._value === e._value || this._hasEquals && this._value.equals(e._value))
        }, o
    }), define("Cesium/DataSources/createPropertyDescriptor", ["../Core/defaultValue", "../Core/defined", "./ConstantProperty"], function (e, t, i) {
        "use strict";
        function n(e, i, n, r, o) {
            return {
                configurable: r, get: function () {
                    return this[i]
                }, set: function (r) {
                    var a = this[i], s = this[n];
                    t(s) && (s(), this[n] = void 0);
                    var u = t(r);
                    u && !t(r.getValue) && t(o) && (r = o(r)), a !== r && (this[i] = r, this._definitionChanged.raiseEvent(this, e, r, a)), t(r) && t(r.definitionChanged) && (this[n] = r.definitionChanged.addEventListener(function () {
                        this._definitionChanged.raiseEvent(this, e, r, r)
                    }, this))
                }
            }
        }

        function r(e) {
            return new i(e)
        }

        function o(t, i, o) {
            return n(t, "_" + t.toString(), "_" + t.toString() + "Subscription", e(i, !1), e(o, r))
        }

        return o
    }), define("Cesium/DataSources/BillboardGraphics", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "./createPropertyDescriptor"], function (e, t, i, n, r, o) {
        "use strict";
        var a = function (t) {
            this._image = void 0, this._imageSubscription = void 0, this._imageSubRegion = void 0, this._imageSubRegionSubscription = void 0, this._width = void 0, this._widthSubscription = void 0, this._height = void 0, this._heightSubscription = void 0, this._scale = void 0, this._scaleSubscription = void 0, this._rotation = void 0, this._rotationSubscription = void 0, this._alignedAxis = void 0, this._alignedAxisSubscription = void 0, this._horizontalOrigin = void 0, this._horizontalOriginSubscription = void 0, this._verticalOrigin = void 0, this._verticalOriginSubscription = void 0, this._color = void 0, this._colorSubscription = void 0, this._eyeOffset = void 0, this._eyeOffsetSubscription = void 0, this._pixelOffset = void 0, this._pixelOffsetSubscription = void 0, this._show = void 0, this._showSubscription = void 0, this._scaleByDistance = void 0, this._scaleByDistanceSubscription = void 0, this._translucencyByDistance = void 0, this._translucencyByDistanceSubscription = void 0, this._pixelOffsetScaleByDistance = void 0, this._pixelOffsetScaleByDistanceSubscription = void 0, this._sizeInMeters = void 0, this._sizeInMetersSubscription = void 0, this._definitionChanged = new r, this.merge(e(t, e.EMPTY_OBJECT))
        };
        return i(a.prototype, {
            definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            },
            image: o("image"),
            imageSubRegion: o("imageSubRegion"),
            scale: o("scale"),
            rotation: o("rotation"),
            alignedAxis: o("alignedAxis"),
            horizontalOrigin: o("horizontalOrigin"),
            verticalOrigin: o("verticalOrigin"),
            color: o("color"),
            eyeOffset: o("eyeOffset"),
            pixelOffset: o("pixelOffset"),
            show: o("show"),
            width: o("width"),
            height: o("height"),
            scaleByDistance: o("scaleByDistance"),
            translucencyByDistance: o("translucencyByDistance"),
            pixelOffsetScaleByDistance: o("pixelOffsetScaleByDistance"),
            sizeInMeters: o("sizeInMeters")
        }), a.prototype.clone = function (e) {
            return t(e) ? (e.color = this._color, e.eyeOffset = this._eyeOffset, e.horizontalOrigin = this._horizontalOrigin, e.image = this._image, e.imageSubRegion = this._imageSubRegion, e.pixelOffset = this._pixelOffset, e.scale = this._scale, e.rotation = this._rotation, e.alignedAxis = this._alignedAxis, e.show = this._show, e.verticalOrigin = this._verticalOrigin, e.width = this._width, e.height = this._height, e.scaleByDistance = this._scaleByDistance, e.translucencyByDistance = this._translucencyByDistance, e.pixelOffsetScaleByDistance = this._pixelOffsetScaleByDistance, e.sizeInMeters = this._sizeInMeters, e) : new a(this)
        }, a.prototype.merge = function (t) {
            this.color = e(this._color, t.color), this.eyeOffset = e(this._eyeOffset, t.eyeOffset), this.horizontalOrigin = e(this._horizontalOrigin, t.horizontalOrigin), this.image = e(this._image, t.image), this.imageSubRegion = e(this._imageSubRegion, t.imageSubRegion), this.pixelOffset = e(this._pixelOffset, t.pixelOffset), this.scale = e(this._scale, t.scale), this.rotation = e(this._rotation, t.rotation), this.alignedAxis = e(this._alignedAxis, t.alignedAxis), this.show = e(this._show, t.show), this.verticalOrigin = e(this._verticalOrigin, t.verticalOrigin), this.width = e(this._width, t.width), this.height = e(this._height, t.height), this.scaleByDistance = e(this._scaleByDistance, t.scaleByDistance), this.translucencyByDistance = e(this._translucencyByDistance, t.translucencyByDistance), this.pixelOffsetScaleByDistance = e(this._pixelOffsetScaleByDistance, t.pixelOffsetScaleByDistance), this.sizeInMeters = e(this._sizeInMeters, t.sizeInMeters)
        }, a
    }), define("Cesium/Core/TimeInterval", ["./defaultValue", "./defined", "./defineProperties", "./DeveloperError", "./freezeObject", "./JulianDate"], function (e, t, i, n, r, o) {
        "use strict";
        var a = function (i) {
            i = e(i, e.EMPTY_OBJECT), this.start = t(i.start) ? o.clone(i.start) : new o, this.stop = t(i.stop) ? o.clone(i.stop) : new o, this.data = i.data, this.isStartIncluded = e(i.isStartIncluded, !0), this.isStopIncluded = e(i.isStopIncluded, !0)
        };
        i(a.prototype, {
            isEmpty: {
                get: function () {
                    var e = o.compare(this.stop, this.start);
                    return 0 > e || 0 === e && (!this.isStartIncluded || !this.isStopIncluded)
                }
            }
        });
        var s = {start: void 0, stop: void 0, isStartIncluded: void 0, isStopIncluded: void 0, data: void 0};
        return a.fromIso8601 = function (i, n) {
            var r = i.iso8601.split("/"), u = o.fromIso8601(r[0]), l = o.fromIso8601(r[1]), c = e(i.isStartIncluded, !0), h = e(i.isStopIncluded, !0), d = i.data;
            return t(n) ? (n.start = u, n.stop = l, n.isStartIncluded = c, n.isStopIncluded = h, n.data = d, n) : (s.start = u, s.stop = l, s.isStartIncluded = c, s.isStopIncluded = h, s.data = d, new a(s))
        }, a.toIso8601 = function (e, t) {
            return o.toIso8601(e.start, t) + "/" + o.toIso8601(e.stop, t)
        }, a.clone = function (e, i) {
            return t(e) ? t(i) ? (i.start = e.start, i.stop = e.stop, i.isStartIncluded = e.isStartIncluded, i.isStopIncluded = e.isStopIncluded, i.data = e.data, i) : new a(e) : void 0
        }, a.equals = function (e, i, n) {
            return e === i || t(e) && t(i) && (e.isEmpty && i.isEmpty || e.isStartIncluded === i.isStartIncluded && e.isStopIncluded === i.isStopIncluded && o.equals(e.start, i.start) && o.equals(e.stop, i.stop) && (e.data === i.data || t(n) && n(e.data, i.data)))
        }, a.equalsEpsilon = function (e, i, n, r) {
            return e === i || t(e) && t(i) && (e.isEmpty && i.isEmpty || e.isStartIncluded === i.isStartIncluded && e.isStopIncluded === i.isStopIncluded && o.equalsEpsilon(e.start, i.start, n) && o.equalsEpsilon(e.stop, i.stop, n) && (e.data === i.data || t(r) && r(e.data, i.data)))
        }, a.intersect = function (e, i, n, r) {
            if (!t(i))return a.clone(a.EMPTY, n);
            var s = e.start, u = e.stop, l = i.start, c = i.stop, h = o.greaterThanOrEquals(l, s) && o.greaterThanOrEquals(u, l), d = !h && o.lessThanOrEquals(l, s) && o.lessThanOrEquals(s, c);
            if (!h && !d)return a.clone(a.EMPTY, n);
            var m = e.isStartIncluded, p = e.isStopIncluded, f = i.isStartIncluded, _ = i.isStopIncluded, v = o.lessThan(u, c);
            return n.start = h ? l : s, n.isStartIncluded = m && f || !o.equals(l, s) && (h && f || d && m), n.stop = v ? u : c, n.isStopIncluded = v ? p : p && _ || !o.equals(c, u) && _, n.data = t(r) ? r(e.data, i.data) : e.data, n
        }, a.contains = function (e, t) {
            if (e.isEmpty)return !1;
            var i = o.compare(e.start, t);
            if (0 === i)return e.isStartIncluded;
            var n = o.compare(t, e.stop);
            return 0 === n ? e.isStopIncluded : 0 > i && 0 > n
        }, a.prototype.clone = function (e) {
            return a.clone(this, e)
        }, a.prototype.equals = function (e, t) {
            return a.equals(this, e, t)
        }, a.prototype.equalsEpsilon = function (e, t, i) {
            return a.equalsEpsilon(this, e, t, i)
        }, a.prototype.toString = function () {
            return a.toIso8601(this)
        }, a.EMPTY = r(new a({start: new o, stop: new o, isStartIncluded: !1, isStopIncluded: !1})), a
    }), define("Cesium/Core/Iso8601", ["./freezeObject", "./JulianDate", "./TimeInterval"], function (e, t, i) {
        "use strict";
        var n = e(t.fromIso8601("0000-01-01T00:00:00Z")), r = e(t.fromIso8601("9999-12-31T24:00:00Z")), o = e(new i({
            start: n,
            stop: r
        })), a = {MINIMUM_VALUE: n, MAXIMUM_VALUE: r, MAXIMUM_INTERVAL: o};
        return a
    }), define("Cesium/DataSources/Property", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Iso8601"], function (e, t, i, n, r) {
        "use strict";
        var o = function () {
            n.throwInstantiationError()
        };
        return i(o.prototype, {
            isConstant: {get: n.throwInstantiationError},
            definitionChanged: {get: n.throwInstantiationError}
        }), o.prototype.getValue = n.throwInstantiationError, o.prototype.equals = n.throwInstantiationError, o.equals = function (e, i) {
            return e === i || t(e) && e.equals(i)
        }, o.arrayEquals = function (e, i) {
            if (e === i)return !0;
            if (!t(e) || !t(i) || e.length !== i.length)return !1;
            for (var n = e.length, r = 0; n > r; r++)if (!o.equals(e[r], i[r]))return !1;
            return !0
        }, o.isConstant = function (e) {
            return !t(e) || e.isConstant
        }, o.getValueOrUndefined = function (e, i, n) {
            return t(e) ? e.getValue(i, n) : void 0
        }, o.getValueOrDefault = function (i, n, r, o) {
            return t(i) ? e(i.getValue(n, o), r) : r
        }, o.getValueOrClonedDefault = function (e, i, n, r) {
            var o;
            return t(e) && (o = e.getValue(i, r)), t(o) || (o = n.clone(o)), o
        }, o
    }), define("Cesium/DataSources/ColorMaterialProperty", ["../Core/Color", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "./ConstantProperty", "./createPropertyDescriptor", "./Property"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        var u = function (e) {
            this._definitionChanged = new r, this._color = void 0, this._colorSubscription = void 0, this.color = e
        };
        return i(u.prototype, {
            isConstant: {
                get: function () {
                    return s.isConstant(this._color)
                }
            }, definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            }, color: a("color")
        }), u.prototype.getType = function (e) {
            return "Color"
        }, u.prototype.getValue = function (i, n) {
            return t(n) || (n = {}), n.color = s.getValueOrClonedDefault(this._color, i, e.WHITE, n.color), n
        }, u.prototype.equals = function (e) {
            return this === e || e instanceof u && s.equals(this._color, e._color)
        }, u
    }), define("Cesium/DataSources/ImageMaterialProperty", ["../Core/Cartesian2", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/Event", "./createPropertyDescriptor", "./Property"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = new e(1, 1), u = function (e) {
            e = t(e, t.EMPTY_OBJECT), this._definitionChanged = new r, this._image = void 0, this._imageSubscription = void 0, this._repeat = void 0, this._repeatSubscription = void 0, this.image = e.image, this.repeat = e.repeat
        };
        return n(u.prototype, {
            isConstant: {
                get: function () {
                    return a.isConstant(this._image) && a.isConstant(this._repeat)
                }
            }, definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            }, image: o("image"), repeat: o("repeat")
        }), u.prototype.getType = function (e) {
            return "Image"
        }, u.prototype.getValue = function (e, t) {
            return i(t) || (t = {}), t.image = a.getValueOrUndefined(this._image, e), t.repeat = a.getValueOrClonedDefault(this._repeat, e, s, t.repeat), t
        }, u.prototype.equals = function (e) {
            return this === e || e instanceof u && a.equals(this._image, e._image) && a.equals(this._repeat, e._repeat)
        }, u
    }), define("Cesium/DataSources/createMaterialPropertyDescriptor", ["../Core/Color", "../Core/DeveloperError", "./ColorMaterialProperty", "./createPropertyDescriptor", "./ImageMaterialProperty"], function (e, t, i, n, r) {
        "use strict";
        function o(t) {
            if (t instanceof e)return new i(t);
            if ("string" == typeof t || t instanceof HTMLCanvasElement) {
                var n = new r;
                return n.image = t, n
            }
        }

        function a(e, t) {
            return n(e, t, o)
        }

        return a
    }), define("Cesium/DataSources/BoxGraphics", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "./createMaterialPropertyDescriptor", "./createPropertyDescriptor"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = function (t) {
            this._dimensions = void 0, this._dimensionsSubscription = void 0, this._show = void 0, this._showSubscription = void 0, this._fill = void 0, this._fillSubscription = void 0, this._material = void 0, this._materialSubscription = void 0, this._outline = void 0, this._outlineSubscription = void 0, this._outlineColor = void 0, this._outlineColorSubscription = void 0, this._outlineWidth = void 0, this._outlineWidthSubscription = void 0, this._definitionChanged = new r, this.merge(e(t, e.EMPTY_OBJECT))
        };
        return i(s.prototype, {
            definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            },
            show: a("show"),
            dimensions: a("dimensions"),
            material: o("material"),
            fill: a("fill"),
            outline: a("outline"),
            outlineColor: a("outlineColor"),
            outlineWidth: a("outlineWidth")
        }), s.prototype.clone = function (e) {
            return t(e) ? (e.dimensions = this.dimensions, e.show = this.show, e.material = this.material, e.fill = this.fill, e.outline = this.outline, e.outlineColor = this.outlineColor, e.outlineWidth = this.outlineWidth, e) : new s(this)
        }, s.prototype.merge = function (t) {
            this.dimensions = e(this.dimensions, t.dimensions), this.show = e(this.show, t.show), this.material = e(this.material, t.material), this.fill = e(this.fill, t.fill), this.outline = e(this.outline, t.outline), this.outlineColor = e(this.outlineColor, t.outlineColor), this.outlineWidth = e(this.outlineWidth, t.outlineWidth)
        }, s
    }), define("Cesium/Core/ReferenceFrame", ["./freezeObject"], function (e) {
        "use strict";
        var t = {FIXED: 0, INERTIAL: 1};
        return e(t)
    }), define("Cesium/DataSources/PositionProperty", ["../Core/Cartesian3", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Matrix3", "../Core/ReferenceFrame", "../Core/Transforms"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = function () {
            n.throwInstantiationError()
        };
        i(s.prototype, {
            isConstant: {get: n.throwInstantiationError},
            definitionChanged: {get: n.throwInstantiationError},
            referenceFrame: {get: n.throwInstantiationError}
        }), s.prototype.getValue = n.throwInstantiationError, s.prototype.getValueInReferenceFrame = n.throwInstantiationError, s.prototype.equals = n.throwInstantiationError;
        var u = new r;
        return s.convertToReferenceFrame = function (i, n, s, l, c) {
            if (!t(n))return n;
            if (t(c) || (c = new e), s === l)return e.clone(n, c);
            var h = a.computeIcrfToFixedMatrix(i, u);
            return t(h) || (h = a.computeTemeToPseudoFixedMatrix(i, u)), s === o.INERTIAL ? r.multiplyByVector(h, n, c) : s === o.FIXED ? r.multiplyByVector(r.transpose(h, u), n, c) : void 0
        }, s
    }), define("Cesium/DataSources/ConstantPositionProperty", ["../Core/Cartesian3", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "../Core/ReferenceFrame", "./PositionProperty"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        var u = function (i, n) {
            this._definitionChanged = new o, this._value = e.clone(i), this._referenceFrame = t(n, a.FIXED)
        };
        return n(u.prototype, {
            isConstant: {
                get: function () {
                    return !i(this._value) || this._referenceFrame === a.FIXED
                }
            }, definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            }, referenceFrame: {
                get: function () {
                    return this._referenceFrame
                }
            }
        }), u.prototype.getValue = function (e, t) {
            return this.getValueInReferenceFrame(e, a.FIXED, t)
        }, u.prototype.setValue = function (t, n) {
            var r = !1;
            e.equals(this._value, t) || (r = !0, this._value = e.clone(t)), i(n) && this._referenceFrame !== n && (r = !0, this._referenceFrame = n), r && this._definitionChanged.raiseEvent(this)
        }, u.prototype.getValueInReferenceFrame = function (e, t, i) {
            return s.convertToReferenceFrame(e, this._value, this._referenceFrame, t, i)
        }, u.prototype.equals = function (t) {
            return this === t || t instanceof u && e.equals(this._value, t._value) && this._referenceFrame === t._referenceFrame
        }, u
    }), define("Cesium/DataSources/CorridorGraphics", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "./createMaterialPropertyDescriptor", "./createPropertyDescriptor"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = function (t) {
            this._show = void 0, this._showSubscription = void 0, this._material = void 0, this._materialSubscription = void 0, this._positions = void 0, this._positionsSubscription = void 0, this._height = void 0, this._heightSubscription = void 0, this._extrudedHeight = void 0, this._extrudedHeightSubscription = void 0, this._granularity = void 0, this._granularitySubscription = void 0, this._width = void 0, this._widthSubscription = void 0, this._cornerType = void 0, this._cornerTypeSubscription = void 0, this._fill = void 0, this._fillSubscription = void 0, this._outline = void 0, this._outlineSubscription = void 0, this._outlineColor = void 0, this._outlineColorSubscription = void 0, this._outlineWidth = void 0, this._outlineWidthSubscription = void 0, this._definitionChanged = new r, this.merge(e(t, e.EMPTY_OBJECT))
        };
        return i(s.prototype, {
            definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            },
            show: a("show"),
            material: o("material"),
            positions: a("positions"),
            height: a("height"),
            extrudedHeight: a("extrudedHeight"),
            granularity: a("granularity"),
            width: a("width"),
            fill: a("fill"),
            outline: a("outline"),
            outlineColor: a("outlineColor"),
            outlineWidth: a("outlineWidth"),
            cornerType: a("cornerType")
        }), s.prototype.clone = function (e) {
            return t(e) ? (e.show = this.show, e.material = this.material, e.positions = this.positions, e.height = this.height, e.extrudedHeight = this.extrudedHeight, e.granularity = this.granularity, e.width = this.width, e.fill = this.fill, e.outline = this.outline, e.outlineColor = this.outlineColor, e.outlineWidth = this.outlineWidth, e.cornerType = this.cornerType, e) : new s(this)
        }, s.prototype.merge = function (t) {
            this.show = e(this.show, t.show), this.material = e(this.material, t.material), this.positions = e(this.positions, t.positions), this.height = e(this.height, t.height), this.extrudedHeight = e(this.extrudedHeight, t.extrudedHeight), this.granularity = e(this.granularity, t.granularity), this.width = e(this.width, t.width), this.fill = e(this.fill, t.fill), this.outline = e(this.outline, t.outline), this.outlineColor = e(this.outlineColor, t.outlineColor), this.outlineWidth = e(this.outlineWidth, t.outlineWidth), this.cornerType = e(this.cornerType, t.cornerType)
        }, s
    }), define("Cesium/DataSources/createRawPropertyDescriptor", ["./createPropertyDescriptor"], function (e) {
        "use strict";
        function t(e) {
            return e
        }

        function i(i, n) {
            return e(i, n, t)
        }

        return i
    }), define("Cesium/DataSources/CylinderGraphics", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "./createMaterialPropertyDescriptor", "./createPropertyDescriptor"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = function (t) {
            this._length = void 0, this._lengthSubscription = void 0, this._topRadius = void 0, this._topRadiusSubscription = void 0, this._bottomRadius = void 0, this._bottomRadiusSubscription = void 0, this._numberOfVerticalLines = void 0, this._numberOfVerticalLinesSubscription = void 0, this._slices = void 0, this._slicesSubscription = void 0, this._show = void 0, this._showSubscription = void 0, this._material = void 0, this._materialSubscription = void 0, this._fill = void 0, this._fillSubscription = void 0, this._outline = void 0, this._outlineSubscription = void 0, this._outlineColor = void 0, this._outlineColorSubscription = void 0, this._outlineWidth = void 0, this._outlineWidthSubscription = void 0, this._definitionChanged = new r, this.merge(e(t, e.EMPTY_OBJECT))
        };
        return i(s.prototype, {
            definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            },
            length: a("length"),
            topRadius: a("topRadius"),
            bottomRadius: a("bottomRadius"),
            numberOfVerticalLines: a("numberOfVerticalLines"),
            slices: a("slices"),
            show: a("show"),
            material: o("material"),
            fill: a("fill"),
            outline: a("outline"),
            outlineColor: a("outlineColor"),
            outlineWidth: a("outlineWidth")
        }), s.prototype.clone = function (e) {
            return t(e) ? (e.bottomRadius = this.bottomRadius, e.length = this.length, e.topRadius = this.topRadius, e.show = this.show, e.material = this.material, e.numberOfVerticalLines = this.numberOfVerticalLines, e.slices = this.slices, e.fill = this.fill, e.outline = this.outline, e.outlineColor = this.outlineColor, e.outlineWidth = this.outlineWidth, e) : new s(this)
        }, s.prototype.merge = function (t) {
            this.bottomRadius = e(this.bottomRadius, t.bottomRadius), this.length = e(this.length, t.length), this.topRadius = e(this.topRadius, t.topRadius), this.show = e(this.show, t.show), this.material = e(this.material, t.material), this.numberOfVerticalLines = e(this.numberOfVerticalLines, t.numberOfVerticalLines), this.slices = e(this.slices, t.slices), this.fill = e(this.fill, t.fill), this.outline = e(this.outline, t.outline), this.outlineColor = e(this.outlineColor, t.outlineColor), this.outlineWidth = e(this.outlineWidth, t.outlineWidth)
        }, s
    }), define("Cesium/DataSources/EllipseGraphics", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "./createMaterialPropertyDescriptor", "./createPropertyDescriptor"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = function (t) {
            this._semiMajorAxis = void 0, this._semiMajorAxisSubscription = void 0, this._semiMinorAxis = void 0, this._semiMinorAxisSubscription = void 0, this._rotation = void 0, this._rotationSubscription = void 0, this._show = void 0, this._showSubscription = void 0, this._material = void 0, this._materialSubscription = void 0, this._height = void 0, this._heightSubscription = void 0, this._extrudedHeight = void 0, this._extrudedHeightSubscription = void 0, this._granularity = void 0, this._granularitySubscription = void 0, this._stRotation = void 0, this._stRotationSubscription = void 0, this._fill = void 0, this._fillSubscription = void 0, this._outline = void 0, this._outlineSubscription = void 0, this._outlineColor = void 0, this._outlineColorSubscription = void 0, this._outlineWidth = void 0, this._outlineWidthSubscription = void 0, this._numberOfVerticalLines = void 0, this._numberOfVerticalLinesSubscription = void 0, this._definitionChanged = new r, this.merge(e(t, e.EMPTY_OBJECT))
        };
        return i(s.prototype, {
            definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            },
            semiMajorAxis: a("semiMajorAxis"),
            semiMinorAxis: a("semiMinorAxis"),
            rotation: a("rotation"),
            show: a("show"),
            material: o("material"),
            height: a("height"),
            extrudedHeight: a("extrudedHeight"),
            granularity: a("granularity"),
            stRotation: a("stRotation"),
            fill: a("fill"),
            outline: a("outline"),
            outlineColor: a("outlineColor"),
            outlineWidth: a("outlineWidth"),
            numberOfVerticalLines: a("numberOfVerticalLines")
        }), s.prototype.clone = function (e) {
            return t(e) ? (e.rotation = this.rotation, e.semiMajorAxis = this.semiMajorAxis, e.semiMinorAxis = this.semiMinorAxis, e.show = this.show, e.material = this.material, e.height = this.height, e.extrudedHeight = this.extrudedHeight, e.granularity = this.granularity, e.stRotation = this.stRotation, e.fill = this.fill, e.outline = this.outline, e.outlineColor = this.outlineColor, e.outlineWidth = this.outlineWidth, e.numberOfVerticalLines = this.numberOfVerticalLines, e) : new s(this)
        }, s.prototype.merge = function (t) {
            this.rotation = e(this.rotation, t.rotation), this.semiMajorAxis = e(this.semiMajorAxis, t.semiMajorAxis), this.semiMinorAxis = e(this.semiMinorAxis, t.semiMinorAxis), this.show = e(this.show, t.show), this.material = e(this.material, t.material), this.height = e(this.height, t.height), this.extrudedHeight = e(this.extrudedHeight, t.extrudedHeight), this.granularity = e(this.granularity, t.granularity), this.stRotation = e(this.stRotation, t.stRotation), this.fill = e(this.fill, t.fill), this.outline = e(this.outline, t.outline), this.outlineColor = e(this.outlineColor, t.outlineColor), this.outlineWidth = e(this.outlineWidth, t.outlineWidth), this.numberOfVerticalLines = e(this.numberOfVerticalLines, t.numberOfVerticalLines)
        }, s
    }), define("Cesium/DataSources/EllipsoidGraphics", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "./createMaterialPropertyDescriptor", "./createPropertyDescriptor"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = function (t) {
            this._show = void 0, this._showSubscription = void 0, this._radii = void 0, this._radiiSubscription = void 0, this._material = void 0, this._materialSubscription = void 0, this._stackPartitions = void 0, this._stackPartitionsSubscription = void 0, this._slicePartitions = void 0, this._slicePartitionsSubscription = void 0, this._subdivisions = void 0, this._subdivisionsSubscription = void 0, this._fill = void 0, this._fillSubscription = void 0, this._outline = void 0, this._outlineSubscription = void 0, this._outlineColor = void 0, this._outlineColorSubscription = void 0, this._outlineWidth = void 0, this._outlineWidthSubscription = void 0, this._definitionChanged = new r, this.merge(e(t, e.EMPTY_OBJECT))
        };
        return i(s.prototype, {
            definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            },
            show: a("show"),
            radii: a("radii"),
            material: o("material"),
            fill: a("fill"),
            outline: a("outline"),
            outlineColor: a("outlineColor"),
            outlineWidth: a("outlineWidth"),
            stackPartitions: a("stackPartitions"),
            slicePartitions: a("slicePartitions"),
            subdivisions: a("subdivisions")
        }), s.prototype.clone = function (e) {
            return t(e) ? (e.show = this.show, e.radii = this.radii, e.material = this.material, e.fill = this.fill, e.outline = this.outline, e.outlineColor = this.outlineColor, e.outlineWidth = this.outlineWidth, e.stackPartitions = this.stackPartitions, e.slicePartitions = this.slicePartitions, e.subdivisions = this.subdivisions, e) : new s(this)
        }, s.prototype.merge = function (t) {
            this.show = e(this.show, t.show), this.radii = e(this.radii, t.radii), this.material = e(this.material, t.material), this.fill = e(this.fill, t.fill), this.outline = e(this.outline, t.outline), this.outlineColor = e(this.outlineColor, t.outlineColor), this.outlineWidth = e(this.outlineWidth, t.outlineWidth), this.stackPartitions = e(this.stackPartitions, t.stackPartitions), this.slicePartitions = e(this.slicePartitions, t.slicePartitions), this.subdivisions = e(this.subdivisions, t.subdivisions)
        }, s
    }), define("Cesium/DataSources/LabelGraphics", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "./createPropertyDescriptor"], function (e, t, i, n, r, o) {
        "use strict";
        var a = function (t) {
            this._text = void 0, this._textSubscription = void 0, this._font = void 0, this._fontSubscription = void 0, this._style = void 0, this._styleSubscription = void 0, this._fillColor = void 0, this._fillColorSubscription = void 0, this._outlineColor = void 0, this._outlineColorSubscription = void 0, this._outlineWidth = void 0, this._outlineWidthSubscription = void 0, this._horizontalOrigin = void 0, this._horizontalOriginSubscription = void 0, this._verticalOrigin = void 0, this._verticalOriginSubscription = void 0, this._eyeOffset = void 0, this._eyeOffsetSubscription = void 0, this._pixelOffset = void 0, this._pixelOffsetSubscription = void 0, this._scale = void 0, this._scaleSubscription = void 0, this._show = void 0, this._showSubscription = void 0, this._translucencyByDistance = void 0, this._translucencyByDistanceSubscription = void 0, this._pixelOffsetScaleByDistance = void 0, this._pixelOffsetScaleByDistanceSubscription = void 0, this._definitionChanged = new r, this.merge(e(t, e.EMPTY_OBJECT))
        };
        return i(a.prototype, {
            definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            },
            text: o("text"),
            font: o("font"),
            style: o("style"),
            fillColor: o("fillColor"),
            outlineColor: o("outlineColor"),
            outlineWidth: o("outlineWidth"),
            horizontalOrigin: o("horizontalOrigin"),
            verticalOrigin: o("verticalOrigin"),
            eyeOffset: o("eyeOffset"),
            pixelOffset: o("pixelOffset"),
            scale: o("scale"),
            show: o("show"),
            translucencyByDistance: o("translucencyByDistance"),
            pixelOffsetScaleByDistance: o("pixelOffsetScaleByDistance")
        }), a.prototype.clone = function (e) {
            return t(e) ? (e.text = this.text, e.font = this.font, e.show = this.show, e.style = this.style, e.fillColor = this.fillColor, e.outlineColor = this.outlineColor, e.outlineWidth = this.outlineWidth, e.scale = this.scale, e.horizontalOrigin = this.horizontalOrigin, e.verticalOrigin = this.verticalOrigin, e.eyeOffset = this.eyeOffset, e.pixelOffset = this.pixelOffset, e.translucencyByDistance = this.translucencyByDistance, e.pixelOffsetScaleByDistance = this.pixelOffsetScaleByDistance, e) : new a(this)
        }, a.prototype.merge = function (t) {
            this.text = e(this.text, t.text), this.font = e(this.font, t.font), this.show = e(this.show, t.show), this.style = e(this.style, t.style), this.fillColor = e(this.fillColor, t.fillColor), this.outlineColor = e(this.outlineColor, t.outlineColor), this.outlineWidth = e(this.outlineWidth, t.outlineWidth), this.scale = e(this.scale, t.scale), this.horizontalOrigin = e(this.horizontalOrigin, t.horizontalOrigin), this.verticalOrigin = e(this.verticalOrigin, t.verticalOrigin), this.eyeOffset = e(this.eyeOffset, t.eyeOffset), this.pixelOffset = e(this.pixelOffset, t.pixelOffset), this.translucencyByDistance = e(this._translucencyByDistance, t.translucencyByDistance), this.pixelOffsetScaleByDistance = e(this._pixelOffsetScaleByDistance, t.pixelOffsetScaleByDistance)
        }, a
    }), define("Cesium/DataSources/ModelGraphics", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "./createPropertyDescriptor"], function (e, t, i, n, r, o) {
        "use strict";
        var a = function (t) {
            this._show = void 0, this._showSubscription = void 0, this._scale = void 0, this._scaleSubscription = void 0, this._minimumPixelSize = void 0, this._minimumPixelSizeSubscription = void 0, this._uri = void 0, this._uriSubscription = void 0, this._definitionChanged = new r, this.merge(e(t, e.EMPTY_OBJECT))
        };
        return i(a.prototype, {
            definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            }, show: o("show"), scale: o("scale"), minimumPixelSize: o("minimumPixelSize"), uri: o("uri")
        }), a.prototype.clone = function (e) {
            return t(e) ? (e.show = this.show, e.scale = this.scale, e.minimumPixelSize = this.minimumPixelSize, e.uri = this.uri, e) : new a(this)
        }, a.prototype.merge = function (t) {
            this.show = e(this.show, t.show), this.scale = e(this.scale, t.scale), this.minimumPixelSize = e(this.minimumPixelSize, t.minimumPixelSize), this.uri = e(this.uri, t.uri)
        }, a
    }), define("Cesium/DataSources/PathGraphics", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "./createMaterialPropertyDescriptor", "./createPropertyDescriptor"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = function (t) {
            this._material = void 0, this._materialSubscription = void 0, this._show = void 0, this._showSubscription = void 0, this._width = void 0, this._widthSubscription = void 0, this._resolution = void 0, this._resolutionSubscription = void 0, this._leadTime = void 0, this._leadTimeSubscription = void 0, this._trailTime = void 0, this._trailTimeSubscription = void 0, this._definitionChanged = new r, this.merge(e(t, e.EMPTY_OBJECT))
        };
        return i(s.prototype, {
            definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            },
            show: a("show"),
            material: o("material"),
            width: a("width"),
            resolution: a("resolution"),
            leadTime: a("leadTime"),
            trailTime: a("trailTime")
        }), s.prototype.clone = function (e) {
            return t(e) ? (e.material = this.material, e.width = this.width, e.resolution = this.resolution, e.show = this.show, e.leadTime = this.leadTime, e.trailTime = this.trailTime, e) : new s(this)
        }, s.prototype.merge = function (t) {
            this.material = e(this.material, t.material), this.width = e(this.width, t.width), this.resolution = e(this.resolution, t.resolution), this.show = e(this.show, t.show), this.leadTime = e(this.leadTime, t.leadTime), this.trailTime = e(this.trailTime, t.trailTime)
        }, s
    }), define("Cesium/DataSources/PointGraphics", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "./createPropertyDescriptor"], function (e, t, i, n, r, o) {
        "use strict";
        var a = function (t) {
            this._color = void 0, this._colorSubscription = void 0, this._pixelSize = void 0, this._pixelSizeSubscription = void 0, this._outlineColor = void 0, this._outlineColorSubscription = void 0, this._outlineWidth = void 0, this._outlineWidthSubscription = void 0, this._show = void 0, this._showSubscription = void 0, this._scaleByDistance = void 0, this._scaleByDistanceSubscription = void 0, this._translucencyByDistance = void 0, this._translucencyByDistanceSubscription = void 0, this._definitionChanged = new r, this.merge(e(t, e.EMPTY_OBJECT))
        };
        return i(a.prototype, {
            definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            },
            color: o("color"),
            pixelSize: o("pixelSize"),
            outlineColor: o("outlineColor"),
            outlineWidth: o("outlineWidth"),
            show: o("show"),
            scaleByDistance: o("scaleByDistance"),
            translucencyByDistance: o("translucencyByDistance")
        }), a.prototype.clone = function (e) {
            return t(e) ? (e.color = this.color, e.pixelSize = this.pixelSize, e.outlineColor = this.outlineColor, e.outlineWidth = this.outlineWidth, e.show = this.show, e.scaleByDistance = this.scaleByDistance, e.translucencyByDistance = this._translucencyByDistance, e) : new a(this)
        }, a.prototype.merge = function (t) {
            this.color = e(this.color, t.color), this.pixelSize = e(this.pixelSize, t.pixelSize), this.outlineColor = e(this.outlineColor, t.outlineColor), this.outlineWidth = e(this.outlineWidth, t.outlineWidth), this.show = e(this.show, t.show), this.scaleByDistance = e(this.scaleByDistance, t.scaleByDistance), this.translucencyByDistance = e(this._translucencyByDistance, t.translucencyByDistance)
        }, a
    }), define("Cesium/DataSources/PolygonGraphics", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "./createMaterialPropertyDescriptor", "./createPropertyDescriptor"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = function (t) {
            this._show = void 0, this._showSubscription = void 0, this._material = void 0, this._materialSubscription = void 0, this._hierarchy = void 0, this._hierarchySubscription = void 0, this._height = void 0, this._heightSubscription = void 0, this._extrudedHeight = void 0, this._extrudedHeightSubscription = void 0, this._granularity = void 0, this._granularitySubscription = void 0, this._stRotation = void 0, this._stRotationSubscription = void 0, this._perPositionHeight = void 0, this._perPositionHeightSubscription = void 0, this._outline = void 0, this._outlineSubscription = void 0, this._outlineColor = void 0, this._outlineColorSubscription = void 0, this._outlineWidth = void 0, this._outlineWidthSubscription = void 0, this._definitionChanged = new r, this._fill = void 0, this._fillSubscription = void 0, this.merge(e(t, e.EMPTY_OBJECT))
        };
        return i(s.prototype, {
            definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            },
            show: a("show"),
            material: o("material"),
            hierarchy: a("hierarchy"),
            height: a("height"),
            extrudedHeight: a("extrudedHeight"),
            granularity: a("granularity"),
            stRotation: a("stRotation"),
            fill: a("fill"),
            outline: a("outline"),
            outlineColor: a("outlineColor"),
            outlineWidth: a("outlineWidth"),
            perPositionHeight: a("perPositionHeight")
        }), s.prototype.clone = function (e) {
            return t(e) ? (e.show = this.show, e.material = this.material, e.hierarchy = this.hierarchy, e.height = this.height, e.extrudedHeight = this.extrudedHeight, e.granularity = this.granularity, e.stRotation = this.stRotation, e.fill = this.fill, e.outline = this.outline, e.outlineColor = this.outlineColor, e.outlineWidth = this.outlineWidth, e.perPositionHeight = this.perPositionHeight, e) : new s(this)
        }, s.prototype.merge = function (t) {
            this.show = e(this.show, t.show), this.material = e(this.material, t.material), this.hierarchy = e(this.hierarchy, t.hierarchy), this.height = e(this.height, t.height), this.extrudedHeight = e(this.extrudedHeight, t.extrudedHeight), this.granularity = e(this.granularity, t.granularity), this.stRotation = e(this.stRotation, t.stRotation), this.fill = e(this.fill, t.fill), this.outline = e(this.outline, t.outline), this.outlineColor = e(this.outlineColor, t.outlineColor), this.outlineWidth = e(this.outlineWidth, t.outlineWidth), this.perPositionHeight = e(this.perPositionHeight, t.perPositionHeight)
        }, s
    }), define("Cesium/DataSources/PolylineGraphics", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "./createMaterialPropertyDescriptor", "./createPropertyDescriptor"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = function (t) {
            this._show = void 0, this._showSubscription = void 0, this._material = void 0, this._materialSubscription = void 0, this._positions = void 0, this._positionsSubscription = void 0, this._followSurface = void 0, this._followSurfaceSubscription = void 0, this._granularity = void 0, this._granularitySubscription = void 0, this._widthSubscription = void 0, this._width = void 0, this._widthSubscription = void 0, this._definitionChanged = new r, this.merge(e(t, e.EMPTY_OBJECT))
        };
        return i(s.prototype, {
            definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            },
            show: a("show"),
            material: o("material"),
            positions: a("positions"),
            width: a("width"),
            followSurface: a("followSurface"),
            granularity: a("granularity")
        }), s.prototype.clone = function (e) {
            return t(e) ? (e.show = this.show, e.material = this.material, e.positions = this.positions, e.width = this.width, e.followSurface = this.followSurface, e.granularity = this.granularity, e) : new s(this)
        }, s.prototype.merge = function (t) {
            this.show = e(this.show, t.show), this.material = e(this.material, t.material), this.positions = e(this.positions, t.positions), this.width = e(this.width, t.width), this.followSurface = e(this.followSurface, t.followSurface), this.granularity = e(this.granularity, t.granularity)
        }, s
    }), define("Cesium/DataSources/PolylineVolumeGraphics", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "./createMaterialPropertyDescriptor", "./createPropertyDescriptor"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = function (t) {
            this._show = void 0, this._showSubscription = void 0, this._material = void 0, this._materialSubscription = void 0, this._positions = void 0, this._positionsSubscription = void 0, this._shape = void 0, this._shapeSubscription = void 0, this._granularity = void 0, this._granularitySubscription = void 0, this._cornerType = void 0, this._cornerTypeSubscription = void 0, this._fill = void 0, this._fillSubscription = void 0, this._outline = void 0, this._outlineSubscription = void 0, this._outlineColor = void 0, this._outlineColorSubscription = void 0, this._outlineWidth = void 0, this._outlineWidthSubscription = void 0, this._definitionChanged = new r, this.merge(e(t, e.EMPTY_OBJECT))
        };
        return i(s.prototype, {
            definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            },
            show: a("show"),
            material: o("material"),
            positions: a("positions"),
            shape: a("shape"),
            granularity: a("granularity"),
            fill: a("fill"),
            outline: a("outline"),
            outlineColor: a("outlineColor"),
            outlineWidth: a("outlineWidth"),
            cornerType: a("cornerType")
        }), s.prototype.clone = function (e) {
            return t(e) ? (e.show = this.show, e.material = this.material, e.positions = this.positions, e.shape = this.shape, e.granularity = this.granularity, e.fill = this.fill, e.outline = this.outline, e.outlineColor = this.outlineColor, e.outlineWidth = this.outlineWidth, e.cornerType = this.cornerType, e) : new s(this)
        }, s.prototype.merge = function (t) {
            this.show = e(this.show, t.show), this.material = e(this.material, t.material), this.positions = e(this.positions, t.positions), this.shape = e(this.shape, t.shape), this.granularity = e(this.granularity, t.granularity), this.fill = e(this.fill, t.fill), this.outline = e(this.outline, t.outline), this.outlineColor = e(this.outlineColor, t.outlineColor), this.outlineWidth = e(this.outlineWidth, t.outlineWidth), this.cornerType = e(this.cornerType, t.cornerType)
        }, s
    }), define("Cesium/DataSources/RectangleGraphics", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "./createMaterialPropertyDescriptor", "./createPropertyDescriptor"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = function (t) {
            this._show = void 0, this._showSubscription = void 0, this._material = void 0, this._materialSubscription = void 0, this._coordinates = void 0, this._coordinatesSubscription = void 0, this._height = void 0, this._heightSubscription = void 0, this._extrudedHeight = void 0, this._extrudedHeightSubscription = void 0, this._granularity = void 0, this._granularitySubscription = void 0, this._stRotation = void 0, this._stRotationSubscription = void 0, this._rotation = void 0, this._rotationSubscription = void 0, this._closeTop = void 0, this._closeTopSubscription = void 0, this._closeBottom = void 0, this._closeBottomSubscription = void 0, this._fill = void 0, this._fillSubscription = void 0, this._outline = void 0, this._outlineSubscription = void 0, this._outlineColor = void 0, this._outlineColorSubscription = void 0, this._outlineWidth = void 0, this._outlineWidthSubscription = void 0, this._definitionChanged = new r, this.merge(e(t, e.EMPTY_OBJECT))
        };
        return i(s.prototype, {
            definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            },
            show: a("show"),
            coordinates: a("coordinates"),
            material: o("material"),
            height: a("height"),
            extrudedHeight: a("extrudedHeight"),
            granularity: a("granularity"),
            stRotation: a("stRotation"),
            rotation: a("rotation"),
            fill: a("fill"),
            outline: a("outline"),
            outlineColor: a("outlineColor"),
            outlineWidth: a("outlineWidth"),
            closeTop: a("closeTop"),
            closeBottom: a("closeBottom")
        }), s.prototype.clone = function (e) {
            return t(e) ? (e.show = this.show, e.coordinates = this.coordinates, e.material = this.material, e.height = this.height, e.extrudedHeight = this.extrudedHeight, e.granularity = this.granularity, e.stRotation = this.stRotation, e.rotation = this.rotation, e.fill = this.fill, e.outline = this.outline, e.outlineColor = this.outlineColor, e.outlineWidth = this.outlineWidth, e.closeTop = this.closeTop, e.closeBottom = this.closeBottom, e) : new s(this)
        }, s.prototype.merge = function (t) {
            this.show = e(this.show, t.show), this.coordinates = e(this.coordinates, t.coordinates), this.material = e(this.material, t.material), this.height = e(this.height, t.height), this.extrudedHeight = e(this.extrudedHeight, t.extrudedHeight), this.granularity = e(this.granularity, t.granularity), this.stRotation = e(this.stRotation, t.stRotation), this.rotation = e(this.rotation, t.rotation), this.fill = e(this.fill, t.fill), this.outline = e(this.outline, t.outline), this.outlineColor = e(this.outlineColor, t.outlineColor), this.outlineWidth = e(this.outlineWidth, t.outlineWidth), this.closeTop = e(this.closeTop, t.closeTop), this.closeBottom = e(this.closeBottom, t.closeBottom)
        }, s
    }), define("Cesium/DataSources/WallGraphics", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "./createMaterialPropertyDescriptor", "./createPropertyDescriptor"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = function (t) {
            this._show = void 0, this._showSubscription = void 0, this._material = void 0, this._materialSubscription = void 0, this._positions = void 0, this._positionsSubscription = void 0, this._minimumHeights = void 0, this._minimumHeightsSubscription = void 0, this._maximumHeights = void 0, this._maximumHeightsSubscription = void 0, this._granularity = void 0, this._granularitySubscription = void 0, this._fill = void 0, this._fillSubscription = void 0, this._outline = void 0, this._outlineSubscription = void 0, this._outlineColor = void 0, this._outlineColorSubscription = void 0, this._outlineWidth = void 0, this._outlineWidthSubscription = void 0, this._definitionChanged = new r, this.merge(e(t, e.EMPTY_OBJECT))
        };
        return i(s.prototype, {
            definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            },
            show: a("show"),
            material: o("material"),
            positions: a("positions"),
            minimumHeights: a("minimumHeights"),
            maximumHeights: a("maximumHeights"),
            granularity: a("granularity"),
            fill: a("fill"),
            outline: a("outline"),
            outlineColor: a("outlineColor"),
            outlineWidth: a("outlineWidth")
        }), s.prototype.clone = function (e) {
            return t(e) ? (e.show = this.show, e.material = this.material, e.positions = this.positions, e.minimumHeights = this.minimumHeights, e.maximumHeights = this.maximumHeights, e.granularity = this.granularity, e.fill = this.fill, e.outline = this.outline, e.outlineColor = this.outlineColor, e.outlineWidth = this.outlineWidth, e) : new s(this)
        }, s.prototype.merge = function (t) {
            this.show = e(this.show, t.show), this.material = e(this.material, t.material), this.positions = e(this.positions, t.positions), this.minimumHeights = e(this.minimumHeights, t.minimumHeights), this.maximumHeights = e(this.maximumHeights, t.maximumHeights), this.granularity = e(this.granularity, t.granularity), this.fill = e(this.fill, t.fill), this.outline = e(this.outline, t.outline), this.outlineColor = e(this.outlineColor, t.outlineColor), this.outlineWidth = e(this.outlineWidth, t.outlineWidth)
        }, s
    }), define("Cesium/DataSources/Entity", ["../Core/Cartesian3", "../Core/createGuid", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "../Core/Matrix3", "../Core/Matrix4", "../Core/Quaternion", "../Core/Transforms", "./BillboardGraphics", "./BoxGraphics", "./ConstantPositionProperty", "./CorridorGraphics", "./createPropertyDescriptor", "./createRawPropertyDescriptor", "./CylinderGraphics", "./EllipseGraphics", "./EllipsoidGraphics", "./LabelGraphics", "./ModelGraphics", "./PathGraphics", "./PointGraphics", "./PolygonGraphics", "./PolylineGraphics", "./PolylineVolumeGraphics", "./Property", "./RectangleGraphics", "./WallGraphics"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S, T, b, w, x, A, P, I) {
        "use strict";
        function D(e) {
            return new m(e)
        }

        function M(e) {
            return f(e, void 0, D)
        }

        function O(e, t) {
            return f(e, void 0, function (e) {
                return e instanceof t ? e : new t(e)
            })
        }

        function R(e, t, i) {
            for (var n = t.length, r = 0; n > r; r++) {
                var o = t[r], a = o._show, s = !i && a, u = i && a;
                s !== u && R(o, o._children, i)
            }
            e._definitionChanged.raiseEvent(e, "isShowing", i, !i)
        }

        var N = function (e) {
            e = i(e, i.EMPTY_OBJECT);
            var r = e.id;
            n(r) || (r = t()), this._availability = void 0, this._id = r, this._definitionChanged = new a, this._name = e.name, this._show = i(e.show, !0), this._parent = void 0, this._propertyNames = ["billboard", "box", "corridor", "cylinder", "description", "ellipse", "ellipsoid", "label", "model", "orientation", "path", "point", "polygon", "polyline", "polylineVolume", "position", "rectangle", "viewFrom", "wall"], this._billboard = void 0, this._billboardSubscription = void 0, this._box = void 0, this._boxSubscription = void 0, this._corridor = void 0, this._corridorSubscription = void 0, this._cylinder = void 0, this._cylinderSubscription = void 0, this._description = void 0, this._descriptionSubscription = void 0, this._ellipse = void 0, this._ellipseSubscription = void 0, this._ellipsoid = void 0, this._ellipsoidSubscription = void 0, this._label = void 0, this._labelSubscription = void 0, this._model = void 0, this._modelSubscription = void 0, this._orientation = void 0, this._orientationSubscription = void 0, this._path = void 0, this._pathSubscription = void 0, this._point = void 0, this._pointSubscription = void 0, this._polygon = void 0, this._polygonSubscription = void 0, this._polyline = void 0, this._polylineSubscription = void 0, this._polylineVolume = void 0, this._polylineVolumeSubscription = void 0, this._position = void 0, this._positionSubscription = void 0, this._rectangle = void 0, this._rectangleSubscription = void 0, this._viewFrom = void 0, this._viewFromSubscription = void 0, this._wall = void 0, this._wallSubscription = void 0, this._children = [], this.parent = e.parent, this.merge(e)
        };
        r(N.prototype, {
            availability: _("availability"),
            id: {
                get: function () {
                    return this._id
                }
            },
            definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            },
            name: _("name"),
            show: {
                get: function () {
                    return this._show
                }, set: function (e) {
                    if (e !== this._show) {
                        var t = this.isShowing;
                        this._show = e;
                        var i = this.isShowing;
                        t !== i && R(this, this._children, i), this._definitionChanged.raiseEvent(this, "show", e, !e)
                    }
                }
            },
            isShowing: {
                get: function () {
                    return this._show && (!n(this._parent) || this._parent.isShowing)
                }
            },
            parent: {
                get: function () {
                    return this._parent
                }, set: function (e) {
                    var t = this._parent;
                    if (t !== e) {
                        var i = this.isShowing;
                        if (n(t)) {
                            var r = t._children.indexOf(this);
                            t._children.splice(r, 1)
                        }
                        this._parent = e, e._children.push(this);
                        var o = this.isShowing;
                        i !== o && R(this, this._children, o), this._definitionChanged.raiseEvent(this, "parent", e, t)
                    }
                }
            },
            propertyNames: {
                get: function () {
                    return this._propertyNames
                }
            },
            billboard: O("billboard", h),
            box: O("box", d),
            corridor: O("corridor", p),
            cylinder: O("cylinder", v),
            description: f("description"),
            ellipse: O("ellipse", g),
            ellipsoid: O("ellipsoid", y),
            label: O("label", C),
            model: O("model", E),
            orientation: f("orientation"),
            path: O("path", S),
            point: O("point", T),
            polygon: O("polygon", b),
            polyline: O("polyline", w),
            polylineVolume: O("polylineVolume", x),
            position: M("position"),
            rectangle: O("rectangle", P),
            viewFrom: f("viewFrom"),
            wall: O("wall", I)
        }), N.prototype.isAvailable = function (e) {
            var t = this._availability;
            return !n(t) || t.contains(e)
        }, N.prototype.addProperty = function (e) {
            var t = this._propertyNames;
            t.push(e), Object.defineProperty(this, e, _(e, !0))
        }, N.prototype.removeProperty = function (e) {
            this._propertyNames;
            this._propertyNames.push(e), delete this[e]
        }, N.prototype.merge = function (e) {
            this.name = i(this.name, e.name), this.availability = i(e.availability, this.availability);
            for (var t = this._propertyNames, r = n(e._propertyNames) ? e._propertyNames : Object.keys(e), o = r.length, a = 0; o > a; a++) {
                var s = r[a];
                if ("parent" !== s) {
                    var u = this[s], l = e[s];
                    n(u) || -1 !== t.indexOf(s) || this.addProperty(s), n(l) && (n(u) ? n(u.merge) && u.merge(l) : n(l.merge) && n(l.clone) ? this[s] = l.clone() : this[s] = l)
                }
            }
        };
        var L = new s, F = new e, B = new l;
        return N.prototype._getModelMatrix = function (e, t) {
            var i = A.getValueOrUndefined(this._position, e, F);
            if (!n(i))return void 0;
            var r = A.getValueOrUndefined(this._orientation, e, B);
            return t = n(r) ? u.fromRotationTranslation(s.fromQuaternion(r, L), i, t) : c.eastNorthUpToFixedFrame(i, void 0, t)
        }, N
    }), define("Cesium/Core/appendForwardSlash", [], function () {
        "use strict";
        var e = function (e) {
            return (0 === e.length || "/" !== e[e.length - 1]) && (e += "/"), e
        };
        return e
    }), define("Cesium/Core/destroyObject", ["./defaultValue", "./DeveloperError"], function (e, t) {
        "use strict";
        function i() {
            return !0
        }

        var n = function (n, r) {
            function o() {
                throw new t(r)
            }

            r = e(r, "This object was destroyed, i.e., destroy() was called.");
            for (var a in n)"function" == typeof n[a] && (n[a] = o);
            return void(n.isDestroyed = i)
        };
        return n
    }), define("Cesium/Renderer/WebGLConstants", ["../Core/freezeObject"], function (e) {
        "use strict";
        var t = {
            DEPTH_BUFFER_BIT: 256,
            STENCIL_BUFFER_BIT: 1024,
            COLOR_BUFFER_BIT: 16384,
            POINTS: 0,
            LINES: 1,
            LINE_LOOP: 2,
            LINE_STRIP: 3,
            TRIANGLES: 4,
            TRIANGLE_STRIP: 5,
            TRIANGLE_FAN: 6,
            ZERO: 0,
            ONE: 1,
            SRC_COLOR: 768,
            ONE_MINUS_SRC_COLOR: 769,
            SRC_ALPHA: 770,
            ONE_MINUS_SRC_ALPHA: 771,
            DST_ALPHA: 772,
            ONE_MINUS_DST_ALPHA: 773,
            DST_COLOR: 774,
            ONE_MINUS_DST_COLOR: 775,
            SRC_ALPHA_SATURATE: 776,
            FUNC_ADD: 32774,
            BLEND_EQUATION: 32777,
            BLEND_EQUATION_RGB: 32777,
            BLEND_EQUATION_ALPHA: 34877,
            FUNC_SUBTRACT: 32778,
            FUNC_REVERSE_SUBTRACT: 32779,
            BLEND_DST_RGB: 32968,
            BLEND_SRC_RGB: 32969,
            BLEND_DST_ALPHA: 32970,
            BLEND_SRC_ALPHA: 32971,
            CONSTANT_COLOR: 32769,
            ONE_MINUS_CONSTANT_COLOR: 32770,
            CONSTANT_ALPHA: 32771,
            ONE_MINUS_CONSTANT_ALPHA: 32772,
            BLEND_COLOR: 32773,
            ARRAY_BUFFER: 34962,
            ELEMENT_ARRAY_BUFFER: 34963,
            ARRAY_BUFFER_BINDING: 34964,
            ELEMENT_ARRAY_BUFFER_BINDING: 34965,
            STREAM_DRAW: 35040,
            STATIC_DRAW: 35044,
            DYNAMIC_DRAW: 35048,
            BUFFER_SIZE: 34660,
            BUFFER_USAGE: 34661,
            CURRENT_VERTEX_ATTRIB: 34342,
            FRONT: 1028,
            BACK: 1029,
            FRONT_AND_BACK: 1032,
            CULL_FACE: 2884,
            BLEND: 3042,
            DITHER: 3024,
            STENCIL_TEST: 2960,
            DEPTH_TEST: 2929,
            SCISSOR_TEST: 3089,
            POLYGON_OFFSET_FILL: 32823,
            SAMPLE_ALPHA_TO_COVERAGE: 32926,
            SAMPLE_COVERAGE: 32928,
            NO_ERROR: 0,
            INVALID_ENUM: 1280,
            INVALID_VALUE: 1281,
            INVALID_OPERATION: 1282,
            OUT_OF_MEMORY: 1285,
            CW: 2304,
            CCW: 2305,
            LINE_WIDTH: 2849,
            ALIASED_POINT_SIZE_RANGE: 33901,
            ALIASED_LINE_WIDTH_RANGE: 33902,
            CULL_FACE_MODE: 2885,
            FRONT_FACE: 2886,
            DEPTH_RANGE: 2928,
            DEPTH_WRITEMASK: 2930,
            DEPTH_CLEAR_VALUE: 2931,
            DEPTH_FUNC: 2932,
            STENCIL_CLEAR_VALUE: 2961,
            STENCIL_FUNC: 2962,
            STENCIL_FAIL: 2964,
            STENCIL_PASS_DEPTH_FAIL: 2965,
            STENCIL_PASS_DEPTH_PASS: 2966,
            STENCIL_REF: 2967,
            STENCIL_VALUE_MASK: 2963,
            STENCIL_WRITEMASK: 2968,
            STENCIL_BACK_FUNC: 34816,
            STENCIL_BACK_FAIL: 34817,
            STENCIL_BACK_PASS_DEPTH_FAIL: 34818,
            STENCIL_BACK_PASS_DEPTH_PASS: 34819,
            STENCIL_BACK_REF: 36003,
            STENCIL_BACK_VALUE_MASK: 36004,
            STENCIL_BACK_WRITEMASK: 36005,
            VIEWPORT: 2978,
            SCISSOR_BOX: 3088,
            COLOR_CLEAR_VALUE: 3106,
            COLOR_WRITEMASK: 3107,
            UNPACK_ALIGNMENT: 3317,
            PACK_ALIGNMENT: 3333,
            MAX_TEXTURE_SIZE: 3379,
            MAX_VIEWPORT_DIMS: 3386,
            SUBPIXEL_BITS: 3408,
            RED_BITS: 3410,
            GREEN_BITS: 3411,
            BLUE_BITS: 3412,
            ALPHA_BITS: 3413,
            DEPTH_BITS: 3414,
            STENCIL_BITS: 3415,
            POLYGON_OFFSET_UNITS: 10752,
            POLYGON_OFFSET_FACTOR: 32824,
            TEXTURE_BINDING_2D: 32873,
            SAMPLE_BUFFERS: 32936,
            SAMPLES: 32937,
            SAMPLE_COVERAGE_VALUE: 32938,
            SAMPLE_COVERAGE_INVERT: 32939,
            COMPRESSED_TEXTURE_FORMATS: 34467,
            DONT_CARE: 4352,
            FASTEST: 4353,
            NICEST: 4354,
            GENERATE_MIPMAP_HINT: 33170,
            BYTE: 5120,
            UNSIGNED_BYTE: 5121,
            SHORT: 5122,
            UNSIGNED_SHORT: 5123,
            INT: 5124,
            UNSIGNED_INT: 5125,
            FLOAT: 5126,
            DEPTH_COMPONENT: 6402,
            ALPHA: 6406,
            RGB: 6407,
            RGBA: 6408,
            LUMINANCE: 6409,
            LUMINANCE_ALPHA: 6410,
            UNSIGNED_SHORT_4_4_4_4: 32819,
            UNSIGNED_SHORT_5_5_5_1: 32820,
            UNSIGNED_SHORT_5_6_5: 33635,
            FRAGMENT_SHADER: 35632,
            VERTEX_SHADER: 35633,
            MAX_VERTEX_ATTRIBS: 34921,
            MAX_VERTEX_UNIFORM_VECTORS: 36347,
            MAX_VARYING_VECTORS: 36348,
            MAX_COMBINED_TEXTURE_IMAGE_UNITS: 35661,
            MAX_VERTEX_TEXTURE_IMAGE_UNITS: 35660,
            MAX_TEXTURE_IMAGE_UNITS: 34930,
            MAX_FRAGMENT_UNIFORM_VECTORS: 36349,
            SHADER_TYPE: 35663,
            DELETE_STATUS: 35712,
            LINK_STATUS: 35714,
            VALIDATE_STATUS: 35715,
            ATTACHED_SHADERS: 35717,
            ACTIVE_UNIFORMS: 35718,
            ACTIVE_ATTRIBUTES: 35721,
            SHADING_LANGUAGE_VERSION: 35724,
            CURRENT_PROGRAM: 35725,
            NEVER: 512,
            LESS: 513,
            EQUAL: 514,
            LEQUAL: 515,
            GREATER: 516,
            NOTEQUAL: 517,
            GEQUAL: 518,
            ALWAYS: 519,
            KEEP: 7680,
            REPLACE: 7681,
            INCR: 7682,
            DECR: 7683,
            INVERT: 5386,
            INCR_WRAP: 34055,
            DECR_WRAP: 34056,
            VENDOR: 7936,
            RENDERER: 7937,
            VERSION: 7938,
            NEAREST: 9728,
            LINEAR: 9729,
            NEAREST_MIPMAP_NEAREST: 9984,
            LINEAR_MIPMAP_NEAREST: 9985,
            NEAREST_MIPMAP_LINEAR: 9986,
            LINEAR_MIPMAP_LINEAR: 9987,
            TEXTURE_MAG_FILTER: 10240,
            TEXTURE_MIN_FILTER: 10241,
            TEXTURE_WRAP_S: 10242,
            TEXTURE_WRAP_T: 10243,
            TEXTURE_2D: 3553,
            TEXTURE: 5890,
            TEXTURE_CUBE_MAP: 34067,
            TEXTURE_BINDING_CUBE_MAP: 34068,
            TEXTURE_CUBE_MAP_POSITIVE_X: 34069,
            TEXTURE_CUBE_MAP_NEGATIVE_X: 34070,
            TEXTURE_CUBE_MAP_POSITIVE_Y: 34071,
            TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072,
            TEXTURE_CUBE_MAP_POSITIVE_Z: 34073,
            TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074,
            MAX_CUBE_MAP_TEXTURE_SIZE: 34076,
            TEXTURE0: 33984,
            TEXTURE1: 33985,
            TEXTURE2: 33986,
            TEXTURE3: 33987,
            TEXTURE4: 33988,
            TEXTURE5: 33989,
            TEXTURE6: 33990,
            TEXTURE7: 33991,
            TEXTURE8: 33992,
            TEXTURE9: 33993,
            TEXTURE10: 33994,
            TEXTURE11: 33995,
            TEXTURE12: 33996,
            TEXTURE13: 33997,
            TEXTURE14: 33998,
            TEXTURE15: 33999,
            TEXTURE16: 34e3,
            TEXTURE17: 34001,
            TEXTURE18: 34002,
            TEXTURE19: 34003,
            TEXTURE20: 34004,
            TEXTURE21: 34005,
            TEXTURE22: 34006,
            TEXTURE23: 34007,
            TEXTURE24: 34008,
            TEXTURE25: 34009,
            TEXTURE26: 34010,
            TEXTURE27: 34011,
            TEXTURE28: 34012,
            TEXTURE29: 34013,
            TEXTURE30: 34014,
            TEXTURE31: 34015,
            ACTIVE_TEXTURE: 34016,
            REPEAT: 10497,
            CLAMP_TO_EDGE: 33071,
            MIRRORED_REPEAT: 33648,
            FLOAT_VEC2: 35664,
            FLOAT_VEC3: 35665,
            FLOAT_VEC4: 35666,
            INT_VEC2: 35667,
            INT_VEC3: 35668,
            INT_VEC4: 35669,
            BOOL: 35670,
            BOOL_VEC2: 35671,
            BOOL_VEC3: 35672,
            BOOL_VEC4: 35673,
            FLOAT_MAT2: 35674,
            FLOAT_MAT3: 35675,
            FLOAT_MAT4: 35676,
            SAMPLER_2D: 35678,
            SAMPLER_CUBE: 35680,
            VERTEX_ATTRIB_ARRAY_ENABLED: 34338,
            VERTEX_ATTRIB_ARRAY_SIZE: 34339,
            VERTEX_ATTRIB_ARRAY_STRIDE: 34340,
            VERTEX_ATTRIB_ARRAY_TYPE: 34341,
            VERTEX_ATTRIB_ARRAY_NORMALIZED: 34922,
            VERTEX_ATTRIB_ARRAY_POINTER: 34373,
            VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 34975,
            IMPLEMENTATION_COLOR_READ_TYPE: 35738,
            IMPLEMENTATION_COLOR_READ_FORMAT: 35739,
            COMPILE_STATUS: 35713,
            LOW_FLOAT: 36336,
            MEDIUM_FLOAT: 36337,
            HIGH_FLOAT: 36338,
            LOW_INT: 36339,
            MEDIUM_INT: 36340,
            HIGH_INT: 36341,
            FRAMEBUFFER: 36160,
            RENDERBUFFER: 36161,
            RGBA4: 32854,
            RGB5_A1: 32855,
            RGB565: 36194,
            DEPTH_COMPONENT16: 33189,
            STENCIL_INDEX: 6401,
            STENCIL_INDEX8: 36168,
            DEPTH_STENCIL: 34041,
            RENDERBUFFER_WIDTH: 36162,
            RENDERBUFFER_HEIGHT: 36163,
            RENDERBUFFER_INTERNAL_FORMAT: 36164,
            RENDERBUFFER_RED_SIZE: 36176,
            RENDERBUFFER_GREEN_SIZE: 36177,
            RENDERBUFFER_BLUE_SIZE: 36178,
            RENDERBUFFER_ALPHA_SIZE: 36179,
            RENDERBUFFER_DEPTH_SIZE: 36180,
            RENDERBUFFER_STENCIL_SIZE: 36181,
            FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 36048,
            FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 36049,
            FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 36050,
            FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 36051,
            COLOR_ATTACHMENT0: 36064,
            DEPTH_ATTACHMENT: 36096,
            STENCIL_ATTACHMENT: 36128,
            DEPTH_STENCIL_ATTACHMENT: 33306,
            NONE: 0,
            FRAMEBUFFER_COMPLETE: 36053,
            FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 36054,
            FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 36055,
            FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 36057,
            FRAMEBUFFER_UNSUPPORTED: 36061,
            FRAMEBUFFER_BINDING: 36006,
            RENDERBUFFER_BINDING: 36007,
            MAX_RENDERBUFFER_SIZE: 34024,
            INVALID_FRAMEBUFFER_OPERATION: 1286,
            UNPACK_FLIP_Y_WEBGL: 37440,
            UNPACK_PREMULTIPLY_ALPHA_WEBGL: 37441,
            CONTEXT_LOST_WEBGL: 37442,
            UNPACK_COLORSPACE_CONVERSION_WEBGL: 37443,
            BROWSER_DEFAULT_WEBGL: 37444,
            UNSIGNED_INT_24_8_WEBGL: 34042,
            DOUBLE: 5130
        };
        return e(t)
    }), define("Cesium/Core/ComponentDatatype", ["../Renderer/WebGLConstants", "./defaultValue", "./defined", "./DeveloperError", "./FeatureDetection", "./freezeObject"], function (e, t, i, n, r, o) {
        "use strict";
        if (!r.supportsTypedArrays())return {};
        var a = {
            BYTE: e.BYTE,
            UNSIGNED_BYTE: e.UNSIGNED_BYTE,
            SHORT: e.SHORT,
            UNSIGNED_SHORT: e.UNSIGNED_SHORT,
            FLOAT: e.FLOAT,
            DOUBLE: e.DOUBLE
        };
        return a.getSizeInBytes = function (e) {
            switch (e) {
                case a.BYTE:
                    return Int8Array.BYTES_PER_ELEMENT;
                case a.UNSIGNED_BYTE:
                    return Uint8Array.BYTES_PER_ELEMENT;
                case a.SHORT:
                    return Int16Array.BYTES_PER_ELEMENT;
                case a.UNSIGNED_SHORT:
                    return Uint16Array.BYTES_PER_ELEMENT;
                case a.FLOAT:
                    return Float32Array.BYTES_PER_ELEMENT;
                case a.DOUBLE:
                    return Float64Array.BYTES_PER_ELEMENT;
                default:
                    throw new n("componentDatatype is not a valid value.")
            }
        }, a.fromTypedArray = function (e) {
            return e instanceof Int8Array ? a.BYTE : e instanceof Uint8Array ? a.UNSIGNED_BYTE : e instanceof Int16Array ? a.SHORT : e instanceof Uint16Array ? a.UNSIGNED_SHORT : e instanceof Float32Array ? a.FLOAT : e instanceof Float64Array ? a.DOUBLE : void 0
        }, a.validate = function (e) {
            return i(e) && (e === a.BYTE || e === a.UNSIGNED_BYTE || e === a.SHORT || e === a.UNSIGNED_SHORT || e === a.FLOAT || e === a.DOUBLE)
        }, a.createTypedArray = function (e, t) {
            switch (e) {
                case a.BYTE:
                    return new Int8Array(t);
                case a.UNSIGNED_BYTE:
                    return new Uint8Array(t);
                case a.SHORT:
                    return new Int16Array(t);
                case a.UNSIGNED_SHORT:
                    return new Uint16Array(t);
                case a.FLOAT:
                    return new Float32Array(t);
                case a.DOUBLE:
                    return new Float64Array(t);
                default:
                    throw new n("componentDatatype is not a valid value.")
            }
        }, a.createArrayBufferView = function (e, i, r, o) {
            switch (r = t(r, 0), o = t(o, (i.byteLength - r) / a.getSizeInBytes(e)), e) {
                case a.BYTE:
                    return new Int8Array(i, r, o);
                case a.UNSIGNED_BYTE:
                    return new Uint8Array(i, r, o);
                case a.SHORT:
                    return new Int16Array(i, r, o);
                case a.UNSIGNED_SHORT:
                    return new Uint16Array(i, r, o);
                case a.FLOAT:
                    return new Float32Array(i, r, o);
                case a.DOUBLE:
                    return new Float64Array(i, r, o);
                default:
                    throw new n("componentDatatype is not a valid value.")
            }
        }, o(a)
    }), define("Cesium/Core/GeometryType", ["./freezeObject"], function (e) {
        "use strict";
        var t = {NONE: 0, TRIANGLES: 1, LINES: 2, POLYLINES: 3};
        return e(t)
    }), define("Cesium/Core/PrimitiveType", ["../Renderer/WebGLConstants", "./freezeObject"], function (e, t) {
        "use strict";
        var i = {
            POINTS: e.POINTS,
            LINES: e.LINES,
            LINE_LOOP: e.LINE_LOOP,
            LINE_STRIP: e.LINE_STRIP,
            TRIANGLES: e.TRIANGLES,
            TRIANGLE_STRIP: e.TRIANGLE_STRIP,
            TRIANGLE_FAN: e.TRIANGLE_FAN,
            validate: function (e) {
                return e === i.POINTS || e === i.LINES || e === i.LINE_LOOP || e === i.LINE_STRIP || e === i.TRIANGLES || e === i.TRIANGLE_STRIP || e === i.TRIANGLE_FAN
            }
        };
        return t(i)
    }), define("Cesium/Core/Geometry", ["./defaultValue", "./defined", "./DeveloperError", "./GeometryType", "./PrimitiveType"], function (e, t, i, n, r) {
        "use strict";
        var o = function (t) {
            t = e(t, e.EMPTY_OBJECT), this.attributes = t.attributes, this.indices = t.indices, this.primitiveType = e(t.primitiveType, r.TRIANGLES), this.boundingSphere = t.boundingSphere, this.geometryType = e(t.geometryType, n.NONE), this.boundingSphereCV = void 0
        };
        return o.computeNumberOfVertices = function (e) {
            var n = -1;
            for (var r in e.attributes)if (e.attributes.hasOwnProperty(r) && t(e.attributes[r]) && t(e.attributes[r].values)) {
                var o = e.attributes[r], a = o.values.length / o.componentsPerAttribute;
                if (n !== a && -1 !== n)throw new i("All attribute lists must have the same number of attributes.");
                n = a
            }
            return n
        }, o
    }), define("Cesium/Core/GeometryAttribute", ["./defaultValue", "./defined", "./DeveloperError"], function (e, t, i) {
        "use strict";
        var n = function (t) {
            t = e(t, e.EMPTY_OBJECT), this.componentDatatype = t.componentDatatype, this.componentsPerAttribute = t.componentsPerAttribute, this.normalize = e(t.normalize, !1), this.values = t.values
        };
        return n
    }), define("Cesium/Core/GeometryAttributes", ["./defaultValue"], function (e) {
        "use strict";
        var t = function (t) {
            t = e(t, e.EMPTY_OBJECT), this.position = t.position, this.normal = t.normal, this.st = t.st, this.binormal = t.binormal, this.tangent = t.tangent, this.color = t.color
        };
        return t
    }), define("Cesium/Core/IndexDatatype", ["../Renderer/WebGLConstants", "./defined", "./DeveloperError", "./freezeObject", "./Math"], function (e, t, i, n, r) {
        "use strict";
        var o = {UNSIGNED_BYTE: e.UNSIGNED_BYTE, UNSIGNED_SHORT: e.UNSIGNED_SHORT, UNSIGNED_INT: e.UNSIGNED_INT};
        return o.getSizeInBytes = function (e) {
            switch (e) {
                case o.UNSIGNED_BYTE:
                    return Uint8Array.BYTES_PER_ELEMENT;
                case o.UNSIGNED_SHORT:
                    return Uint16Array.BYTES_PER_ELEMENT;
                case o.UNSIGNED_INT:
                    return Uint32Array.BYTES_PER_ELEMENT
            }
        }, o.validate = function (e) {
            return t(e) && (e === o.UNSIGNED_BYTE || e === o.UNSIGNED_SHORT || e === o.UNSIGNED_INT)
        }, o.createTypedArray = function (e, t) {
            return e > r.SIXTY_FOUR_KILOBYTES ? new Uint32Array(t) : new Uint16Array(t)
        }, o.createTypedArrayFromArrayBuffer = function (e, t, i, n) {
            return e > r.SIXTY_FOUR_KILOBYTES ? new Uint32Array(t, i, n) : new Uint16Array(t, i, n)
        }, n(o)
    }), define("Cesium/Core/AxisAlignedBoundingBox", ["./Cartesian3", "./defaultValue", "./defined", "./deprecationWarning", "./DeveloperError", "./Intersect", "./Plane"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = function (n, r, o) {
            this.minimum = e.clone(t(n, e.ZERO)), this.maximum = e.clone(t(r, e.ZERO)), i(o) ? o = e.clone(o) : (o = e.add(this.minimum, this.maximum, new e), e.multiplyByScalar(o, .5, o)), this.center = o
        };
        s.fromPoints = function (t, n) {
            if (i(n) || (n = new s), !i(t) || 0 === t.length)return n.minimum = e.clone(e.ZERO, n.minimum), n.maximum = e.clone(e.ZERO, n.maximum), n.center = e.clone(e.ZERO, n.center), n;
            for (var r = t[0].x, o = t[0].y, a = t[0].z, u = t[0].x, l = t[0].y, c = t[0].z, h = t.length, d = 1; h > d; d++) {
                var m = t[d], p = m.x, f = m.y, _ = m.z;
                r = Math.min(p, r), u = Math.max(p, u), o = Math.min(f, o), l = Math.max(f, l), a = Math.min(_, a), c = Math.max(_, c)
            }
            var v = n.minimum;
            v.x = r, v.y = o, v.z = a;
            var g = n.maximum;
            g.x = u, g.y = l, g.z = c;
            var y = e.add(v, g, n.center);
            return e.multiplyByScalar(y, .5, y), n
        }, s.clone = function (t, n) {
            return i(t) ? i(n) ? (n.minimum = e.clone(t.minimum, n.minimum), n.maximum = e.clone(t.maximum, n.maximum), n.center = e.clone(t.center, n.center), n) : new s(t.minimum, t.maximum) : void 0
        }, s.equals = function (t, n) {
            return t === n || i(t) && i(n) && e.equals(t.center, n.center) && e.equals(t.minimum, n.minimum) && e.equals(t.maximum, n.maximum)
        };
        var u = new e;
        return s.intersectPlane = function (t, i) {
            u = e.subtract(t.maximum, t.minimum, u);
            var n = e.multiplyByScalar(u, .5, u), r = i.normal, a = n.x * Math.abs(r.x) + n.y * Math.abs(r.y) + n.z * Math.abs(r.z), s = e.dot(t.center, r) + i.distance;
            return s - a > 0 ? o.INSIDE : 0 > s + a ? o.OUTSIDE : o.INTERSECTING
        }, s.prototype.clone = function (e) {
            return s.clone(this, e)
        }, s.prototype.intersectPlane = function (e) {
            return s.intersectPlane(this, e)
        }, s.prototype.equals = function (e) {
            return s.equals(this, e)
        }, s
    }), define("Cesium/Core/QuadraticRealPolynomial", ["./DeveloperError", "./Math"], function (e, t) {
        "use strict";
        function i(e, i, n) {
            var r = e + i;
            return t.sign(e) !== t.sign(i) && Math.abs(r / Math.max(Math.abs(e), Math.abs(i))) < n ? 0 : r
        }

        var n = {};
        return n.computeDiscriminant = function (e, t, i) {
            var n = t * t - 4 * e * i;
            return n
        }, n.computeRealRoots = function (e, n, r) {
            var o;
            if (0 === e)return 0 === n ? [] : [-r / n];
            if (0 === n) {
                if (0 === r)return [0, 0];
                var a = Math.abs(r), s = Math.abs(e);
                if (s > a && a / s < t.EPSILON14)return [0, 0];
                if (a > s && s / a < t.EPSILON14)return [];
                if (o = -r / e, 0 > o)return [];
                var u = Math.sqrt(o);
                return [-u, u]
            }
            if (0 === r)return o = -n / e, 0 > o ? [o, 0] : [0, o];
            var l = n * n, c = 4 * e * r, h = i(l, -c, t.EPSILON14);
            if (0 > h)return [];
            var d = -.5 * i(n, t.sign(n) * Math.sqrt(h), t.EPSILON14);
            return n > 0 ? [d / e, r / d] : [r / d, d / e]
        }, n
    }), define("Cesium/Core/CubicRealPolynomial", ["./DeveloperError", "./QuadraticRealPolynomial"], function (e, t) {
        "use strict";
        function i(e, t, i, n) {
            var r, o, a = e, s = t / 3, u = i / 3, l = n, c = a * u, h = s * l, d = s * s, m = u * u, p = a * u - d, f = a * l - s * u, _ = s * l - m, v = 4 * p * _ - f * f;
            if (0 > v) {
                var g, y, C;
                d * h >= c * m ? (g = a, y = p, C = -2 * s * p + a * f) : (g = l, y = _, C = -l * f + 2 * u * _);
                var E = 0 > C ? -1 : 1, S = -E * Math.abs(g) * Math.sqrt(-v);
                o = -C + S;
                var T = o / 2, b = 0 > T ? -Math.pow(-T, 1 / 3) : Math.pow(T, 1 / 3), w = o === S ? -b : -y / b;
                return r = 0 >= y ? b + w : -C / (b * b + w * w + y), d * h >= c * m ? [(r - s) / a] : [-l / (r + u)]
            }
            var x = p, A = -2 * s * p + a * f, P = _, I = -l * f + 2 * u * _, D = Math.sqrt(v), M = Math.sqrt(3) / 2, O = Math.abs(Math.atan2(a * D, -A) / 3);
            r = 2 * Math.sqrt(-x);
            var R = Math.cos(O);
            o = r * R;
            var N = r * (-R / 2 - M * Math.sin(O)), L = o + N > 2 * s ? o - s : N - s, F = a, B = L / F;
            O = Math.abs(Math.atan2(l * D, -I) / 3), r = 2 * Math.sqrt(-P), R = Math.cos(O), o = r * R, N = r * (-R / 2 - M * Math.sin(O));
            var z = -l, V = 2 * u > o + N ? o + u : N + u, U = z / V, k = F * V, G = -L * V - F * z, H = L * z, W = (u * G - s * H) / (-s * G + u * k);
            return W >= B ? U >= B ? U >= W ? [B, W, U] : [B, U, W] : [U, B, W] : U >= B ? [W, B, U] : U >= W ? [W, U, B] : [U, W, B]
        }

        var n = {};
        return n.computeDiscriminant = function (e, t, i, n) {
            var r = e * e, o = t * t, a = i * i, s = n * n, u = 18 * e * t * i * n + o * a - 27 * r * s - 4 * (e * a * i + o * t * n);
            return u
        }, n.computeRealRoots = function (e, n, r, o) {
            var a, s;
            if (0 === e)return t.computeRealRoots(n, r, o);
            if (0 === n) {
                if (0 === r) {
                    if (0 === o)return [0, 0, 0];
                    s = -o / e;
                    var u = 0 > s ? -Math.pow(-s, 1 / 3) : Math.pow(s, 1 / 3);
                    return [u, u, u]
                }
                return 0 === o ? (a = t.computeRealRoots(e, 0, r), 0 === a.Length ? [0] : [a[0], 0, a[1]]) : i(e, 0, r, o)
            }
            return 0 === r ? 0 === o ? (s = -n / e, 0 > s ? [s, 0, 0] : [0, 0, s]) : i(e, n, 0, o) : 0 === o ? (a = t.computeRealRoots(e, n, r), 0 === a.length ? [0] : a[1] <= 0 ? [a[0], a[1], 0] : a[0] >= 0 ? [0, a[0], a[1]] : [a[0], 0, a[1]]) : i(e, n, r, o)
        }, n
    }), define("Cesium/Core/QuarticRealPolynomial", ["./CubicRealPolynomial", "./DeveloperError", "./Math", "./QuadraticRealPolynomial"], function (e, t, i, n) {
        "use strict";
        function r(t, r, o, a) {
            var s = t * t, u = r - 3 * s / 8, l = o - r * t / 2 + s * t / 8, c = a - o * t / 4 + r * s / 16 - 3 * s * s / 256, h = e.computeRealRoots(1, 2 * u, u * u - 4 * c, -l * l);
            if (h.length > 0) {
                var d = -t / 4, m = h[h.length - 1];
                if (Math.abs(m) < i.EPSILON14) {
                    var p = n.computeRealRoots(1, u, c);
                    if (2 === p.length) {
                        var f, _ = p[0], v = p[1];
                        if (_ >= 0 && v >= 0) {
                            var g = Math.sqrt(_), y = Math.sqrt(v);
                            return [d - y, d - g, d + g, d + y]
                        }
                        if (_ >= 0 && 0 > v)return f = Math.sqrt(_), [d - f, d + f];
                        if (0 > _ && v >= 0)return f = Math.sqrt(v), [d - f, d + f]
                    }
                    return []
                }
                if (m > 0) {
                    var C = Math.sqrt(m), E = (u + m - l / C) / 2, S = (u + m + l / C) / 2, T = n.computeRealRoots(1, C, E), b = n.computeRealRoots(1, -C, S);
                    return 0 !== T.length ? (T[0] += d, T[1] += d, 0 !== b.length ? (b[0] += d, b[1] += d, T[1] <= b[0] ? [T[0], T[1], b[0], b[1]] : b[1] <= T[0] ? [b[0], b[1], T[0], T[1]] : T[0] >= b[0] && T[1] <= b[1] ? [b[0], T[0], T[1], b[1]] : b[0] >= T[0] && b[1] <= T[1] ? [T[0], b[0], b[1], T[1]] : T[0] > b[0] && T[0] < b[1] ? [b[0], T[0], b[1], T[1]] : [T[0], b[0], T[1], b[1]]) : T) : 0 !== b.length ? (b[0] += d, b[1] += d, b) : []
                }
            }
            return []
        }

        function o(t, r, o, a) {
            var s = o * o, u = r * r, l = t * t, c = -2 * r, h = o * t + u - 4 * a, d = l * a - o * r * t + s, m = e.computeRealRoots(1, c, h, d);
            if (m.length > 0) {
                var p, f, _ = m[0], v = r - _, g = v * v, y = t / 2, C = v / 2, E = g - 4 * a, S = g + 4 * Math.abs(a), T = l - 4 * _, b = l + 4 * Math.abs(_);
                if (0 > _ || T * S > E * b) {
                    var w = Math.sqrt(T);
                    p = w / 2, f = 0 === w ? 0 : (t * C - o) / w
                } else {
                    var x = Math.sqrt(E);
                    p = 0 === x ? 0 : (t * C - o) / x, f = x / 2
                }
                var A, P;
                0 === y && 0 === p ? (A = 0, P = 0) : i.sign(y) === i.sign(p) ? (A = y + p, P = _ / A) : (P = y - p, A = _ / P);
                var I, D;
                0 === C && 0 === f ? (I = 0, D = 0) : i.sign(C) === i.sign(f) ? (I = C + f, D = a / I) : (D = C - f, I = a / D);
                var M = n.computeRealRoots(1, A, I), O = n.computeRealRoots(1, P, D);
                if (0 !== M.length)return 0 !== O.length ? M[1] <= O[0] ? [M[0], M[1], O[0], O[1]] : O[1] <= M[0] ? [O[0], O[1], M[0], M[1]] : M[0] >= O[0] && M[1] <= O[1] ? [O[0], M[0], M[1], O[1]] : O[0] >= M[0] && O[1] <= M[1] ? [M[0], O[0], O[1], M[1]] : M[0] > O[0] && M[0] < O[1] ? [O[0], M[0], O[1], M[1]] : [M[0], O[0], M[1], O[1]] : M;
                if (0 !== O.length)return O
            }
            return []
        }

        var a = {};
        return a.computeDiscriminant = function (e, t, i, n, r) {
            var o = e * e, a = o * e, s = t * t, u = s * t, l = i * i, c = l * i, h = n * n, d = h * n, m = r * r, p = m * r, f = s * l * h - 4 * u * d - 4 * e * c * h + 18 * e * t * i * d - 27 * o * h * h + 256 * a * p + r * (18 * u * i * n - 4 * s * c + 16 * e * l * l - 80 * e * t * l * n - 6 * e * s * h + 144 * o * i * h) + m * (144 * e * s * i - 27 * s * s - 128 * o * l - 192 * o * t * n);
            return f
        }, a.computeRealRoots = function (t, n, a, s, u) {
            if (Math.abs(t) < i.EPSILON15)return e.computeRealRoots(n, a, s, u);
            var l = n / t, c = a / t, h = s / t, d = u / t, m = 0 > l ? 1 : 0;
            switch (m += 0 > c ? m + 1 : m, m += 0 > h ? m + 1 : m, m += 0 > d ? m + 1 : m) {
                case 0:
                    return r(l, c, h, d);
                case 1:
                    return o(l, c, h, d);
                case 2:
                    return o(l, c, h, d);
                case 3:
                    return r(l, c, h, d);
                case 4:
                    return r(l, c, h, d);
                case 5:
                    return o(l, c, h, d);
                case 6:
                    return r(l, c, h, d);
                case 7:
                    return r(l, c, h, d);
                case 8:
                    return o(l, c, h, d);
                case 9:
                    return r(l, c, h, d);
                case 10:
                    return r(l, c, h, d);
                case 11:
                    return o(l, c, h, d);
                case 12:
                    return r(l, c, h, d);
                case 13:
                    return r(l, c, h, d);
                case 14:
                    return r(l, c, h, d);
                case 15:
                    return r(l, c, h, d);
                default:
                    return void 0
            }
        }, a
    }),define("Cesium/Core/Ray", ["./Cartesian3", "./defaultValue", "./defined", "./DeveloperError"], function (e, t, i, n) {
        "use strict";
        var r = function (i, n) {
            n = e.clone(t(n, e.ZERO)), e.equals(n, e.ZERO) || e.normalize(n, n), this.origin = e.clone(t(i, e.ZERO)), this.direction = n
        };
        return r.getPoint = function (t, n, r) {
            return i(r) || (r = new e), r = e.multiplyByScalar(t.direction, n, r), e.add(t.origin, r, r)
        }, r
    }),define("Cesium/Core/IntersectionTests", ["./Cartesian3", "./Cartographic", "./defaultValue", "./defined", "./DeveloperError", "./Math", "./Matrix3", "./QuadraticRealPolynomial", "./QuarticRealPolynomial", "./Ray"], function (e, t, i, n, r, o, a, s, u, l) {
        "use strict";
        function c(t, n, r, a, s) {
            s = i(s, !1);
            var u, l, c, h, d, m = t.origin, p = t.direction, f = e.subtract(r, n, _), E = e.subtract(a, n, v), S = e.cross(p, E, g), T = e.dot(f, S);
            if (s) {
                if (T < o.EPSILON6)return void 0;
                if (u = e.subtract(m, n, y), c = e.dot(u, S), 0 > c || c > T)return void 0;
                if (l = e.cross(u, f, C), h = e.dot(p, l), 0 > h || c + h > T)return void 0;
                d = e.dot(E, l) / T
            } else {
                if (Math.abs(T) < o.EPSILON6)return void 0;
                var b = 1 / T;
                if (u = e.subtract(m, n, y), c = e.dot(u, S) * b, 0 > c || c > 1)return void 0;
                if (l = e.cross(u, f, C), h = e.dot(p, l) * b, 0 > h || c + h > 1)return void 0;
                d = e.dot(E, l) * b
            }
            return d
        }

        function h(e, t, i, n) {
            var r = t * t - 4 * e * i;
            if (0 > r)return void 0;
            if (r > 0) {
                var o = 1 / (2 * e), a = Math.sqrt(r), s = (-t + a) * o, u = (-t - a) * o;
                return u > s ? (n.root0 = s, n.root1 = u) : (n.root0 = u, n.root1 = s), n
            }
            var l = -t / (2 * e);
            return 0 === l ? void 0 : (n.root0 = n.root1 = l, n)
        }

        function d(t, i, r) {
            n(r) || (r = {});
            var o = t.origin, a = t.direction, s = i.center, u = i.radius * i.radius, l = e.subtract(o, s, g), c = e.dot(a, a), d = 2 * e.dot(a, l), m = e.magnitudeSquared(l) - u, p = h(c, d, m, S);
            return n(p) ? (r.start = p.root0, r.stop = p.root1, r) : void 0
        }

        function m(e, t, i) {
            var n = e + t;
            return o.sign(e) !== o.sign(t) && Math.abs(n / Math.max(Math.abs(e), Math.abs(t))) < i ? 0 : n
        }

        function p(t, i, n, r, l) {
            var c, h = r * r, d = l * l, p = (t[a.COLUMN1ROW1] - t[a.COLUMN2ROW2]) * d, f = l * (r * m(t[a.COLUMN1ROW0], t[a.COLUMN0ROW1], o.EPSILON15) + i.y), _ = t[a.COLUMN0ROW0] * h + t[a.COLUMN2ROW2] * d + r * i.x + n, v = d * m(t[a.COLUMN2ROW1], t[a.COLUMN1ROW2], o.EPSILON15), g = l * (r * m(t[a.COLUMN2ROW0], t[a.COLUMN0ROW2]) + i.z), y = [];
            if (0 === g && 0 === v) {
                if (c = s.computeRealRoots(p, f, _), 0 === c.length)return y;
                var C = c[0], E = Math.sqrt(Math.max(1 - C * C, 0));
                if (y.push(new e(r, l * C, l * -E)), y.push(new e(r, l * C, l * E)), 2 === c.length) {
                    var S = c[1], T = Math.sqrt(Math.max(1 - S * S, 0));
                    y.push(new e(r, l * S, l * -T)), y.push(new e(r, l * S, l * T))
                }
                return y
            }
            var b = g * g, w = v * v, x = p * p, A = g * v, P = x + w, I = 2 * (f * p + A), D = 2 * _ * p + f * f - w + b, M = 2 * (_ * f - A), O = _ * _ - b;
            if (0 === P && 0 === I && 0 === D && 0 === M)return y;
            c = u.computeRealRoots(P, I, D, M, O);
            var R = c.length;
            if (0 === R)return y;
            for (var N = 0; R > N; ++N) {
                var L, F = c[N], B = F * F, z = Math.max(1 - B, 0), V = Math.sqrt(z);
                L = o.sign(p) === o.sign(_) ? m(p * B + _, f * F, o.EPSILON12) : o.sign(_) === o.sign(f * F) ? m(p * B, f * F + _, o.EPSILON12) : m(p * B + f * F, _, o.EPSILON12);
                var U = m(v * F, g, o.EPSILON15), k = L * U;
                0 > k ? y.push(new e(r, l * F, l * V)) : k > 0 ? y.push(new e(r, l * F, l * -V)) : 0 !== V ? (y.push(new e(r, l * F, l * -V)), y.push(new e(r, l * F, l * V)), ++N) : y.push(new e(r, l * F, l * V))
            }
            return y
        }

        var f = {};
        f.rayPlane = function (t, i, r) {
            n(r) || (r = new e);
            var a = t.origin, s = t.direction, u = i.normal, l = e.dot(u, s);
            if (Math.abs(l) < o.EPSILON15)return void 0;
            var c = (-i.distance - e.dot(u, a)) / l;
            return 0 > c ? void 0 : (r = e.multiplyByScalar(s, c, r), e.add(a, r, r))
        };
        var _ = new e, v = new e, g = new e, y = new e, C = new e;
        f.rayTriangle = function (t, i, r, o, a, s) {
            var u = c(t, i, r, o, a);
            return !n(u) || 0 > u ? void 0 : (n(s) || (s = new e), e.multiplyByScalar(t.direction, u, s), e.add(t.origin, s, s))
        };
        var E = new l;
        f.lineSegmentTriangle = function (t, i, r, o, a, s, u) {
            var l = E;
            e.clone(t, l.origin), e.subtract(i, t, l.direction), e.normalize(l.direction, l.direction);
            var h = c(l, r, o, a, s);
            return !n(h) || 0 > h || h > e.distance(t, i) ? void 0 : (n(u) || (u = new e), e.multiplyByScalar(l.direction, h, u), e.add(l.origin, u, u))
        };
        var S = {root0: 0, root1: 0};
        f.raySphere = function (e, t, i) {
            return i = d(e, t, i), !n(i) || i.stop < 0 ? void 0 : (i.start = Math.max(i.start, 0), i)
        };
        var T = new l;
        f.lineSegmentSphere = function (t, i, r, o) {
            var a = T, s = (e.clone(t, a.origin), e.subtract(i, t, a.direction)), u = e.magnitude(s);
            return e.normalize(s, s), o = d(a, r, o), !n(o) || o.stop < 0 || o.start > u ? void 0 : (o.start = Math.max(o.start, 0), o.stop = Math.min(o.stop, u), o)
        };
        var b = new e, w = new e;
        f.rayEllipsoid = function (t, i) {
            var n, r, o, a, s, u = i.oneOverRadii, l = e.multiplyComponents(u, t.origin, b), c = e.multiplyComponents(u, t.direction, w), h = e.magnitudeSquared(l), d = e.dot(l, c);
            if (h > 1) {
                if (d >= 0)return void 0;
                var m = d * d;
                if (n = h - 1, r = e.magnitudeSquared(c), o = r * n, o > m)return void 0;
                if (m > o) {
                    a = d * d - o, s = -d + Math.sqrt(a);
                    var p = s / r, f = n / s;
                    return f > p ? {start: p, stop: f} : {start: f, stop: p}
                }
                var _ = Math.sqrt(n / r);
                return {start: _, stop: _}
            }
            return 1 > h ? (n = h - 1, r = e.magnitudeSquared(c), o = r * n, a = d * d - o, s = -d + Math.sqrt(a), {
                start: 0,
                stop: s / r
            }) : 0 > d ? (r = e.magnitudeSquared(c), {start: 0, stop: -d / r}) : void 0
        };
        var x = new e, A = new e, P = new e, I = new e, D = new e, M = new a, O = new a, R = new a, N = new a, L = new a, F = new a, B = new a, z = new e, V = new e, U = new t;
        f.grazingAltitudeLocation = function (t, i) {
            var r = t.origin, s = t.direction, u = i.geodeticSurfaceNormal(r, x);
            if (e.dot(s, u) >= 0)return r;
            var l = n(this.rayEllipsoid(t, i)), c = i.transformPositionToScaledSpace(s, x), h = e.normalize(c, c), d = e.mostOrthogonalAxis(c, I), m = e.normalize(e.cross(d, h, A), A), f = e.normalize(e.cross(h, m, P), P), _ = M;
            _[0] = h.x, _[1] = h.y, _[2] = h.z, _[3] = m.x, _[4] = m.y, _[5] = m.z, _[6] = f.x, _[7] = f.y, _[8] = f.z;
            var v = a.transpose(_, O), g = a.fromScale(i.radii, R), y = a.fromScale(i.oneOverRadii, N), C = L;
            C[0] = 0, C[1] = -s.z, C[2] = s.y, C[3] = s.z, C[4] = 0, C[5] = -s.x, C[6] = -s.y, C[7] = s.x, C[8] = 0;
            var E, S, T = a.multiply(a.multiply(v, y, F), C, F), b = a.multiply(a.multiply(T, g, B), _, B), w = a.multiplyByVector(T, r, D), k = p(b, e.negate(w, x), 0, 0, 1), G = k.length;
            if (G > 0) {
                for (var H = e.clone(e.ZERO, V), W = Number.NEGATIVE_INFINITY, q = 0; G > q; ++q) {
                    E = a.multiplyByVector(g, a.multiplyByVector(_, k[q], z), z);
                    var j = e.normalize(e.subtract(E, r, I), I), Y = e.dot(j, s);
                    Y > W && (W = Y, H = e.clone(E, H))
                }
                var X = i.cartesianToCartographic(H, U);
                return W = o.clamp(W, 0, 1), S = e.magnitude(e.subtract(H, r, I)) * Math.sqrt(1 - W * W), S = l ? -S : S, X.height = S, i.cartographicToCartesian(X, new e)
            }
            return void 0
        };
        var k = new e;
        return f.lineSegmentPlane = function (t, i, r, a) {
            n(a) || (a = new e);
            var s = e.subtract(i, t, k), u = r.normal, l = e.dot(u, s);
            if (Math.abs(l) < o.EPSILON6)return void 0;
            var c = e.dot(u, t), h = -(r.distance + c) / l;
            return 0 > h || h > 1 ? void 0 : (e.multiplyByScalar(s, h, a), e.add(t, a, a), a)
        }, f.trianglePlaneIntersection = function (t, i, n, r) {
            var o = r.normal, a = r.distance, s = e.dot(o, t) + a < 0, u = e.dot(o, i) + a < 0, l = e.dot(o, n) + a < 0, c = 0;
            c += s ? 1 : 0, c += u ? 1 : 0, c += l ? 1 : 0;
            var h, d;
            if ((1 === c || 2 === c) && (h = new e, d = new e), 1 === c) {
                if (s)return f.lineSegmentPlane(t, i, r, h), f.lineSegmentPlane(t, n, r, d), {
                    positions: [t, i, n, h, d],
                    indices: [0, 3, 4, 1, 2, 4, 1, 4, 3]
                };
                if (u)return f.lineSegmentPlane(i, n, r, h), f.lineSegmentPlane(i, t, r, d), {
                    positions: [t, i, n, h, d],
                    indices: [1, 3, 4, 2, 0, 4, 2, 4, 3]
                };
                if (l)return f.lineSegmentPlane(n, t, r, h), f.lineSegmentPlane(n, i, r, d), {
                    positions: [t, i, n, h, d],
                    indices: [2, 3, 4, 0, 1, 4, 0, 4, 3]
                }
            } else if (2 === c) {
                if (!s)return f.lineSegmentPlane(i, t, r, h), f.lineSegmentPlane(n, t, r, d), {
                    positions: [t, i, n, h, d],
                    indices: [1, 2, 4, 1, 4, 3, 0, 3, 4]
                };
                if (!u)return f.lineSegmentPlane(n, i, r, h), f.lineSegmentPlane(t, i, r, d), {
                    positions: [t, i, n, h, d],
                    indices: [2, 0, 4, 2, 4, 3, 1, 3, 4]
                };
                if (!l)return f.lineSegmentPlane(t, n, r, h), f.lineSegmentPlane(i, n, r, d), {
                    positions: [t, i, n, h, d],
                    indices: [0, 1, 4, 0, 4, 3, 2, 3, 4]
                }
            }
            return void 0
        }, f
    }),define("Cesium/Core/EllipsoidTangentPlane", ["./AxisAlignedBoundingBox", "./Cartesian2", "./Cartesian3", "./Cartesian4", "./defaultValue", "./defined", "./defineProperties", "./DeveloperError", "./Ellipsoid", "./IntersectionTests", "./Matrix3", "./Matrix4", "./Plane", "./Ray", "./Transforms"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p) {
        "use strict";
        var f = new n, _ = function (e, t) {
            t = r(t, u.WGS84), e = t.scaleToGeodeticSurface(e);
            var n = p.eastNorthUpToFixedFrame(e, t);
            this._ellipsoid = t, this._origin = e, this._xAxis = i.fromCartesian4(h.getColumn(n, 0, f)), this._yAxis = i.fromCartesian4(h.getColumn(n, 1, f));
            var o = i.fromCartesian4(h.getColumn(n, 2, f));
            this._plane = d.fromPointNormal(e, o)
        };
        a(_.prototype, {
            ellipsoid: {
                get: function () {
                    return this._ellipsoid
                }
            }, origin: {
                get: function () {
                    return this._origin
                }
            }, plane: {
                get: function () {
                    return this._plane
                }
            }, xAxis: {
                get: function () {
                    return this._xAxis
                }
            }, yAxis: {
                get: function () {
                    return this._yAxis
                }
            }, zAxis: {
                get: function () {
                    return this._plane.normal
                }
            }
        });
        var v = new e;
        _.fromPoints = function (t, i) {
            var n = e.fromPoints(t, v);
            return new _(n.center, i)
        };
        var g = new m, y = new i;
        _.prototype.projectPointOntoPlane = function (e, n) {
            var r = g;
            r.origin = e, i.normalize(e, r.direction);
            var a = l.rayPlane(r, this._plane, y);
            if (o(a) || (i.negate(r.direction, r.direction), a = l.rayPlane(r, this._plane, y)), o(a)) {
                var s = i.subtract(a, this._origin, a), u = i.dot(this._xAxis, s), c = i.dot(this._yAxis, s);
                return o(n) ? (n.x = u, n.y = c, n) : new t(u, c)
            }
            return void 0
        }, _.prototype.projectPointsOntoPlane = function (e, t) {
            o(t) || (t = []);
            for (var i = 0, n = e.length, r = 0; n > r; r++) {
                var a = this.projectPointOntoPlane(e[r], t[i]);
                o(a) && (t[i] = a, i++)
            }
            return t.length = i, t
        }, _.prototype.projectPointToNearestOnPlane = function (e, n) {
            o(n) || (n = new t);
            var r = g;
            r.origin = e, i.clone(this._plane.normal, r.direction);
            var a = l.rayPlane(r, this._plane, y);
            o(a) || (i.negate(r.direction, r.direction), a = l.rayPlane(r, this._plane, y));
            var s = i.subtract(a, this._origin, a), u = i.dot(this._xAxis, s), c = i.dot(this._yAxis, s);
            return n.x = u, n.y = c, n
        }, _.prototype.projectPointsToNearestOnPlane = function (e, t) {
            o(t) || (t = []);
            var i = e.length;
            t.length = i;
            for (var n = 0; i > n; n++)t[n] = this.projectPointToNearestOnPlane(e[n], t[n]);
            return t
        };
        var C = new i;
        return _.prototype.projectPointsOntoEllipsoid = function (e, t) {
            var n = e.length;
            o(t) ? t.length = n : t = new Array(n);
            for (var r = this._ellipsoid, a = this._origin, s = this._xAxis, u = this._yAxis, l = C, c = 0; n > c; ++c) {
                var h = e[c];
                i.multiplyByScalar(s, h.x, l), o(t[c]) || (t[c] = new i);
                var d = i.add(a, l, t[c]);
                i.multiplyByScalar(u, h.y, l), i.add(d, l, d), r.scaleToGeocentricSurface(d, d)
            }
            return t
        }, _
    }),define("Cesium/Core/barycentricCoordinates", ["./Cartesian2", "./Cartesian3", "./defined", "./DeveloperError"], function (e, t, i, n) {
        "use strict";
        var r = new t, o = new t, a = new t, s = function (n, s, u, l, c) {
            i(c) || (c = new t);
            var h, d, m, p, f, _, v, g;
            i(s.z) ? (h = t.subtract(u, s, r), d = t.subtract(l, s, o), m = t.subtract(n, s, a), p = t.dot(h, h), f = t.dot(h, d), _ = t.dot(h, m), v = t.dot(d, d), g = t.dot(d, m)) : (h = e.subtract(u, s, r), d = e.subtract(l, s, o), m = e.subtract(n, s, a), p = e.dot(h, h), f = e.dot(h, d), _ = e.dot(h, m), v = e.dot(d, d), g = e.dot(d, m));
            var y = 1 / (p * v - f * f);
            return c.y = (v * _ - f * g) * y, c.z = (p * g - f * _) * y, c.x = 1 - c.y - c.z, c
        };
        return s
    }),define("Cesium/Core/pointInsideTriangle", ["./barycentricCoordinates", "./Cartesian3"], function (e, t) {
        "use strict";
        var i = new t, n = function (t, n, r, o) {
            return e(t, n, r, o, i), i.x > 0 && i.y > 0 && i.z > 0
        };
        return n
    }),define("Cesium/Core/EllipsoidGeodesic", ["./Cartesian3", "./Cartographic", "./defaultValue", "./defined", "./defineProperties", "./DeveloperError", "./Ellipsoid", "./Math"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        function u(e) {
            var t = e._uSquared, i = e._ellipsoid.maximumRadius, n = e._ellipsoid.minimumRadius, r = (i - n) / i, o = Math.cos(e._startHeading), a = Math.sin(e._startHeading), s = (1 - r) * Math.tan(e._start.latitude), u = 1 / Math.sqrt(1 + s * s), l = u * s, c = Math.atan2(s, o), h = u * a, d = h * h, m = 1 - d, p = Math.sqrt(m), f = t / 4, _ = f * f, v = _ * f, g = _ * _, y = 1 + f - 3 * _ / 4 + 5 * v / 4 - 175 * g / 64, C = 1 - f + 15 * _ / 8 - 35 * v / 8, E = 1 - 3 * f + 35 * _ / 4, S = 1 - 5 * f, T = y * c - C * Math.sin(2 * c) * f / 2 - E * Math.sin(4 * c) * _ / 16 - S * Math.sin(6 * c) * v / 48 - 5 * Math.sin(8 * c) * g / 512, b = e._constants;
            b.a = i, b.b = n, b.f = r, b.cosineHeading = o, b.sineHeading = a, b.tanU = s, b.cosineU = u, b.sineU = l, b.sigma = c, b.sineAlpha = h, b.sineSquaredAlpha = d, b.cosineSquaredAlpha = m, b.cosineAlpha = p, b.u2Over4 = f, b.u4Over16 = _, b.u6Over64 = v, b.u8Over256 = g, b.a0 = y, b.a1 = C, b.a2 = E, b.a3 = S, b.distanceRatio = T
        }

        function l(e, t) {
            return e * t * (4 + e * (4 - 3 * t)) / 16
        }

        function c(e, t, i, n, r, o, a) {
            var s = l(e, i);
            return (1 - s) * e * t * (n + s * r * (a + s * o * (2 * a * a - 1)))
        }

        function h(e, t, i, n, r, o, a) {
            var u, l, h, d, m, p = (t - i) / t, f = o - n, _ = Math.atan((1 - p) * Math.tan(r)), v = Math.atan((1 - p) * Math.tan(a)), g = Math.cos(_), y = Math.sin(_), C = Math.cos(v), E = Math.sin(v), S = g * C, T = g * E, b = y * E, w = y * C, x = f, A = s.TWO_PI, P = Math.cos(x), I = Math.sin(x);
            do {
                P = Math.cos(x), I = Math.sin(x);
                var D = T - w * P;
                h = Math.sqrt(C * C * I * I + D * D), l = b + S * P, u = Math.atan2(h, l);
                var M;
                0 === h ? (M = 0, d = 1) : (M = S * I / h, d = 1 - M * M), A = x, m = l - 2 * b / d, isNaN(m) && (m = 0), x = f + c(p, M, d, u, h, l, m)
            } while (Math.abs(x - A) > s.EPSILON12);
            var O = d * (t * t - i * i) / (i * i), R = 1 + O * (4096 + O * (O * (320 - 175 * O) - 768)) / 16384, N = O * (256 + O * (O * (74 - 47 * O) - 128)) / 1024, L = m * m, F = N * h * (m + N * (l * (2 * L - 1) - N * m * (4 * h * h - 3) * (4 * L - 3) / 6) / 4), B = i * R * (u - F), z = Math.atan2(C * I, T - w * P), V = Math.atan2(g * I, T * P - w);
            e._distance = B, e._startHeading = z, e._endHeading = V, e._uSquared = O
        }

        function d(i, n, r, o) {
            e.normalize(o.cartographicToCartesian(n, p), m), e.normalize(o.cartographicToCartesian(r, p), p);
            h(i, o.maximumRadius, o.minimumRadius, n.longitude, n.latitude, r.longitude, r.latitude), i._start = t.clone(n, i._start), i._end = t.clone(r, i._end), i._start.height = 0, i._end.height = 0, u(i)
        }

        var m = new e, p = new e, f = function (e, r, o) {
            var s = i(o, a.WGS84);
            this._ellipsoid = s, this._start = new t, this._end = new t, this._constants = {}, this._startHeading = void 0, this._endHeading = void 0, this._distance = void 0, this._uSquared = void 0, n(e) && n(r) && d(this, e, r, s)
        };
        return r(f.prototype, {
            ellipsoid: {
                get: function () {
                    return this._ellipsoid
                }
            }, surfaceDistance: {
                get: function () {
                    return this._distance
                }
            }, start: {
                get: function () {
                    return this._start
                }
            }, end: {
                get: function () {
                    return this._end
                }
            }, startHeading: {
                get: function () {
                    return this._startHeading
                }
            }, endHeading: {
                get: function () {
                    return this._endHeading
                }
            }
        }), f.prototype.setEndPoints = function (e, t) {
            d(this, e, t, this._ellipsoid)
        }, f.prototype.interpolateUsingFraction = function (e, t) {
            return this.interpolateUsingSurfaceDistance(this._distance * e, t)
        }, f.prototype.interpolateUsingSurfaceDistance = function (e, i) {
            var r = this._constants, o = r.distanceRatio + e / r.b, a = Math.cos(2 * o), s = Math.cos(4 * o), u = Math.cos(6 * o), l = Math.sin(2 * o), h = Math.sin(4 * o), d = Math.sin(6 * o), m = Math.sin(8 * o), p = o * o, f = o * p, _ = r.u8Over256, v = r.u2Over4, g = r.u6Over64, y = r.u4Over16, C = 2 * f * _ * a / 3 + o * (1 - v + 7 * y / 4 - 15 * g / 4 + 579 * _ / 64 - (y - 15 * g / 4 + 187 * _ / 16) * a - (5 * g / 4 - 115 * _ / 16) * s - 29 * _ * u / 16) + (v / 2 - y + 71 * g / 32 - 85 * _ / 16) * l + (5 * y / 16 - 5 * g / 4 + 383 * _ / 96) * h - p * ((g - 11 * _ / 2) * l + 5 * _ * h / 2) + (29 * g / 96 - 29 * _ / 16) * d + 539 * _ * m / 1536, E = Math.asin(Math.sin(C) * r.cosineAlpha), S = Math.atan(r.a / r.b * Math.tan(E));
            C -= r.sigma;
            var T = Math.cos(2 * r.sigma + C), b = Math.sin(C), w = Math.cos(C), x = r.cosineU * w, A = r.sineU * b, P = Math.atan2(b * r.sineHeading, x - A * r.cosineHeading), I = P - c(r.f, r.sineAlpha, r.cosineSquaredAlpha, C, b, w, T);
            return n(i) ? (i.longitude = this._start.longitude + I, i.latitude = S, i.height = 0, i) : new t(this._start.longitude + I, S, 0)
        }, f
    }),define("Cesium/Core/PolylinePipeline", ["./Cartesian3", "./Cartographic", "./defaultValue", "./defined", "./DeveloperError", "./Ellipsoid", "./EllipsoidGeodesic", "./IntersectionTests", "./isArray", "./Math", "./Matrix4", "./Plane"], function (e, t, i, n, r, o, a, s, u, l, c, h) {
        "use strict";
        function d(e, t, i) {
            var n = b;
            n.length = e;
            var r;
            if (t === i) {
                for (r = 0; e > r; r++)n[r] = t;
                return n
            }
            var o = i - t, a = o / e;
            for (r = 0; e > r; r++) {
                var s = t + r * a;
                n[r] = s
            }
            return n
        }

        function m(t, i, n, r, o, a, s, u) {
            var l = r.scaleToGeodeticSurface(t, P), c = r.scaleToGeodeticSurface(i, I), h = p.numberOfPoints(t, i, n), m = r.cartesianToCartographic(l, w), f = r.cartesianToCartographic(c, x), _ = d(h, o, a);
            D.setEndPoints(m, f);
            var v = D.surfaceDistance / h, g = u;
            m.height = o;
            var y = r.cartographicToCartesian(m, A);
            e.pack(y, s, g), g += 3;
            for (var C = 1; h > C; C++) {
                var E = D.interpolateUsingSurfaceDistance(C * v, x);
                E.height = _[C], y = r.cartographicToCartesian(E, A), e.pack(y, s, g), g += 3
            }
            return g
        }

        var p = {};
        p.numberOfPoints = function (t, i, n) {
            var r = e.distance(t, i);
            return Math.ceil(r / n)
        };
        var f = new t;
        p.extractHeights = function (e, t) {
            for (var i = e.length, n = new Array(i), r = 0; i > r; r++) {
                var o = e[r];
                n[r] = t.cartesianToCartographic(o, f).height
            }
            return n
        };
        var _ = new c, v = new e, g = new e, y = new h(e.ZERO, 0), C = new e, E = new h(e.ZERO, 0), S = new e, T = new e, b = [], w = new t, x = new t, A = new e, P = new e, I = new e, D = new a;
        p.wrapLongitude = function (t, r) {
            var o = [], a = [];
            if (n(t) && t.length > 0) {
                r = i(r, c.IDENTITY);
                var u = c.inverseTransformation(r, _), l = c.multiplyByPoint(u, e.ZERO, v), d = c.multiplyByPointAsVector(u, e.UNIT_Y, g), m = h.fromPointNormal(l, d, y), p = c.multiplyByPointAsVector(u, e.UNIT_X, C), f = h.fromPointNormal(l, p, E), b = 1;
                o.push(e.clone(t[0]));
                for (var w = o[0], x = t.length, A = 1; x > A; ++A) {
                    var P = t[A];
                    if (h.getPointDistance(f, w) < 0 || h.getPointDistance(f, P) < 0) {
                        var I = s.lineSegmentPlane(w, P, m, S);
                        if (n(I)) {
                            var D = e.multiplyByScalar(d, 5e-9, T);
                            h.getPointDistance(m, w) < 0 && e.negate(D, D), o.push(e.add(I, D, new e)), a.push(b + 1), e.negate(D, D), o.push(e.add(I, D, new e)), b = 1
                        }
                    }
                    o.push(e.clone(t[A])), b++, w = P
                }
                a.push(b)
            }
            return {positions: o, lengths: a}
        };
        var M = l.EPSILON7;
        return p.removeDuplicates = function (t) {
            var i = t.length;
            if (2 > i)return t;
            var n, r, o;
            for (n = 1; i > n && (r = t[n - 1], o = t[n], !e.equalsEpsilon(r, o, M)); ++n);
            if (n === i)return t;
            for (var a = t.slice(0, n); i > n; ++n)o = t[n], e.equalsEpsilon(r, o, M) || (a.push(e.clone(o)), r = o);
            return a
        }, p.generateArc = function (t) {
            n(t) || (t = {});
            var r = t.positions, a = r.length, s = i(t.ellipsoid, o.WGS84), c = i(t.height, 0);
            if (1 > a)return [];
            if (1 === a) {
                var h = s.scaleToGeodeticSurface(r[0], P);
                if (0 !== c) {
                    var d = s.geodeticSurfaceNormal(h, A);
                    e.multiplyByScalar(d, c, d), e.add(h, d, h)
                }
                return [h.x, h.y, h.z]
            }
            var f = t.minDistance;
            if (!n(f)) {
                var _ = i(t.granularity, l.RADIANS_PER_DEGREE);
                f = l.chordLength(_, s.maximumRadius)
            }
            var v, g = 0;
            for (v = 0; a - 1 > v; v++)g += p.numberOfPoints(r[v], r[v + 1], f);
            var y = 3 * (g + 1), C = new Array(y), E = 0, S = u(c);
            for (v = 0; a - 1 > v; v++) {
                var T = r[v], x = r[v + 1], I = S ? c[v] : c, D = S ? c[v + 1] : c;
                E = m(T, x, f, s, I, D, C, E)
            }
            b.length = 0;
            var M = r[a - 1], O = s.cartesianToCartographic(M, w);
            O.height = S ? c[a - 1] : c;
            var R = s.cartographicToCartesian(O, A);
            return e.pack(R, C, y - 3), C
        }, p.generateCartesianArc = function (t) {
            for (var i = p.generateArc(t), n = i.length / 3, r = new Array(n), o = 0; n > o; o++)r[o] = e.unpack(i, 3 * o);
            return r
        }, p
    }),define("Cesium/Core/Queue", ["../Core/defaultValue", "../Core/defineProperties"], function (e, t) {
        "use strict";
        var i = function (t) {
            t = e(t, e.EMPTY_OBJECT), this.compact = e(t.compact, !0), this._array = [], this._offset = 0, this._length = 0
        };
        return t(i.prototype, {
            length: {
                get: function () {
                    return this._length
                }
            }
        }), i.prototype.enqueue = function (e) {
            this._array.push(e), this._length++
        }, i.prototype.dequeue = function () {
            if (0 === this._length)return void 0;
            var e = this._array, t = this._offset, i = e[t];
            return e[t] = void 0, t++, this.compact && t > 10 && 2 * t > e.length && (this._array = e.slice(t), t = 0), this._offset = t, this._length--, i
        }, i.prototype.peek = function () {
            return 0 === this._length ? void 0 : this._array[this._offset]
        }, i.prototype.contains = function (e) {
            return -1 !== this._array.indexOf(e)
        }, i.prototype.clear = function () {
            this._array.length = this._offset = this._length = 0
        }, i.prototype.sort = function (e) {
            this._offset > 0 && (this._array = this._array.slice(this._offset), this._offset = 0), this._array.sort(e)
        }, i
    }),define("Cesium/Core/WindingOrder", ["../Renderer/WebGLConstants", "./freezeObject"], function (e, t) {
        "use strict";
        var i = {
            CLOCKWISE: e.CW, COUNTER_CLOCKWISE: e.CCW, validate: function (e) {
                return e === i.CLOCKWISE || e === i.COUNTER_CLOCKWISE
            }
        };
        return t(i)
    }),define("Cesium/Core/PolygonPipeline", ["./Cartesian2", "./Cartesian3", "./ComponentDatatype", "./defaultValue", "./defined", "./DeveloperError", "./Ellipsoid", "./EllipsoidTangentPlane", "./Geometry", "./GeometryAttribute", "./Math", "./pointInsideTriangle", "./PolylinePipeline", "./PrimitiveType", "./Queue", "./WindingOrder"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f) {
        "use strict";
        function _(t, i, n) {
            var r = e.subtract(i, t, F), o = e.subtract(n, i, B);
            return r.x * o.y - r.y * o.x >= 0
        }

        function v(e) {
            for (var t = e[0].x, i = 0, n = 0; n < e.length; n++)e[n].x > t && (t = e[n].x, i = n);
            return i
        }

        function g(e) {
            for (var t = e[0][0].x, i = 0, n = 0; n < e.length; n++) {
                var r = e[n][v(e[n])].x;
                r > t && (t = r, i = n)
            }
            return i
        }

        function y(e) {
            for (var t = [], i = 0; i < e.length; i++) {
                var n = e[(i - 1 + e.length) % e.length], r = e[i], o = e[(i + 1) % e.length];
                _(n, r, o) || t.push(r)
            }
            return t
        }

        function C(t, i) {
            for (var n = 0; n < t.length; n++)if (e.equals(i, t[n]))return n;
            return -1
        }

        function E(i, r, o) {
            o = n(o, []);
            var a = Number.MAX_VALUE, s = v(r), u = new e(r[s].x, i.y);
            o.push(s), o.push((s + 1) % r.length);
            for (var l = r[0].x, c = l, h = 1; h < r.length; ++h)r[h].x < l ? l = r[h].x : r[h].x > c && (c = r[h].x);
            c += c - l;
            var d = new t(c, i.y, 0);
            for (h = 0; h < r.length; h++) {
                var m = r[h], p = r[(h + 1) % r.length];
                if ((m.x >= i.x || p.x >= i.x) && (m.y >= i.y && p.y <= i.y || m.y <= i.y && p.y >= i.y)) {
                    var f = (p.y - m.y) * (d.x - i.x) - (p.x - m.x) * (d.y - i.y);
                    if (0 !== f) {
                        f = 1 / f;
                        var _ = ((p.x - m.x) * (i.y - m.y) - (p.y - m.y) * (i.x - m.x)) * f, g = ((d.x - i.x) * (i.y - m.y) - (d.y - i.y) * (i.x - m.x)) * f;
                        if (_ >= 0 && 1 >= _ && g >= 0 && 1 >= g) {
                            var y = new e(i.x + _ * (d.x - i.x), i.y + _ * (d.y - i.y)), C = e.subtract(y, i, z);
                            f = e.magnitudeSquared(C), a > f && (u = y, a = f, o[0] = h, o[1] = (h + 1) % r.length)
                        }
                    }
                }
            }
            return u
        }

        function S(t, i) {
            var n = g(i), r = i[n], o = v(r), a = r[o], s = [], u = E(a, t, s), l = C(t, u);
            if (-1 !== l)return l;
            var d = e.magnitudeSquared(e.subtract(t[s[0]], a, V)), m = e.magnitudeSquared(e.subtract(t[s[1]], a, V)), p = m > d ? t[s[0]] : t[s[1]], f = y(t), _ = f.indexOf(p);
            -1 !== _ && f.splice(_, 1);
            for (var S = [], T = 0; T < f.length; T++) {
                var b = f[T];
                h(b, a, u, p) && S.push(b)
            }
            var w = Number.MAX_VALUE;
            if (S.length > 0) {
                var x = e.fromElements(1, 0, V);
                for (T = 0; T < S.length; T++) {
                    var A = e.subtract(S[T], a, U), P = e.magnitude(x) * e.magnitudeSquared(A);
                    if (0 !== P) {
                        var I = Math.abs(c.acosClamped(e.dot(x, A) / P));
                        w > I && (w = I, p = S[T])
                    }
                }
            }
            return t.indexOf(p)
        }

        function T(e, i, n) {
            for (var r = ee.computeWindingOrder2D(e), o = 0; o < i.length; o++) {
                var a = i[o];
                t.equals(a[0], a[a.length - 1]) || a.push(a[0]);
                var u = ee.computeWindingOrder2D(a);
                u === r && a.reverse()
            }
            var l = s.fromPoints(e, n), c = l.projectPointsOntoPlane(e), h = [];
            for (o = 0; o < i.length; o++)h.push(l.projectPointsOntoPlane(i[o]));
            var d = S(c, h), m = g(h), p = v(h[m]), f = i[m], _ = [];
            for (o = 0; o < e.length; o++)_.push(e[o]);
            var y, C = [];
            if (0 !== p)for (y = 0; y <= f.length; y++) {
                var E = (y + p) % f.length;
                0 !== E && C.push(f[E])
            } else for (y = 0; y < f.length; y++)C.push(f[(y + p) % f.length]);
            var T = _.lastIndexOf(e[d]);
            C.push(e[T]);
            var b = _.slice(0, T + 1), w = _.slice(T + 1);
            return _ = b.concat(C, w), i.splice(m, 1), _
        }

        function b(e) {
            var t = c.nextRandomNumber(), i = Math.floor(t * e);
            return i === e && i--, i
        }

        function w(e, t, i, n) {
            var r = n[e].position, o = n[t].position, a = n[i].position, s = a.x, u = a.y, l = r.x - s, c = r.y - u, h = o.x - s, d = o.y - u;
            return l * d - c * h
        }

        function x(e, t) {
            return e.x * t.y - e.y * t.x
        }

        function A(e, t) {
            var i = t.length, n = c.mod(e - 1, i), r = c.mod(e + 1, i);
            return 0 === w(n, r, e, t) ? !1 : !0
        }

        function P(t, i) {
            return e.magnitudeSquared(i) < e.magnitudeSquared(t)
        }

        function I(t, i, n) {
            if (!A(t, n))return t;
            var r = n[t].position, o = n[i].position, a = n.length, s = c.mod(t - 1, a);
            if (!A(s, n))return s;
            var u = c.mod(t + 1, a);
            if (!A(u, n))return u;
            var l = e.subtract(n[s].position, r, H), h = e.subtract(n[u].position, r, W), d = e.subtract(o, r, q), m = x(l, d), p = x(h, d);
            if (0 === m)return P(l, d) ? k : G;
            if (0 === p)return P(h, d) ? k : G;
            var f = x(l, h);
            return 0 > f ? 0 > m && p > 0 ? k : G : f > 0 ? m > 0 && 0 > p ? G : k : void 0
        }

        function D(e, t, i) {
            return (e > t || e > i) && (t > e || i > e) || t === i && t === e
        }

        function M(t, i, n, r) {
            var o = e.subtract(n, t, Y), a = i.x * r.y - i.y * r.x, s = a * a, u = e.magnitudeSquared(i), l = e.magnitudeSquared(r);
            if (s > j * u * l) {
                var c = (o.x * r.y - o.y * r.x) / a;
                return e.add(t, e.multiplyByScalar(i, c, Y), Y)
            }
            return void 0
        }

        function O(t, i, n) {
            for (var o = e.subtract(i, t, X), a = n.length, s = 0; a > s; s++) {
                var u = n[s].position, l = n[c.mod(s + 1, a)].position;
                if (!(e.equals(t, u) || e.equals(i, l) || e.equals(t, l) || e.equals(i, u))) {
                    var h = e.subtract(l, u, Z), d = M(t, o, u, h);
                    if (r(d) && !(e.equals(d, t) || e.equals(d, i) || e.equals(d, u) || e.equals(d, l))) {
                        var m = d.x, p = d.y, f = D(m, t.x, i.x) && D(p, t.y, i.y) && D(m, u.x, l.x) && D(p, u.y, l.y);
                        if (f)return !0
                    }
                }
            }
            return !1
        }

        function R(t, i, n) {
            var r = I(t, i, n);
            if (r >= 0)return r;
            var o = I(i, t, n);
            return o >= 0 ? o : r !== k || o !== k || O(n[t].position, n[i].position, n) || e.equals(n[t].position, n[i].position) ? J : K
        }

        function N(e) {
            return 0 === w(1, 2, 0, e)
        }

        function L(e) {
            var t = e.length;
            if (3 === t)return N(e) ? [] : [e[0].index, e[1].index, e[2].index];
            if (e.length < 3)throw new o("Invalid polygon: must have at least three vertices.");
            for (var i, n, r = 0, a = 10 * e.length, s = J; K > s && r++ < a;) {
                for (i = b(e.length), n = i + 1; Math.abs(i - n) < 2 || Math.abs(i - n) > e.length - 2;)n = b(e.length);
                if (i > n) {
                    var u = i;
                    i = n, n = u
                }
                s = R(i, n, e)
            }
            if (s === K) {
                var l = e.splice(i, n - i + 1, e[i], e[n]);
                return L(e).concat(L(l))
            }
            return s >= 0 ? (e.splice(s, 1), L(e)) : []
        }

        var F = new e, B = new e, z = new e, V = new e(1, 0), U = new e, k = -1, G = -2, H = new t, W = new t, q = new t, j = c.EPSILON14, Y = new e, X = (new e, new e), Z = new e, K = -1, J = -2, Q = new t, $ = new t, ee = {};
        ee.removeDuplicates = function (e) {
            var i = d.removeDuplicates(e);
            return t.equals(i[0], i[i.length - 1]) ? i.slice(1) : i
        }, ee.computeArea2D = function (e) {
            for (var t = e.length, i = 0, n = t - 1, r = 0; t > r; n = r++) {
                var o = e[n], a = e[r];
                i += o.x * a.y - a.x * o.y
            }
            return .5 * i
        }, ee.computeWindingOrder2D = function (e) {
            var t = ee.computeArea2D(e);
            return t > 0 ? f.COUNTER_CLOCKWISE : f.CLOCKWISE
        }, ee.triangulate = function (e) {
            for (var t = e.length, i = [], n = 0; t > n; ++n)i[n] = {position: e[n], index: n};
            return L(i)
        };
        var te = new t, ie = new t, ne = new t, re = new t, oe = new t, ae = new t, se = new t;
        return ee.computeSubdivision = function (e, o, a, s) {
            s = n(s, c.RADIANS_PER_DEGREE);
            var h, d = a.slice(0), p = o.length, f = new Array(3 * p), _ = 0;
            for (h = 0; p > h; h++) {
                var v = o[h];
                f[_++] = v.x, f[_++] = v.y, f[_++] = v.z
            }
            for (var g = [], y = {}, C = e.maximumRadius, E = c.chordLength(s, C), S = E * E; d.length > 0;) {
                var T, b, w = d.pop(), x = d.pop(), A = d.pop(), P = t.fromArray(f, 3 * A, te), I = t.fromArray(f, 3 * x, ie), D = t.fromArray(f, 3 * w, ne), M = t.multiplyByScalar(t.normalize(P, re), C, re), O = t.multiplyByScalar(t.normalize(I, oe), C, oe), R = t.multiplyByScalar(t.normalize(D, ae), C, ae), N = t.magnitudeSquared(t.subtract(M, O, se)), L = t.magnitudeSquared(t.subtract(O, R, se)), F = t.magnitudeSquared(t.subtract(R, M, se)), B = Math.max(N, L, F);
                B > S ? N === B ? (T = Math.min(A, x) + " " + Math.max(A, x), h = y[T], r(h) || (b = t.add(P, I, se), t.multiplyByScalar(b, .5, b), f.push(b.x, b.y, b.z), h = f.length / 3 - 1, y[T] = h), d.push(A, h, w), d.push(h, x, w)) : L === B ? (T = Math.min(x, w) + " " + Math.max(x, w), h = y[T], r(h) || (b = t.add(I, D, se), t.multiplyByScalar(b, .5, b), f.push(b.x, b.y, b.z), h = f.length / 3 - 1, y[T] = h), d.push(x, h, A), d.push(h, w, A)) : F === B && (T = Math.min(w, A) + " " + Math.max(w, A), h = y[T], r(h) || (b = t.add(D, P, se), t.multiplyByScalar(b, .5, b), f.push(b.x, b.y, b.z), h = f.length / 3 - 1, y[T] = h), d.push(w, h, x), d.push(h, A, x)) : (g.push(A), g.push(x), g.push(w))
            }
            return new u({
                attributes: {
                    position: new l({
                        componentDatatype: i.DOUBLE,
                        componentsPerAttribute: 3,
                        values: f
                    })
                }, indices: g, primitiveType: m.TRIANGLES
            })
        }, ee.scaleToGeodeticHeight = function (e, i, o, s) {
            o = n(o, a.WGS84);
            var u = Q, l = $;
            if (i = n(i, 0), s = n(s, !0), r(e) && r(e.attributes) && r(e.attributes.position))for (var c = e.attributes.position.values, h = c.length, d = 0; h > d; d += 3)t.fromArray(c, d, l), s && (l = o.scaleToGeodeticSurface(l, l)), u = o.geodeticSurfaceNormal(l, u), t.multiplyByScalar(u, i, u), t.add(l, u, l), c[d] = l.x, c[d + 1] = l.y, c[d + 2] = l.z;
            return e
        }, ee.eliminateHoles = function (e, i, r) {
            r = n(r, a.WGS84);
            for (var o = [], s = 0; s < i.length; s++) {
                for (var u = [], l = 0; l < i[s].length; l++)u.push(t.clone(i[s][l]));
                o.push(u)
            }
            for (var c = e; o.length > 0;)c = T(c, o, r);
            return c
        }, ee
    }),define("Cesium/Core/Matrix2", ["./Cartesian2", "./defaultValue", "./defined", "./DeveloperError", "./freezeObject"], function (e, t, i, n, r) {
        "use strict";
        var o = function (e, i, n, r) {
            this[0] = t(e, 0), this[1] = t(n, 0), this[2] = t(i, 0), this[3] = t(r, 0)
        };
        o.packedLength = 4, o.pack = function (e, i, n) {
            n = t(n, 0), i[n++] = e[0], i[n++] = e[1], i[n++] = e[2], i[n++] = e[3]
        }, o.unpack = function (e, n, r) {
            return n = t(n, 0), i(r) || (r = new o), r[0] = e[n++], r[1] = e[n++], r[2] = e[n++], r[3] = e[n++], r
        }, o.clone = function (e, t) {
            return i(e) ? i(t) ? (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t) : new o(e[0], e[2], e[1], e[3]) : void 0
        }, o.fromArray = function (e, n, r) {
            return n = t(n, 0), i(r) || (r = new o), r[0] = e[n], r[1] = e[n + 1], r[2] = e[n + 2], r[3] = e[n + 3], r
        }, o.fromColumnMajorArray = function (e, t) {
            return o.clone(e, t)
        }, o.fromRowMajorArray = function (e, t) {
            return i(t) ? (t[0] = e[0], t[1] = e[2], t[2] = e[1], t[3] = e[3], t) : new o(e[0], e[1], e[2], e[3])
        }, o.fromScale = function (e, t) {
            return i(t) ? (t[0] = e.x, t[1] = 0, t[2] = 0, t[3] = e.y, t) : new o(e.x, 0, 0, e.y)
        }, o.fromUniformScale = function (e, t) {
            return i(t) ? (t[0] = e, t[1] = 0, t[2] = 0, t[3] = e, t) : new o(e, 0, 0, e)
        }, o.fromRotation = function (e, t) {
            var n = Math.cos(e), r = Math.sin(e);
            return i(t) ? (t[0] = n, t[1] = r, t[2] = -r, t[3] = n, t) : new o(n, -r, r, n)
        }, o.toArray = function (e, t) {
            return i(t) ? (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t) : [e[0], e[1], e[2], e[3]]
        }, o.getElementIndex = function (e, t) {
            return 2 * e + t
        }, o.getColumn = function (e, t, i) {
            var n = 2 * t, r = e[n], o = e[n + 1];
            return i.x = r, i.y = o, i
        }, o.setColumn = function (e, t, i, n) {
            n = o.clone(e, n);
            var r = 2 * t;
            return n[r] = i.x, n[r + 1] = i.y, n
        }, o.getRow = function (e, t, i) {
            var n = e[t], r = e[t + 2];
            return i.x = n, i.y = r, i
        }, o.setRow = function (e, t, i, n) {
            return n = o.clone(e, n), n[t] = i.x, n[t + 2] = i.y, n
        };
        var a = new e;
        o.getScale = function (t, i) {
            return i.x = e.magnitude(e.fromElements(t[0], t[1], a)), i.y = e.magnitude(e.fromElements(t[2], t[3], a)), i
        };
        var s = new e;
        return o.getMaximumScale = function (t) {
            return o.getScale(t, s), e.maximumComponent(s)
        }, o.multiply = function (e, t, i) {
            var n = e[0] * t[0] + e[2] * t[1], r = e[0] * t[2] + e[2] * t[3], o = e[1] * t[0] + e[3] * t[1], a = e[1] * t[2] + e[3] * t[3];
            return i[0] = n, i[1] = o, i[2] = r, i[3] = a, i
        }, o.add = function (e, t, i) {
            return i[0] = e[0] + t[0], i[1] = e[1] + t[1], i[2] = e[2] + t[2], i[3] = e[3] + t[3], i
        }, o.subtract = function (e, t, i) {
            return i[0] = e[0] - t[0], i[1] = e[1] - t[1], i[2] = e[2] - t[2], i[3] = e[3] - t[3], i
        }, o.multiplyByVector = function (e, t, i) {
            var n = e[0] * t.x + e[2] * t.y, r = e[1] * t.x + e[3] * t.y;
            return i.x = n, i.y = r, i
        }, o.multiplyByScalar = function (e, t, i) {
            return i[0] = e[0] * t, i[1] = e[1] * t, i[2] = e[2] * t, i[3] = e[3] * t, i
        }, o.multiplyByScale = function (e, t, i) {
            return i[0] = e[0] * t.x, i[1] = e[1] * t.x, i[2] = e[2] * t.y, i[3] = e[3] * t.y, i
        }, o.negate = function (e, t) {
            return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = -e[3], t
        }, o.transpose = function (e, t) {
            var i = e[0], n = e[2], r = e[1], o = e[3];
            return t[0] = i, t[1] = n, t[2] = r, t[3] = o, t
        }, o.abs = function (e, t) {
            return t[0] = Math.abs(e[0]), t[1] = Math.abs(e[1]), t[2] = Math.abs(e[2]), t[3] = Math.abs(e[3]), t
        }, o.equals = function (e, t) {
            return e === t || i(e) && i(t) && e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3]
        }, o.equalsArray = function (e, t, i) {
            return e[0] === t[i] && e[1] === t[i + 1] && e[2] === t[i + 2] && e[3] === t[i + 3]
        }, o.equalsEpsilon = function (e, t, n) {
            return e === t || i(e) && i(t) && Math.abs(e[0] - t[0]) <= n && Math.abs(e[1] - t[1]) <= n && Math.abs(e[2] - t[2]) <= n && Math.abs(e[3] - t[3]) <= n
        }, o.IDENTITY = r(new o(1, 0, 0, 1)), o.ZERO = r(new o(0, 0, 0, 0)), o.COLUMN0ROW0 = 0, o.COLUMN0ROW1 = 1, o.COLUMN1ROW0 = 2, o.COLUMN1ROW1 = 3, o.prototype.clone = function (e) {
            return o.clone(this, e)
        }, o.prototype.equals = function (e) {
            return o.equals(this, e)
        }, o.prototype.equalsEpsilon = function (e, t) {
            return o.equalsEpsilon(this, e, t)
        }, o.prototype.toString = function () {
            return "(" + this[0] + ", " + this[2] + ")\n(" + this[1] + ", " + this[3] + ")"
        }, o
    }),define("Cesium/Core/RectangleGeometryLibrary", ["./Cartesian3", "./Cartographic", "./defined", "./DeveloperError", "./GeographicProjection", "./Math", "./Matrix2", "./Rectangle"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        var u = Math.cos, l = Math.sin, c = Math.sqrt, h = {};
        h.computePosition = function (e, t, n, r, o) {
            var s = e.ellipsoid.radiiSquared, h = e.nwCorner, d = e.rectangle, m = h.latitude - e.granYCos * t + n * e.granXSin, p = u(m), f = l(m), _ = s.z * f, v = h.longitude + t * e.granYSin + n * e.granXCos, g = p * u(v), y = p * l(v), C = s.x * g, E = s.y * y, S = c(C * g + E * y + _ * f);
            r.x = C / S, r.y = E / S, r.z = _ / S, i(e.vertexFormat) && e.vertexFormat.st && (o.x = (v - d.west) * e.lonScalar - .5, o.y = (m - d.south) * e.latScalar - .5, a.multiplyByVector(e.textureMatrix, o, o), o.x += .5, o.y += .5)
        };
        var d = new a, m = new e, p = new t, f = new e, _ = new r;
        return h.computeOptions = function (t, r, u) {
            var l, c, h, v, g, y = t._granularity, C = t._ellipsoid, E = t._surfaceHeight, S = t._rotation, T = t._extrudedHeight, b = r.east, w = r.west, x = r.north, A = r.south, P = x - A;
            w > b ? (g = o.TWO_PI - w + b, l = Math.ceil(g / y) + 1, c = Math.ceil(P / y) + 1, h = g / (l - 1), v = P / (c - 1)) : (g = b - w, l = Math.ceil(g / y) + 1, c = Math.ceil(P / y) + 1, h = g / (l - 1), v = P / (c - 1)), u = s.northwest(r, u);
            var I = s.center(r, p), D = v, M = h, O = 0, R = 0;
            if (i(S)) {
                var N = Math.cos(S);
                D *= N, M *= N;
                var L = Math.sin(S);
                O = v * L, R = h * L, m = _.project(u, m), f = _.project(I, f), m = e.subtract(m, f, m);
                var F = a.fromRotation(S, d);
                m = a.multiplyByVector(F, m, m), m = e.add(m, f, m), u = _.unproject(m, u);
                var B = u.latitude, z = B + (l - 1) * R, V = B - D * (c - 1), U = B - D * (c - 1) + (l - 1) * R;
                x = Math.max(B, z, V, U), A = Math.min(B, z, V, U);
                var k = u.longitude, G = k + (l - 1) * M, H = k + (c - 1) * O, W = k + (c - 1) * O + (l - 1) * M;
                if (b = Math.max(k, G, H, W), w = Math.min(k, G, H, W), x < -o.PI_OVER_TWO || x > o.PI_OVER_TWO || A < -o.PI_OVER_TWO || A > o.PI_OVER_TWO)throw new n("Rotated extent is invalid.");
                r.north = x, r.south = A, r.east = b, r.west = w
            }
            return {
                granYCos: D,
                granYSin: O,
                granXCos: M,
                granXSin: R,
                ellipsoid: C,
                width: l,
                height: c,
                surfaceHeight: E,
                extrudedHeight: T,
                nwCorner: u,
                rectangle: r
            }
        }, h
    }),define("Cesium/Core/RectangleOutlineGeometry", ["./BoundingSphere", "./Cartesian3", "./Cartographic", "./ComponentDatatype", "./defaultValue", "./defined", "./DeveloperError", "./Ellipsoid", "./Geometry", "./GeometryAttribute", "./GeometryAttributes", "./IndexDatatype", "./Math", "./PolygonPipeline", "./PrimitiveType", "./Rectangle", "./RectangleGeometryLibrary"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _) {
        "use strict";
        function v(e) {
            var t, i = e.size, r = e.height, o = e.width, a = new Float64Array(3 * i), s = 0, d = 0, m = E;
            for (t = 0; o > t; t++)_.computePosition(e, d, t, m), a[s++] = m.x, a[s++] = m.y, a[s++] = m.z;
            for (t = o - 1, d = 1; r > d; d++)_.computePosition(e, d, t, m), a[s++] = m.x, a[s++] = m.y, a[s++] = m.z;
            for (d = r - 1, t = o - 2; t >= 0; t--)_.computePosition(e, d, t, m), a[s++] = m.x, a[s++] = m.y, a[s++] = m.z;
            for (t = 0, d = r - 2; d > 0; d--)_.computePosition(e, d, t, m), a[s++] = m.x, a[s++] = m.y, a[s++] = m.z;
            for (var f = a.length / 3 * 2, v = h.createTypedArray(a.length / 3, f), g = 0, y = 0; y < a.length / 3 - 1; y++)v[g++] = y, v[g++] = y + 1;
            v[g++] = a.length / 3 - 1, v[g++] = 0;
            var C = new u({attributes: new c, primitiveType: p.LINES});
            return C.attributes.position = new l({
                componentDatatype: n.DOUBLE,
                componentsPerAttribute: 3,
                values: a
            }), C.indices = v, C
        }

        function g(e) {
            var t = e.surfaceHeight, i = e.extrudedHeight, n = e.ellipsoid, r = Math.min(i, t), o = Math.max(i, t), a = v(e);
            if (d.equalsEpsilon(r, o, d.EPSILON10))return a;
            var s = e.height, u = e.width;
            a = m.scaleToGeodeticHeight(a, o, n, !1);
            var l = a.attributes.position.values, c = l.length, p = new Float64Array(2 * c);
            p.set(l), a = m.scaleToGeodeticHeight(a, r, n);
            var f = a.attributes.position.values;
            p.set(f, c), a.attributes.position.values = p;
            var _ = p.length / 3 * 2 + 8, g = h.createTypedArray(p.length / 3, _);
            c = p.length / 6;
            for (var y = 0, C = 0; c - 1 > C; C++)g[y++] = C, g[y++] = C + 1, g[y++] = C + c, g[y++] = C + c + 1;
            return g[y++] = c - 1, g[y++] = 0, g[y++] = c + c - 1, g[y++] = c, g[y++] = 0, g[y++] = c, g[y++] = u - 1, g[y++] = c + u - 1, g[y++] = u + s - 2, g[y++] = u + s - 2 + c, g[y++] = 2 * u + s - 3, g[y++] = 2 * u + s - 3 + c, a.indices = g, a
        }

        var y = new e, C = new e, E = new t, S = new f, T = function (e) {
            e = r(e, r.EMPTY_OBJECT);
            var t = e.rectangle, i = r(e.granularity, d.RADIANS_PER_DEGREE), n = r(e.ellipsoid, s.WGS84), o = r(e.height, 0), a = r(e.rotation, 0), u = e.extrudedHeight;
            this._rectangle = t, this._granularity = i, this._ellipsoid = n, this._surfaceHeight = o, this._rotation = a, this._extrudedHeight = u, this._workerName = "createRectangleOutlineGeometry"
        };
        T.packedLength = f.packedLength + s.packedLength + 5, T.pack = function (e, t, i) {
            i = r(i, 0), f.pack(e._rectangle, t, i), i += f.packedLength, s.pack(e._ellipsoid, t, i), i += s.packedLength, t[i++] = e._granularity, t[i++] = e._surfaceHeight, t[i++] = e._rotation, t[i++] = o(e._extrudedHeight) ? 1 : 0, t[i] = r(e._extrudedHeight, 0)
        };
        var b = new f, w = s.clone(s.UNIT_SPHERE), x = {
            rectangle: b,
            ellipsoid: w,
            granularity: void 0,
            height: void 0,
            rotation: void 0,
            extrudedHeight: void 0
        };
        T.unpack = function (e, t, i) {
            t = r(t, 0);
            var n = f.unpack(e, t, b);
            t += f.packedLength;
            var a = s.unpack(e, t, w);
            t += s.packedLength;
            var u = e[t++], l = e[t++], c = e[t++], h = e[t++], d = e[t];
            return o(i) ? (i._rectangle = f.clone(n, i._rectangle), i._ellipsoid = s.clone(a, i._ellipsoid), i._surfaceHeight = l, i._rotation = c, i._extrudedHeight = h ? d : void 0, i) : (x.granularity = u, x.height = l, x.rotation = c, x.extrudedHeight = h ? d : void 0, new T(x))
        };
        var A = new i;
        return T.createGeometry = function (t) {
            var i = f.clone(t._rectangle, S), n = t._ellipsoid, r = t._surfaceHeight, a = t._extrudedHeight, s = _.computeOptions(t, i, A);
            s.size = 2 * s.width + 2 * s.height - 4;
            var l, c;
            if (i = t._rectangle, o(a)) {
                l = g(s);
                var h = e.fromRectangle3D(i, n, r, C), d = e.fromRectangle3D(i, n, a, y);
                c = e.union(h, d)
            } else l = v(s), l = m.scaleToGeodeticHeight(l, r, n, !1), c = e.fromRectangle3D(i, n, r);
            return new u({attributes: l.attributes, indices: l.indices, primitiveType: p.LINES, boundingSphere: c})
        }, T
    }),define("Cesium/Core/ColorGeometryInstanceAttribute", ["./Color", "./ComponentDatatype", "./defaultValue", "./defined", "./defineProperties", "./DeveloperError"], function (e, t, i, n, r, o) {
        "use strict";
        var a = function (t, n, r, o) {
            t = i(t, 1), n = i(n, 1), r = i(r, 1), o = i(o, 1), this.value = new Uint8Array([e.floatToByte(t), e.floatToByte(n), e.floatToByte(r), e.floatToByte(o)])
        };
        return r(a.prototype, {
            componentDatatype: {
                get: function () {
                    return t.UNSIGNED_BYTE
                }
            }, componentsPerAttribute: {
                get: function () {
                    return 4
                }
            }, normalize: {
                get: function () {
                    return !0
                }
            }
        }), a.fromColor = function (e) {
            return new a(e.red, e.green, e.blue, e.alpha)
        }, a.toValue = function (e, t) {
            return n(t) ? e.toBytes(t) : new Uint8Array(e.toBytes())
        }, a
    }),define("Cesium/Core/GeometryInstance", ["./defaultValue", "./defined", "./DeveloperError", "./Matrix4"], function (e, t, i, n) {
        "use strict";
        var r = function (t) {
            t = e(t, e.EMPTY_OBJECT), this.geometry = t.geometry, this.modelMatrix = n.clone(e(t.modelMatrix, n.IDENTITY)), this.id = t.id, this.pickPrimitive = t.pickPrimitive, this.attributes = e(t.attributes, {}), this.westHemisphereGeometry = void 0, this.eastHemisphereGeometry = void 0
        };
        return r
    }),define("Cesium/Core/BoxOutlineGeometry", ["./BoundingSphere", "./Cartesian3", "./ComponentDatatype", "./defaultValue", "./defined", "./DeveloperError", "./Geometry", "./GeometryAttribute", "./GeometryAttributes", "./PrimitiveType"], function (e, t, i, n, r, o, a, s, u, l) {
        "use strict";
        var c = new t, h = function (e) {
            e = n(e, n.EMPTY_OBJECT);
            var i = e.minimumCorner, r = e.maximumCorner;
            this._min = t.clone(i), this._max = t.clone(r), this._workerName = "createBoxOutlineGeometry"
        };
        h.fromDimensions = function (e) {
            e = n(e, n.EMPTY_OBJECT);
            var i = e.dimensions, r = t.multiplyByScalar(i, .5, new t), o = t.negate(r, new t), a = r, s = {
                minimumCorner: o,
                maximumCorner: a
            };
            return new h(s)
        }, h.packedLength = 2 * t.packedLength, h.pack = function (e, i, r) {
            r = n(r, 0), t.pack(e._min, i, r), t.pack(e._max, i, r + t.packedLength)
        };
        var d = new t, m = new t, p = {minimumCorner: d, maximumCorner: m};
        return h.unpack = function (e, i, o) {
            i = n(i, 0);
            var a = t.unpack(e, i, d), s = t.unpack(e, i + t.packedLength, m);
            return r(o) ? (o._min = t.clone(a, o._min), o._max = t.clone(s, o._max), o) : new h(p)
        }, h.createGeometry = function (n) {
            var r = n._min, o = n._max, h = new u, d = new Uint16Array(24), m = new Float64Array(24);
            m[0] = r.x, m[1] = r.y, m[2] = r.z, m[3] = o.x, m[4] = r.y, m[5] = r.z, m[6] = o.x, m[7] = o.y, m[8] = r.z, m[9] = r.x, m[10] = o.y, m[11] = r.z, m[12] = r.x, m[13] = r.y, m[14] = o.z, m[15] = o.x, m[16] = r.y, m[17] = o.z, m[18] = o.x, m[19] = o.y, m[20] = o.z, m[21] = r.x, m[22] = o.y, m[23] = o.z, h.position = new s({
                componentDatatype: i.DOUBLE,
                componentsPerAttribute: 3,
                values: m
            }), d[0] = 4, d[1] = 5, d[2] = 5, d[3] = 6, d[4] = 6, d[5] = 7, d[6] = 7, d[7] = 4, d[8] = 0, d[9] = 1, d[10] = 1, d[11] = 2, d[12] = 2, d[13] = 3, d[14] = 3, d[15] = 0, d[16] = 0, d[17] = 4, d[18] = 1, d[19] = 5, d[20] = 2, d[21] = 6, d[22] = 3, d[23] = 7;
            var p = t.subtract(o, r, c), f = .5 * t.magnitude(p);
            return new a({attributes: h, indices: d, primitiveType: l.LINES, boundingSphere: new e(t.ZERO, f)})
        }, h
    }),define("Cesium/Core/OrientedBoundingBox", ["./BoundingSphere", "./Cartesian2", "./Cartesian3", "./Cartographic", "./defaultValue", "./defined", "./DeveloperError", "./Ellipsoid", "./EllipsoidTangentPlane", "./Intersect", "./Interval", "./Plane", "./Rectangle", "./Math", "./Matrix3"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p) {
        "use strict";
        var f = function (e, t) {
            this.center = i.clone(r(e, i.ZERO)), this.halfAxes = p.clone(r(t, p.ZERO))
        }, _ = new i, v = new i, g = new i, y = new i, C = new i, E = new p, S = {unitary: new p, diagonal: new p};
        f.fromPoints = function (e, t) {
            if (o(t) || (t = new f), !o(e) || 0 === e.length)return t.halfAxes = p.ZERO, t.center = i.ZERO, t;
            var n, r = e.length, a = i.clone(e[0], _);
            for (n = 1; r > n; n++)i.add(a, e[n], a);
            var s = 1 / r;
            i.multiplyByScalar(a, s, a);
            var u, l = 0, c = 0, h = 0, d = 0, m = 0, T = 0;
            for (n = 0; r > n; n++)u = i.subtract(e[n], a, v), l += u.x * u.x, c += u.x * u.y, h += u.x * u.z, d += u.y * u.y, m += u.y * u.z, T += u.z * u.z;
            l *= s, c *= s, h *= s, d *= s, m *= s, T *= s;
            var b = E;
            b[0] = l, b[1] = c, b[2] = h, b[3] = c, b[4] = d, b[5] = m, b[6] = h, b[7] = m, b[8] = T;
            var w = p.computeEigenDecomposition(b, S), x = p.transpose(w.unitary, t.halfAxes);
            u = i.subtract(e[0], a, v);
            var A = p.multiplyByVector(x, u, g), P = i.clone(A, y), I = i.clone(A, C);
            for (n = 1; r > n; n++)u = i.subtract(e[n], a, u), p.multiplyByVector(x, u, A), i.minimumByComponent(I, A, I), i.maximumByComponent(P, A, P);
            var D = i.add(I, P, g);
            i.multiplyByScalar(D, .5, D), p.multiplyByVector(x, D, D), i.add(a, D, t.center);
            var M = i.subtract(P, I, g);
            return i.multiplyByScalar(M, .5, M), p.multiplyByScale(t.halfAxes, M, t.halfAxes), t
        };
        var T = new i, b = new i, w = function (e, t, n, r, a, s, u, l) {
            o(l) || (l = new f);
            var c = l.halfAxes;
            p.setColumn(c, 0, e.xAxis, c), p.setColumn(c, 1, e.yAxis, c), p.setColumn(c, 2, e.zAxis, c);
            var h = T;
            h.x = (t + n) / 2, h.y = (r + a) / 2, h.z = (s + u) / 2;
            var d = b;
            d.x = (n - t) / 2, d.y = (a - r) / 2, d.z = (u - s) / 2;
            var m = l.center;
            return h = p.multiplyByVector(c, h, h), i.add(e.origin, h, m), p.multiplyByScale(c, d, c), l
        }, x = new n, A = new i, P = [new n, new n, new n, new n, new n, new n, new n, new n], I = [new i, new i, new i, new i, new i, new i, new i, new i], D = [new t, new t, new t, new t, new t, new t, new t, new t];
        f.fromRectangle = function (e, t, i, n, o) {
            t = r(t, 0), i = r(i, 0), n = r(n, s.WGS84);
            var a = d.center(e, x), l = n.cartographicToCartesian(a, A), c = new u(l, n), m = c.plane, p = P[0], f = P[1], _ = P[2], v = P[3], g = P[4], y = P[5], C = P[6], E = P[7], S = a.longitude, T = e.south < 0 && e.north > 0 ? 0 : a.latitude;
            C.latitude = y.latitude = g.latitude = e.south, E.latitude = v.latitude = T, p.latitude = f.latitude = _.latitude = e.north, C.longitude = E.longitude = p.longitude = e.west, y.longitude = f.longitude = S, g.longitude = v.longitude = _.longitude = e.east, _.height = f.height = p.height = E.height = C.height = y.height = g.height = v.height = i, n.cartographicArrayToCartesianArray(P, I), c.projectPointsToNearestOnPlane(I, D);
            var b = Math.min(D[6].x, D[7].x, D[0].x), M = Math.max(D[2].x, D[3].x, D[4].x), O = Math.min(D[4].y, D[5].y, D[6].y), R = Math.max(D[0].y, D[1].y, D[2].y);
            _.height = p.height = g.height = C.height = t, n.cartographicArrayToCartesianArray(P, I);
            var N = Math.min(h.getPointDistance(m, I[0]), h.getPointDistance(m, I[2]), h.getPointDistance(m, I[4]), h.getPointDistance(m, I[6])), L = i;
            return w(c, b, M, O, R, N, L, o)
        }, f.clone = function (e, t) {
            return o(e) ? o(t) ? (i.clone(e.center, t.center), p.clone(e.halfAxes, t.halfAxes), t) : new f(e.center, e.halfAxes) : void 0
        }, f.intersectPlane = function (e, t) {
            var n = e.center, r = t.normal, o = e.halfAxes, a = r.x, s = r.y, u = r.z, c = Math.abs(a * o[p.COLUMN0ROW0] + s * o[p.COLUMN0ROW1] + u * o[p.COLUMN0ROW2]) + Math.abs(a * o[p.COLUMN1ROW0] + s * o[p.COLUMN1ROW1] + u * o[p.COLUMN1ROW2]) + Math.abs(a * o[p.COLUMN2ROW0] + s * o[p.COLUMN2ROW1] + u * o[p.COLUMN2ROW2]), h = i.dot(r, n) + t.distance;
            return -c >= h ? l.OUTSIDE : h >= c ? l.INSIDE : l.INTERSECTING
        };
        var M = new i, O = new i, R = new i, N = new i;
        f.distanceSquaredTo = function (e, t) {
            var n = i.subtract(t, e.center, T), r = e.halfAxes, o = p.getColumn(r, 0, M), a = p.getColumn(r, 1, O), s = p.getColumn(r, 2, R), u = i.magnitude(o), l = i.magnitude(a), c = i.magnitude(s);
            i.normalize(o, o), i.normalize(a, a), i.normalize(s, s);
            var h = N;
            h.x = i.dot(n, o), h.y = i.dot(n, a), h.z = i.dot(n, s);
            var d, m = 0;
            return h.x < -u ? (d = h.x + u, m += d * d) : h.x > u && (d = h.x - u, m += d * d), h.y < -l ? (d = h.y + l, m += d * d) : h.y > l && (d = h.y - l, m += d * d), h.z < -c ? (d = h.z + c, m += d * d) : h.z > c && (d = h.z - c, m += d * d), m
        };
        var L = new i, F = new i;
        new i;
        f.computePlaneDistances = function (e, t, n, r) {
            o(r) || (r = new c);
            var a = Number.POSITIVE_INFINITY, s = Number.NEGATIVE_INFINITY, u = e.center, l = e.halfAxes, h = p.getColumn(l, 0, M), d = p.getColumn(l, 1, O), m = p.getColumn(l, 2, R), f = i.add(h, d, L);
            i.add(f, m, f), i.add(f, u, f);
            var _ = i.subtract(f, t, F), v = i.dot(n, _);
            return a = Math.min(v, a), s = Math.max(v, s), i.add(u, h, f), i.add(f, d, f), i.subtract(f, m, f), i.subtract(f, t, _), v = i.dot(n, _), a = Math.min(v, a), s = Math.max(v, s),
                i.add(u, h, f), i.subtract(f, d, f), i.add(f, m, f), i.subtract(f, t, _), v = i.dot(n, _), a = Math.min(v, a), s = Math.max(v, s), i.add(u, h, f), i.subtract(f, d, f), i.subtract(f, m, f), i.subtract(f, t, _), v = i.dot(n, _), a = Math.min(v, a), s = Math.max(v, s), i.subtract(u, h, f), i.add(f, d, f), i.add(f, m, f), i.subtract(f, t, _), v = i.dot(n, _), a = Math.min(v, a), s = Math.max(v, s), i.subtract(u, h, f), i.add(f, d, f), i.subtract(f, m, f), i.subtract(f, t, _), v = i.dot(n, _), a = Math.min(v, a), s = Math.max(v, s), i.subtract(u, h, f), i.subtract(f, d, f), i.add(f, m, f), i.subtract(f, t, _), v = i.dot(n, _), a = Math.min(v, a), s = Math.max(v, s), i.subtract(u, h, f), i.subtract(f, d, f), i.subtract(f, m, f), i.subtract(f, t, _), v = i.dot(n, _), a = Math.min(v, a), s = Math.max(v, s), r.start = a, r.stop = s, r
        };
        var B = new e;
        return f.isOccluded = function (e, t) {
            var n = e.halfAxes, r = p.getColumn(n, 0, M), o = p.getColumn(n, 1, O), a = p.getColumn(n, 2, R), s = i.magnitude(r), u = i.magnitude(o), l = i.magnitude(a), c = B;
            return c.center = i.clone(e.center, c.center), c.radius = Math.max(s, u, l), !t.isBoundingSphereVisible(c)
        }, f.prototype.intersectPlane = function (e) {
            return f.intersectPlane(this, e)
        }, f.prototype.distanceSquaredTo = function (e) {
            return f.distanceSquaredTo(this, e)
        }, f.prototype.computePlaneDistances = function (e, t, i) {
            return f.computePlaneDistances(this, e, t, i)
        }, f.prototype.isOccluded = function (e) {
            return f.isOccluded(this, e)
        }, f.equals = function (e, t) {
            return e === t || o(e) && o(t) && i.equals(e.center, t.center) && p.equals(e.halfAxes, t.halfAxes)
        }, f.prototype.clone = function (e) {
            return f.clone(this, e)
        }, f.prototype.equals = function (e) {
            return f.equals(this, e)
        }, f
    }),define("Cesium/Core/combine", ["./defaultValue", "./defined"], function (e, t) {
        "use strict";
        var i = function (n, r, o) {
            o = e(o, !1);
            var a, s, u, l = {}, c = t(n), h = t(r);
            if (c)for (a in n)n.hasOwnProperty(a) && (s = n[a], h && o && "object" == typeof s && r.hasOwnProperty(a) ? (u = r[a], "object" == typeof u ? l[a] = i(s, u, o) : l[a] = s) : l[a] = s);
            if (h)for (a in r)r.hasOwnProperty(a) && !l.hasOwnProperty(a) && (u = r[a], l[a] = u);
            return l
        };
        return i
    }),define("Cesium/Core/getStringFromTypedArray", ["./defined", "./DeveloperError"], function (e, t) {
        "use strict";
        var i = function (e) {
            return i.decode(e)
        };
        return i.decodeWithTextDecoder = function (e) {
            var t = new TextDecoder("utf-8");
            return t.decode(e)
        }, i.decodeWithFromCharCode = function (e) {
            for (var t = "", i = e.length, n = 0; i > n; ++n)t += String.fromCharCode(e[n]);
            return t
        }, "undefined" != typeof TextDecoder ? i.decode = i.decodeWithTextDecoder : i.decode = i.decodeWithFromCharCode, i
    }),define("Cesium/Core/loadArrayBuffer", ["./loadWithXhr"], function (e) {
        "use strict";
        var t = function (t, i) {
            return e({url: t, responseType: "arraybuffer", headers: i})
        };
        return t
    }),define("Cesium/Core/PixelFormat", ["../Renderer/WebGLConstants", "./freezeObject"], function (e, t) {
        "use strict";
        var i = {
            DEPTH_COMPONENT: e.DEPTH_COMPONENT,
            DEPTH_STENCIL: e.DEPTH_STENCIL,
            ALPHA: e.ALPHA,
            RGB: e.RGB,
            RGBA: e.RGBA,
            LUMINANCE: e.LUMINANCE,
            LUMINANCE_ALPHA: e.LUMINANCE_ALPHA,
            validate: function (e) {
                return e === i.DEPTH_COMPONENT || e === i.DEPTH_STENCIL || e === i.ALPHA || e === i.RGB || e === i.RGBA || e === i.LUMINANCE || e === i.LUMINANCE_ALPHA
            },
            isColorFormat: function (e) {
                return e === i.ALPHA || e === i.RGB || e === i.RGBA || e === i.LUMINANCE || e === i.LUMINANCE_ALPHA
            },
            isDepthFormat: function (e) {
                return e === i.DEPTH_COMPONENT || e === i.DEPTH_STENCIL
            }
        };
        return t(i)
    }),define("Cesium/Shaders/ViewportQuadVS", [], function () {
        "use strict";
        return "attribute vec4 position;\nattribute vec2 textureCoordinates;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main() \n{\n    gl_Position = position;\n    v_textureCoordinates = textureCoordinates;\n}"
    }),define("Cesium/Renderer/BufferUsage", ["../Core/freezeObject", "./WebGLConstants"], function (e, t) {
        "use strict";
        var i = {
            STREAM_DRAW: t.STREAM_DRAW,
            STATIC_DRAW: t.STATIC_DRAW,
            DYNAMIC_DRAW: t.DYNAMIC_DRAW,
            validate: function (e) {
                return e === i.STREAM_DRAW || e === i.STATIC_DRAW || e === i.DYNAMIC_DRAW
            }
        };
        return e(i)
    }),define("Cesium/Renderer/ClearCommand", ["../Core/Color", "../Core/defaultValue", "../Core/freezeObject"], function (e, t, i) {
        "use strict";
        var n = function (e) {
            e = t(e, t.EMPTY_OBJECT), this.color = e.color, this.depth = e.depth, this.stencil = e.stencil, this.renderState = e.renderState, this.framebuffer = e.framebuffer, this.owner = e.owner
        };
        return n.ALL = i(new n({
            color: new e(0, 0, 0, 0),
            depth: 1,
            stencil: 0
        })), n.prototype.execute = function (e, t) {
            e.clear(this, t)
        }, n
    }),define("Cesium/Renderer/ContextLimits", ["../Core/defineProperties"], function (e) {
        "use strict";
        var t = {
            _maximumCombinedTextureImageUnits: 0,
            _maximumCubeMapSize: 0,
            _maximumFragmentUniformVectors: 0,
            _maximumTextureImageUnits: 0,
            _maximumRenderbufferSize: 0,
            _maximumTextureSize: 0,
            _maximumVaryingVectors: 0,
            _maximumVertexAttributes: 0,
            _maximumVertexTextureImageUnits: 0,
            _maximumVertexUniformVectors: 0,
            _minimumAliasedLineWidth: 0,
            _maximumAliasedLineWidth: 0,
            _minimumAliasedPointSize: 0,
            _maximumAliasedPointSize: 0,
            _maximumViewportWidth: 0,
            _maximumViewportHeight: 0,
            _maximumTextureFilterAnisotropy: 0,
            _maximumDrawBuffers: 0,
            _maximumColorAttachments: 0,
            _highpFloatSupported: !1,
            _highpIntSupported: !1
        };
        return e(t, {
            maximumCombinedTextureImageUnits: {
                get: function () {
                    return t._maximumCombinedTextureImageUnits
                }
            }, maximumCubeMapSize: {
                get: function () {
                    return t._maximumCubeMapSize
                }
            }, maximumFragmentUniformVectors: {
                get: function () {
                    return t._maximumFragmentUniformVectors
                }
            }, maximumTextureImageUnits: {
                get: function () {
                    return t._maximumTextureImageUnits
                }
            }, maximumRenderbufferSize: {
                get: function () {
                    return t._maximumRenderbufferSize
                }
            }, maximumTextureSize: {
                get: function () {
                    return t._maximumTextureSize
                }
            }, maximumVaryingVectors: {
                get: function () {
                    return t._maximumVaryingVectors
                }
            }, maximumVertexAttributes: {
                get: function () {
                    return t._maximumVertexAttributes
                }
            }, maximumVertexTextureImageUnits: {
                get: function () {
                    return t._maximumVertexTextureImageUnits
                }
            }, maximumVertexUniformVectors: {
                get: function () {
                    return t._maximumVertexUniformVectors
                }
            }, minimumAliasedLineWidth: {
                get: function () {
                    return t._minimumAliasedLineWidth
                }
            }, maximumAliasedLineWidth: {
                get: function () {
                    return t._maximumAliasedLineWidth
                }
            }, minimumAliasedPointSize: {
                get: function () {
                    return t._minimumAliasedPointSize
                }
            }, maximumAliasedPointSize: {
                get: function () {
                    return t._maximumAliasedPointSize
                }
            }, maximumViewportWidth: {
                get: function () {
                    return t._maximumViewportWidth
                }
            }, maximumViewportHeight: {
                get: function () {
                    return t._maximumViewportHeight
                }
            }, maximumTextureFilterAnisotropy: {
                get: function () {
                    return t._maximumTextureFilterAnisotropy
                }
            }, maximumDrawBuffers: {
                get: function () {
                    return t._maximumDrawBuffers
                }
            }, maximumColorAttachments: {
                get: function () {
                    return t._maximumColorAttachments
                }
            }, highpFloatSupported: {
                get: function () {
                    return t._highpFloatSupported
                }
            }, highpIntSupported: {
                get: function () {
                    return t._highpIntSupported
                }
            }
        }), t
    }),define("Cesium/Renderer/PixelDatatype", ["../Core/freezeObject", "./WebGLConstants"], function (e, t) {
        "use strict";
        var i = {
            UNSIGNED_BYTE: t.UNSIGNED_BYTE,
            UNSIGNED_SHORT: t.UNSIGNED_SHORT,
            UNSIGNED_INT: t.UNSIGNED_INT,
            FLOAT: t.FLOAT,
            UNSIGNED_INT_24_8_WEBGL: t.UNSIGNED_INT_24_8_WEBGL,
            UNSIGNED_SHORT_4_4_4_4: t.UNSIGNED_SHORT_4_4_4_4,
            UNSIGNED_SHORT_5_5_5_1: t.UNSIGNED_SHORT_5_5_5_1,
            UNSIGNED_SHORT_5_6_5: t.UNSIGNED_SHORT_5_6_5,
            validate: function (e) {
                return e === i.UNSIGNED_BYTE || e === i.UNSIGNED_SHORT || e === i.UNSIGNED_INT || e === i.FLOAT || e === i.UNSIGNED_INT_24_8_WEBGL || e === i.UNSIGNED_SHORT_4_4_4_4 || e === i.UNSIGNED_SHORT_5_5_5_1 || e === i.UNSIGNED_SHORT_5_6_5
            }
        };
        return e(i)
    }),define("Cesium/Renderer/CubeMapFace", ["../Core/defaultValue", "../Core/defineProperties", "../Core/DeveloperError", "./PixelDatatype"], function (e, t, i, n) {
        "use strict";
        var r = function (e, t, i, n, r, o, a, s, u) {
            this._gl = e, this._texture = t, this._textureTarget = i, this._targetFace = n, this._pixelFormat = r, this._pixelDatatype = o, this._size = a, this._preMultiplyAlpha = s, this._flipY = u
        };
        return t(r.prototype, {
            pixelFormat: {
                get: function () {
                    return this._pixelFormat
                }
            }, pixelDatatype: {
                get: function () {
                    return this._pixelDatatype
                }
            }, _target: {
                get: function () {
                    return this._targetFace
                }
            }
        }), r.prototype.copyFrom = function (t, i, n) {
            i = e(i, 0), n = e(n, 0);
            var r = this._gl, o = this._textureTarget;
            r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._preMultiplyAlpha), r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, this._flipY), r.activeTexture(r.TEXTURE0), r.bindTexture(o, this._texture), t.arrayBufferView ? r.texSubImage2D(this._targetFace, 0, i, n, t.width, t.height, this._pixelFormat, this._pixelDatatype, t.arrayBufferView) : r.texSubImage2D(this._targetFace, 0, i, n, this._pixelFormat, this._pixelDatatype, t), r.bindTexture(o, null)
        }, r.prototype.copyFromFramebuffer = function (t, i, n, r, o, a) {
            t = e(t, 0), i = e(i, 0), n = e(n, 0), r = e(r, 0), o = e(o, this._size), a = e(a, this._size);
            var s = this._gl, u = this._textureTarget;
            s.activeTexture(s.TEXTURE0), s.bindTexture(u, this._texture), s.copyTexSubImage2D(this._targetFace, 0, t, i, n, r, o, a), s.bindTexture(u, null)
        }, r
    }),define("Cesium/Renderer/MipmapHint", ["../Core/freezeObject", "./WebGLConstants"], function (e, t) {
        "use strict";
        var i = {
            DONT_CARE: t.DONT_CARE, FASTEST: t.FASTEST, NICEST: t.NICEST, validate: function (e) {
                return e === i.DONT_CARE || e === i.FASTEST || e === i.NICEST
            }
        };
        return e(i)
    }),define("Cesium/Renderer/TextureMagnificationFilter", ["../Core/freezeObject", "./WebGLConstants"], function (e, t) {
        "use strict";
        var i = {
            NEAREST: t.NEAREST, LINEAR: t.LINEAR, validate: function (e) {
                return e === i.NEAREST || e === i.LINEAR
            }
        };
        return e(i)
    }),define("Cesium/Renderer/TextureMinificationFilter", ["../Core/freezeObject", "./WebGLConstants"], function (e, t) {
        "use strict";
        var i = {
            NEAREST: t.NEAREST,
            LINEAR: t.LINEAR,
            NEAREST_MIPMAP_NEAREST: t.NEAREST_MIPMAP_NEAREST,
            LINEAR_MIPMAP_NEAREST: t.LINEAR_MIPMAP_NEAREST,
            NEAREST_MIPMAP_LINEAR: t.NEAREST_MIPMAP_LINEAR,
            LINEAR_MIPMAP_LINEAR: t.LINEAR_MIPMAP_LINEAR,
            validate: function (e) {
                return e === i.NEAREST || e === i.LINEAR || e === i.NEAREST_MIPMAP_NEAREST || e === i.LINEAR_MIPMAP_NEAREST || e === i.NEAREST_MIPMAP_LINEAR || e === i.LINEAR_MIPMAP_LINEAR
            }
        };
        return e(i)
    }),define("Cesium/Renderer/TextureWrap", ["../Core/freezeObject", "./WebGLConstants"], function (e, t) {
        "use strict";
        var i = {
            CLAMP_TO_EDGE: t.CLAMP_TO_EDGE,
            REPEAT: t.REPEAT,
            MIRRORED_REPEAT: t.MIRRORED_REPEAT,
            validate: function (e) {
                return e === i.CLAMP_TO_EDGE || e === i.REPEAT || e === i.MIRRORED_REPEAT
            }
        };
        return e(i)
    }),define("Cesium/Renderer/Sampler", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "./TextureMagnificationFilter", "./TextureMinificationFilter", "./TextureWrap"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = function (i) {
            i = e(i, e.EMPTY_OBJECT);
            var n = e(i.wrapS, a.CLAMP_TO_EDGE), s = e(i.wrapT, a.CLAMP_TO_EDGE), u = e(i.minificationFilter, o.LINEAR), l = e(i.magnificationFilter, r.LINEAR), c = t(i.maximumAnisotropy) ? i.maximumAnisotropy : 1;
            this._wrapS = n, this._wrapT = s, this._minificationFilter = u, this._magnificationFilter = l, this._maximumAnisotropy = c
        };
        return i(s.prototype, {
            wrapS: {
                get: function () {
                    return this._wrapS
                }
            }, wrapT: {
                get: function () {
                    return this._wrapT
                }
            }, minificationFilter: {
                get: function () {
                    return this._minificationFilter
                }
            }, magnificationFilter: {
                get: function () {
                    return this._magnificationFilter
                }
            }, maximumAnisotropy: {
                get: function () {
                    return this._maximumAnisotropy
                }
            }
        }), s
    }),define("Cesium/Renderer/CubeMap", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Math", "../Core/PixelFormat", "./ContextLimits", "./CubeMapFace", "./MipmapHint", "./PixelDatatype", "./Sampler", "./TextureMagnificationFilter", "./TextureMinificationFilter", "./TextureWrap"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p) {
        "use strict";
        var f = function (i) {
            function n(e, t) {
                t.arrayBufferView ? g.texImage2D(e, 0, p, m, m, 0, p, f, t.arrayBufferView) : g.texImage2D(e, 0, p, p, f, t)
            }

            i = e(i, e.EMPTY_OBJECT);
            var r, o, s = i.context, l = i.source;
            if (t(l)) {
                var d = [l.positiveX, l.negativeX, l.positiveY, l.negativeY, l.positiveZ, l.negativeZ];
                r = d[0].width, o = d[0].height
            } else r = i.width, o = i.height;
            var m = r, p = e(i.pixelFormat, a.RGBA), f = e(i.pixelDatatype, c.UNSIGNED_BYTE), _ = i.preMultiplyAlpha || p === a.RGB || p === a.LUMINANCE, v = e(i.flipY, !0), g = s._gl, y = g.TEXTURE_CUBE_MAP, C = g.createTexture();
            g.activeTexture(g.TEXTURE0), g.bindTexture(y, C), t(l) ? (g.pixelStorei(g.UNPACK_PREMULTIPLY_ALPHA_WEBGL, _), g.pixelStorei(g.UNPACK_FLIP_Y_WEBGL, v), n(g.TEXTURE_CUBE_MAP_POSITIVE_X, l.positiveX), n(g.TEXTURE_CUBE_MAP_NEGATIVE_X, l.negativeX), n(g.TEXTURE_CUBE_MAP_POSITIVE_Y, l.positiveY), n(g.TEXTURE_CUBE_MAP_NEGATIVE_Y, l.negativeY), n(g.TEXTURE_CUBE_MAP_POSITIVE_Z, l.positiveZ), n(g.TEXTURE_CUBE_MAP_NEGATIVE_Z, l.negativeZ)) : (g.texImage2D(g.TEXTURE_CUBE_MAP_POSITIVE_X, 0, p, m, m, 0, p, f, null), g.texImage2D(g.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, p, m, m, 0, p, f, null), g.texImage2D(g.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, p, m, m, 0, p, f, null), g.texImage2D(g.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, p, m, m, 0, p, f, null), g.texImage2D(g.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, p, m, m, 0, p, f, null), g.texImage2D(g.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, p, m, m, 0, p, f, null)), g.bindTexture(y, null), this._gl = g, this._textureFilterAnisotropic = s._textureFilterAnisotropic, this._textureTarget = y, this._texture = C, this._pixelFormat = p, this._pixelDatatype = f, this._size = m, this._preMultiplyAlpha = _, this._flipY = v, this._sampler = void 0, this._positiveX = new u(g, C, y, g.TEXTURE_CUBE_MAP_POSITIVE_X, p, f, m, _, v), this._negativeX = new u(g, C, y, g.TEXTURE_CUBE_MAP_NEGATIVE_X, p, f, m, _, v), this._positiveY = new u(g, C, y, g.TEXTURE_CUBE_MAP_POSITIVE_Y, p, f, m, _, v), this._negativeY = new u(g, C, y, g.TEXTURE_CUBE_MAP_NEGATIVE_Y, p, f, m, _, v), this._positiveZ = new u(g, C, y, g.TEXTURE_CUBE_MAP_POSITIVE_Z, p, f, m, _, v), this._negativeZ = new u(g, C, y, g.TEXTURE_CUBE_MAP_NEGATIVE_Z, p, f, m, _, v), this.sampler = new h
        };
        return i(f.prototype, {
            positiveX: {
                get: function () {
                    return this._positiveX
                }
            }, negativeX: {
                get: function () {
                    return this._negativeX
                }
            }, positiveY: {
                get: function () {
                    return this._positiveY
                }
            }, negativeY: {
                get: function () {
                    return this._negativeY
                }
            }, positiveZ: {
                get: function () {
                    return this._positiveZ
                }
            }, negativeZ: {
                get: function () {
                    return this._negativeZ
                }
            }, sampler: {
                get: function () {
                    return this._sampler
                }, set: function (e) {
                    var i = e.minificationFilter, n = e.magnificationFilter, r = i === m.NEAREST_MIPMAP_NEAREST || i === m.NEAREST_MIPMAP_LINEAR || i === m.LINEAR_MIPMAP_NEAREST || i === m.LINEAR_MIPMAP_LINEAR;
                    this._pixelDatatype === c.FLOAT && (i = r ? m.NEAREST_MIPMAP_NEAREST : m.NEAREST, n = d.NEAREST);
                    var o = this._gl, a = this._textureTarget;
                    o.activeTexture(o.TEXTURE0), o.bindTexture(a, this._texture), o.texParameteri(a, o.TEXTURE_MIN_FILTER, i), o.texParameteri(a, o.TEXTURE_MAG_FILTER, n), o.texParameteri(a, o.TEXTURE_WRAP_S, e.wrapS), o.texParameteri(a, o.TEXTURE_WRAP_T, e.wrapT), t(this._textureFilterAnisotropic) && o.texParameteri(a, this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, e.maximumAnisotropy), o.bindTexture(a, null), this._sampler = e
                }
            }, pixelFormat: {
                get: function () {
                    return this._pixelFormat
                }
            }, pixelDatatype: {
                get: function () {
                    return this._pixelDatatype
                }
            }, width: {
                get: function () {
                    return this._size
                }
            }, height: {
                get: function () {
                    return this._size
                }
            }, preMultiplyAlpha: {
                get: function () {
                    return this._preMultiplyAlpha
                }
            }, flipY: {
                get: function () {
                    return this._flipY
                }
            }, _target: {
                get: function () {
                    return this._textureTarget
                }
            }
        }), f.prototype.generateMipmap = function (t) {
            t = e(t, l.DONT_CARE);
            var i = this._gl, n = this._textureTarget;
            i.hint(i.GENERATE_MIPMAP_HINT, t), i.activeTexture(i.TEXTURE0), i.bindTexture(n, this._texture), i.generateMipmap(n), i.bindTexture(n, null)
        }, f.prototype.isDestroyed = function () {
            return !1
        }, f.prototype.destroy = function () {
            return this._gl.deleteTexture(this._texture), this._positiveX = n(this._positiveX), this._negativeX = n(this._negativeX), this._positiveY = n(this._positiveY), this._negativeY = n(this._negativeY), this._positiveZ = n(this._positiveZ), this._negativeZ = n(this._negativeZ), n(this)
        }, f
    }),define("Cesium/Renderer/DrawCommand", ["../Core/defaultValue", "../Core/PrimitiveType"], function (e, t) {
        "use strict";
        var i = function (i) {
            i = e(i, e.EMPTY_OBJECT), this.boundingVolume = i.boundingVolume, this.orientedBoundingBox = i.orientedBoundingBox, this.cull = e(i.cull, !0), this.modelMatrix = i.modelMatrix, this.primitiveType = e(i.primitiveType, t.TRIANGLES), this.vertexArray = i.vertexArray, this.count = i.count, this.offset = e(i.offset, 0), this.shaderProgram = i.shaderProgram, this.uniformMap = i.uniformMap, this.renderState = i.renderState, this.framebuffer = i.framebuffer, this.pass = i.pass, this.executeInClosestFrustum = e(i.executeInClosestFrustum, !1), this.owner = i.owner, this.debugShowBoundingVolume = e(i.debugShowBoundingVolume, !1), this.debugOverlappingFrustums = 0, this.oit = void 0
        };
        return i.prototype.execute = function (e, t, i, n) {
            e.draw(this, t, i, n)
        }, i
    }),define("Cesium/Renderer/PassState", [], function () {
        "use strict";
        var e = function (e) {
            this.context = e, this.framebuffer = void 0, this.blendingEnabled = void 0, this.scissorTest = void 0
        };
        return e
    }),define("Cesium/Core/BoundingRectangle", ["./Cartesian2", "./Cartographic", "./defaultValue", "./defined", "./DeveloperError", "./GeographicProjection", "./Intersect", "./Rectangle"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        var u = function (e, t, n, r) {
            this.x = i(e, 0), this.y = i(t, 0), this.width = i(n, 0), this.height = i(r, 0)
        };
        u.fromPoints = function (e, t) {
            if (n(t) || (t = new u), !n(e) || 0 === e.length)return t.x = 0, t.y = 0, t.width = 0, t.height = 0, t;
            for (var i = e.length, r = e[0].x, o = e[0].y, a = e[0].x, s = e[0].y, l = 1; i > l; l++) {
                var c = e[l], h = c.x, d = c.y;
                r = Math.min(h, r), a = Math.max(h, a), o = Math.min(d, o), s = Math.max(d, s)
            }
            return t.x = r, t.y = o, t.width = a - r, t.height = s - o, t
        };
        var l = new o, c = new t, h = new t;
        return u.fromRectangle = function (t, r, o) {
            if (n(o) || (o = new u), !n(t))return o.x = 0, o.y = 0, o.width = 0, o.height = 0, o;
            r = i(r, l);
            var a = r.project(s.southwest(t, c)), d = r.project(s.northeast(t, h));
            return e.subtract(d, a, d), o.x = a.x, o.y = a.y, o.width = d.x, o.height = d.y, o
        }, u.clone = function (e, t) {
            return n(e) ? n(t) ? (t.x = e.x, t.y = e.y, t.width = e.width, t.height = e.height, t) : new u(e.x, e.y, e.width, e.height) : void 0
        }, u.union = function (e, t, i) {
            n(i) || (i = new u);
            var r = Math.min(e.x, t.x), o = Math.min(e.y, t.y), a = Math.max(e.x + e.width, t.x + t.width), s = Math.max(e.y + e.height, t.y + t.height);
            return i.x = r, i.y = o, i.width = a - r, i.height = s - o, i
        }, u.expand = function (e, t, i) {
            i = u.clone(e, i);
            var n = t.x - i.x, r = t.y - i.y;
            return n > i.width ? i.width = n : 0 > n && (i.width -= n, i.x = t.x), r > i.height ? i.height = r : 0 > r && (i.height -= r, i.y = t.y), i
        }, u.intersect = function (e, t) {
            var i = e.x, n = e.y, r = t.x, o = t.y;
            return i > r + t.width || i + e.width < r || n + e.height < o || n > o + t.height ? a.OUTSIDE : a.INTERSECTING
        }, u.equals = function (e, t) {
            return e === t || n(e) && n(t) && e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height
        }, u.prototype.clone = function (e) {
            return u.clone(this, e)
        }, u.prototype.intersect = function (e) {
            return u.intersect(this, e)
        }, u.prototype.equals = function (e) {
            return u.equals(this, e)
        }, u
    }),define("Cesium/Renderer/Framebuffer", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/PixelFormat", "./ContextLimits"], function (e, t, i, n, r, o, a) {
        "use strict";
        function s(e, t, i) {
            var n = e._gl;
            n.framebufferTexture2D(n.FRAMEBUFFER, t, i._target, i._texture, 0)
        }

        function u(e, t, i) {
            var n = e._gl;
            n.framebufferRenderbuffer(n.FRAMEBUFFER, t, n.RENDERBUFFER, i._getRenderbuffer())
        }

        var l = function (i) {
            i = e(i, e.EMPTY_OBJECT);
            var n = i.context._gl;
            a.maximumColorAttachments;
            this._gl = n, this._framebuffer = n.createFramebuffer(), this._colorTextures = [], this._colorRenderbuffers = [], this._activeColorAttachments = [], this._depthTexture = void 0, this._depthRenderbuffer = void 0, this._stencilRenderbuffer = void 0, this._depthStencilTexture = void 0, this._depthStencilRenderbuffer = void 0, this.destroyAttachments = e(i.destroyAttachments, !0);
            t(i.depthTexture) || t(i.depthRenderbuffer), t(i.depthStencilTexture) || t(i.depthStencilRenderbuffer);
            this._bind();
            var r, o, l, c, h;
            if (t(i.colorTextures)) {
                var d = i.colorTextures;
                for (c = this._colorTextures.length = this._activeColorAttachments.length = d.length, l = 0; c > l; ++l)r = d[l], h = this._gl.COLOR_ATTACHMENT0 + l, s(this, h, r), this._activeColorAttachments[l] = h, this._colorTextures[l] = r
            }
            if (t(i.colorRenderbuffers)) {
                var m = i.colorRenderbuffers;
                for (c = this._colorRenderbuffers.length = this._activeColorAttachments.length = m.length, l = 0; c > l; ++l)o = m[l], h = this._gl.COLOR_ATTACHMENT0 + l, u(this, h, o), this._activeColorAttachments[l] = h, this._colorRenderbuffers[l] = o
            }
            t(i.depthTexture) && (r = i.depthTexture, s(this, this._gl.DEPTH_ATTACHMENT, r), this._depthTexture = r), t(i.depthRenderbuffer) && (o = i.depthRenderbuffer, u(this, this._gl.DEPTH_ATTACHMENT, o), this._depthRenderbuffer = o), t(i.stencilRenderbuffer) && (o = i.stencilRenderbuffer, u(this, this._gl.STENCIL_ATTACHMENT, o), this._stencilRenderbuffer = o), t(i.depthStencilTexture) && (r = i.depthStencilTexture, s(this, this._gl.DEPTH_STENCIL_ATTACHMENT, r), this._depthStencilTexture = r), t(i.depthStencilRenderbuffer) && (o = i.depthStencilRenderbuffer, u(this, this._gl.DEPTH_STENCIL_ATTACHMENT, o), this._depthStencilRenderbuffer = o), this._unBind()
        };
        return i(l.prototype, {
            status: {
                get: function () {
                    this._bind();
                    var e = this._gl.checkFramebufferStatus(this._gl.FRAMEBUFFER);
                    return this._unBind(), e
                }
            }, numberOfColorAttachments: {
                get: function () {
                    return this._activeColorAttachments.length
                }
            }, depthTexture: {
                get: function () {
                    return this._depthTexture
                }
            }, depthRenderbuffer: {
                get: function () {
                    return this._depthRenderbuffer
                }
            }, stencilRenderbuffer: {
                get: function () {
                    return this._stencilRenderbuffer
                }
            }, depthStencilTexture: {
                get: function () {
                    return this._depthStencilTexture
                }
            }, depthStencilRenderbuffer: {
                get: function () {
                    return this._depthStencilRenderbuffer
                }
            }, hasDepthAttachment: {
                get: function () {
                    return !!(this.depthTexture || this.depthRenderbuffer || this.depthStencilTexture || this.depthStencilRenderbuffer)
                }
            }
        }), l.prototype._bind = function () {
            var e = this._gl;
            e.bindFramebuffer(e.FRAMEBUFFER, this._framebuffer)
        }, l.prototype._unBind = function () {
            var e = this._gl;
            e.bindFramebuffer(e.FRAMEBUFFER, null)
        }, l.prototype._getActiveColorAttachments = function () {
            return this._activeColorAttachments
        }, l.prototype.getColorTexture = function (e) {
            return this._colorTextures[e]
        }, l.prototype.getColorRenderbuffer = function (e) {
            return this._colorRenderbuffers[e]
        }, l.prototype.isDestroyed = function () {
            return !1
        }, l.prototype.destroy = function () {
            if (this.destroyAttachments) {
                for (var e = 0, i = this._colorTextures, r = i.length; r > e; ++e) {
                    var o = i[e];
                    t(o) && o.destroy()
                }
                var a = this._colorRenderbuffers;
                for (r = a.length, e = 0; r > e; ++e) {
                    var s = a[e];
                    t(s) && s.destroy()
                }
                this._depthTexture = this._depthTexture && this._depthTexture.destroy(), this._depthRenderbuffer = this._depthRenderbuffer && this._depthRenderbuffer.destroy(), this._stencilRenderbuffer = this._stencilRenderbuffer && this._stencilRenderbuffer.destroy(), this._depthStencilTexture = this._depthStencilTexture && this._depthStencilTexture.destroy(), this._depthStencilRenderbuffer = this._depthStencilRenderbuffer && this._depthStencilRenderbuffer.destroy()
            }
            return this._gl.deleteFramebuffer(this._framebuffer), n(this)
        }, l
    }),define("Cesium/Renderer/RenderbufferFormat", ["../Core/freezeObject", "./WebGLConstants"], function (e, t) {
        "use strict";
        var i = {
            RGBA4: t.RGBA4,
            RGB5_A1: t.RGB5_A1,
            RGB565: t.RGB565,
            DEPTH_COMPONENT16: t.DEPTH_COMPONENT16,
            STENCIL_INDEX8: t.STENCIL_INDEX8,
            DEPTH_STENCIL: t.DEPTH_STENCIL,
            validate: function (e) {
                return e === i.RGBA4 || e === i.RGB5_A1 || e === i.RGB565 || e === i.DEPTH_COMPONENT16 || e === i.STENCIL_INDEX8 || e === i.DEPTH_STENCIL
            }
        };
        return e(i)
    }),define("Cesium/Renderer/Renderbuffer", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "./ContextLimits", "./RenderbufferFormat"], function (e, t, i, n, r, o, a) {
        "use strict";
        function s(i) {
            i = e(i, e.EMPTY_OBJECT);
            var n = i.context, r = n._gl, s = (o.maximumRenderbufferSize, e(i.format, a.RGBA4)), u = t(i.width) ? i.width : r.drawingBufferWidth, l = t(i.height) ? i.height : r.drawingBufferHeight;
            this._gl = r, this._format = s, this._width = u, this._height = l, this._renderbuffer = this._gl.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, this._renderbuffer), r.renderbufferStorage(r.RENDERBUFFER, s, u, l), r.bindRenderbuffer(r.RENDERBUFFER, null)
        }

        return i(s.prototype, {
            format: {
                get: function () {
                    return this._format
                }
            }, width: {
                get: function () {
                    return this._width
                }
            }, height: {
                get: function () {
                    return this._height
                }
            }
        }), s.prototype._getRenderbuffer = function () {
            return this._renderbuffer
        }, s.prototype.isDestroyed = function () {
            return !1
        }, s.prototype.destroy = function () {
            return this._gl.deleteRenderbuffer(this._renderbuffer), n(this)
        }, s
    }),define("Cesium/Renderer/Texture", ["../Core/Cartesian2", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Math", "../Core/PixelFormat", "./ContextLimits", "./MipmapHint", "./PixelDatatype", "./Sampler", "./TextureMagnificationFilter", "./TextureMinificationFilter", "./TextureWrap"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p) {
        "use strict";
        var f = function (n) {
            n = t(n, t.EMPTY_OBJECT);
            var r = n.context, a = n.source, u = i(a) ? a.width : n.width, l = i(a) ? a.height : n.height, d = t(n.pixelFormat, s.RGBA), m = t(n.pixelDatatype, c.UNSIGNED_BYTE);
            if (m === c.FLOAT && !r.floatingPointTexture)throw new o("When options.pixelDatatype is FLOAT, this WebGL implementation must support the OES_texture_float extension.  Check context.floatingPointTexture.");
            if (s.isDepthFormat(d) && !r.depthTexture)throw new o("When options.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, this WebGL implementation must support WEBGL_depth_texture.  Check context.depthTexture.");
            var p = n.preMultiplyAlpha || d === s.RGB || d === s.LUMINANCE, f = t(n.flipY, !0), _ = r._gl, v = _.TEXTURE_2D, g = _.createTexture();
            _.activeTexture(_.TEXTURE0), _.bindTexture(v, g), i(a) ? (_.pixelStorei(_.UNPACK_PREMULTIPLY_ALPHA_WEBGL, p), _.pixelStorei(_.UNPACK_FLIP_Y_WEBGL, f), i(a.arrayBufferView) ? _.texImage2D(v, 0, d, u, l, 0, d, m, a.arrayBufferView) : i(a.framebuffer) ? (a.framebuffer !== r.defaultFramebuffer && a.framebuffer._bind(), _.copyTexImage2D(v, 0, d, a.xOffset, a.yOffset, u, l, 0), a.framebuffer !== r.defaultFramebuffer && a.framebuffer._unBind()) : _.texImage2D(v, 0, d, d, m, a)) : _.texImage2D(v, 0, d, u, l, 0, d, m, null), _.bindTexture(v, null), this._context = r, this._textureFilterAnisotropic = r._textureFilterAnisotropic, this._textureTarget = v, this._texture = g, this._pixelFormat = d, this._pixelDatatype = m, this._width = u, this._height = l, this._dimensions = new e(u, l), this._preMultiplyAlpha = p, this._flipY = f, this._sampler = void 0, this.sampler = i(n.sampler) ? n.sampler : new h
        };
        return f.fromFramebuffer = function (e) {
            e = t(e, t.EMPTY_OBJECT);
            var n = e.context, r = n._gl, o = t(e.pixelFormat, s.RGB), a = t(e.framebufferXOffset, 0), u = t(e.framebufferYOffset, 0), l = t(e.width, r.drawingBufferWidth), c = t(e.height, r.drawingBufferHeight), h = e.framebuffer, d = new f({
                context: n,
                width: l,
                height: c,
                pixelFormat: o,
                source: {framebuffer: i(h) ? h : n.defaultFramebuffer, xOffset: a, yOffset: u, width: l, height: c}
            });
            return d
        }, n(f.prototype, {
            sampler: {
                get: function () {
                    return this._sampler
                }, set: function (e) {
                    var t = e.minificationFilter, n = e.magnificationFilter, r = t === m.NEAREST_MIPMAP_NEAREST || t === m.NEAREST_MIPMAP_LINEAR || t === m.LINEAR_MIPMAP_NEAREST || t === m.LINEAR_MIPMAP_LINEAR;
                    this._pixelDatatype === c.FLOAT && (t = r ? m.NEAREST_MIPMAP_NEAREST : m.NEAREST, n = d.NEAREST);
                    var o = this._context._gl, a = this._textureTarget;
                    o.activeTexture(o.TEXTURE0), o.bindTexture(a, this._texture), o.texParameteri(a, o.TEXTURE_MIN_FILTER, t), o.texParameteri(a, o.TEXTURE_MAG_FILTER, n), o.texParameteri(a, o.TEXTURE_WRAP_S, e.wrapS), o.texParameteri(a, o.TEXTURE_WRAP_T, e.wrapT), i(this._textureFilterAnisotropic) && o.texParameteri(a, this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, e.maximumAnisotropy), o.bindTexture(a, null), this._sampler = e
                }
            }, pixelFormat: {
                get: function () {
                    return this._pixelFormat
                }
            }, pixelDatatype: {
                get: function () {
                    return this._pixelDatatype
                }
            }, dimensions: {
                get: function () {
                    return this._dimensions
                }
            }, preMultiplyAlpha: {
                get: function () {
                    return this._preMultiplyAlpha
                }
            }, flipY: {
                get: function () {
                    return this._flipY
                }
            }, width: {
                get: function () {
                    return this._width
                }
            }, height: {
                get: function () {
                    return this._height
                }
            }, _target: {
                get: function () {
                    return this._textureTarget
                }
            }
        }), f.prototype.copyFrom = function (e, i, n) {
            i = t(i, 0), n = t(n, 0);
            var r = this._context._gl, o = this._textureTarget;
            r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._preMultiplyAlpha), r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, this._flipY), r.activeTexture(r.TEXTURE0), r.bindTexture(o, this._texture), e.arrayBufferView ? r.texSubImage2D(o, 0, i, n, e.width, e.height, this._pixelFormat, this._pixelDatatype, e.arrayBufferView) : r.texSubImage2D(o, 0, i, n, this._pixelFormat, this._pixelDatatype, e), r.bindTexture(o, null)
        }, f.prototype.copyFromFramebuffer = function (e, i, n, r, o, a) {
            e = t(e, 0), i = t(i, 0), n = t(n, 0), r = t(r, 0), o = t(o, this._width), a = t(a, this._height);
            var s = this._context._gl, u = this._textureTarget;
            s.activeTexture(s.TEXTURE0), s.bindTexture(u, this._texture), s.copyTexSubImage2D(u, 0, e, i, n, r, o, a), s.bindTexture(u, null)
        }, f.prototype.generateMipmap = function (e) {
            e = t(e, l.DONT_CARE);
            var i = this._context._gl, n = this._textureTarget;
            i.hint(i.GENERATE_MIPMAP_HINT, e), i.activeTexture(i.TEXTURE0), i.bindTexture(n, this._texture), i.generateMipmap(n), i.bindTexture(n, null)
        }, f.prototype.isDestroyed = function () {
            return !1
        }, f.prototype.destroy = function () {
            return this._context._gl.deleteTexture(this._texture), r(this)
        }, f
    }),define("Cesium/Renderer/PickFramebuffer", ["../Core/BoundingRectangle", "../Core/Color", "../Core/defaultValue", "../Core/defined", "../Core/destroyObject", "./Framebuffer", "./PassState", "./Renderbuffer", "./RenderbufferFormat", "./Texture"], function (e, t, i, n, r, o, a, s, u, l) {
        "use strict";
        var c = function (t) {
            var i = new a(t);
            i.blendingEnabled = !1, i.scissorTest = {
                enabled: !0,
                rectangle: new e
            }, this._context = t, this._fb = void 0, this._passState = i, this._width = 0, this._height = 0
        };
        c.prototype.begin = function (t) {
            var i = this._context, r = i.drawingBufferWidth, a = i.drawingBufferHeight;
            return e.clone(t, this._passState.scissorTest.rectangle), n(this._fb) && this._width === r && this._height === a || (this._width = r, this._height = a, this._fb = this._fb && this._fb.destroy(), this._fb = new o({
                context: i,
                colorTextures: [new l({context: i, width: r, height: a})],
                depthStencilRenderbuffer: new s({context: i, format: u.DEPTH_STENCIL})
            }), this._passState.framebuffer = this._fb), this._passState
        };
        var h = new t;
        return c.prototype.end = function (e) {
            for (var r = i(e.width, 1), o = i(e.height, 1), a = this._context, s = a.readPixels({
                x: e.x,
                y: e.y,
                width: r,
                height: o,
                framebuffer: this._fb
            }), u = Math.max(r, o), l = u * u, c = Math.floor(.5 * r), d = Math.floor(.5 * o), m = 0, p = 0, f = 0, _ = -1, v = 0; l > v; ++v) {
                if (m >= -c && c >= m && p >= -d && d >= p) {
                    var g = 4 * ((d - p) * r + m + c);
                    h.red = t.byteToFloat(s[g]), h.green = t.byteToFloat(s[g + 1]), h.blue = t.byteToFloat(s[g + 2]), h.alpha = t.byteToFloat(s[g + 3]);
                    var y = a.getObjectByPickColor(h);
                    if (n(y))return y
                }
                if (m === p || 0 > m && -m === p || m > 0 && m === 1 - p) {
                    var C = f;
                    f = -_, _ = C
                }
                m += f, p += _
            }
            return void 0
        }, c.prototype.isDestroyed = function () {
            return !1
        }, c.prototype.destroy = function () {
            return this._fb = this._fb && this._fb.destroy(), r(this)
        }, c
    }),define("Cesium/Renderer/RenderState", ["../Core/BoundingRectangle", "../Core/Color", "../Core/defaultValue", "../Core/defined", "../Core/DeveloperError", "../Core/RuntimeError", "../Core/WindingOrder", "./ContextLimits", "./WebGLConstants"], function (e, t, i, n, r, o, a, s, u) {
        "use strict";
        function l(e, t, i) {
            i ? e.enable(t) : e.disable(t)
        }

        function c(e, t) {
            e.frontFace(t.frontFace)
        }

        function h(e, t) {
            var i = t.cull, n = i.enabled;
            l(e, e.CULL_FACE, n), n && e.cullFace(i.face)
        }

        function d(e, t) {
            e.lineWidth(t.lineWidth)
        }

        function m(e, t) {
            var i = t.polygonOffset, n = i.enabled;
            l(e, e.POLYGON_OFFSET_FILL, n), n && e.polygonOffset(i.factor, i.units)
        }

        function p(e, t, i) {
            var r = t.scissorTest, o = n(i.scissorTest) ? i.scissorTest.enabled : r.enabled;
            if (l(e, e.SCISSOR_TEST, o), o) {
                var a = n(i.scissorTest) ? i.scissorTest.rectangle : r.rectangle;
                e.scissor(a.x, a.y, a.width, a.height)
            }
        }

        function f(e, t) {
            var i = t.depthRange;
            e.depthRange(i.near, i.far)
        }

        function _(e, t) {
            var i = t.depthTest, n = i.enabled;
            l(e, e.DEPTH_TEST, n), n && e.depthFunc(i.func)
        }

        function v(e, t) {
            var i = t.colorMask;
            e.colorMask(i.red, i.green, i.blue, i.alpha)
        }

        function g(e, t) {
            e.depthMask(t.depthMask)
        }

        function y(e, t) {
            e.stencilMask(t.stencilMask)
        }

        function C(e, t, i) {
            var r = t.blending, o = n(i.blendingEnabled) ? i.blendingEnabled : r.enabled;
            l(e, e.BLEND, o), o && (A(e, r.color), e.blendEquationSeparate(r.equationRgb, r.equationAlpha), e.blendFuncSeparate(r.functionSourceRgb, r.functionDestinationRgb, r.functionSourceAlpha, r.functionDestinationAlpha))
        }

        function E(e, t) {
            var i = t.stencilTest, n = i.enabled;
            if (l(e, e.STENCIL_TEST, n), n) {
                var r = i.frontFunction, o = i.backFunction, a = i.reference, s = i.mask;
                e.stencilFunc(i.frontFunction, i.reference, i.mask), e.stencilFuncSeparate(e.BACK, o, a, s), e.stencilFuncSeparate(e.FRONT, r, a, s);
                var u = i.frontOperation, c = u.fail, h = u.zFail, d = u.zPass;
                e.stencilOpSeparate(e.FRONT, c, h, d);
                var m = i.backOperation, p = m.fail, f = m.zFail, _ = m.zPass;
                e.stencilOpSeparate(e.BACK, p, f, _)
            }
        }

        function S(e, t, i) {
            var r = t.viewport;
            n(r) || (r = I, r.width = i.context.drawingBufferWidth, r.height = i.context.drawingBufferHeight), i.context.uniformState.viewport = r, e.viewport(r.x, r.y, r.width, r.height)
        }

        function T(e, t) {
            var i = [];
            return e.frontFace !== t.frontFace && i.push(c), (e.cull.enabled !== t.cull.enabled || e.cull.face !== t.cull.face) && i.push(h), e.lineWidth !== t.lineWidth && i.push(d), (e.polygonOffset.enabled !== t.polygonOffset.enabled || e.polygonOffset.factor !== t.polygonOffset.factor || e.polygonOffset.units !== t.polygonOffset.units) && i.push(m), (e.depthRange.near !== t.depthRange.near || e.depthRange.far !== t.depthRange.far) && i.push(f),
            (e.depthTest.enabled !== t.depthTest.enabled || e.depthTest.func !== t.depthTest.func) && i.push(_), (e.colorMask.red !== t.colorMask.red || e.colorMask.green !== t.colorMask.green || e.colorMask.blue !== t.colorMask.blue || e.colorMask.alpha !== t.colorMask.alpha) && i.push(v), e.depthMask !== t.depthMask && i.push(g), e.stencilMask !== t.stencilMask && i.push(y), (e.stencilTest.enabled !== t.stencilTest.enabled || e.stencilTest.frontFunction !== t.stencilTest.frontFunction || e.stencilTest.backFunction !== t.stencilTest.backFunction || e.stencilTest.reference !== t.stencilTest.reference || e.stencilTest.mask !== t.stencilTest.mask || e.stencilTest.frontOperation.fail !== t.stencilTest.frontOperation.fail || e.stencilTest.frontOperation.zFail !== t.stencilTest.frontOperation.zFail || e.stencilTest.backOperation.fail !== t.stencilTest.backOperation.fail || e.stencilTest.backOperation.zFail !== t.stencilTest.backOperation.zFail || e.stencilTest.backOperation.zPass !== t.stencilTest.backOperation.zPass) && i.push(E), (e.sampleCoverage.enabled !== t.sampleCoverage.enabled || e.sampleCoverage.value !== t.sampleCoverage.value || e.sampleCoverage.invert !== t.sampleCoverage.invert) && i.push(P), i
        }

        var b = function (r) {
            var o = i(r, {}), s = i(o.cull, {}), l = i(o.polygonOffset, {}), c = i(o.scissorTest, {}), h = i(c.rectangle, {}), d = i(o.depthRange, {}), m = i(o.depthTest, {}), p = i(o.colorMask, {}), f = i(o.blending, {}), _ = i(f.color, {}), v = i(o.stencilTest, {}), g = i(v.frontOperation, {}), y = i(v.backOperation, {}), C = i(o.sampleCoverage, {}), E = o.viewport;
            this.frontFace = i(o.frontFace, a.COUNTER_CLOCKWISE), this.cull = {
                enabled: i(s.enabled, !1),
                face: i(s.face, u.BACK)
            }, this.lineWidth = i(o.lineWidth, 1), this.polygonOffset = {
                enabled: i(l.enabled, !1),
                factor: i(l.factor, 0),
                units: i(l.units, 0)
            }, this.scissorTest = {
                enabled: i(c.enabled, !1),
                rectangle: e.clone(h)
            }, this.depthRange = {near: i(d.near, 0), far: i(d.far, 1)}, this.depthTest = {
                enabled: i(m.enabled, !1),
                func: i(m.func, u.LESS)
            }, this.colorMask = {
                red: i(p.red, !0),
                green: i(p.green, !0),
                blue: i(p.blue, !0),
                alpha: i(p.alpha, !0)
            }, this.depthMask = i(o.depthMask, !0), this.stencilMask = i(o.stencilMask, -1), this.blending = {
                enabled: i(f.enabled, !1),
                color: new t(i(_.red, 0), i(_.green, 0), i(_.blue, 0), i(_.alpha, 0)),
                equationRgb: i(f.equationRgb, u.FUNC_ADD),
                equationAlpha: i(f.equationAlpha, u.FUNC_ADD),
                functionSourceRgb: i(f.functionSourceRgb, u.ONE),
                functionSourceAlpha: i(f.functionSourceAlpha, u.ONE),
                functionDestinationRgb: i(f.functionDestinationRgb, u.ZERO),
                functionDestinationAlpha: i(f.functionDestinationAlpha, u.ZERO)
            }, this.stencilTest = {
                enabled: i(v.enabled, !1),
                frontFunction: i(v.frontFunction, u.ALWAYS),
                backFunction: i(v.backFunction, u.ALWAYS),
                reference: i(v.reference, 0),
                mask: i(v.mask, -1),
                frontOperation: {fail: i(g.fail, u.KEEP), zFail: i(g.zFail, u.KEEP), zPass: i(g.zPass, u.KEEP)},
                backOperation: {fail: i(y.fail, u.KEEP), zFail: i(y.zFail, u.KEEP), zPass: i(y.zPass, u.KEEP)}
            }, this.sampleCoverage = {
                enabled: i(C.enabled, !1),
                value: i(C.value, 1),
                invert: i(C.invert, !1)
            }, this.viewport = n(E) ? new e(E.x, E.y, E.width, E.height) : void 0, this.id = 0, this._applyFunctions = []
        }, w = 0, x = {};
        b.fromCache = function (e) {
            var t = JSON.stringify(e), i = x[t];
            if (n(i))return ++i.referenceCount, i.state;
            var r = new b(e), o = JSON.stringify(r);
            return i = x[o], n(i) || (r.id = w++, i = {
                referenceCount: 0,
                state: r
            }, x[o] = i), ++i.referenceCount, x[t] = {referenceCount: 1, state: i.state}, i.state
        }, b.removeFromCache = function (e) {
            var t = new b(e), i = JSON.stringify(t), r = x[i], o = JSON.stringify(e), a = x[o];
            n(a) && (--a.referenceCount, 0 === a.referenceCount && (delete x[o], n(r) && --r.referenceCount)), n(r) && 0 === r.referenceCount && delete x[i]
        }, b.getCache = function () {
            return x
        }, b.clearCache = function () {
            x = {}
        };
        var A = function (e, t) {
            e.blendColor(t.red, t.green, t.blue, t.alpha)
        }, P = function (e, t) {
            var i = t.sampleCoverage, n = i.enabled;
            l(e, e.SAMPLE_COVERAGE, n), n && e.sampleCoverage(i.value, i.invert)
        }, I = new e;
        return b.apply = function (e, t, i) {
            c(e, t), h(e, t), d(e, t), m(e, t), f(e, t), _(e, t), v(e, t), g(e, t), y(e, t), E(e, t), P(e, t), p(e, t, i), C(e, t, i), S(e, t, i)
        }, b.partialApply = function (e, t, i, r, o, a) {
            if (t !== i) {
                var s = i._applyFunctions[t.id];
                n(s) || (s = T(t, i), i._applyFunctions[t.id] = s);
                for (var u = s.length, l = 0; u > l; ++l)s[l](e, i)
            }
            var c = n(r.scissorTest) ? r.scissorTest : t.scissorTest, h = n(o.scissorTest) ? o.scissorTest : i.scissorTest;
            (c !== h || a) && p(e, i, o);
            var d = n(r.blendingEnabled) ? r.blendingEnabled : t.blending.enabled, m = n(o.blendingEnabled) ? o.blendingEnabled : i.blending.enabled;
            (d !== m || m && t.blending !== i.blending) && C(e, i, o), (t !== i || r.context !== o.context) && S(e, i, o)
        }, b.getState = function (i) {
            return {
                frontFace: i.frontFace,
                cull: {enabled: i.cull.enabled, face: i.cull.face},
                lineWidth: i.lineWidth,
                polygonOffset: {
                    enabled: i.polygonOffset.enabled,
                    factor: i.polygonOffset.factor,
                    units: i.polygonOffset.units
                },
                scissorTest: {enabled: i.scissorTest.enabled, rectangle: e.clone(i.scissorTest.rectangle)},
                depthRange: {near: i.depthRange.near, far: i.depthRange.far},
                depthTest: {enabled: i.depthTest.enabled, func: i.depthTest.func},
                colorMask: {
                    red: i.colorMask.red,
                    green: i.colorMask.green,
                    blue: i.colorMask.blue,
                    alpha: i.colorMask.alpha
                },
                depthMask: i.depthMask,
                stencilMask: i.stencilMask,
                blending: {
                    enabled: i.blending.enabled,
                    color: t.clone(i.blending.color),
                    equationRgb: i.blending.equationRgb,
                    equationAlpha: i.blending.equationAlpha,
                    functionSourceRgb: i.blending.functionSourceRgb,
                    functionSourceAlpha: i.blending.functionSourceAlpha,
                    functionDestinationRgb: i.blending.functionDestinationRgb,
                    functionDestinationAlpha: i.blending.functionDestinationAlpha
                },
                stencilTest: {
                    enabled: i.stencilTest.enabled,
                    frontFunction: i.stencilTest.frontFunction,
                    backFunction: i.stencilTest.backFunction,
                    reference: i.stencilTest.reference,
                    mask: i.stencilTest.mask,
                    frontOperation: {
                        fail: i.stencilTest.frontOperation.fail,
                        zFail: i.stencilTest.frontOperation.zFail,
                        zPass: i.stencilTest.frontOperation.zPass
                    },
                    backOperation: {
                        fail: i.stencilTest.backOperation.fail,
                        zFail: i.stencilTest.backOperation.zFail,
                        zPass: i.stencilTest.backOperation.zPass
                    }
                },
                sampleCoverage: {
                    enabled: i.sampleCoverage.enabled,
                    value: i.sampleCoverage.value,
                    invert: i.sampleCoverage.invert
                },
                viewport: n(i.viewport) ? e.clone(i.viewport) : void 0
            }
        }, b
    }),define("Cesium/Renderer/AutomaticUniforms", ["../Core/Cartesian3", "../Core/Matrix4", "./WebGLConstants"], function (e, t, i) {
        "use strict";
        var n = new e, r = function (e) {
            this._size = e.size, this._datatype = e.datatype, this.getValue = e.getValue
        };
        if ("undefined" == typeof WebGLRenderingContext)return {};
        var o = {};
        o[i.FLOAT] = "float", o[i.FLOAT_VEC2] = "vec2", o[i.FLOAT_VEC3] = "vec3", o[i.FLOAT_VEC4] = "vec4", o[i.INT] = "int", o[i.INT_VEC2] = "ivec2", o[i.INT_VEC3] = "ivec3", o[i.INT_VEC4] = "ivec4", o[i.BOOL] = "bool", o[i.BOOL_VEC2] = "bvec2", o[i.BOOL_VEC3] = "bvec3", o[i.BOOL_VEC4] = "bvec4", o[i.FLOAT_MAT2] = "mat2", o[i.FLOAT_MAT3] = "mat3", o[i.FLOAT_MAT4] = "mat4", o[i.SAMPLER_2D] = "sampler2D", o[i.SAMPLER_CUBE] = "samplerCube", r.prototype.getDeclaration = function (e) {
            var t = "uniform " + o[this._datatype] + " " + e, i = this._size;
            return t += 1 === i ? ";" : "[" + i.toString() + "];"
        };
        var a = {
            czm_viewport: new r({
                size: 1, datatype: i.FLOAT_VEC4, getValue: function (e) {
                    return e.viewportCartesian4
                }
            }), czm_viewportOrthographic: new r({
                size: 1, datatype: i.FLOAT_MAT4, getValue: function (e) {
                    return e.viewportOrthographic
                }
            }), czm_viewportTransformation: new r({
                size: 1, datatype: i.FLOAT_MAT4, getValue: function (e) {
                    return e.viewportTransformation
                }
            }), czm_globeDepthTexture: new r({
                size: 1, datatype: i.SAMPLER_2D, getValue: function (e) {
                    return e.globeDepthTexture
                }
            }), czm_model: new r({
                size: 1, datatype: i.FLOAT_MAT4, getValue: function (e) {
                    return e.model
                }
            }), czm_inverseModel: new r({
                size: 1, datatype: i.FLOAT_MAT4, getValue: function (e) {
                    return e.inverseModel
                }
            }), czm_view: new r({
                size: 1, datatype: i.FLOAT_MAT4, getValue: function (e) {
                    return e.view
                }
            }), czm_view3D: new r({
                size: 1, datatype: i.FLOAT_MAT4, getValue: function (e) {
                    return e.view3D
                }
            }), czm_viewRotation: new r({
                size: 1, datatype: i.FLOAT_MAT3, getValue: function (e) {
                    return e.viewRotation
                }
            }), czm_viewRotation3D: new r({
                size: 1, datatype: i.FLOAT_MAT3, getValue: function (e) {
                    return e.viewRotation3D
                }
            }), czm_inverseView: new r({
                size: 1, datatype: i.FLOAT_MAT4, getValue: function (e) {
                    return e.inverseView
                }
            }), czm_inverseView3D: new r({
                size: 1, datatype: i.FLOAT_MAT4, getValue: function (e) {
                    return e.inverseView3D
                }
            }), czm_inverseViewRotation: new r({
                size: 1, datatype: i.FLOAT_MAT3, getValue: function (e) {
                    return e.inverseViewRotation
                }
            }), czm_inverseViewRotation3D: new r({
                size: 1, datatype: i.FLOAT_MAT3, getValue: function (e) {
                    return e.inverseViewRotation3D
                }
            }), czm_projection: new r({
                size: 1, datatype: i.FLOAT_MAT4, getValue: function (e) {
                    return e.projection
                }
            }), czm_inverseProjection: new r({
                size: 1, datatype: i.FLOAT_MAT4, getValue: function (e) {
                    return e.inverseProjection
                }
            }), czm_inverseProjectionOIT: new r({
                size: 1, datatype: i.FLOAT_MAT4, getValue: function (e) {
                    return e.inverseProjectionOIT
                }
            }), czm_infiniteProjection: new r({
                size: 1, datatype: i.FLOAT_MAT4, getValue: function (e) {
                    return e.infiniteProjection
                }
            }), czm_modelView: new r({
                size: 1, datatype: i.FLOAT_MAT4, getValue: function (e) {
                    return e.modelView
                }
            }), czm_modelView3D: new r({
                size: 1, datatype: i.FLOAT_MAT4, getValue: function (e) {
                    return e.modelView3D
                }
            }), czm_modelViewRelativeToEye: new r({
                size: 1, datatype: i.FLOAT_MAT4, getValue: function (e) {
                    return e.modelViewRelativeToEye
                }
            }), czm_inverseModelView: new r({
                size: 1, datatype: i.FLOAT_MAT4, getValue: function (e) {
                    return e.inverseModelView
                }
            }), czm_inverseModelView3D: new r({
                size: 1, datatype: i.FLOAT_MAT4, getValue: function (e) {
                    return e.inverseModelView3D
                }
            }), czm_viewProjection: new r({
                size: 1, datatype: i.FLOAT_MAT4, getValue: function (e) {
                    return e.viewProjection
                }
            }), czm_inverseViewProjection: new r({
                size: 1, datatype: i.FLOAT_MAT4, getValue: function (e) {
                    return e.inverseViewProjection
                }
            }), czm_modelViewProjection: new r({
                size: 1, datatype: i.FLOAT_MAT4, getValue: function (e) {
                    return e.modelViewProjection
                }
            }), czm_inverseModelViewProjection: new r({
                size: 1, datatype: i.FLOAT_MAT4, getValue: function (e) {
                    return e.inverseModelViewProjection
                }
            }), czm_modelViewProjectionRelativeToEye: new r({
                size: 1, datatype: i.FLOAT_MAT4, getValue: function (e) {
                    return e.modelViewProjectionRelativeToEye
                }
            }), czm_modelViewInfiniteProjection: new r({
                size: 1, datatype: i.FLOAT_MAT4, getValue: function (e) {
                    return e.modelViewInfiniteProjection
                }
            }), czm_normal: new r({
                size: 1, datatype: i.FLOAT_MAT3, getValue: function (e) {
                    return e.normal
                }
            }), czm_normal3D: new r({
                size: 1, datatype: i.FLOAT_MAT3, getValue: function (e) {
                    return e.normal3D
                }
            }), czm_inverseNormal: new r({
                size: 1, datatype: i.FLOAT_MAT3, getValue: function (e) {
                    return e.inverseNormal
                }
            }), czm_inverseNormal3D: new r({
                size: 1, datatype: i.FLOAT_MAT3, getValue: function (e) {
                    return e.inverseNormal3D
                }
            }), czm_eyeHeight2D: new r({
                size: 1, datatype: i.FLOAT_VEC2, getValue: function (e) {
                    return e.eyeHeight2D
                }
            }), czm_entireFrustum: new r({
                size: 1, datatype: i.FLOAT_VEC2, getValue: function (e) {
                    return e.entireFrustum
                }
            }), czm_currentFrustum: new r({
                size: 1, datatype: i.FLOAT_VEC2, getValue: function (e) {
                    return e.currentFrustum
                }
            }), czm_frustumPlanes: new r({
                size: 1, datatype: i.FLOAT_VEC4, getValue: function (e) {
                    return e.frustumPlanes
                }
            }), czm_sunPositionWC: new r({
                size: 1, datatype: i.FLOAT_VEC3, getValue: function (e) {
                    return e.sunPositionWC
                }
            }), czm_sunPositionColumbusView: new r({
                size: 1, datatype: i.FLOAT_VEC3, getValue: function (e) {
                    return e.sunPositionColumbusView
                }
            }), czm_sunDirectionEC: new r({
                size: 1, datatype: i.FLOAT_VEC3, getValue: function (e) {
                    return e.sunDirectionEC
                }
            }), czm_sunDirectionWC: new r({
                size: 1, datatype: i.FLOAT_VEC3, getValue: function (e) {
                    return e.sunDirectionWC
                }
            }), czm_moonDirectionEC: new r({
                size: 1, datatype: i.FLOAT_VEC3, getValue: function (e) {
                    return e.moonDirectionEC
                }
            }), czm_encodedCameraPositionMCHigh: new r({
                size: 1, datatype: i.FLOAT_VEC3, getValue: function (e) {
                    return e.encodedCameraPositionMCHigh
                }
            }), czm_encodedCameraPositionMCLow: new r({
                size: 1, datatype: i.FLOAT_VEC3, getValue: function (e) {
                    return e.encodedCameraPositionMCLow
                }
            }), czm_viewerPositionWC: new r({
                size: 1, datatype: i.FLOAT_VEC3, getValue: function (e) {
                    return t.getTranslation(e.inverseView, n)
                }
            }), czm_frameNumber: new r({
                size: 1, datatype: i.FLOAT, getValue: function (e) {
                    return e.frameState.frameNumber
                }
            }), czm_morphTime: new r({
                size: 1, datatype: i.FLOAT, getValue: function (e) {
                    return e.frameState.morphTime
                }
            }), czm_sceneMode: new r({
                size: 1, datatype: i.FLOAT, getValue: function (e) {
                    return e.frameState.mode
                }
            }), czm_temeToPseudoFixed: new r({
                size: 1, datatype: i.FLOAT_MAT3, getValue: function (e) {
                    return e.temeToPseudoFixedMatrix
                }
            }), czm_resolutionScale: new r({
                size: 1, datatype: i.FLOAT, getValue: function (e) {
                    return e.resolutionScale
                }
            })
        };
        return a
    }),define("Cesium/Renderer/createUniform", ["../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/Color", "../Core/defined", "../Core/DeveloperError", "../Core/Matrix2", "../Core/Matrix3", "../Core/Matrix4", "../Core/RuntimeError"], function (e, t, i, n, r, o, a, s, u, l) {
        "use strict";
        function c(e, t, i, n) {
            this.name = i, this.value = void 0, this._value = 0, this._gl = e, this._location = n
        }

        function h(t, i, n, r) {
            this.name = n, this.value = void 0, this._value = new e, this._gl = t, this._location = r
        }

        function d(e, t, i, n) {
            this.name = i, this.value = void 0, this._value = void 0, this._gl = e, this._location = n
        }

        function m(e, t, i, n) {
            this.name = i, this.value = void 0, this._value = void 0, this._gl = e, this._location = n
        }

        function p(e, t, i, n) {
            this.name = i, this.value = void 0, this._gl = e, this._location = n, this.textureUnitIndex = void 0
        }

        function f(e, t, i, n) {
            this.name = i, this.value = void 0, this._value = 0, this._gl = e, this._location = n
        }

        function _(t, i, n, r) {
            this.name = n, this.value = void 0, this._value = new e, this._gl = t, this._location = r
        }

        function v(e, i, n, r) {
            this.name = n, this.value = void 0, this._value = new t, this._gl = e, this._location = r
        }

        function g(e, t, n, r) {
            this.name = n, this.value = void 0, this._value = new i, this._gl = e, this._location = r
        }

        function y(e, t, i, n) {
            this.name = i, this.value = void 0, this._value = new Float32Array(4), this._gl = e, this._location = n
        }

        function C(e, t, i, n) {
            this.name = i, this.value = void 0, this._value = new Float32Array(9), this._gl = e, this._location = n
        }

        function E(e, t, i, n) {
            this.name = i, this.value = void 0, this._value = new Float32Array(16), this._gl = e, this._location = n
        }

        var S = function (e, t, i, n) {
            switch (t.type) {
                case e.FLOAT:
                    return new c(e, t, i, n);
                case e.FLOAT_VEC2:
                    return new h(e, t, i, n);
                case e.FLOAT_VEC3:
                    return new d(e, t, i, n);
                case e.FLOAT_VEC4:
                    return new m(e, t, i, n);
                case e.SAMPLER_2D:
                case e.SAMPLER_CUBE:
                    return new p(e, t, i, n);
                case e.INT:
                case e.BOOL:
                    return new f(e, t, i, n);
                case e.INT_VEC2:
                case e.BOOL_VEC2:
                    return new _(e, t, i, n);
                case e.INT_VEC3:
                case e.BOOL_VEC3:
                    return new v(e, t, i, n);
                case e.INT_VEC4:
                case e.BOOL_VEC4:
                    return new g(e, t, i, n);
                case e.FLOAT_MAT2:
                    return new y(e, t, i, n);
                case e.FLOAT_MAT3:
                    return new C(e, t, i, n);
                case e.FLOAT_MAT4:
                    return new E(e, t, i, n);
                default:
                    throw new l("Unrecognized uniform type: " + t.type + ' for uniform "' + i + '".')
            }
        };
        return c.prototype.set = function () {
            this.value !== this._value && (this._value = this.value, this._gl.uniform1f(this._location, this.value))
        }, h.prototype.set = function () {
            var t = this.value;
            e.equals(t, this._value) || (e.clone(t, this._value), this._gl.uniform2f(this._location, t.x, t.y))
        }, d.prototype.set = function () {
            var e = this.value;
            if (r(e.red))n.equals(e, this._value) || (this._value = n.clone(e, this._value), this._gl.uniform3f(this._location, e.red, e.green, e.blue)); else {
                if (!r(e.x))throw new o('Invalid vec3 value for uniform "' + this._activethis.name + '".');
                t.equals(e, this._value) || (this._value = t.clone(e, this._value), this._gl.uniform3f(this._location, e.x, e.y, e.z))
            }
        }, m.prototype.set = function () {
            var e = this.value;
            if (r(e.red))n.equals(e, this._value) || (this._value = n.clone(e, this._value), this._gl.uniform4f(this._location, e.red, e.green, e.blue, e.alpha)); else {
                if (!r(e.x))throw new o('Invalid vec4 value for uniform "' + this._activethis.name + '".');
                i.equals(e, this._value) || (this._value = i.clone(e, this._value), this._gl.uniform4f(this._location, e.x, e.y, e.z, e.w))
            }
        }, p.prototype.set = function () {
            var e = this._gl;
            e.activeTexture(e.TEXTURE0 + this.textureUnitIndex);
            var t = this.value;
            e.bindTexture(t._target, t._texture)
        }, p.prototype._setSampler = function (e) {
            return this.textureUnitIndex = e, this._gl.uniform1i(this._location, e), e + 1
        }, f.prototype.set = function () {
            this.value !== this._value && (this._value = this.value, this._gl.uniform1i(this._location, this.value))
        }, _.prototype.set = function () {
            var t = this.value;
            e.equals(t, this._value) || (e.clone(t, this._value), this._gl.uniform2i(this._location, t.x, t.y))
        }, v.prototype.set = function () {
            var e = this.value;
            t.equals(e, this._value) || (t.clone(e, this._value), this._gl.uniform3i(this._location, e.x, e.y, e.z))
        }, g.prototype.set = function () {
            var e = this.value;
            i.equals(e, this._value) || (i.clone(e, this._value), this._gl.uniform4i(this._location, e.x, e.y, e.z, e.w))
        }, y.prototype.set = function () {
            a.equalsArray(this.value, this._value, 0) || (a.toArray(this.value, this._value), this._gl.uniformMatrix2fv(this._location, !1, this._value))
        }, C.prototype.set = function () {
            s.equalsArray(this.value, this._value, 0) || (s.toArray(this.value, this._value), this._gl.uniformMatrix3fv(this._location, !1, this._value))
        }, E.prototype.set = function () {
            u.equalsArray(this.value, this._value, 0) || (u.toArray(this.value, this._value), this._gl.uniformMatrix4fv(this._location, !1, this._value))
        }, S
    }),define("Cesium/Renderer/createUniformArray", ["../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/Color", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Matrix2", "../Core/Matrix3", "../Core/Matrix4", "../Core/RuntimeError"], function (e, t, i, n, r, o, a, s, u, l, c) {
        "use strict";
        function h(e, t, i, n) {
            var r = n.length;
            this.name = i, this.value = new Array(r), this._value = new Float32Array(r), this._gl = e, this._location = n[0]
        }

        function d(e, t, i, n) {
            var r = n.length;
            this.name = i, this.value = new Array(r), this._value = new Float32Array(2 * r), this._gl = e, this._location = n[0]
        }

        function m(e, t, i, n) {
            var r = n.length;
            this.name = i, this.value = new Array(r), this._value = new Float32Array(3 * r), this._gl = e, this._location = n[0]
        }

        function p(e, t, i, n) {
            var r = n.length;
            this.name = i, this.value = new Array(r), this._value = new Float32Array(4 * r), this._gl = e, this._location = n[0]
        }

        function f(e, t, i, n) {
            var r = n.length;
            this.name = i, this.value = new Array(r), this._value = new Float32Array(r), this._gl = e, this._locations = n, this.textureUnitIndex = void 0
        }

        function _(e, t, i, n) {
            var r = n.length;
            this.name = i, this.value = new Array(r), this._value = new Int32Array(r), this._gl = e, this._location = n[0]
        }

        function v(e, t, i, n) {
            var r = n.length;
            this.name = i, this.value = new Array(r), this._value = new Int32Array(2 * r), this._gl = e, this._location = n[0]
        }

        function g(e, t, i, n) {
            var r = n.length;
            this.name = i, this.value = new Array(r), this._value = new Int32Array(3 * r), this._gl = e, this._location = n[0]
        }

        function y(e, t, i, n) {
            var r = n.length;
            this.name = i, this.value = new Array(r), this._value = new Int32Array(4 * r), this._gl = e, this._location = n[0]
        }

        function C(e, t, i, n) {
            var r = n.length;
            this.name = i, this.value = new Array(r), this._value = new Float32Array(4 * r), this._gl = e, this._location = n[0]
        }

        function E(e, t, i, n) {
            var r = n.length;
            this.name = i, this.value = new Array(r), this._value = new Float32Array(9 * r), this._gl = e, this._location = n[0]
        }

        function S(e, t, i, n) {
            var r = n.length;
            this.name = i, this.value = new Array(r), this._value = new Float32Array(16 * r), this._gl = e, this._location = n[0]
        }

        var T = function (e, t, i, n) {
            switch (t.type) {
                case e.FLOAT:
                    return new h(e, t, i, n);
                case e.FLOAT_VEC2:
                    return new d(e, t, i, n);
                case e.FLOAT_VEC3:
                    return new m(e, t, i, n);
                case e.FLOAT_VEC4:
                    return new p(e, t, i, n);
                case e.SAMPLER_2D:
                case e.SAMPLER_CUBE:
                    return new f(e, t, i, n);
                case e.INT:
                case e.BOOL:
                    return new _(e, t, i, n);
                case e.INT_VEC2:
                case e.BOOL_VEC2:
                    return new v(e, t, i, n);
                case e.INT_VEC3:
                case e.BOOL_VEC3:
                    return new g(e, t, i, n);
                case e.INT_VEC4:
                case e.BOOL_VEC4:
                    return new y(e, t, i, n);
                case e.FLOAT_MAT2:
                    return new C(e, t, i, n);
                case e.FLOAT_MAT3:
                    return new E(e, t, i, n);
                case e.FLOAT_MAT4:
                    return new S(e, t, i, n);
                default:
                    throw new c("Unrecognized uniform type: " + t.type + ' for uniform "' + i + '".')
            }
        };
        return h.prototype.set = function () {
            for (var e = this.value, t = e.length, i = this._value, n = !1, r = 0; t > r; ++r) {
                var o = e[r];
                o !== i[r] && (i[r] = o, n = !0)
            }
            n && this._gl.uniform1fv(this._location, i)
        }, d.prototype.set = function () {
            for (var t = this.value, i = t.length, n = this._value, r = !1, o = 0, a = 0; i > a; ++a) {
                var s = t[a];
                e.equalsArray(s, n, o) || (e.pack(s, n, o), r = !0), o += 2
            }
            r && this._gl.uniform2fv(this._location, n)
        }, m.prototype.set = function () {
            for (var e = this.value, i = e.length, n = this._value, o = !1, s = 0, u = 0; i > u; ++u) {
                var l = e[u];
                if (r(l.red))(l.red !== n[s] || l.green !== n[s + 1] || l.blue !== n[s + 2]) && (n[s] = l.red, n[s + 1] = l.green, n[s + 2] = l.blue, o = !0); else {
                    if (!r(l.x))throw new a("Invalid vec3 value.");
                    t.equalsArray(l, n, s) || (t.pack(l, n, s), o = !0)
                }
                s += 3
            }
            o && this._gl.uniform3fv(this._location, n)
        }, p.prototype.set = function () {
            for (var e = this.value, t = e.length, o = this._value, s = !1, u = 0, l = 0; t > l; ++l) {
                var c = e[l];
                if (r(c.red))n.equalsArray(c, o, u) || (n.pack(c, o, u), s = !0); else {
                    if (!r(c.x))throw new a("Invalid vec4 value.");
                    i.equalsArray(c, o, u) || (i.pack(c, o, u), s = !0)
                }
                u += 4
            }
            s && this._gl.uniform4fv(this._location, o)
        }, f.prototype.set = function () {
            for (var e = this._gl, t = e.TEXTURE0 + this.textureUnitIndex, i = this.value, n = i.length, r = 0; n > r; ++r) {
                var o = i[r];
                e.activeTexture(t + r), e.bindTexture(o._target, o._texture)
            }
        }, f.prototype._setSampler = function (e) {
            this.textureUnitIndex = e;
            for (var t = this._locations, i = t.length, n = 0; i > n; ++n) {
                var r = e + n;
                this._gl.uniform1i(t[n], r)
            }
            return e + i
        }, _.prototype.set = function () {
            for (var e = this.value, t = e.length, i = this._value, n = !1, r = 0; t > r; ++r) {
                var o = e[r];
                o !== i[r] && (i[r] = o, n = !0)
            }
            n && this._gl.uniform1iv(this._location, i)
        }, v.prototype.set = function () {
            for (var t = this.value, i = t.length, n = this._value, r = !1, o = 0, a = 0; i > a; ++a) {
                var s = t[a];
                e.equalsArray(s, n, o) || (e.pack(s, n, o), r = !0), o += 2
            }
            r && this._gl.uniform2iv(this._location, n)
        }, g.prototype.set = function () {
            for (var e = this.value, i = e.length, n = this._value, r = !1, o = 0, a = 0; i > a; ++a) {
                var s = e[a];
                t.equalsArray(s, n, o) || (t.pack(s, n, o), r = !0), o += 3
            }
            r && this._gl.uniform3iv(this._location, n)
        }, y.prototype.set = function () {
            for (var e = this.value, t = e.length, n = this._value, r = !1, o = 0, a = 0; t > a; ++a) {
                var s = e[a];
                i.equalsArray(s, n, o) || (i.pack(s, n, o), r = !0), o += 4
            }
            r && this._gl.uniform4iv(this._location, n)
        }, C.prototype.set = function () {
            for (var e = this.value, t = e.length, i = this._value, n = !1, r = 0, o = 0; t > o; ++o) {
                var a = e[o];
                s.equalsArray(a, i, r) || (s.pack(a, i, r), n = !0), r += 4
            }
            n && this._gl.uniformMatrix2fv(this._location, !1, i)
        }, E.prototype.set = function () {
            for (var e = this.value, t = e.length, i = this._value, n = !1, r = 0, o = 0; t > o; ++o) {
                var a = e[o];
                u.equalsArray(a, i, r) || (u.pack(a, i, r), n = !0), r += 9
            }
            n && this._gl.uniformMatrix3fv(this._location, !1, i)
        }, S.prototype.set = function () {
            for (var e = this.value, t = e.length, i = this._value, n = !1, r = 0, o = 0; t > o; ++o) {
                var a = e[o];
                l.equalsArray(a, i, r) || (l.pack(a, i, r), n = !0), r += 16
            }
            n && this._gl.uniformMatrix4fv(this._location, !1, i)
        }, T
    }),define("Cesium/Renderer/ShaderProgram", ["../Core/defaultValue", "../Core/defined", "../Core/definedNotNull", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/RuntimeError", "./AutomaticUniforms", "./ContextLimits", "./createUniform", "./createUniformArray"], function (e, t, i, n, r, o, a, s, u, l, c) {
        "use strict";
        function h(e) {
            var t = [], n = e.match(/uniform.*?(?![^{]*})(?=[=\[;])/g);
            if (i(n))for (var r = n.length, o = 0; r > o; o++) {
                var a = n[o].trim(), s = a.slice(a.lastIndexOf(" ") + 1);
                t.push(s)
            }
            return t
        }

        function d(e, t) {
            var i = {};
            if (!u.highpFloatSupported || !u.highpIntSupported) {
                var n, r, o, a, s = h(e), l = h(t), c = s.length, d = l.length;
                for (n = 0; c > n; n++)for (r = 0; d > r; r++)if (s[n] === l[r]) {
                    o = s[n], a = "czm_mediump_" + o;
                    var m = new RegExp(o + "\\b", "g");
                    t = t.replace(m, a), i[a] = o
                }
            }
            return {fragmentShaderText: t, duplicateUniformNames: i}
        }

        function m(e, i) {
            var n = i._vertexShaderText, r = i._fragmentShaderText, o = e.createShader(e.VERTEX_SHADER);
            e.shaderSource(o, n), e.compileShader(o);
            var s = e.createShader(e.FRAGMENT_SHADER);
            e.shaderSource(s, r), e.compileShader(s);
            var u = e.createProgram();
            e.attachShader(u, o), e.attachShader(u, s), e.deleteShader(o), e.deleteShader(s);
            var l = i._attributeLocations;
            if (t(l))for (var c in l)l.hasOwnProperty(c) && e.bindAttribLocation(u, l[c], c);
            e.linkProgram(u);
            var h;
            if (!e.getProgramParameter(u, e.LINK_STATUS)) {
                var d = i._debugShaders;
                if (!e.getShaderParameter(s, e.COMPILE_STATUS)) {
                    if (h = e.getShaderInfoLog(s), console.error(E + "Fragment shader compile log: " + h), t(d)) {
                        var m = d.getTranslatedShaderSource(s);
                        "" !== m ? console.error(E + "Translated fragment shader source:\n" + m) : console.error(E + "Fragment shader translation failed.")
                    }
                    throw e.deleteProgram(u), new a("Fragment shader failed to compile.  Compile log: " + h)
                }
                if (!e.getShaderParameter(o, e.COMPILE_STATUS)) {
                    if (h = e.getShaderInfoLog(o), console.error(E + "Vertex shader compile log: " + h), t(d)) {
                        var p = d.getTranslatedShaderSource(o);
                        "" !== p ? console.error(E + "Translated vertex shader source:\n" + p) : console.error(E + "Vertex shader translation failed.")
                    }
                    throw e.deleteProgram(u), new a("Vertex shader failed to compile.  Compile log: " + h)
                }
                throw h = e.getProgramInfoLog(u), console.error(E + "Shader program link log: " + h), t(d) && (console.error(E + "Translated vertex shader source:\n" + d.getTranslatedShaderSource(o)), console.error(E + "Translated fragment shader source:\n" + d.getTranslatedShaderSource(s))), e.deleteProgram(u), new a("Program failed to link.  Link log: " + h)
            }
            var f = i._logShaderCompilation;
            return f && (h = e.getShaderInfoLog(o), t(h) && h.length > 0 && console.log(E + "Vertex shader compile log: " + h)), f && (h = e.getShaderInfoLog(s), t(h) && h.length > 0 && console.log(E + "Fragment shader compile log: " + h)), f && (h = e.getProgramInfoLog(u), t(h) && h.length > 0 && console.log(E + "Shader program link log: " + h)), u
        }

        function p(e, t, i) {
            for (var n = {}, r = 0; i > r; ++r) {
                var o = e.getActiveAttrib(t, r), a = e.getAttribLocation(t, o.name);
                n[o.name] = {name: o.name, type: o.type, index: a}
            }
            return n
        }

        function f(e, i) {
            for (var n = {}, r = [], o = [], a = e.getProgramParameter(i, e.ACTIVE_UNIFORMS), s = 0; a > s; ++s) {
                var u = e.getActiveUniform(i, s), h = "[0]", d = -1 !== u.name.indexOf(h, u.name.length - h.length) ? u.name.slice(0, u.name.length - 3) : u.name;
                if (0 !== d.indexOf("gl_"))if (u.name.indexOf("[") < 0) {
                    var m = e.getUniformLocation(i, d);
                    if (null !== m) {
                        var p = l(e, u, d, m);
                        n[d] = p, r.push(p), p._setSampler && o.push(p)
                    }
                } else {
                    var f, _, v, g, y = d.indexOf("[");
                    if (y >= 0) {
                        if (f = n[d.slice(0, y)], !t(f))continue;
                        _ = f._locations, _.length <= 1 && (v = f.value, g = e.getUniformLocation(i, d), null !== g && (_.push(g), v.push(e.getUniform(i, g))))
                    } else {
                        _ = [];
                        for (var C = 0; C < u.size; ++C)g = e.getUniformLocation(i, d + "[" + C + "]"), null !== g && _.push(g);
                        f = c(e, u, d, _), n[d] = f, r.push(f), f._setSampler && o.push(f)
                    }
                }
            }
            return {uniformsByName: n, uniforms: r, samplerUniforms: o}
        }

        function _(e, i) {
            var n = [], r = [];
            for (var o in i)if (i.hasOwnProperty(o)) {
                var a = i[o], u = o, l = e._duplicateUniformNames[u];
                t(l) && (a.name = l, u = l);
                var c = s[u];
                t(c) ? n.push({uniform: a, automaticUniform: c}) : r.push(a)
            }
            return {automaticUniforms: n, manualUniforms: r}
        }

        function v(e, t, i) {
            e.useProgram(t);
            for (var n = 0, r = i.length, o = 0; r > o; ++o)n = i[o]._setSampler(n);
            return e.useProgram(null), n
        }

        function g(e) {
            if (!t(e._program)) {
                var i = e._gl, n = m(i, e, e._debugShaders), r = i.getProgramParameter(n, i.ACTIVE_ATTRIBUTES), o = f(i, n), a = _(e, o.uniformsByName);
                e._program = n, e._numberOfVertexAttributes = r, e._vertexAttributes = p(i, n, r), e._uniformsByName = o.uniformsByName, e._uniforms = o.uniforms, e._automaticUniforms = a.automaticUniforms, e._manualUniforms = a.manualUniforms, e.maximumTextureUnitIndex = v(i, n, o.samplerUniforms)
            }
        }

        var y = 0, C = function (e) {
            var t = d(e.vertexShaderText, e.fragmentShaderText);
            this._gl = e.gl, this._logShaderCompilation = e.logShaderCompilation, this._debugShaders = e.debugShaders, this._attributeLocations = e.attributeLocations, this._program = void 0, this._numberOfVertexAttributes = void 0, this._vertexAttributes = void 0, this._uniformsByName = void 0, this._uniforms = void 0, this._automaticUniforms = void 0, this._manualUniforms = void 0, this._duplicateUniformNames = t.duplicateUniformNames, this._cachedShader = void 0, this.maximumTextureUnitIndex = void 0, this._vertexShaderSource = e.vertexShaderSource, this._vertexShaderText = e.vertexShaderText, this._fragmentShaderSource = e.fragmentShaderSource, this._fragmentShaderText = t.fragmentShaderText, this.id = y++
        };
        C.fromCache = function (t) {
            return t = e(t, e.EMPTY_OBJECT), t.context.shaderCache.getShaderProgram(t)
        }, C.replaceCache = function (t) {
            return t = e(t, e.EMPTY_OBJECT), t.context.shaderCache.replaceShaderProgram(t)
        }, n(C.prototype, {
            vertexShaderSource: {
                get: function () {
                    return this._vertexShaderSource
                }
            }, fragmentShaderSource: {
                get: function () {
                    return this._fragmentShaderSource
                }
            }, vertexAttributes: {
                get: function () {
                    return g(this), this._vertexAttributes
                }
            }, numberOfVertexAttributes: {
                get: function () {
                    return g(this), this._numberOfVertexAttributes
                }
            }, allUniforms: {
                get: function () {
                    return g(this), this._uniformsByName
                }
            }
        });
        var E = "[Cesium WebGL] ";
        return C.prototype._bind = function () {
            g(this), this._gl.useProgram(this._program)
        }, C.prototype._setUniforms = function (e, i, n) {
            var r, a;
            if (t(e)) {
                var s = this._manualUniforms;
                for (r = s.length, a = 0; r > a; ++a) {
                    var u = s[a];
                    u.value = e[u.name]()
                }
            }
            var l = this._automaticUniforms;
            for (r = l.length, a = 0; r > a; ++a) {
                var c = l[a];
                c.uniform.value = c.automaticUniform.getValue(i)
            }
            var h = this._uniforms;
            for (r = h.length, a = 0; r > a; ++a)h[a].set();
            if (n) {
                var d = this._gl, m = this._program;
                if (d.validateProgram(m), !d.getProgramParameter(m, d.VALIDATE_STATUS))throw new o("Program validation failed.  Program info log: " + d.getProgramInfoLog(m))
            }
        }, C.prototype.isDestroyed = function () {
            return !1
        }, C.prototype.destroy = function () {
            return void this._cachedShader.cache.releaseShaderProgram(this)
        }, C.prototype.finalDestroy = function () {
            return this._gl.deleteProgram(this._program), r(this)
        }, C
    }),define("Cesium/Shaders/Builtin/Constants/degreesPerRadian", [], function () {
        "use strict";
        return "/**\n * A built-in GLSL floating-point constant for converting radians to degrees.\n *\n * @alias czm_degreesPerRadian\n * @glslConstant\n *\n * @see CesiumMath.DEGREES_PER_RADIAN\n *\n * @example\n * // GLSL declaration\n * const float czm_degreesPerRadian = ...;\n *\n * // Example\n * float deg = czm_degreesPerRadian * rad;\n */\nconst float czm_degreesPerRadian = 57.29577951308232;"
    }),define("Cesium/Shaders/Builtin/Constants/depthRange", [], function () {
        "use strict";
        return "/**\n * A built-in GLSL vec2 constant for defining the depth range.\n * This is a workaround to a bug where IE11 does not implement gl_DepthRange.\n *\n * @alias czm_depthRange\n * @glslConstant\n *\n * @example\n * // GLSL declaration\n * float depthRangeNear = czm_depthRange.near;\n * float depthRangeFar = czm_depthRange.far;\n *\n */\nconst czm_depthRangeStruct czm_depthRange = czm_depthRangeStruct(0.0, 1.0);"
    }),define("Cesium/Shaders/Builtin/Constants/epsilon1", [], function () {
        "use strict";
        return "/**\n * 0.1\n *\n * @name czm_epsilon1\n * @glslConstant\n */\nconst float czm_epsilon1 = 0.1;"
    }),define("Cesium/Shaders/Builtin/Constants/epsilon2", [], function () {
        "use strict";
        return "/**\n * 0.01\n *\n * @name czm_epsilon2\n * @glslConstant\n */\nconst float czm_epsilon2 = 0.01;"
    }),define("Cesium/Shaders/Builtin/Constants/epsilon3", [], function () {
        "use strict";
        return "/**\n * 0.001\n *\n * @name czm_epsilon3\n * @glslConstant\n */\nconst float czm_epsilon3 = 0.001;"
    }),define("Cesium/Shaders/Builtin/Constants/epsilon4", [], function () {
        "use strict";
        return "/**\n * 0.0001\n *\n * @name czm_epsilon4\n * @glslConstant\n */\nconst float czm_epsilon4 = 0.0001;"
    }),define("Cesium/Shaders/Builtin/Constants/epsilon5", [], function () {
        "use strict";
        return "/**\n * 0.00001\n *\n * @name czm_epsilon5\n * @glslConstant\n */\nconst float czm_epsilon5 = 0.00001;"
    }),define("Cesium/Shaders/Builtin/Constants/epsilon6", [], function () {
        "use strict";
        return "/**\n * 0.000001\n *\n * @name czm_epsilon6\n * @glslConstant\n */\nconst float czm_epsilon6 = 0.000001;"
    }),define("Cesium/Shaders/Builtin/Constants/epsilon7", [], function () {
        "use strict";
        return "/**\n * 0.0000001\n *\n * @name czm_epsilon7\n * @glslConstant\n */\nconst float czm_epsilon7 = 0.0000001;"
    }),define("Cesium/Shaders/Builtin/Constants/infinity", [], function () {
        "use strict";
        return "/**\n * DOC_TBA\n *\n * @name czm_infinity\n * @glslConstant\n */\nconst float czm_infinity = 5906376272000.0;  // Distance from the Sun to Pluto in meters.  TODO: What is best given lowp, mediump, and highp?"
    }),define("Cesium/Shaders/Builtin/Constants/oneOverPi", [], function () {
        "use strict";
        return "/**\n * A built-in GLSL floating-point constant for <code>1/pi</code>.\n *\n * @alias czm_oneOverPi\n * @glslConstant\n *\n * @see CesiumMath.ONE_OVER_PI\n *\n * @example\n * // GLSL declaration\n * const float czm_oneOverPi = ...;\n *\n * // Example\n * float pi = 1.0 / czm_oneOverPi;\n */\nconst float czm_oneOverPi = 0.3183098861837907;"
    }),define("Cesium/Shaders/Builtin/Constants/oneOverTwoPi", [], function () {
        "use strict";
        return "/**\n * A built-in GLSL floating-point constant for <code>1/2pi</code>.\n *\n * @alias czm_oneOverTwoPi\n * @glslConstant\n *\n * @see CesiumMath.ONE_OVER_TWO_PI\n *\n * @example\n * // GLSL declaration\n * const float czm_oneOverTwoPi = ...;\n *\n * // Example\n * float pi = 2.0 * czm_oneOverTwoPi;\n */\nconst float czm_oneOverTwoPi = 0.15915494309189535;"
    }),define("Cesium/Shaders/Builtin/Constants/pi", [], function () {
        "use strict";
        return "/**\n * A built-in GLSL floating-point constant for <code>Math.PI</code>.\n *\n * @alias czm_pi\n * @glslConstant\n *\n * @see CesiumMath.PI\n *\n * @example\n * // GLSL declaration\n * const float czm_pi = ...;\n *\n * // Example\n * float twoPi = 2.0 * czm_pi;\n */\nconst float czm_pi = 3.141592653589793;"
    }),define("Cesium/Shaders/Builtin/Constants/piOverFour", [], function () {
        "use strict";
        return "/**\n * A built-in GLSL floating-point constant for <code>pi/4</code>.\n *\n * @alias czm_piOverFour\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_FOUR\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverFour = ...;\n *\n * // Example\n * float pi = 4.0 * czm_piOverFour;\n */\nconst float czm_piOverFour = 0.7853981633974483;"
    }),define("Cesium/Shaders/Builtin/Constants/piOverSix", [], function () {
        "use strict";
        return "/**\n * A built-in GLSL floating-point constant for <code>pi/6</code>.\n *\n * @alias czm_piOverSix\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_SIX\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverSix = ...;\n *\n * // Example\n * float pi = 6.0 * czm_piOverSix;\n */\nconst float czm_piOverSix = 0.5235987755982988;"
    }),define("Cesium/Shaders/Builtin/Constants/piOverThree", [], function () {
        "use strict";
        return "/**\n * A built-in GLSL floating-point constant for <code>pi/3</code>.\n *\n * @alias czm_piOverThree\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_THREE\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverThree = ...;\n *\n * // Example\n * float pi = 3.0 * czm_piOverThree;\n */\nconst float czm_piOverThree = 1.0471975511965976;"
    }),define("Cesium/Shaders/Builtin/Constants/piOverTwo", [], function () {
        "use strict";
        return "/**\n * A built-in GLSL floating-point constant for <code>pi/2</code>.\n *\n * @alias czm_piOverTwo\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_TWO\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverTwo = ...;\n *\n * // Example\n * float pi = 2.0 * czm_piOverTwo;\n */\nconst float czm_piOverTwo = 1.5707963267948966;"
    }),define("Cesium/Shaders/Builtin/Constants/radiansPerDegree", [], function () {
        "use strict";
        return "/**\n * A built-in GLSL floating-point constant for converting degrees to radians.\n *\n * @alias czm_radiansPerDegree\n * @glslConstant\n *\n * @see CesiumMath.RADIANS_PER_DEGREE\n *\n * @example\n * // GLSL declaration\n * const float czm_radiansPerDegree = ...;\n *\n * // Example\n * float rad = czm_radiansPerDegree * deg;\n */\nconst float czm_radiansPerDegree = 0.017453292519943295;"
    }),define("Cesium/Shaders/Builtin/Constants/sceneMode2D", [], function () {
        "use strict";
        return "/**\n * The constant identifier for the 2D {@link SceneMode}\n *\n * @name czm_sceneMode2D\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneModeColumbusView\n * @see czm_sceneMode3D\n * @see czm_sceneModeMorphing\n */\nconst float czm_sceneMode2D = 2.0;"
    }),define("Cesium/Shaders/Builtin/Constants/sceneMode3D", [], function () {
        "use strict";
        return "/**\n * The constant identifier for the 3D {@link SceneMode}\n *\n * @name czm_sceneMode3D\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneMode2D\n * @see czm_sceneModeColumbusView\n * @see czm_sceneModeMorphing\n */\nconst float czm_sceneMode3D = 3.0;"
    }),define("Cesium/Shaders/Builtin/Constants/sceneModeColumbusView", [], function () {
        "use strict";
        return "/**\n * The constant identifier for the Columbus View {@link SceneMode}\n *\n * @name czm_sceneModeColumbusView\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneMode2D\n * @see czm_sceneMode3D\n * @see czm_sceneModeMorphing\n */\nconst float czm_sceneModeColumbusView = 1.0;"
    }),define("Cesium/Shaders/Builtin/Constants/sceneModeMorphing", [], function () {
        "use strict";
        return "/**\n * The constant identifier for the Morphing {@link SceneMode}\n *\n * @name czm_sceneModeMorphing\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneMode2D\n * @see czm_sceneModeColumbusView\n * @see czm_sceneMode3D\n */\nconst float czm_sceneModeMorphing = 0.0;"
    }),define("Cesium/Shaders/Builtin/Constants/solarRadius", [], function () {
        "use strict";
        return "/**\n * A built-in GLSL floating-point constant for one solar radius.\n *\n * @alias czm_solarRadius\n * @glslConstant\n *\n * @see CesiumMath.SOLAR_RADIUS\n *\n * @example\n * // GLSL declaration\n * const float czm_solarRadius = ...;\n */\nconst float czm_solarRadius = 695500000.0;"
    }),define("Cesium/Shaders/Builtin/Constants/threePiOver2", [], function () {
        "use strict";
        return "/**\n * A built-in GLSL floating-point constant for <code>3pi/2</code>.\n *\n * @alias czm_threePiOver2\n * @glslConstant\n *\n * @see CesiumMath.THREE_PI_OVER_TWO\n *\n * @example\n * // GLSL declaration\n * const float czm_threePiOver2 = ...;\n *\n * // Example\n * float pi = (2.0 / 3.0) * czm_threePiOver2;\n */\nconst float czm_threePiOver2 = 4.71238898038469;"
    }),define("Cesium/Shaders/Builtin/Constants/twoPi", [], function () {
        "use strict";
        return "/**\n * A built-in GLSL floating-point constant for <code>2pi</code>.\n *\n * @alias czm_twoPi\n * @glslConstant\n *\n * @see CesiumMath.TWO_PI\n *\n * @example\n * // GLSL declaration\n * const float czm_twoPi = ...;\n *\n * // Example\n * float pi = czm_twoPi / 2.0;\n */\nconst float czm_twoPi = 6.283185307179586;"
    }),define("Cesium/Shaders/Builtin/Constants/webMercatorMaxLatitude", [], function () {
        "use strict";
        return "/**\n * The maximum latitude, in radians, both North and South, supported by a Web Mercator\n * (EPSG:3857) projection.  Technically, the Mercator projection is defined\n * for any latitude up to (but not including) 90 degrees, but it makes sense\n * to cut it off sooner because it grows exponentially with increasing latitude.\n * The logic behind this particular cutoff value, which is the one used by\n * Google Maps, Bing Maps, and Esri, is that it makes the projection\n * square.  That is, the rectangle is equal in the X and Y directions.\n *\n * The constant value is computed as follows:\n *   czm_pi * 0.5 - (2.0 * atan(exp(-czm_pi)))\n *\n * @name czm_webMercatorMaxLatitude\n * @glslConstant\n */\nconst float czm_webMercatorMaxLatitude = 1.4844222297453324;"
    }),define("Cesium/Shaders/Builtin/Structs/depthRangeStruct", [], function () {
        "use strict";
        return "/**\n * @name czm_depthRangeStruct\n * @glslStruct\n */\nstruct czm_depthRangeStruct\n{\n    float near;\n    float far;\n};"
    }),define("Cesium/Shaders/Builtin/Structs/ellipsoid", [], function () {
        "use strict";
        return "/** DOC_TBA\n *\n * @name czm_ellipsoid\n * @glslStruct\n */\nstruct czm_ellipsoid\n{\n    vec3 center;\n    vec3 radii;\n    vec3 inverseRadii;\n    vec3 inverseRadiiSquared;\n};"
    }),define("Cesium/Shaders/Builtin/Structs/material", [], function () {
        "use strict";
        return "/**\n * Holds material information that can be used for lighting. Returned by all czm_getMaterial functions.\n *\n * @name czm_material\n * @glslStruct\n *\n * @property {vec3} diffuse Incoming light that scatters evenly in all directions.\n * @property {float} specular Intensity of incoming light reflecting in a single direction.\n * @property {float} shininess The sharpness of the specular reflection.  Higher values create a smaller, more focused specular highlight.\n * @property {vec3} normal Surface's normal in eye coordinates. It is used for effects such as normal mapping. The default is the surface's unmodified normal.\n * @property {vec3} emission Light emitted by the material equally in all directions. The default is vec3(0.0), which emits no light.\n * @property {float} alpha Opacity of this material. 0.0 is completely transparent; 1.0 is completely opaque.\n */\nstruct czm_material\n{\n    vec3 diffuse;\n    float specular;\n    float shininess;\n    vec3 normal;\n    vec3 emission;\n    float alpha;\n};"
    }),define("Cesium/Shaders/Builtin/Structs/materialInput", [], function () {
        "use strict";
        return "/**\n * Used as input to every material's czm_getMaterial function.\n *\n * @name czm_materialInput\n * @glslStruct\n *\n * @property {float} s 1D texture coordinates.\n * @property {vec2} st 2D texture coordinates.\n * @property {vec3} str 3D texture coordinates.\n * @property {vec3} normalEC Unperturbed surface normal in eye coordinates.\n * @property {mat3} tangentToEyeMatrix Matrix for converting a tangent space normal to eye space.\n * @property {vec3} positionToEyeEC Vector from the fragment to the eye in eye coordinates.  The magnitude is the distance in meters from the fragment to the eye.\n */\nstruct czm_materialInput\n{\n    float s;\n    vec2 st;\n    vec3 str;\n    vec3 normalEC;\n    mat3 tangentToEyeMatrix;\n    vec3 positionToEyeEC;\n};"
    }),define("Cesium/Shaders/Builtin/Structs/ray", [], function () {
        "use strict";
        return "/**\n * DOC_TBA\n *\n * @name czm_ray\n * @glslStruct\n */\nstruct czm_ray\n{\n    vec3 origin;\n    vec3 direction;\n};"
    }),define("Cesium/Shaders/Builtin/Structs/raySegment", [], function () {
        "use strict";
        return "/**\n * DOC_TBA\n *\n * @name czm_raySegment\n * @glslStruct\n */\nstruct czm_raySegment\n{\n    float start;\n    float stop;\n};\n\n/**\n * DOC_TBA\n *\n * @name czm_emptyRaySegment\n * @glslConstant \n */\nconst czm_raySegment czm_emptyRaySegment = czm_raySegment(-czm_infinity, -czm_infinity);\n\n/**\n * DOC_TBA\n *\n * @name czm_fullRaySegment\n * @glslConstant \n */\nconst czm_raySegment czm_fullRaySegment = czm_raySegment(0.0, czm_infinity);\n"
    }),define("Cesium/Shaders/Builtin/Functions/RGBToXYZ", [], function () {
        "use strict";
        return "/**\n * Converts an RGB color to CIE Yxy.\n * <p>The conversion is described in\n * {@link http://content.gpwiki.org/index.php/D3DBook:High-Dynamic_Range_Rendering#Luminance_Transform|Luminance Transform}\n * </p>\n * \n * @name czm_RGBToXYZ\n * @glslFunction\n * \n * @param {vec3} rgb The color in RGB.\n *\n * @returns {vec3} The color in CIE Yxy.\n *\n * @example\n * vec3 xyz = czm_RGBToXYZ(rgb);\n * xyz.x = max(xyz.x - luminanceThreshold, 0.0);\n * rgb = czm_XYZToRGB(xyz);\n */\nvec3 czm_RGBToXYZ(vec3 rgb)\n{\n    const mat3 RGB2XYZ = mat3(0.4124, 0.2126, 0.0193,\n                              0.3576, 0.7152, 0.1192,\n                              0.1805, 0.0722, 0.9505);\n    vec3 xyz = RGB2XYZ * rgb;\n    vec3 Yxy;\n    Yxy.r = xyz.g;\n    float temp = dot(vec3(1.0), xyz);\n    Yxy.gb = xyz.rg / temp;\n    return Yxy;\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/XYZToRGB", [], function () {
        "use strict";
        return "/**\n * Converts a CIE Yxy color to RGB.\n * <p>The conversion is described in\n * {@link http://content.gpwiki.org/index.php/D3DBook:High-Dynamic_Range_Rendering#Luminance_Transform|Luminance Transform}\n * </p>\n * \n * @name czm_XYZToRGB\n * @glslFunction\n * \n * @param {vec3} Yxy The color in CIE Yxy.\n *\n * @returns {vec3} The color in RGB.\n *\n * @example\n * vec3 xyz = czm_RGBToXYZ(rgb);\n * xyz.x = max(xyz.x - luminanceThreshold, 0.0);\n * rgb = czm_XYZToRGB(xyz);\n */\nvec3 czm_XYZToRGB(vec3 Yxy)\n{\n    const mat3 XYZ2RGB = mat3( 3.2405, -0.9693,  0.0556,\n                              -1.5371,  1.8760, -0.2040,\n                              -0.4985,  0.0416,  1.0572);\n    vec3 xyz;\n    xyz.r = Yxy.r * Yxy.g / Yxy.b;\n    xyz.g = Yxy.r;\n    xyz.b = Yxy.r * (1.0 - Yxy.g - Yxy.b) / Yxy.b;\n    \n    return XYZ2RGB * xyz;\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/alphaWeight", [], function () {
        "use strict";
        return "/**\n * @private\n */\nfloat czm_alphaWeight(float a)\n{\n    float z;\n    if (czm_sceneMode != czm_sceneMode2D)\n    {\n        float x = 2.0 * (gl_FragCoord.x - czm_viewport.x) / czm_viewport.z - 1.0;\n        float y = 2.0 * (gl_FragCoord.y - czm_viewport.y) / czm_viewport.w - 1.0;\n        z = (gl_FragCoord.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];\n        vec4 q = vec4(x, y, z, 0.0);\n        q /= gl_FragCoord.w;\n        z = (czm_inverseProjectionOIT * q).z;\n    }\n    else\n    {\n        z = gl_FragCoord.z * (czm_currentFrustum.y - czm_currentFrustum.x) + czm_currentFrustum.x;\n    }\n    \n    // See Weighted Blended Order-Independent Transparency for examples of different weighting functions:\n    // http://jcgt.org/published/0002/02/09/\n    return pow(a + 0.01, 4.0) + max(1e-2, min(3.0 * 1e3, 100.0 / (1e-5 + pow(abs(z) / 10.0, 3.0) + pow(abs(z) / 200.0, 6.0))));\n}"
    }),define("Cesium/Shaders/Builtin/Functions/antialias", [], function () {
        "use strict";
        return "/**\n * Procedural anti-aliasing by blurring two colors that meet at a sharp edge.\n *\n * @name czm_antialias\n * @glslFunction\n *\n * @param {vec4} color1 The color on one side of the edge.\n * @param {vec4} color2 The color on the other side of the edge.\n * @param {vec4} currentcolor The current color, either <code>color1</code> or <code>color2</code>.\n * @param {float} dist The distance to the edge in texture coordinates.\n * @param {float} [fuzzFactor=0.1] Controls the blurriness between the two colors.\n * @returns {vec4} The anti-aliased color.\n *\n * @example\n * // GLSL declarations\n * vec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist, float fuzzFactor);\n * vec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist);\n *\n * // get the color for a material that has a sharp edge at the line y = 0.5 in texture space\n * float dist = abs(textureCoordinates.t - 0.5);\n * vec4 currentColor = mix(bottomColor, topColor, step(0.5, textureCoordinates.t));\n * vec4 color = czm_antialias(bottomColor, topColor, currentColor, dist, 0.1);\n */\nvec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist, float fuzzFactor)\n{\n    float val1 = clamp(dist / fuzzFactor, 0.0, 1.0);\n    float val2 = clamp((dist - 0.5) / fuzzFactor, 0.0, 1.0);\n    val1 = val1 * (1.0 - val2);\n    val1 = val1 * val1 * (3.0 - (2.0 * val1));\n    val1 = pow(val1, 0.5); //makes the transition nicer\n    \n    vec4 midColor = (color1 + color2) * 0.5;\n    return mix(midColor, currentColor, val1);\n}\n\nvec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist)\n{\n    return czm_antialias(color1, color2, currentColor, dist, 0.1);\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/columbusViewMorph", [], function () {
        "use strict";
        return "/**\n * DOC_TBA\n *\n * @name czm_columbusViewMorph\n * @glslFunction\n */\nvec4 czm_columbusViewMorph(vec4 position2D, vec4 position3D, float time)\n{\n    // Just linear for now.\n    vec3 p = mix(position2D.xyz, position3D.xyz, time);\n    return vec4(p, 1.0);\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/computePosition", [], function () {
        "use strict";
        return "/**\n * Returns a position in model coordinates relative to eye taking into\n * account the current scene mode: 3D, 2D, or Columbus view.\n * <p>\n * This uses standard position attributes, <code>position3DHigh</code>, \n * <code>position3DLow</code>, <code>position2DHigh</code>, and <code>position2DLow</code>, \n * and should be used when writing a vertex shader for an {@link Appearance}.\n * </p>\n *\n * @name czm_computePosition\n * @glslFunction\n *\n * @returns {vec4} The position relative to eye.\n *\n * @example\n * vec4 p = czm_computePosition();\n * v_positionEC = (czm_modelViewRelativeToEye * p).xyz;\n * gl_Position = czm_modelViewProjectionRelativeToEye * p;\n *\n * @see czm_translateRelativeToEye\n */\nvec4 czm_computePosition();\n"
    }),define("Cesium/Shaders/Builtin/Functions/cosineAndSine", [], function () {
        "use strict";
        return "/**\n * @private\n */\nvec2 cordic(float angle)\n{\n// Scale the vector by the appropriate factor for the 24 iterations to follow.\n    vec2 vector = vec2(6.0725293500888267e-1, 0.0);\n// Iteration 1\n    float sense = (angle < 0.0) ? -1.0 : 1.0;\n //   float factor = sense * 1.0;  // 2^-0\n    mat2 rotation = mat2(1.0, sense, -sense, 1.0);\n    vector = rotation * vector;\n    angle -= sense * 7.8539816339744828e-1;  // atan(2^-0)\n// Iteration 2\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    float factor = sense * 5.0e-1;  // 2^-1\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 4.6364760900080609e-1;  // atan(2^-1)\n// Iteration 3\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 2.5e-1;  // 2^-2\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 2.4497866312686414e-1;  // atan(2^-2)\n// Iteration 4\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.25e-1;  // 2^-3\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.2435499454676144e-1;  // atan(2^-3)\n// Iteration 5\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 6.25e-2;  // 2^-4\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 6.2418809995957350e-2;  // atan(2^-4)\n// Iteration 6\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.125e-2;  // 2^-5\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.1239833430268277e-2;  // atan(2^-5)\n// Iteration 7\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.5625e-2;  // 2^-6\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.5623728620476831e-2;  // atan(2^-6)\n// Iteration 8\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 7.8125e-3;  // 2^-7\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 7.8123410601011111e-3;  // atan(2^-7)\n// Iteration 9\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.90625e-3;  // 2^-8\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.9062301319669718e-3;  // atan(2^-8)\n// Iteration 10\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.953125e-3;  // 2^-9\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.9531225164788188e-3;  // atan(2^-9)\n// Iteration 11\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 9.765625e-4;  // 2^-10\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 9.7656218955931946e-4;  // atan(2^-10)\n// Iteration 12\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 4.8828125e-4;  // 2^-11\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 4.8828121119489829e-4;  // atan(2^-11)\n// Iteration 13\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 2.44140625e-4;  // 2^-12\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 2.4414062014936177e-4;  // atan(2^-12)\n// Iteration 14\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.220703125e-4;  // 2^-13\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.2207031189367021e-4;  // atan(2^-13)\n// Iteration 15\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 6.103515625e-5;  // 2^-14\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 6.1035156174208773e-5;  // atan(2^-14)\n// Iteration 16\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.0517578125e-5;  // 2^-15\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.0517578115526096e-5;  // atan(2^-15)\n// Iteration 17\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.52587890625e-5;  // 2^-16\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.5258789061315762e-5;  // atan(2^-16)\n// Iteration 18\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 7.62939453125e-6;  // 2^-17\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 7.6293945311019700e-6;  // atan(2^-17)\n// Iteration 19\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.814697265625e-6;  // 2^-18\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.8146972656064961e-6;  // atan(2^-18)\n// Iteration 20\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.9073486328125e-6;  // 2^-19\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.9073486328101870e-6;  // atan(2^-19)\n// Iteration 21\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 9.5367431640625e-7;  // 2^-20\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 9.5367431640596084e-7;  // atan(2^-20)\n// Iteration 22\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 4.76837158203125e-7;  // 2^-21\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 4.7683715820308884e-7;  // atan(2^-21)\n// Iteration 23\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 2.384185791015625e-7;  // 2^-22\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 2.3841857910155797e-7;  // atan(2^-22)\n// Iteration 24\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.1920928955078125e-7;  // 2^-23\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n//    angle -= sense * 1.1920928955078068e-7;  // atan(2^-23)\n\n    return vector;\n}\n\n/**\n * Computes the cosine and sine of the provided angle using the CORDIC algorithm.\n *\n * @name czm_cosineAndSine\n * @glslFunction\n *\n * @param {float} angle The angle in radians.\n *\n * @returns {vec2} The resulting cosine of the angle (as the x coordinate) and sine of the angle (as the y coordinate).\n *\n * @example\n * vec2 v = czm_cosineAndSine(czm_piOverSix);\n * float cosine = v.x;\n * float sine = v.y;\n */\nvec2 czm_cosineAndSine(float angle)\n{\n    if (angle < -czm_piOverTwo || angle > czm_piOverTwo)\n    {\n        if (angle < 0.0)\n        {\n            return -cordic(angle + czm_pi);\n        }\n        else\n        {\n            return -cordic(angle - czm_pi);\n        }\n    }\n    else\n    {\n        return cordic(angle);\n    }\n}"
    }),define("Cesium/Shaders/Builtin/Functions/decompressTextureCoordinates", [], function () {
        "use strict";
        return "/**\n * Decompresses texture coordinates that were packed into a single float.\n *\n * @name czm_decompressTextureCoordinates\n * @glslFunction\n *\n * @param {float} encoded The compressed texture coordinates.\n * @returns {vec2} The decompressed texture coordinates.\n */\n vec2 czm_decompressTextureCoordinates(float encoded)\n {\n    float temp = encoded / 4096.0;\n    float stx = floor(temp) / 4096.0;\n    float sty = temp - floor(temp);\n    return vec2(stx, sty);\n }\n"
    }),define("Cesium/Shaders/Builtin/Functions/eastNorthUpToEyeCoordinates", [], function () {
        "use strict";
        return "/**\n * Computes a 3x3 rotation matrix that transforms vectors from an ellipsoid's east-north-up coordinate system \n * to eye coordinates.  In east-north-up coordinates, x points east, y points north, and z points along the \n * surface normal.  East-north-up can be used as an ellipsoid's tangent space for operations such as bump mapping.\n * <br /><br />\n * The ellipsoid is assumed to be centered at the model coordinate's origin.\n *\n * @name czm_eastNorthUpToEyeCoordinates\n * @glslFunction\n *\n * @param {vec3} positionMC The position on the ellipsoid in model coordinates.\n * @param {vec3} normalEC The normalized ellipsoid surface normal, at <code>positionMC</code>, in eye coordinates.\n *\n * @returns {mat3} A 3x3 rotation matrix that transforms vectors from the east-north-up coordinate system to eye coordinates.\n *\n * @example\n * // Transform a vector defined in the east-north-up coordinate \n * // system, (0, 0, 1) which is the surface normal, to eye \n * // coordinates.\n * mat3 m = czm_eastNorthUpToEyeCoordinates(positionMC, normalEC);\n * vec3 normalEC = m * vec3(0.0, 0.0, 1.0);\n */\nmat3 czm_eastNorthUpToEyeCoordinates(vec3 positionMC, vec3 normalEC)\n{\n    vec3 tangentMC = normalize(vec3(-positionMC.y, positionMC.x, 0.0));  // normalized surface tangent in model coordinates\n    vec3 tangentEC = normalize(czm_normal3D * tangentMC);                // normalized surface tangent in eye coordiantes\n    vec3 bitangentEC = normalize(cross(normalEC, tangentEC));            // normalized surface bitangent in eye coordinates\n\n    return mat3(\n        tangentEC.x,   tangentEC.y,   tangentEC.z,\n        bitangentEC.x, bitangentEC.y, bitangentEC.z,\n        normalEC.x,    normalEC.y,    normalEC.z);\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/ellipsoidContainsPoint", [], function () {
        "use strict";
        return "/**\n * DOC_TBA\n *\n * @name czm_ellipsoidContainsPoint\n * @glslFunction\n *\n */\nbool czm_ellipsoidContainsPoint(czm_ellipsoid ellipsoid, vec3 point)\n{\n    vec3 scaled = ellipsoid.inverseRadii * (czm_inverseModelView * vec4(point, 1.0)).xyz;\n    return (dot(scaled, scaled) <= 1.0);\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/ellipsoidNew", [], function () {
        "use strict";
        return "/**\n * DOC_TBA\n *\n * @name czm_ellipsoidNew\n * @glslFunction\n *\n */\nczm_ellipsoid czm_ellipsoidNew(vec3 center, vec3 radii)\n{\n    vec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\n    vec3 inverseRadiiSquared = inverseRadii * inverseRadii;\n    czm_ellipsoid temp = czm_ellipsoid(center, radii, inverseRadii, inverseRadiiSquared);\n    return temp;\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/ellipsoidWgs84TextureCoordinates", [], function () {
        "use strict";
        return "/**\n * DOC_TBA\n *\n * @name czm_ellipsoidWgs84TextureCoordinates\n * @glslFunction\n */\nvec2 czm_ellipsoidWgs84TextureCoordinates(vec3 normal)\n{\n    return vec2(atan(normal.y, normal.x) * czm_oneOverTwoPi + 0.5, asin(normal.z) * czm_oneOverPi + 0.5);\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/equalsEpsilon", [], function () {
        "use strict";
        return "/**\n * Compares <code>left</code> and <code>right</code> componentwise. Returns <code>true</code>\n * if they are within <code>epsilon</code> and <code>false</code> otherwise. The inputs\n * <code>left</code> and <code>right</code> can be <code>float</code>s, <code>vec2</code>s,\n * <code>vec3</code>s, or <code>vec4</code>s.\n *\n * @name czm_equalsEpsilon\n * @glslFunction\n *\n * @param {} left The first vector.\n * @param {} right The second vector.\n * @param {float} epsilon The epsilon to use for equality testing.\n * @returns {bool} <code>true</code> if the components are within <code>epsilon</code> and <code>false</code> otherwise.\n *\n * @example\n * // GLSL declarations\n * bool czm_equalsEpsilon(float left, float right, float epsilon);\n * bool czm_equalsEpsilon(vec2 left, vec2 right, float epsilon);\n * bool czm_equalsEpsilon(vec3 left, vec3 right, float epsilon);\n * bool czm_equalsEpsilon(vec4 left, vec4 right, float epsilon);\n */\nbool czm_equalsEpsilon(vec4 left, vec4 right, float epsilon) {\n    return all(lessThanEqual(abs(left - right), vec4(epsilon)));\n}\n\nbool czm_equalsEpsilon(vec3 left, vec3 right, float epsilon) {\n    return all(lessThanEqual(abs(left - right), vec3(epsilon)));\n}\n\nbool czm_equalsEpsilon(vec2 left, vec2 right, float epsilon) {\n    return all(lessThanEqual(abs(left - right), vec2(epsilon)));\n}\n\nbool czm_equalsEpsilon(float left, float right, float epsilon) {\n    return (abs(left - right) <= epsilon);\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/eyeOffset", [], function () {
        "use strict";
        return "/**\n * DOC_TBA\n *\n * @name czm_eyeOffset\n * @glslFunction\n *\n * @param {vec4} positionEC DOC_TBA.\n * @param {vec3} eyeOffset DOC_TBA.\n *\n * @returns {vec4} DOC_TBA.\n */\nvec4 czm_eyeOffset(vec4 positionEC, vec3 eyeOffset)\n{\n    // This equation is approximate in x and y.\n    vec4 p = positionEC;\n    vec4 zEyeOffset = normalize(p) * eyeOffset.z;\n    p.xy += eyeOffset.xy + zEyeOffset.xy;\n    p.z += zEyeOffset.z;\n    return p;\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/eyeToWindowCoordinates", [], function () {
        "use strict";
        return "/**\n * Transforms a position from eye to window coordinates.  The transformation\n * from eye to clip coordinates is done using {@link czm_projection}.\n * The transform from normalized device coordinates to window coordinates is\n * done using {@link czm_viewportTransformation}, which assumes a depth range\n * of <code>near = 0</code> and <code>far = 1</code>.\n * <br /><br />\n * This transform is useful when there is a need to manipulate window coordinates\n * in a vertex shader as done by {@link BillboardCollection}.\n *\n * @name czm_eyeToWindowCoordinates\n * @glslFunction\n *\n * @param {vec4} position The position in eye coordinates to transform.\n *\n * @returns {vec4} The transformed position in window coordinates.\n *\n * @see czm_modelToWindowCoordinates\n * @see czm_projection\n * @see czm_viewportTransformation\n * @see BillboardCollection\n *\n * @example\n * vec4 positionWC = czm_eyeToWindowCoordinates(positionEC);\n */\nvec4 czm_eyeToWindowCoordinates(vec4 positionEC)\n{\n    vec4 q = czm_projection * positionEC;                        // clip coordinates\n    q.xyz /= q.w;                                                // normalized device coordinates\n    q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // window coordinates\n    return q;\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/geodeticSurfaceNormal", [], function () {
        "use strict";
        return "/**\n * DOC_TBA\n *\n * @name czm_geodeticSurfaceNormal\n * @glslFunction\n *\n * @param {vec3} positionOnEllipsoid DOC_TBA\n * @param {vec3} ellipsoidCenter DOC_TBA\n * @param {vec3} oneOverEllipsoidRadiiSquared DOC_TBA\n * \n * @returns {vec3} DOC_TBA.\n */\nvec3 czm_geodeticSurfaceNormal(vec3 positionOnEllipsoid, vec3 ellipsoidCenter, vec3 oneOverEllipsoidRadiiSquared)\n{\n    return normalize((positionOnEllipsoid - ellipsoidCenter) * oneOverEllipsoidRadiiSquared);\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/getDefaultMaterial", [], function () {
        "use strict";
        return "/**\n * An czm_material with default values. Every material's czm_getMaterial\n * should use this default material as a base for the material it returns.\n * The default normal value is given by materialInput.normalEC.\n *\n * @name czm_getDefaultMaterial\n * @glslFunction \n *\n * @param {czm_materialInput} input The input used to construct the default material.\n * \n * @returns {czm_material} The default material.\n *\n * @see czm_materialInput\n * @see czm_material\n * @see czm_getMaterial\n */\nczm_material czm_getDefaultMaterial(czm_materialInput materialInput)\n{\n    czm_material material;\n    material.diffuse = vec3(0.0);\n    material.specular = 0.0;\n    material.shininess = 1.0;\n    material.normal = materialInput.normalEC;\n    material.emission = vec3(0.0);\n    material.alpha = 1.0;\n    return material;\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/getLambertDiffuse", [], function () {
        "use strict";
        return "/**\n * Calculates the intensity of diffusely reflected light.\n *\n * @name czm_getLambertDiffuse\n * @glslFunction\n *\n * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates.\n * @param {vec3} normalEC The surface normal in eye coordinates.\n *\n * @returns {float} The intensity of the diffuse reflection.\n *\n * @see czm_phong\n *\n * @example\n * float diffuseIntensity = czm_getLambertDiffuse(lightDirectionEC, normalEC);\n * float specularIntensity = czm_getSpecular(lightDirectionEC, toEyeEC, normalEC, 200);\n * vec3 color = (diffuseColor * diffuseIntensity) + (specularColor * specularIntensity);\n */\nfloat czm_getLambertDiffuse(vec3 lightDirectionEC, vec3 normalEC)\n{\n    return max(dot(lightDirectionEC, normalEC), 0.0);\n}";
    }),define("Cesium/Shaders/Builtin/Functions/getSpecular", [], function () {
        "use strict";
        return "/**\n * Calculates the specular intensity of reflected light.\n *\n * @name czm_getSpecular\n * @glslFunction\n *\n * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates.\n * @param {vec3} toEyeEC Unit vector pointing to the eye position in eye coordinates.\n * @param {vec3} normalEC The surface normal in eye coordinates.\n * @param {float} shininess The sharpness of the specular reflection.  Higher values create a smaller, more focused specular highlight.\n *\n * @returns {float} The intensity of the specular highlight.\n *\n * @see czm_phong\n *\n * @example\n * float diffuseIntensity = czm_getLambertDiffuse(lightDirectionEC, normalEC);\n * float specularIntensity = czm_getSpecular(lightDirectionEC, toEyeEC, normalEC, 200);\n * vec3 color = (diffuseColor * diffuseIntensity) + (specularColor * specularIntensity);\n */\nfloat czm_getSpecular(vec3 lightDirectionEC, vec3 toEyeEC, vec3 normalEC, float shininess)\n{\n    vec3 toReflectedLight = reflect(-lightDirectionEC, normalEC);\n    float specular = max(dot(toReflectedLight, toEyeEC), 0.0);\n    return pow(specular, shininess);\n}"
    }),define("Cesium/Shaders/Builtin/Functions/getWaterNoise", [], function () {
        "use strict";
        return "/**\n * @private\n */\nvec4 czm_getWaterNoise(sampler2D normalMap, vec2 uv, float time, float angleInRadians)\n{\n    float cosAngle = cos(angleInRadians);\n    float sinAngle = sin(angleInRadians);\n\n    // time dependent sampling directions\n    vec2 s0 = vec2(1.0/17.0, 0.0);\n    vec2 s1 = vec2(-1.0/29.0, 0.0);\n    vec2 s2 = vec2(1.0/101.0, 1.0/59.0);\n    vec2 s3 = vec2(-1.0/109.0, -1.0/57.0);\n\n    // rotate sampling direction by specified angle\n    s0 = vec2((cosAngle * s0.x) - (sinAngle * s0.y), (sinAngle * s0.x) + (cosAngle * s0.y));\n    s1 = vec2((cosAngle * s1.x) - (sinAngle * s1.y), (sinAngle * s1.x) + (cosAngle * s1.y));\n    s2 = vec2((cosAngle * s2.x) - (sinAngle * s2.y), (sinAngle * s2.x) + (cosAngle * s2.y));\n    s3 = vec2((cosAngle * s3.x) - (sinAngle * s3.y), (sinAngle * s3.x) + (cosAngle * s3.y));\n\n    vec2 uv0 = (uv/103.0) + (time * s0);\n    vec2 uv1 = uv/107.0 + (time * s1) + vec2(0.23);\n    vec2 uv2 = uv/vec2(897.0, 983.0) + (time * s2) + vec2(0.51);\n    vec2 uv3 = uv/vec2(991.0, 877.0) + (time * s3) + vec2(0.71);\n\n    uv0 = fract(uv0);\n    uv1 = fract(uv1);\n    uv2 = fract(uv2);\n    uv3 = fract(uv3);\n    vec4 noise = (texture2D(normalMap, uv0)) +\n                 (texture2D(normalMap, uv1)) +\n                 (texture2D(normalMap, uv2)) +\n                 (texture2D(normalMap, uv3));\n\n    // average and scale to between -1 and 1\n    return ((noise / 4.0) - 0.5) * 2.0;\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/getWgs84EllipsoidEC", [], function () {
        "use strict";
        return "/**\n * Returns the WGS84 ellipsoid, with its center at the origin of world coordinates, in eye coordinates.\n *\n * @name czm_getWgs84EllipsoidEC\n * @glslFunction\n *\n * @returns {czm_ellipsoid} The WGS84 ellipsoid, with its center at the origin of world coordinates, in eye coordinates.\n *\n * @see Ellipsoid.WGS84\n *\n * @example\n * czm_ellipsoid ellipsoid = czm_getWgs84EllipsoidEC();\n */\nczm_ellipsoid czm_getWgs84EllipsoidEC()\n{\n    vec3 radii = vec3(6378137.0, 6378137.0, 6356752.314245);\n    vec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\n    vec3 inverseRadiiSquared = inverseRadii * inverseRadii;\n    czm_ellipsoid temp = czm_ellipsoid(czm_view[3].xyz, radii, inverseRadii, inverseRadiiSquared);\n    return temp;\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/hue", [], function () {
        "use strict";
        return "/**\n * Adjusts the hue of a color.\n * \n * @name czm_hue\n * @glslFunction\n * \n * @param {vec3} rgb The color.\n * @param {float} adjustment The amount to adjust the hue of the color in radians.\n *\n * @returns {float} The color with the hue adjusted.\n *\n * @example\n * vec3 adjustHue = czm_hue(color, czm_pi); // The same as czm_hue(color, -czm_pi)\n */\nvec3 czm_hue(vec3 rgb, float adjustment)\n{\n    const mat3 toYIQ = mat3(0.299,     0.587,     0.114,\n                            0.595716, -0.274453, -0.321263,\n                            0.211456, -0.522591,  0.311135);\n    const mat3 toRGB = mat3(1.0,  0.9563,  0.6210,\n                            1.0, -0.2721, -0.6474,\n                            1.0, -1.107,   1.7046);\n    \n    vec3 yiq = toYIQ * rgb;\n    float hue = atan(yiq.z, yiq.y) + adjustment;\n    float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\n    \n    vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\n    return toRGB * color;\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/isEmpty", [], function () {
        "use strict";
        return "/**\n * Determines if a time interval is empty.\n *\n * @name czm_isEmpty\n * @glslFunction \n * \n * @param {czm_raySegment} interval The interval to test.\n * \n * @returns {bool} <code>true</code> if the time interval is empty; otherwise, <code>false</code>.\n *\n * @example\n * bool b0 = czm_isEmpty(czm_emptyRaySegment);      // true\n * bool b1 = czm_isEmpty(czm_raySegment(0.0, 1.0)); // false\n * bool b2 = czm_isEmpty(czm_raySegment(1.0, 1.0)); // false, contains 1.0.\n */\nbool czm_isEmpty(czm_raySegment interval)\n{\n    return (interval.stop < 0.0);\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/isFull", [], function () {
        "use strict";
        return "/**\n * Determines if a time interval is empty.\n *\n * @name czm_isFull\n * @glslFunction \n * \n * @param {czm_raySegment} interval The interval to test.\n * \n * @returns {bool} <code>true</code> if the time interval is empty; otherwise, <code>false</code>.\n *\n * @example\n * bool b0 = czm_isEmpty(czm_emptyRaySegment);      // true\n * bool b1 = czm_isEmpty(czm_raySegment(0.0, 1.0)); // false\n * bool b2 = czm_isEmpty(czm_raySegment(1.0, 1.0)); // false, contains 1.0.\n */\nbool czm_isFull(czm_raySegment interval)\n{\n    return (interval.start == 0.0 && interval.stop == czm_infinity);\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/latitudeToWebMercatorFraction", [], function () {
        "use strict";
        return "/**\n * Computes the fraction of a Web Wercator rectangle at which a given geodetic latitude is located.\n *\n * @name czm_latitudeToWebMercatorFraction\n * @glslFunction\n *\n * @param {float} latitude The geodetic latitude, in radians.\n * @param {float} southMercatorYLow The low portion of the Web Mercator coordinate of the southern boundary of the rectangle.\n * @param {float} southMercatorYHigh The high portion of the Web Mercator coordinate of the southern boundary of the rectangle.\n * @param {float} oneOverMercatorHeight The total height of the rectangle in Web Mercator coordinates.\n *\n * @returns {float} The fraction of the rectangle at which the latitude occurs.  If the latitude is the southern\n *          boundary of the rectangle, the return value will be zero.  If it is the northern boundary, the return\n *          value will be 1.0.  Latitudes in between are mapped according to the Web Mercator projection.\n */ \nfloat czm_latitudeToWebMercatorFraction(float latitude, float southMercatorYLow, float southMercatorYHigh, float oneOverMercatorHeight)\n{\n    float sinLatitude = sin(latitude);\n    float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\n    \n    // mercatorY - southMercatorY in simulated double precision.\n    float t1 = 0.0 - southMercatorYLow;\n    float e = t1 - 0.0;\n    float t2 = ((-southMercatorYLow - e) + (0.0 - (t1 - e))) + mercatorY - southMercatorYHigh;\n    float highDifference = t1 + t2;\n    float lowDifference = t2 - (highDifference - t1);\n    \n    return highDifference * oneOverMercatorHeight + lowDifference * oneOverMercatorHeight;\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/luminance", [], function () {
        "use strict";
        return "/**\n * Computes the luminance of a color. \n *\n * @name czm_luminance\n * @glslFunction\n *\n * @param {vec3} rgb The color.\n * \n * @returns {float} The luminance.\n *\n * @example\n * float light = czm_luminance(vec3(0.0)); // 0.0\n * float dark = czm_luminance(vec3(1.0));  // ~1.0 \n */\nfloat czm_luminance(vec3 rgb)\n{\n    // Algorithm from Chapter 10 of Graphics Shaders.\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    return dot(rgb, W);\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/metersPerPixel", [], function () {
        "use strict";
        return "/**\n * Computes the size of a pixel in meters at a distance from the eye.\n \n * @name czm_metersPerPixel\n * @glslFunction\n *\n * @param {vec3} positionEC The position to get the meters per pixel in eye coordinates.\n *\n * @returns {float} The meters per pixel at positionEC.\n */\nfloat czm_metersPerPixel(vec4 positionEC)\n{\n    float width = czm_viewport.z;\n    float height = czm_viewport.w;\n    float pixelWidth;\n    float pixelHeight;\n    \n    float top = czm_frustumPlanes.x;\n    float bottom = czm_frustumPlanes.y;\n    float left = czm_frustumPlanes.z;\n    float right = czm_frustumPlanes.w;\n    \n    if (czm_sceneMode == czm_sceneMode2D)\n    {\n        float frustumWidth = right - left;\n        float frustumHeight = top - bottom;\n        pixelWidth = frustumWidth / width;\n        pixelHeight = frustumHeight / height;\n    }\n    else\n    {\n        float distanceToPixel = -positionEC.z;\n        float inverseNear = 1.0 / czm_currentFrustum.x;\n        float tanTheta = top * inverseNear;\n        pixelHeight = 2.0 * distanceToPixel * tanTheta / height;\n        tanTheta = right * inverseNear;\n        pixelWidth = 2.0 * distanceToPixel * tanTheta / width;\n    }\n\n    return max(pixelWidth, pixelHeight);\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/modelToWindowCoordinates", [], function () {
        "use strict";
        return "/**\n * Transforms a position from model to window coordinates.  The transformation\n * from model to clip coordinates is done using {@link czm_modelViewProjection}.\n * The transform from normalized device coordinates to window coordinates is\n * done using {@link czm_viewportTransformation}, which assumes a depth range\n * of <code>near = 0</code> and <code>far = 1</code>.\n * <br /><br />\n * This transform is useful when there is a need to manipulate window coordinates\n * in a vertex shader as done by {@link BillboardCollection}.\n * <br /><br />\n * This function should not be confused with {@link czm_viewportOrthographic},\n * which is an orthographic projection matrix that transforms from window \n * coordinates to clip coordinates.\n *\n * @name czm_modelToWindowCoordinates\n * @glslFunction\n *\n * @param {vec4} position The position in model coordinates to transform.\n *\n * @returns {vec4} The transformed position in window coordinates.\n *\n * @see czm_eyeToWindowCoordinates\n * @see czm_modelViewProjection\n * @see czm_viewportTransformation\n * @see czm_viewportOrthographic\n * @see BillboardCollection\n *\n * @example\n * vec4 positionWC = czm_modelToWindowCoordinates(positionMC);\n */\nvec4 czm_modelToWindowCoordinates(vec4 position)\n{\n    vec4 q = czm_modelViewProjection * position;                // clip coordinates\n    q.xyz /= q.w;                                                // normalized device coordinates\n    q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // window coordinates\n    return q;\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/multiplyWithColorBalance", [], function () {
        "use strict";
        return "/**\n * DOC_TBA\n *\n * @name czm_multiplyWithColorBalance\n * @glslFunction\n */\nvec3 czm_multiplyWithColorBalance(vec3 left, vec3 right)\n{\n    // Algorithm from Chapter 10 of Graphics Shaders.\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    \n    vec3 target = left * right;\n    float leftLuminance = dot(left, W);\n    float rightLuminance = dot(right, W);\n    float targetLuminance = dot(target, W);\n    \n    return ((leftLuminance + rightLuminance) / (2.0 * targetLuminance)) * target;\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/nearFarScalar", [], function () {
        "use strict";
        return "/**\n * Computes a value that scales with distance.  The scaling is clamped at the near and\n * far distances, and does not extrapolate.  This function works with the\n * {@link NearFarScalar} JavaScript class.\n *\n * @name czm_nearFarScalar\n * @glslFunction\n *\n * @param {vec4} nearFarScalar A vector with 4 components: Near distance (x), Near value (y), Far distance (z), Far value (w).\n * @param {float} cameraDistSq The square of the current distance from the camera.\n *\n * @returns {float} The value at this distance.\n */\nfloat czm_nearFarScalar(vec4 nearFarScalar, float cameraDistSq)\n{\n    float valueAtMin = nearFarScalar.y;\n    float valueAtMax = nearFarScalar.w;\n    float nearDistanceSq = nearFarScalar.x * nearFarScalar.x;\n    float farDistanceSq = nearFarScalar.z * nearFarScalar.z;\n\n    float t = (cameraDistSq - nearDistanceSq) / (farDistanceSq - nearDistanceSq);\n\n    t = pow(clamp(t, 0.0, 1.0), 0.2);\n\n    return mix(valueAtMin, valueAtMax, t);\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/octDecode", [], function () {
        "use strict";
        return "/**\n * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component Cartesian vector.\n * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\",\n * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/\n * \n * @name czm_octDecode\n * @param {vec2} encoded The oct-encoded, unit-length vector\n * @returns {vec3} The decoded and normalized vector\n */\n vec3 czm_octDecode(vec2 encoded)\n {\n    encoded = encoded / 255.0 * 2.0 - 1.0;\n    vec3 v = vec3(encoded.x, encoded.y, 1.0 - abs(encoded.x) - abs(encoded.y));\n    if (v.z < 0.0)\n    {\n        v.xy = (1.0 - abs(v.yx)) * czm_signNotZero(v.xy);\n    }\n    \n    return normalize(v);\n }\n\n /**\n * Decodes a unit-length vector in 'oct' encoding packed into a floating-point number to a normalized 3-component Cartesian vector.\n * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\",\n * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/\n * \n * @name czm_octDecode\n * @param {float} encoded The oct-encoded, unit-length vector\n * @returns {vec3} The decoded and normalized vector\n */\n vec3 czm_octDecode(float encoded)\n {\n    float temp = encoded / 256.0;\n    float x = floor(temp);\n    float y = (temp - x) * 256.0;\n    return czm_octDecode(vec2(x, y));\n }\n \n/**\n * Decodes three unit-length vectors in 'oct' encoding packed into two floating-point numbers to normalized 3-component Cartesian vectors.\n * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\",\n * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/\n * \n * @name czm_octDecode\n * @param {vec2} encoded The packed oct-encoded, unit-length vectors.\n * @param {vec3} vector1 One decoded and normalized vector.\n * @param {vec3} vector2 One decoded and normalized vector.\n * @param {vec3} vector3 One decoded and normalized vector.\n */\n  void czm_octDecode(vec2 encoded, out vec3 vector1, out vec3 vector2, out vec3 vector3)\n {\n    float temp = encoded.x / 65536.0;\n    float x = floor(temp);\n    float encodedFloat1 = (temp - x) * 65536.0;\n\n    temp = encoded.y / 65536.0;\n    float y = floor(temp);\n    float encodedFloat2 = (temp - y) * 65536.0;\n\n    vector1 = czm_octDecode(encodedFloat1);\n    vector2 = czm_octDecode(encodedFloat2);\n    vector3 = czm_octDecode(vec2(x, y));\n }\n "
    }),define("Cesium/Shaders/Builtin/Functions/packDepth", [], function () {
        "use strict";
        return "/**\n * Packs a depth value into a vec3 that can be represented by unsigned bytes.\n *\n * @name czm_packDepth\n * @glslFunction\n *\n * @param {float} depth The floating-point depth.\n * @returns {vec3} The packed depth.\n */\nvec4 czm_packDepth(float depth)\n{\n    // See Aras Pranckevi�?ius' post Encoding Floats to RGBA\n    // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n    vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n    enc = fract(enc);\n    enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n    return enc;\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/phong", [], function () {
        "use strict";
        return "float czm_private_getLambertDiffuseOfMaterial(vec3 lightDirectionEC, czm_material material)\n{\n    return czm_getLambertDiffuse(lightDirectionEC, material.normal);\n}\n\nfloat czm_private_getSpecularOfMaterial(vec3 lightDirectionEC, vec3 toEyeEC, czm_material material)\n{\n    return czm_getSpecular(lightDirectionEC, toEyeEC, material.normal, material.shininess);\n}\n\n/**\n * Computes a color using the Phong lighting model.\n *\n * @name czm_phong\n * @glslFunction\n *\n * @param {vec3} toEye A normalized vector from the fragment to the eye in eye coordinates.\n * @param {czm_material} material The fragment's material.\n * \n * @returns {vec4} The computed color.\n * \n * @example\n * vec3 positionToEyeEC = // ...\n * czm_material material = // ...\n * gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\n *\n * @see czm_getMaterial\n */\nvec4 czm_phong(vec3 toEye, czm_material material)\n{\n    // Diffuse from directional light sources at eye (for top-down)\n    float diffuse = czm_private_getLambertDiffuseOfMaterial(vec3(0.0, 0.0, 1.0), material);\n    if (czm_sceneMode == czm_sceneMode3D) {\n        // (and horizon views in 3D)\n        diffuse += czm_private_getLambertDiffuseOfMaterial(vec3(0.0, 1.0, 0.0), material);\n    }\n\n    // Specular from sun and pseudo-moon\n    float specular = czm_private_getSpecularOfMaterial(czm_sunDirectionEC, toEye, material) + czm_private_getSpecularOfMaterial(czm_moonDirectionEC, toEye, material);\n\n    // Temporary workaround for adding ambient.\n    vec3 materialDiffuse = material.diffuse * 0.5;\n    \n    vec3 ambient = materialDiffuse;\n    vec3 color = ambient + material.emission;\n    color += materialDiffuse * diffuse;\n    color += material.specular * specular;\n\n    return vec4(color, material.alpha);\n}\n\nvec4 czm_private_phong(vec3 toEye, czm_material material)\n{\n    float diffuse = czm_private_getLambertDiffuseOfMaterial(czm_sunDirectionEC, material);\n    float specular = czm_private_getSpecularOfMaterial(czm_sunDirectionEC, toEye, material);\n\n    vec3 ambient = vec3(0.0);\n    vec3 color = ambient + material.emission;\n    color += material.diffuse * diffuse;\n    color += material.specular * specular;\n\n    return vec4(color, material.alpha);\n}"
    }),define("Cesium/Shaders/Builtin/Functions/pointAlongRay", [], function () {
        "use strict";
        return "/**\n * Computes the point along a ray at the given time.  <code>time</code> can be positive, negative, or zero.\n *\n * @name czm_pointAlongRay\n * @glslFunction\n *\n * @param {czm_ray} ray The ray to compute the point along.\n * @param {float} time The time along the ray.\n * \n * @returns {vec3} The point along the ray at the given time.\n * \n * @example\n * czm_ray ray = czm_ray(vec3(0.0), vec3(1.0, 0.0, 0.0)); // origin, direction\n * vec3 v = czm_pointAlongRay(ray, 2.0); // (2.0, 0.0, 0.0)\n */\nvec3 czm_pointAlongRay(czm_ray ray, float time)\n{\n    return ray.origin + (time * ray.direction);\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/rayEllipsoidIntersectionInterval", [], function () {
        "use strict";
        return "/**\n * DOC_TBA\n *\n * @name czm_rayEllipsoidIntersectionInterval\n * @glslFunction\n */\nczm_raySegment czm_rayEllipsoidIntersectionInterval(czm_ray ray, czm_ellipsoid ellipsoid)\n{\n   // ray and ellipsoid center in eye coordinates.  radii in model coordinates.\n    vec3 q = ellipsoid.inverseRadii * (czm_inverseModelView * vec4(ray.origin, 1.0)).xyz;\n    vec3 w = ellipsoid.inverseRadii * (czm_inverseModelView * vec4(ray.direction, 0.0)).xyz;\n   \n    q = q - ellipsoid.inverseRadii * (czm_inverseModelView * vec4(ellipsoid.center, 1.0)).xyz;\n    \n    float q2 = dot(q, q);\n    float qw = dot(q, w);\n    \n    if (q2 > 1.0) // Outside ellipsoid.\n    {\n        if (qw >= 0.0) // Looking outward or tangent (0 intersections).\n        {\n            return czm_emptyRaySegment;\n        }\n        else // qw < 0.0.\n        {\n            float qw2 = qw * qw;\n            float difference = q2 - 1.0; // Positively valued.\n            float w2 = dot(w, w);\n            float product = w2 * difference;\n            \n            if (qw2 < product) // Imaginary roots (0 intersections).\n            {\n                return czm_emptyRaySegment;     \n            }   \n            else if (qw2 > product) // Distinct roots (2 intersections).\n            {\n                float discriminant = qw * qw - product;\n                float temp = -qw + sqrt(discriminant); // Avoid cancellation.\n                float root0 = temp / w2;\n                float root1 = difference / temp;\n                if (root0 < root1)\n                {\n                    czm_raySegment i = czm_raySegment(root0, root1);\n                    return i;\n                }\n                else\n                {\n                    czm_raySegment i = czm_raySegment(root1, root0);\n                    return i;\n                }\n            }\n            else // qw2 == product.  Repeated roots (2 intersections).\n            {\n                float root = sqrt(difference / w2);\n                czm_raySegment i = czm_raySegment(root, root);\n                return i;\n            }\n        }\n    }\n    else if (q2 < 1.0) // Inside ellipsoid (2 intersections).\n    {\n        float difference = q2 - 1.0; // Negatively valued.\n        float w2 = dot(w, w);\n        float product = w2 * difference; // Negatively valued.\n        float discriminant = qw * qw - product;\n        float temp = -qw + sqrt(discriminant); // Positively valued.\n        czm_raySegment i = czm_raySegment(0.0, temp / w2);\n        return i;\n    }\n    else // q2 == 1.0. On ellipsoid.\n    {\n        if (qw < 0.0) // Looking inward.\n        {\n            float w2 = dot(w, w);\n            czm_raySegment i = czm_raySegment(0.0, -qw / w2);\n            return i;\n        }\n        else // qw >= 0.0.  Looking outward or tangent.\n        {\n            return czm_emptyRaySegment;\n        }\n    }\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/saturation", [], function () {
        "use strict";
        return "/**\n * Adjusts the saturation of a color.\n * \n * @name czm_saturation\n * @glslFunction\n * \n * @param {vec3} rgb The color.\n * @param {float} adjustment The amount to adjust the saturation of the color.\n *\n * @returns {float} The color with the saturation adjusted.\n *\n * @example\n * vec3 greyScale = czm_saturation(color, 0.0);\n * vec3 doubleSaturation = czm_saturation(color, 2.0);\n */\nvec3 czm_saturation(vec3 rgb, float adjustment)\n{\n    // Algorithm from Chapter 16 of OpenGL Shading Language\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    vec3 intensity = vec3(dot(rgb, W));\n    return mix(intensity, rgb, adjustment);\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/signNotZero", [], function () {
        "use strict";
        return "/**\n * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.  This is similar to the GLSL\n * built-in function <code>sign</code> except that returns 1.0 instead of 0.0 when the input value is 0.0.\n * \n * @name czm_signNotZero\n * @glslFunction\n *\n * @param {} value The value for which to determine the sign.\n * @returns {} 1.0 if the value is positive or zero, -1.0 if the value is negative.\n */\nfloat czm_signNotZero(float value)\n{\n    return value >= 0.0 ? 1.0 : -1.0;\n}\n\nvec2 czm_signNotZero(vec2 value)\n{\n    return vec2(czm_signNotZero(value.x), czm_signNotZero(value.y));\n}\n\nvec3 czm_signNotZero(vec3 value)\n{\n    return vec3(czm_signNotZero(value.x), czm_signNotZero(value.y), czm_signNotZero(value.z));\n}\n\nvec4 czm_signNotZero(vec4 value)\n{\n    return vec4(czm_signNotZero(value.x), czm_signNotZero(value.y), czm_signNotZero(value.z), czm_signNotZero(value.w));\n}"
    }),define("Cesium/Shaders/Builtin/Functions/tangentToEyeSpaceMatrix", [], function () {
        "use strict";
        return "/**\n * Creates a matrix that transforms vectors from tangent space to eye space.\n *\n * @name czm_tangentToEyeSpaceMatrix\n * @glslFunction\n * \n * @param {vec3} normalEC The normal vector in eye coordinates.\n * @param {vec3} tangentEC The tangent vector in eye coordinates.\n * @param {vec3} binormalEC The binormal vector in eye coordinates.\n *\n * @returns {mat3} The matrix that transforms from tangent space to eye space.\n *\n * @example\n * mat3 tangentToEye = czm_tangentToEyeSpaceMatrix(normalEC, tangentEC, binormalEC);\n * vec3 normal = tangentToEye * texture2D(normalMap, st).xyz;\n */\nmat3 czm_tangentToEyeSpaceMatrix(vec3 normalEC, vec3 tangentEC, vec3 binormalEC)\n{\n    vec3 normal = normalize(normalEC);\n    vec3 tangent = normalize(tangentEC);\n    vec3 binormal = normalize(binormalEC);\n    return mat3(tangent.x,  tangent.y,  tangent.z,\n                binormal.x, binormal.y, binormal.z,\n                normal.x,   normal.y,   normal.z);\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/translateRelativeToEye", [], function () {
        "use strict";
        return "/**\n * Translates a position (or any <code>vec3</code>) that was encoded with {@link EncodedCartesian3},\n * and then provided to the shader as separate <code>high</code> and <code>low</code> bits to\n * be relative to the eye.  As shown in the example, the position can then be transformed in eye\n * or clip coordinates using {@link czm_modelViewRelativeToEye} or {@link czm_modelViewProjectionRelativeToEye},\n * respectively.\n * <p>\n * This technique, called GPU RTE, eliminates jittering artifacts when using large coordinates as\n * described in {@link http://blogs.agi.com/insight3d/index.php/2008/09/03/precisions-precisions/|Precisions, Precisions}.\n * </p>\n *\n * @name czm_translateRelativeToEye\n * @glslFunction\n *\n * @param {vec3} high The position's high bits.\n * @param {vec3} low The position's low bits.\n * @returns {vec3} The position translated to be relative to the camera's position.\n *\n * @example\n * attribute vec3 positionHigh;\n * attribute vec3 positionLow;\n * \n * void main() \n * {\n *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n *   gl_Position = czm_modelViewProjectionRelativeToEye * p;\n * }\n *\n * @see czm_modelViewRelativeToEye\n * @see czm_modelViewProjectionRelativeToEye\n * @see czm_computePosition\n * @see EncodedCartesian3\n */\nvec4 czm_translateRelativeToEye(vec3 high, vec3 low)\n{\n    vec3 highDifference = high - czm_encodedCameraPositionMCHigh;\n    vec3 lowDifference = low - czm_encodedCameraPositionMCLow;\n\n    return vec4(highDifference + lowDifference, 1.0);\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/translucentPhong", [], function () {
        "use strict";
        return "/**\n * @private\n */\nvec4 czm_translucentPhong(vec3 toEye, czm_material material)\n{\n    // Diffuse from directional light sources at eye (for top-down and horizon views)\n    float diffuse = czm_getLambertDiffuse(vec3(0.0, 0.0, 1.0), material.normal);\n    \n    if (czm_sceneMode == czm_sceneMode3D) {\n        // (and horizon views in 3D)\n        diffuse += czm_getLambertDiffuse(vec3(0.0, 1.0, 0.0), material.normal);\n    }\n    \n    diffuse = clamp(diffuse, 0.0, 1.0);\n\n    // Specular from sun and pseudo-moon\n    float specular = czm_getSpecular(czm_sunDirectionEC, toEye, material.normal, material.shininess);\n    specular += czm_getSpecular(czm_moonDirectionEC, toEye, material.normal, material.shininess);\n\n    // Temporary workaround for adding ambient.\n    vec3 materialDiffuse = material.diffuse * 0.5;\n\n    vec3 ambient = materialDiffuse;\n    vec3 color = ambient + material.emission;\n    color += materialDiffuse * diffuse;\n    color += material.specular * specular;\n\n    return vec4(color, material.alpha);\n}"
    }),define("Cesium/Shaders/Builtin/Functions/transpose", [], function () {
        "use strict";
        return "/**\n * Returns the transpose of the matrix.  The input <code>matrix</code> can be \n * a <code>mat2</code>, <code>mat3</code>, or <code>mat4</code>.\n *\n * @name czm_transpose\n * @glslFunction\n *\n * @param {} matrix The matrix to transpose.\n *\n * @returns {} The transposed matrix.\n *\n * @example\n * // GLSL declarations\n * mat2 czm_transpose(mat2 matrix);\n * mat3 czm_transpose(mat3 matrix);\n * mat4 czm_transpose(mat4 matrix);\n *\n * // Tranpose a 3x3 rotation matrix to find its inverse.\n * mat3 eastNorthUpToEye = czm_eastNorthUpToEyeCoordinates(\n *     positionMC, normalEC);\n * mat3 eyeToEastNorthUp = czm_transpose(eastNorthUpToEye);\n */\nmat2 czm_transpose(mat2 matrix)\n{\n    return mat2(\n        matrix[0][0], matrix[1][0],\n        matrix[0][1], matrix[1][1]);\n}\n\nmat3 czm_transpose(mat3 matrix)\n{\n    return mat3(\n        matrix[0][0], matrix[1][0], matrix[2][0],\n        matrix[0][1], matrix[1][1], matrix[2][1],\n        matrix[0][2], matrix[1][2], matrix[2][2]);\n}\n\nmat4 czm_transpose(mat4 matrix)\n{\n    return mat4(\n        matrix[0][0], matrix[1][0], matrix[2][0], matrix[3][0],\n        matrix[0][1], matrix[1][1], matrix[2][1], matrix[3][1],\n        matrix[0][2], matrix[1][2], matrix[2][2], matrix[3][2],\n        matrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3]);\n}\n"
    }),define("Cesium/Shaders/Builtin/Functions/unpackDepth", [], function () {
        "use strict";
        return "/**\n * Unpacks a vec3 depth depth value to a float.\n *\n * @name czm_unpackDepth\n * @glslFunction\n *\n * @param {vec3} packedDepth The packed depth.\n *\n * @returns {float} The floating-point depth.\n */\n float czm_unpackDepth(vec4 packedDepth)\n {\n    // See Aras Pranckevi�?ius' post Encoding Floats to RGBA\n    // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n    return dot(packedDepth, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n }\n"
    }),define("Cesium/Shaders/Builtin/Functions/windowToEyeCoordinates", [], function () {
        "use strict";
        return "/**\n * Transforms a position from window to eye coordinates.\n * The transform from window to normalized device coordinates is done using components\n * of (@link czm_viewport} and {@link czm_viewportTransformation} instead of calculating\n * the inverse of <code>czm_viewportTransformation</code>. The transformation from \n * normalized device coordinates to clip coordinates is done using <code>positionWC.w</code>,\n * which is expected to be the scalar used in the perspective divide. The transformation\n * from clip to eye coordinates is done using {@link czm_inverseProjection}.\n *\n * @name czm_windowToEyeCoordinates\n * @glslFunction\n *\n * @param {vec4} fragmentCoordinate The position in window coordinates to transform.\n *\n * @returns {vec4} The transformed position in eye coordinates.\n *\n * @see czm_modelToWindowCoordinates\n * @see czm_eyeToWindowCoordinates\n * @see czm_inverseProjection\n * @see czm_viewport\n * @see czm_viewportTransformation\n *\n * @example\n * vec4 positionEC = czm_windowToEyeCoordinates(gl_FragCoord);\n */\nvec4 czm_windowToEyeCoordinates(vec4 fragmentCoordinate)\n{\n    float x = 2.0 * (fragmentCoordinate.x - czm_viewport.x) / czm_viewport.z - 1.0;\n    float y = 2.0 * (fragmentCoordinate.y - czm_viewport.y) / czm_viewport.w - 1.0;\n    float z = (fragmentCoordinate.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];\n    vec4 q = vec4(x, y, z, 1.0);\n    q /= fragmentCoordinate.w;\n    q = czm_inverseProjection * q;\n    return q;\n}\n"
    }),define("Cesium/Shaders/Builtin/CzmBuiltins", ["./Constants/degreesPerRadian", "./Constants/depthRange", "./Constants/epsilon1", "./Constants/epsilon2", "./Constants/epsilon3", "./Constants/epsilon4", "./Constants/epsilon5", "./Constants/epsilon6", "./Constants/epsilon7", "./Constants/infinity", "./Constants/oneOverPi", "./Constants/oneOverTwoPi", "./Constants/pi", "./Constants/piOverFour", "./Constants/piOverSix", "./Constants/piOverThree", "./Constants/piOverTwo", "./Constants/radiansPerDegree", "./Constants/sceneMode2D", "./Constants/sceneMode3D", "./Constants/sceneModeColumbusView", "./Constants/sceneModeMorphing", "./Constants/solarRadius", "./Constants/threePiOver2", "./Constants/twoPi", "./Constants/webMercatorMaxLatitude", "./Structs/depthRangeStruct", "./Structs/ellipsoid", "./Structs/material", "./Structs/materialInput", "./Structs/ray", "./Structs/raySegment", "./Functions/RGBToXYZ", "./Functions/XYZToRGB", "./Functions/alphaWeight", "./Functions/antialias", "./Functions/columbusViewMorph", "./Functions/computePosition", "./Functions/cosineAndSine", "./Functions/decompressTextureCoordinates", "./Functions/eastNorthUpToEyeCoordinates", "./Functions/ellipsoidContainsPoint", "./Functions/ellipsoidNew", "./Functions/ellipsoidWgs84TextureCoordinates", "./Functions/equalsEpsilon", "./Functions/eyeOffset", "./Functions/eyeToWindowCoordinates", "./Functions/geodeticSurfaceNormal", "./Functions/getDefaultMaterial", "./Functions/getLambertDiffuse", "./Functions/getSpecular", "./Functions/getWaterNoise", "./Functions/getWgs84EllipsoidEC", "./Functions/hue", "./Functions/isEmpty", "./Functions/isFull", "./Functions/latitudeToWebMercatorFraction", "./Functions/luminance", "./Functions/metersPerPixel", "./Functions/modelToWindowCoordinates", "./Functions/multiplyWithColorBalance", "./Functions/nearFarScalar", "./Functions/octDecode", "./Functions/packDepth", "./Functions/phong", "./Functions/pointAlongRay", "./Functions/rayEllipsoidIntersectionInterval", "./Functions/saturation", "./Functions/signNotZero", "./Functions/tangentToEyeSpaceMatrix", "./Functions/translateRelativeToEye", "./Functions/translucentPhong", "./Functions/transpose", "./Functions/unpackDepth", "./Functions/windowToEyeCoordinates"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S, T, b, w, x, A, P, I, D, M, O, R, N, L, F, B, z, V, U, k, G, H, W, q, j, Y, X, Z, K, J, Q, $, ee, te, ie, ne, re, oe, ae, se, ue, le, ce, he, de, me, pe, fe, _e, ve, ge, ye, Ce) {
        "use strict";
        return {
            czm_degreesPerRadian: e,
            czm_depthRange: t,
            czm_epsilon1: i,
            czm_epsilon2: n,
            czm_epsilon3: r,
            czm_epsilon4: o,
            czm_epsilon5: a,
            czm_epsilon6: s,
            czm_epsilon7: u,
            czm_infinity: l,
            czm_oneOverPi: c,
            czm_oneOverTwoPi: h,
            czm_pi: d,
            czm_piOverFour: m,
            czm_piOverSix: p,
            czm_piOverThree: f,
            czm_piOverTwo: _,
            czm_radiansPerDegree: v,
            czm_sceneMode2D: g,
            czm_sceneMode3D: y,
            czm_sceneModeColumbusView: C,
            czm_sceneModeMorphing: E,
            czm_solarRadius: S,
            czm_threePiOver2: T,
            czm_twoPi: b,
            czm_webMercatorMaxLatitude: w,
            czm_depthRangeStruct: x,
            czm_ellipsoid: A,
            czm_material: P,
            czm_materialInput: I,
            czm_ray: D,
            czm_raySegment: M,
            czm_RGBToXYZ: O,
            czm_XYZToRGB: R,
            czm_alphaWeight: N,
            czm_antialias: L,
            czm_columbusViewMorph: F,
            czm_computePosition: B,
            czm_cosineAndSine: z,
            czm_decompressTextureCoordinates: V,
            czm_eastNorthUpToEyeCoordinates: U,
            czm_ellipsoidContainsPoint: k,
            czm_ellipsoidNew: G,
            czm_ellipsoidWgs84TextureCoordinates: H,
            czm_equalsEpsilon: W,
            czm_eyeOffset: q,
            czm_eyeToWindowCoordinates: j,
            czm_geodeticSurfaceNormal: Y,
            czm_getDefaultMaterial: X,
            czm_getLambertDiffuse: Z,
            czm_getSpecular: K,
            czm_getWaterNoise: J,
            czm_getWgs84EllipsoidEC: Q,
            czm_hue: $,
            czm_isEmpty: ee,
            czm_isFull: te,
            czm_latitudeToWebMercatorFraction: ie,
            czm_luminance: ne,
            czm_metersPerPixel: re,
            czm_modelToWindowCoordinates: oe,
            czm_multiplyWithColorBalance: ae,
            czm_nearFarScalar: se,
            czm_octDecode: ue,
            czm_packDepth: le,
            czm_phong: ce,
            czm_pointAlongRay: he,
            czm_rayEllipsoidIntersectionInterval: de,
            czm_saturation: me,
            czm_signNotZero: pe,
            czm_tangentToEyeSpaceMatrix: fe,
            czm_translateRelativeToEye: _e,
            czm_translucentPhong: ve,
            czm_transpose: ge,
            czm_unpackDepth: ye,
            czm_windowToEyeCoordinates: Ce
        }
    }),define("Cesium/Renderer/ShaderSource", ["../Core/defaultValue", "../Core/defined", "../Core/DeveloperError", "../Shaders/Builtin/CzmBuiltins", "./AutomaticUniforms"], function (e, t, i, n, r) {
        "use strict";
        function o(e) {
            return e = e.replace(/\/\/.*/g, ""), e.replace(/\/\*\*[\s\S]*?\*\//gm, function (e) {
                for (var t = e.match(/\n/gm).length, i = "", n = 0; t > n; ++n)i += "\n";
                return i
            })
        }

        function a(e, i, n) {
            for (var r, a = 0; a < n.length; ++a)n[a].name === e && (r = n[a]);
            return t(r) || (i = o(i), r = {
                name: e,
                glslSource: i,
                dependsOn: [],
                requiredBy: [],
                evaluated: !1
            }, n.push(r)), r
        }

        function s(e, i) {
            if (!e.evaluated) {
                e.evaluated = !0;
                var n = e.glslSource.match(/\bczm_[a-zA-Z0-9_]*/g);
                t(n) && null !== n && (n = n.filter(function (e, t) {
                    return n.indexOf(e) === t
                }), n.forEach(function (t) {
                    if (t !== e.name && h._czmBuiltinsAndUniforms.hasOwnProperty(t)) {
                        var n = a(t, h._czmBuiltinsAndUniforms[t], i);
                        e.dependsOn.push(n), n.requiredBy.push(e), s(n, i)
                    }
                }))
            }
        }

        function u(e) {
            for (var t = [], n = []; e.length > 0;) {
                var r = e.pop();
                n.push(r), 0 === r.requiredBy.length && t.push(r)
            }
            for (; t.length > 0;) {
                var o = t.shift();
                e.push(o);
                for (var a = 0; a < o.dependsOn.length; ++a) {
                    var s = o.dependsOn[a], u = s.requiredBy.indexOf(o);
                    s.requiredBy.splice(u, 1), 0 === s.requiredBy.length && t.push(s)
                }
            }
            for (var l = [], c = 0; c < n.length; ++c)0 !== n[c].requiredBy.length && l.push(n[c]);
            if (0 !== l.length) {
                var h = "A circular dependency was found in the following built-in functions/structs/constants: \n";
                for (c = 0; c < l.length; ++c)h = h + l[c].name + "\n";
                throw new i(h)
            }
        }

        function l(e) {
            var t = [], i = a("main", e, t);
            s(i, t), u(t);
            for (var n = "", r = t.length - 1; r >= 0; --r)n = n + t[r].glslSource + "\n";
            return n.replace(i.glslSource, "")
        }

        function c(e, n) {
            var r, a, s = "", u = e.sources;
            if (t(u))for (r = 0, a = u.length; a > r; ++r)s += "\n#line 0\n" + u[r];
            s = o(s);
            var c;
            s = s.replace(/#version\s+(.*?)\n/gm, function (e, n) {
                if (t(c) && c !== n)throw new i("inconsistent versions found: " + c + " and " + n);
                return c = n, "\n"
            });
            var d = e.pickColorQualifier;
            t(d) && (s = h.replaceMain(s, "czm_pick_main"), s += "\n" + d + " vec4 czm_pickColor;\nvoid main()\n{\n    czm_pick_main();\n    if (gl_FragColor.a == 0.0) {\n        discard;\n    }\n    gl_FragColor = czm_pickColor;\n}");
            var m = "";
            t(c) && (m = "#version " + c), n && (m += "#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\n\n");
            var p = e.defines;
            if (t(p))for (r = 0, a = p.length; a > r; ++r) {
                var f = p[r];
                0 !== f.length && (m += "#define " + f + "\n")
            }
            return e.includeBuiltIns && (m += l(s)), m += "\n#line 0\n", m += s
        }

        var h = function (i) {
            i = e(i, e.EMPTY_OBJECT);
            var n = i.pickColorQualifier;
            this.defines = t(i.defines) ? i.defines.slice(0) : [], this.sources = t(i.sources) ? i.sources.slice(0) : [], this.pickColorQualifier = n, this.includeBuiltIns = e(i.includeBuiltIns, !0)
        };
        h.prototype.clone = function () {
            return new h({
                sources: this.sources,
                defines: this.defines,
                pickColorQuantifier: this.pickColorQualifier,
                includeBuiltIns: this.includeBuiltIns
            })
        }, h.replaceMain = function (e, t) {
            return t = "void " + t + "()", e.replace(/void\s+main\s*\(\s*(?:void)?\s*\)/g, t)
        }, h.prototype.createCombinedVertexShader = function () {
            return c(this, !1)
        }, h.prototype.createCombinedFragmentShader = function () {
            return c(this, !0)
        }, h._czmBuiltinsAndUniforms = {};
        for (var d in n)n.hasOwnProperty(d) && (h._czmBuiltinsAndUniforms[d] = n[d]);
        for (var m in r)if (r.hasOwnProperty(m)) {
            var p = r[m];
            "function" == typeof p.getDeclaration && (h._czmBuiltinsAndUniforms[m] = p.getDeclaration(m))
        }
        return h
    }),define("Cesium/Renderer/ShaderCache", ["../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "./ShaderProgram", "./ShaderSource"], function (e, t, i, n, r) {
        "use strict";
        var o = function (e) {
            this._context = e, this._shaders = {}, this._numberOfShaders = 0, this._shadersToRelease = {}
        };
        return t(o.prototype, {
            numberOfShaders: {
                get: function () {
                    return this._numberOfShaders
                }
            }
        }), o.prototype.replaceShaderProgram = function (t) {
            return e(t.shaderProgram) && t.shaderProgram.destroy(), this.getShaderProgram(t)
        }, o.prototype.getShaderProgram = function (e) {
            var t = e.vertexShaderSource, i = e.fragmentShaderSource, o = e.attributeLocations;
            "string" == typeof t && (t = new r({sources: [t]})), "string" == typeof i && (i = new r({sources: [i]}));
            var a, s = t.createCombinedVertexShader(), u = i.createCombinedFragmentShader(), l = s + u + JSON.stringify(o);
            if (this._shaders[l])a = this._shaders[l], delete this._shadersToRelease[l]; else {
                var c = this._context, h = new n({
                    gl: c._gl,
                    logShaderCompilation: c.logShaderCompilation,
                    debugShaders: c.debugShaders,
                    vertexShaderSource: t,
                    vertexShaderText: s,
                    fragmentShaderSource: i,
                    fragmentShaderText: u,
                    attributeLocations: o
                });
                a = {
                    cache: this,
                    shaderProgram: h,
                    keyword: l,
                    count: 0
                }, h._cachedShader = a, this._shaders[l] = a, ++this._numberOfShaders
            }
            return ++a.count, a.shaderProgram
        }, o.prototype.destroyReleasedShaderPrograms = function () {
            var e = this._shadersToRelease;
            for (var t in e)if (e.hasOwnProperty(t)) {
                var i = e[t];
                delete this._shaders[i.keyword], i.shaderProgram.finalDestroy(), --this._numberOfShaders
            }
            this._shadersToRelease = {}
        }, o.prototype.releaseShaderProgram = function (e) {
            if (e) {
                var t = e._cachedShader;
                t && 0 === --t.count && (this._shadersToRelease[t.keyword] = t)
            }
        }, o.prototype.isDestroyed = function () {
            return !1
        }, o.prototype.destroy = function () {
            var e = this._shaders;
            for (var t in e)e.hasOwnProperty(t) && e[t].shaderProgram.finalDestroy();
            return i(this)
        }, o
    }),define("Cesium/Core/EncodedCartesian3", ["./Cartesian3", "./defined", "./DeveloperError"], function (e, t, i) {
        "use strict";
        var n = function () {
            this.high = e.clone(e.ZERO), this.low = e.clone(e.ZERO)
        };
        n.encode = function (e, i) {
            t(i) || (i = {high: 0, low: 0});
            var n;
            return e >= 0 ? (n = 65536 * Math.floor(e / 65536), i.high = n, i.low = e - n) : (n = 65536 * Math.floor(-e / 65536), i.high = -n, i.low = e + n), i
        };
        var r = {high: 0, low: 0};
        n.fromCartesian = function (e, i) {
            t(i) || (i = new n);
            var o = i.high, a = i.low;
            return n.encode(e.x, r), o.x = r.high, a.x = r.low, n.encode(e.y, r), o.y = r.high, a.y = r.low, n.encode(e.z, r), o.z = r.high, a.z = r.low, i
        };
        var o = new n;
        return n.writeElements = function (e, t, i) {
            n.fromCartesian(e, o);
            var r = o.high, a = o.low;
            t[i] = r.x, t[i + 1] = r.y, t[i + 2] = r.z, t[i + 3] = a.x, t[i + 4] = a.y, t[i + 5] = a.z
        }, n
    }),define("Cesium/Core/Simon1994PlanetaryPositions", ["./Cartesian3", "./defined", "./DeveloperError", "./JulianDate", "./Math", "./Matrix3", "./TimeConstants", "./TimeStandard"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        function u(e) {
            var t = 6.239996 + .0172019696544 * e;
            return .001657 * Math.sin(t + .01671 * Math.sin(t))
        }

        function l(e, t) {
            t = n.addSeconds(e, C, t);
            var i = n.totalDays(t) - E;
            return t = n.addSeconds(t, u(i), t)
        }

        function c(n, a, s, u, l, c, m, p) {
            if (0 > s && (s = -s, l += r.PI), 0 > s || s > r.PI)throw new i("The inclination is out of range. Inclination must be greater than or equal to zero and less than or equal to Pi radians.");
            var _ = n * (1 - a), v = u - l, g = l, y = d(c - u, a), C = h(a, 0);
            if ("Hyperbolic" === C && Math.abs(r.negativePiToPi(y)) >= Math.acos(-1 / a))throw new i("The true anomaly of the hyperbolic orbit lies outside of the bounds of the hyperbola.");
            f(v, s, g, I);
            var E = _ * (1 + a), S = Math.cos(y), T = Math.sin(y), b = 1 + a * S;
            if (b <= r.Epsilon10)throw new i("elements cannot be converted to cartesian");
            var w = E / b;
            return t(p) ? (p.x = w * S, p.y = w * T, p.z = 0) : p = new e(w * S, w * T, 0), o.multiplyByVector(I, p, p)
        }

        function h(e, t) {
            if (0 > e)throw new i("eccentricity cannot be negative.");
            return t >= e ? "Circular" : 1 - t > e ? "Elliptical" : 1 + t >= e ? "Parabolic" : "Hyperbolic"
        }

        function d(e, t) {
            if (0 > t || t >= 1)throw new i("eccentricity out of range.");
            var n = m(e, t);
            return p(n, t)
        }

        function m(e, t) {
            if (0 > t || t >= 1)throw new i("eccentricity out of range.");
            var n = Math.floor(e / r.TWO_PI);
            e -= n * r.TWO_PI;
            var o, a = e + t * Math.sin(e) / (1 - Math.sin(e + t) + Math.sin(e)), s = Number.MAX_VALUE;
            for (o = 0; D > o && Math.abs(s - a) > M; ++o) {
                s = a;
                var u = s - t * Math.sin(s) - e, l = 1 - t * Math.cos(s);
                a = s - u / l
            }
            if (o >= D)throw new i("Kepler equation did not converge");
            return s = a + n * r.TWO_PI
        }

        function p(e, t) {
            if (0 > t || t >= 1)throw new i("eccentricity out of range.");
            var n = Math.floor(e / r.TWO_PI);
            e -= n * r.TWO_PI;
            var o = Math.cos(e) - t, a = Math.sin(e) * Math.sqrt(1 - t * t), s = Math.atan2(a, o);
            return s = r.zeroToTwoPi(s), 0 > e && (s -= r.TWO_PI), s += n * r.TWO_PI
        }

        function f(e, n, a, s) {
            if (0 > n || n > r.PI)throw new i("inclination out of range");
            var u = Math.cos(e), l = Math.sin(e), c = Math.cos(n), h = Math.sin(n), d = Math.cos(a), m = Math.sin(a);
            return t(s) ? (s[0] = d * u - m * l * c, s[1] = m * u + d * l * c, s[2] = l * h, s[3] = -d * l - m * u * c, s[4] = -m * l + d * u * c, s[5] = u * h, s[6] = m * h, s[7] = -d * h, s[8] = c) : s = new o(d * u - m * l * c, -d * l - m * u * c, m * h, m * u + d * l * c, -m * l + d * u * c, -d * h, l * h, u * h, c), s
        }

        function _(e, t) {
            l(e, Ie);
            var i = Ie.dayNumber - S.dayNumber + (Ie.secondsOfDay - S.secondsOfDay) / a.SECONDS_PER_DAY, n = i / (10 * a.DAYS_PER_JULIAN_CENTURY), r = .3595362 * n, o = O + H * Math.cos(L * r) + J * Math.sin(L * r) + W * Math.cos(F * r) + Q * Math.sin(F * r) + q * Math.cos(B * r) + $ * Math.sin(B * r) + j * Math.cos(z * r) + ee * Math.sin(z * r) + Y * Math.cos(V * r) + te * Math.sin(V * r) + X * Math.cos(U * r) + ie * Math.sin(U * r) + Z * Math.cos(k * r) + ne * Math.sin(k * r) + K * Math.cos(G * r) + re * Math.sin(G * r), s = R + N * n + me * Math.cos(oe * r) + Ee * Math.sin(oe * r) + pe * Math.cos(ae * r) + Se * Math.sin(ae * r) + fe * Math.cos(se * r) + Te * Math.sin(se * r) + _e * Math.cos(ue * r) + be * Math.sin(ue * r) + ve * Math.cos(le * r) + we * Math.sin(le * r) + ge * Math.cos(ce * r) + xe * Math.sin(ce * r) + ye * Math.cos(he * r) + Ae * Math.sin(he * r) + Ce * Math.cos(de * r) + Pe * Math.sin(de * r), u = .0167086342 - .0004203654 * n, h = 102.93734808 * x + 11612.3529 * A * n, d = 469.97289 * A * n, m = 174.87317577 * x - 8679.27034 * A * n;
            return c(o, u, d, h, m, s, b, t)
        }

        function v(e, t) {
            l(e, Ie);
            var i = Ie.dayNumber - S.dayNumber + (Ie.secondsOfDay - S.secondsOfDay) / a.SECONDS_PER_DAY, n = i / a.DAYS_PER_JULIAN_CENTURY, r = n * n, o = r * n, s = o * n, u = 383397.7725 + .004 * n, h = .055545526 - 1.6e-8 * n, d = 5.15668983 * x, m = -8e-5 * n + .02966 * r - 42e-6 * o - 1.3e-7 * s, p = 83.35324312 * x, f = 14643420.2669 * n - 38.2702 * r - .045047 * o + 21301e-8 * s, _ = 125.04455501 * x, v = -6967919.3631 * n + 6.3602 * r + .007625 * o - 3586e-8 * s, g = 218.31664563 * x, y = 1732559343.4847 * n - 6.391 * r + .006588 * o - 3169e-8 * s, C = 297.85019547 * x + A * (1602961601.209 * n - 6.3706 * r + .006593 * o - 3169e-8 * s), E = 93.27209062 * x + A * (1739527262.8478 * n - 12.7512 * r - .001037 * o + 417e-8 * s), b = 134.96340251 * x + A * (1717915923.2178 * n + 31.8792 * r + .051635 * o - 2447e-7 * s), P = 357.52910918 * x + A * (129596581.0481 * n - .5532 * r + 136e-6 * o - 1149e-8 * s), I = 310.17137918 * x - A * (6967051.436 * n + 6.2068 * r + .007618 * o - 3219e-8 * s), D = 2 * C, M = 4 * C, O = 6 * C, R = 2 * b, N = 3 * b, L = 4 * b, F = 2 * E;
            u += 3400.4 * Math.cos(D) - 635.6 * Math.cos(D - b) - 235.6 * Math.cos(b) + 218.1 * Math.cos(D - P) + 181 * Math.cos(D + b), h += .014216 * Math.cos(D - b) + .008551 * Math.cos(D - R) - .001383 * Math.cos(b) + .001356 * Math.cos(D + b) - .001147 * Math.cos(M - N) - 914e-6 * Math.cos(M - R) + 869e-6 * Math.cos(D - P - b) - 627e-6 * Math.cos(D) - 394e-6 * Math.cos(M - L) + 282e-6 * Math.cos(D - P - R) - 279e-6 * Math.cos(C - b) - 236e-6 * Math.cos(R) + 231e-6 * Math.cos(M) + 229e-6 * Math.cos(O - L) - 201e-6 * Math.cos(R - F), m += 486.26 * Math.cos(D - F) - 40.13 * Math.cos(D) + 37.51 * Math.cos(F) + 25.73 * Math.cos(R - F) + 19.97 * Math.cos(D - P - F), f += -55609 * Math.sin(D - b) - 34711 * Math.sin(D - R) - 9792 * Math.sin(b) + 9385 * Math.sin(M - N) + 7505 * Math.sin(M - R) + 5318 * Math.sin(D + b) + 3484 * Math.sin(M - L) - 3417 * Math.sin(D - P - b) - 2530 * Math.sin(O - L) - 2376 * Math.sin(D) - 2075 * Math.sin(D - N) - 1883 * Math.sin(R) - 1736 * Math.sin(O - 5 * b) + 1626 * Math.sin(P) - 1370 * Math.sin(O - N), v += -5392 * Math.sin(D - F) - 540 * Math.sin(P) - 441 * Math.sin(D) + 423 * Math.sin(F) - 288 * Math.sin(R - F), y += -3332.9 * Math.sin(D) + 1197.4 * Math.sin(D - b) - 662.5 * Math.sin(P) + 396.3 * Math.sin(b) - 218 * Math.sin(D - P);
            var B = 2 * I, z = 3 * I;
            m += 46.997 * Math.cos(I) * n - .614 * Math.cos(D - F + I) * n + .614 * Math.cos(D - F - I) * n - .0297 * Math.cos(B) * r - .0335 * Math.cos(I) * r + .0012 * Math.cos(D - F + B) * r - 16e-5 * Math.cos(I) * o + 4e-5 * Math.cos(z) * o + 4e-5 * Math.cos(B) * o;
            var V = 2.116 * Math.sin(I) * n - .111 * Math.sin(D - F - I) * n - .0015 * Math.sin(I) * r;
            f += V, y += V, v += -520.77 * Math.sin(I) * n + 13.66 * Math.sin(D - F + I) * n + 1.12 * Math.sin(D - I) * n - 1.06 * Math.sin(F - I) * n + .66 * Math.sin(B) * r + .371 * Math.sin(I) * r - .035 * Math.sin(D - F + B) * r - .015 * Math.sin(D - F + I) * r + .0014 * Math.sin(I) * o - .0011 * Math.sin(z) * o - 9e-4 * Math.sin(B) * o, u *= w;
            var U = d + m * A, k = p + f * A, G = g + y * A, H = _ + v * A;
            return c(u, h, U, k, H, G, T, t)
        }

        function g(t, i) {
            return i = v(t, i), e.multiplyByScalar(i, Me, i)
        }

        var y = {}, C = 32.184, E = 2451545, S = new n(2451545, 0, s.TAI), T = 398600435e6, b = 1.012300034 * T * 328900.56, w = 1e3, x = r.RADIANS_PER_DEGREE, A = r.RADIANS_PER_ARCSECOND, P = 14959787e4, I = new o, D = 50, M = r.EPSILON8, O = 1.0000010178 * P, R = 100.46645683 * x, N = 1295977422.83429 * A, L = 16002, F = 21863, B = 32004, z = 10931, V = 14529, U = 16368, k = 15318, G = 32794, H = 64e-7 * P, W = -152 * 1e-7 * P, q = 62e-7 * P, j = -8e-7 * P, Y = 32e-7 * P, X = -41 * 1e-7 * P, Z = 19e-7 * P, K = -11 * 1e-7 * P, J = -150 * 1e-7 * P, Q = -46 * 1e-7 * P, $ = 68 * 1e-7 * P, ee = 54e-7 * P, te = 14e-7 * P, ie = 24e-7 * P, ne = -28 * 1e-7 * P, re = 22e-7 * P, oe = 10, ae = 16002, se = 21863, ue = 10931, le = 1473, ce = 32004, he = 4387, de = 73, me = -325 * 1e-7, pe = -322 * 1e-7, fe = -79 * 1e-7, _e = 232 * 1e-7, ve = -52 * 1e-7, ge = 97e-7, ye = 55e-7, Ce = -41 * 1e-7, Ee = -105 * 1e-7, Se = -137 * 1e-7, Te = 258e-7, be = 35e-7, we = -116 * 1e-7, xe = -88 * 1e-7, Ae = -112 * 1e-7, Pe = -80 * 1e-7, Ie = new n(0, 0, s.TAI), De = .012300034, Me = De / (De + 1) * -1, Oe = new o(1.0000000000000002, 5.619723173785822e-16, 4.690511510146299e-19, -5.154129427414611e-16, .9174820620691819, -.39777715593191376, -2.23970096136568e-16, .39777715593191376, .9174820620691819), Re = new e;
        return y.computeSunPositionInEarthInertialFrame = function (i, r) {
            return t(i) || (i = n.now()), t(r) || (r = new e), Re = _(i, Re), r = e.negate(Re, r), g(i, Re), e.subtract(r, Re, r), o.multiplyByVector(Oe, r, r), r
        }, y.computeMoonPositionInEarthInertialFrame = function (e, i) {
            return t(e) || (e = n.now()), i = v(e, i), o.multiplyByVector(Oe, i, i), i
        }, y
    }),define("Cesium/Scene/SceneMode", ["../Core/freezeObject"], function (e) {
        "use strict";
        var t = {MORPHING: 0, COLUMBUS_VIEW: 1, SCENE2D: 2, SCENE3D: 3};
        return t.getMorphTime = function (e) {
            return e === t.SCENE3D ? 1 : e === t.MORPHING ? void 0 : 0
        }, e(t)
    }),define("Cesium/Renderer/UniformState", ["../Core/BoundingRectangle", "../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/Cartographic", "../Core/defined", "../Core/defineProperties", "../Core/EncodedCartesian3", "../Core/Math", "../Core/Matrix3", "../Core/Matrix4", "../Core/Simon1994PlanetaryPositions", "../Core/Transforms", "../Scene/SceneMode"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m) {
        "use strict";
        function p(e, t) {
            c.clone(t, e._view), c.getRotation(t, e._viewRotation), e._view3DDirty = !0, e._inverseView3DDirty = !0, e._modelViewDirty = !0, e._modelView3DDirty = !0, e._modelViewRelativeToEyeDirty = !0, e._inverseModelViewDirty = !0, e._inverseModelView3DDirty = !0, e._viewProjectionDirty = !0, e._modelViewProjectionDirty = !0, e._modelViewProjectionRelativeToEyeDirty = !0, e._modelViewInfiniteProjectionDirty = !0, e._normalDirty = !0, e._inverseNormalDirty = !0, e._normal3DDirty = !0, e._inverseNormal3DDirty = !0
        }

        function f(e, t) {
            c.clone(t, e._inverseView), c.getRotation(t, e._inverseViewRotation)
        }

        function _(e, t) {
            c.clone(t, e._projection), e._inverseProjectionDirty = !0, e._inverseProjectionOITDirty = !0, e._viewProjectionDirty = !0, e._modelViewProjectionDirty = !0, e._modelViewProjectionRelativeToEyeDirty = !0
        }

        function v(e, t) {
            c.clone(t, e._infiniteProjection), e._modelViewInfiniteProjectionDirty = !0
        }

        function g(e, t) {
            i.clone(t.positionWC, e._cameraPosition), i.clone(t.directionWC, e._cameraDirection), i.clone(t.rightWC, e._cameraRight), i.clone(t.upWC, e._cameraUp), e._encodedCameraPositionMCDirty = !0
        }

        function y(e, t) {
            o(d.computeIcrfToFixedMatrix(t.time, k)) || (k = d.computeTemeToPseudoFixedMatrix(t.time, k));
            var n = h.computeSunPositionInEarthInertialFrame(t.time, e._sunPositionWC);
            l.multiplyByVector(k, n, n), i.normalize(n, e._sunDirectionWC), n = l.multiplyByVector(e.viewRotation3D, n, e._sunDirectionEC), i.normalize(n, n), n = h.computeMoonPositionInEarthInertialFrame(t.time, e._moonDirectionEC), l.multiplyByVector(k, n, n), l.multiplyByVector(e.viewRotation3D, n, n), i.normalize(n, n);
            var r = t.mapProjection, a = r.ellipsoid, s = a.cartesianToCartographic(e._sunPositionWC, G);
            r.project(s, e._sunPositionColumbusView)
        }

        function C(e) {
            if (e._viewportDirty) {
                var t = e._viewport;
                c.computeOrthographicOffCenter(t.x, t.x + t.width, t.y, t.y + t.height, 0, 1, e._viewportOrthographicMatrix), c.computeViewportTransformation(t, 0, 1, e._viewportTransformation), e._viewportDirty = !1
            }
        }

        function E(e) {
            e._inverseProjectionDirty && (e._inverseProjectionDirty = !1, c.inverse(e._projection, e._inverseProjection))
        }

        function S(e) {
            e._inverseProjectionOITDirty && (e._inverseProjectionOITDirty = !1, e._mode !== m.SCENE2D && e._mode !== m.MORPHING ? c.inverse(e._projection, e._inverseProjectionOIT) : c.clone(c.IDENTITY, e._inverseProjectionOIT))
        }

        function T(e) {
            e._modelViewDirty && (e._modelViewDirty = !1, c.multiplyTransformation(e._view, e._model, e._modelView))
        }

        function b(e) {
            e._modelView3DDirty && (e._modelView3DDirty = !1, c.multiplyTransformation(e.view3D, e._model, e._modelView3D))
        }

        function w(e) {
            e._inverseModelViewDirty && (e._inverseModelViewDirty = !1, c.inverse(e.modelView, e._inverseModelView))
        }

        function x(e) {
            e._inverseModelView3DDirty && (e._inverseModelView3DDirty = !1, c.inverse(e.modelView3D, e._inverseModelView3D))
        }

        function A(e) {
            e._viewProjectionDirty && (e._viewProjectionDirty = !1, c.multiply(e._projection, e._view, e._viewProjection))
        }

        function P(e) {
            e._inverseViewProjectionDirty && (e._inverseViewProjectionDirty = !1, c.inverse(e.viewProjection, e._inverseViewProjection))
        }

        function I(e) {
            e._modelViewProjectionDirty && (e._modelViewProjectionDirty = !1, c.multiply(e._projection, e.modelView, e._modelViewProjection))
        }

        function D(e) {
            if (e._modelViewRelativeToEyeDirty) {
                e._modelViewRelativeToEyeDirty = !1;
                var t = e.modelView, i = e._modelViewRelativeToEye;
                i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[4] = t[4], i[5] = t[5], i[6] = t[6], i[7] = t[7], i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = 0, i[13] = 0, i[14] = 0, i[15] = t[15]
            }
        }

        function M(e) {
            e._inverseModelViewProjectionDirty && (e._inverseModelViewProjectionDirty = !1, c.inverse(e.modelViewProjection, e._inverseModelViewProjection))
        }

        function O(e) {
            e._modelViewProjectionRelativeToEyeDirty && (e._modelViewProjectionRelativeToEyeDirty = !1, c.multiply(e._projection, e.modelViewRelativeToEye, e._modelViewProjectionRelativeToEye))
        }

        function R(e) {
            e._modelViewInfiniteProjectionDirty && (e._modelViewInfiniteProjectionDirty = !1, c.multiply(e._infiniteProjection, e.modelView, e._modelViewInfiniteProjection))
        }

        function N(e) {
            if (e._normalDirty) {
                e._normalDirty = !1;
                var t = e._normal;
                c.getRotation(e.inverseModelView, t), l.transpose(t, t)
            }
        }

        function L(e) {
            if (e._normal3DDirty) {
                e._normal3DDirty = !1;
                var t = e._normal3D;
                c.getRotation(e.inverseModelView3D, t), l.transpose(t, t)
            }
        }

        function F(e) {
            e._inverseNormalDirty && (e._inverseNormalDirty = !1, c.getRotation(e.inverseModelView, e._inverseNormal))
        }

        function B(e) {
            e._inverseNormal3DDirty && (e._inverseNormal3DDirty = !1, c.getRotation(e.inverseModelView3D, e._inverseNormal3D))
        }

        function z(e) {
            e._encodedCameraPositionMCDirty && (e._encodedCameraPositionMCDirty = !1, c.multiplyByPoint(e.inverseModel, e._cameraPosition, H), s.fromCartesian(H, e._encodedCameraPositionMC))
        }

        function V(e, t, n, r, a, s, l, h) {
            var p = W;
            p.x = e.y, p.y = e.z, p.z = e.x;
            var f = q;
            f.x = n.y, f.y = n.z, f.z = n.x;
            var _ = j;
            _.x = r.y, _.y = r.z, _.z = r.x;
            var v = Y;
            v.x = t.y, v.y = t.z, v.z = t.x, s === m.SCENE2D && (p.z = .5 * a);
            var g = l.unproject(p, X);
            g.longitude = u.clamp(g.longitude, -Math.PI, Math.PI), g.latitude = u.clamp(g.latitude, -u.PI_OVER_TWO, u.PI_OVER_TWO);
            var y = l.ellipsoid, C = y.cartographicToCartesian(g, Z), E = d.eastNorthUpToFixedFrame(C, y, K);
            return c.multiplyByPointAsVector(E, f, f), c.multiplyByPointAsVector(E, _, _), c.multiplyByPointAsVector(E, v, v), o(h) || (h = new c), h[0] = f.x, h[1] = _.x, h[2] = -v.x, h[3] = 0, h[4] = f.y, h[5] = _.y, h[6] = -v.y, h[7] = 0, h[8] = f.z, h[9] = _.z, h[10] = -v.z, h[11] = 0, h[12] = -i.dot(f, C), h[13] = -i.dot(_, C), h[14] = i.dot(v, C), h[15] = 1, h
        }

        var U = function () {
            this.globeDepthTexture = void 0, this._viewport = new e, this._viewportCartesian4 = new n, this._viewportDirty = !1, this._viewportOrthographicMatrix = c.clone(c.IDENTITY), this._viewportTransformation = c.clone(c.IDENTITY), this._model = c.clone(c.IDENTITY), this._view = c.clone(c.IDENTITY), this._inverseView = c.clone(c.IDENTITY), this._projection = c.clone(c.IDENTITY), this._infiniteProjection = c.clone(c.IDENTITY), this._entireFrustum = new t, this._currentFrustum = new t, this._frustumPlanes = new n, this._frameState = void 0, this._temeToPseudoFixed = l.clone(c.IDENTITY), this._view3DDirty = !0, this._view3D = new c, this._inverseView3DDirty = !0, this._inverseView3D = new c, this._inverseModelDirty = !0, this._inverseModel = new c, this._inverseTransposeModelDirty = !0, this._inverseTransposeModel = new l, this._viewRotation = new l, this._inverseViewRotation = new l, this._viewRotation3D = new l, this._inverseViewRotation3D = new l, this._inverseProjectionDirty = !0, this._inverseProjection = new c, this._inverseProjectionOITDirty = !0, this._inverseProjectionOIT = new c, this._modelViewDirty = !0, this._modelView = new c, this._modelView3DDirty = !0, this._modelView3D = new c, this._modelViewRelativeToEyeDirty = !0, this._modelViewRelativeToEye = new c, this._inverseModelViewDirty = !0, this._inverseModelView = new c, this._inverseModelView3DDirty = !0, this._inverseModelView3D = new c, this._viewProjectionDirty = !0, this._viewProjection = new c, this._inverseViewProjectionDirty = !0, this._inverseViewProjection = new c, this._modelViewProjectionDirty = !0, this._modelViewProjection = new c, this._inverseModelViewProjectionDirty = !0, this._inverseModelViewProjection = new c, this._modelViewProjectionRelativeToEyeDirty = !0, this._modelViewProjectionRelativeToEye = new c, this._modelViewInfiniteProjectionDirty = !0, this._modelViewInfiniteProjection = new c, this._normalDirty = !0, this._normal = new l, this._normal3DDirty = !0, this._normal3D = new l, this._inverseNormalDirty = !0, this._inverseNormal = new l, this._inverseNormal3DDirty = !0, this._inverseNormal3D = new l, this._encodedCameraPositionMCDirty = !0, this._encodedCameraPositionMC = new s, this._cameraPosition = new i, this._sunPositionWC = new i, this._sunPositionColumbusView = new i, this._sunDirectionWC = new i, this._sunDirectionEC = new i, this._moonDirectionEC = new i, this._mode = void 0, this._mapProjection = void 0, this._cameraDirection = new i, this._cameraRight = new i, this._cameraUp = new i, this._frustum2DWidth = 0, this._eyeHeight2D = new t, this._resolutionScale = 1
        };
        a(U.prototype, {
            frameState: {
                get: function () {
                    return this._frameState
                }
            }, viewport: {
                get: function () {
                    return this._viewport
                }, set: function (t) {
                    if (!e.equals(t, this._viewport)) {
                        e.clone(t, this._viewport);
                        var i = this._viewport, n = this._viewportCartesian4;
                        n.x = i.x, n.y = i.y, n.z = i.width, n.w = i.height, this._viewportDirty = !0
                    }
                }
            }, viewportCartesian4: {
                get: function () {
                    return this._viewportCartesian4
                }
            }, viewportOrthographic: {
                get: function () {
                    return C(this), this._viewportOrthographicMatrix
                }
            }, viewportTransformation: {
                get: function () {
                    return C(this), this._viewportTransformation
                }
            }, model: {
                get: function () {
                    return this._model
                }, set: function (e) {
                    c.clone(e, this._model), this._modelView3DDirty = !0, this._inverseModelView3DDirty = !0, this._inverseModelDirty = !0, this._inverseTransposeModelDirty = !0, this._modelViewDirty = !0, this._inverseModelViewDirty = !0, this._viewProjectionDirty = !0, this._inverseViewProjectionDirty = !0, this._modelViewRelativeToEyeDirty = !0, this._inverseModelViewDirty = !0, this._modelViewProjectionDirty = !0, this._inverseModelViewProjectionDirty = !0, this._modelViewProjectionRelativeToEyeDirty = !0, this._modelViewInfiniteProjectionDirty = !0, this._normalDirty = !0, this._inverseNormalDirty = !0, this._normal3DDirty = !0, this._inverseNormal3DDirty = !0, this._encodedCameraPositionMCDirty = !0
                }
            }, inverseModel: {
                get: function () {
                    return this._inverseModelDirty && (this._inverseModelDirty = !1, c.inverse(this._model, this._inverseModel)), this._inverseModel
                }
            }, inverseTranposeModel: {
                get: function () {
                    var e = this._inverseTransposeModel;
                    return this._inverseTransposeModelDirty && (this._inverseTransposeModelDirty = !1, c.getRotation(this.inverseModel, e), l.transpose(e, e)), e
                }
            }, view: {
                get: function () {
                    return this._view
                }
            }, view3D: {
                get: function () {
                    return this._view3DDirty && (this._mode === m.SCENE3D ? c.clone(this._view, this._view3D) : V(this._cameraPosition, this._cameraDirection, this._cameraRight, this._cameraUp, this._frustum2DWidth, this._mode, this._mapProjection, this._view3D), c.getRotation(this._view3D, this._viewRotation3D), this._view3DDirty = !1), this._view3D
                }
            }, viewRotation: {
                get: function () {
                    return this._viewRotation
                }
            }, viewRotation3D: {
                get: function () {
                    this.view3D;
                    return this._viewRotation3D
                }
            }, inverseView: {
                get: function () {
                    return this._inverseView
                }
            }, inverseView3D: {
                get: function () {
                    return this._inverseView3DDirty && (c.inverseTransformation(this.view3D, this._inverseView3D), c.getRotation(this._inverseView3D, this._inverseViewRotation3D), this._inverseView3DDirty = !1), this._inverseView3D
                }
            }, inverseViewRotation: {
                get: function () {
                    return this._inverseViewRotation
                }
            }, inverseViewRotation3D: {
                get: function () {
                    this.inverseView3D;
                    return this._inverseViewRotation3D
                }
            }, projection: {
                get: function () {
                    return this._projection
                }
            }, inverseProjection: {
                get: function () {
                    return E(this), this._inverseProjection
                }
            }, inverseProjectionOIT: {
                get: function () {
                    return S(this), this._inverseProjectionOIT
                }
            }, infiniteProjection: {
                get: function () {
                    return this._infiniteProjection
                }
            }, modelView: {
                get: function () {
                    return T(this), this._modelView
                }
            }, modelView3D: {
                get: function () {
                    return b(this), this._modelView3D
                }
            }, modelViewRelativeToEye: {
                get: function () {
                    return D(this), this._modelViewRelativeToEye
                }
            }, inverseModelView: {
                get: function () {
                    return w(this), this._inverseModelView
                }
            }, inverseModelView3D: {
                get: function () {
                    return x(this), this._inverseModelView3D
                }
            }, viewProjection: {
                get: function () {
                    return A(this), this._viewProjection
                }
            }, inverseViewProjection: {
                get: function () {
                    return P(this), this._inverseViewProjection
                }
            }, modelViewProjection: {
                get: function () {
                    return I(this), this._modelViewProjection
                }
            }, inverseModelViewProjection: {
                get: function () {
                    return M(this), this._inverseModelViewProjection
                }
            }, modelViewProjectionRelativeToEye: {
                get: function () {
                    return O(this), this._modelViewProjectionRelativeToEye
                }
            }, modelViewInfiniteProjection: {
                get: function () {
                    return R(this), this._modelViewInfiniteProjection
                }
            }, normal: {
                get: function () {
                    return N(this), this._normal
                }
            }, normal3D: {
                get: function () {
                    return L(this), this._normal3D
                }
            }, inverseNormal: {
                get: function () {
                    return F(this), this._inverseNormal
                }
            }, inverseNormal3D: {
                get: function () {
                    return B(this), this._inverseNormal3D
                }
            }, entireFrustum: {
                get: function () {
                    return this._entireFrustum
                }
            }, currentFrustum: {
                get: function () {
                    return this._currentFrustum
                }
            }, frustumPlanes: {
                get: function () {
                    return this._frustumPlanes
                }
            }, eyeHeight2D: {
                get: function () {
                    return this._eyeHeight2D
                }
            }, sunPositionWC: {
                get: function () {
                    return this._sunPositionWC
                }
            }, sunPositionColumbusView: {
                get: function () {
                    return this._sunPositionColumbusView
                }
            }, sunDirectionWC: {
                get: function () {
                    return this._sunDirectionWC
                }
            }, sunDirectionEC: {
                get: function () {
                    return this._sunDirectionEC
                }
            }, moonDirectionEC: {
                get: function () {
                    return this._moonDirectionEC
                }
            }, encodedCameraPositionMCHigh: {
                get: function () {
                    return z(this), this._encodedCameraPositionMC.high
                }
            }, encodedCameraPositionMCLow: {
                get: function () {
                    return z(this), this._encodedCameraPositionMC.low
                }
            }, temeToPseudoFixedMatrix: {
                get: function () {
                    return this._temeToPseudoFixed
                }
            }, resolutionScale: {
                get: function () {
                    return this._resolutionScale
                }
            }
        });
        var k = new l, G = new r;
        U.prototype.updateFrustum = function (e) {
            _(this, e.projectionMatrix), o(e.infiniteProjectionMatrix) && v(this, e.infiniteProjectionMatrix), this._currentFrustum.x = e.near, this._currentFrustum.y = e.far, o(e.top) || (e = e._offCenterFrustum), this._frustumPlanes.x = e.top, this._frustumPlanes.y = e.bottom, this._frustumPlanes.z = e.left, this._frustumPlanes.w = e.right
        }, U.prototype.update = function (e, t) {
            this._mode = t.mode, this._mapProjection = t.mapProjection;
            var i = e._canvas;
            this._resolutionScale = i.width / i.clientWidth;
            var n = t.camera;
            p(this, n.viewMatrix), f(this, n.inverseViewMatrix), g(this, n), t.mode === m.SCENE2D ? (this._frustum2DWidth = n.frustum.right - n.frustum.left, this._eyeHeight2D.x = .5 * this._frustum2DWidth, this._eyeHeight2D.y = this._eyeHeight2D.x * this._eyeHeight2D.x) : (this._frustum2DWidth = 0, this._eyeHeight2D.x = 0, this._eyeHeight2D.y = 0), y(this, t), this._entireFrustum.x = n.frustum.near, this._entireFrustum.y = n.frustum.far, this.updateFrustum(n.frustum), this._frameState = t, this._temeToPseudoFixed = d.computeTemeToPseudoFixedMatrix(t.time, this._temeToPseudoFixed)
        };
        var H = new i, W = new i, q = new i, j = new i, Y = new i, X = new r, Z = new i, K = new c;
        return U
    }),define("Cesium/Renderer/Buffer", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/IndexDatatype", "./BufferUsage"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = function (i) {
            i = e(i, e.EMPTY_OBJECT);
            var n = i.context._gl, r = i.bufferTarget, o = i.typedArray, a = i.sizeInBytes, s = i.usage, u = t(o);
            u && (a = o.byteLength);
            var l = n.createBuffer();
            n.bindBuffer(r, l), n.bufferData(r, u ? o : a, s), n.bindBuffer(r, null), this._gl = n, this._bufferTarget = r, this._sizeInBytes = a, this._usage = s, this._buffer = l, this.vertexArrayDestroyable = !0
        };
        return s.createVertexBuffer = function (e) {
            return new s({
                context: e.context,
                bufferTarget: e.context._gl.ARRAY_BUFFER,
                typedArray: e.typedArray,
                sizeInBytes: e.sizeInBytes,
                usage: e.usage
            })
        }, s.createIndexBuffer = function (e) {
            var t = e.context, n = e.indexDatatype, r = o.getSizeInBytes(n), a = new s({
                context: t,
                bufferTarget: t._gl.ELEMENT_ARRAY_BUFFER,
                typedArray: e.typedArray,
                sizeInBytes: e.sizeInBytes,
                usage: e.usage
            }), u = a.sizeInBytes / r;
            return i(a, {
                indexDatatype: {
                    get: function () {
                        return n
                    }
                }, bytesPerIndex: {
                    get: function () {
                        return r
                    }
                }, numberOfIndices: {
                    get: function () {
                        return u
                    }
                }
            }), a
        }, i(s.prototype, {
            sizeInBytes: {
                get: function () {
                    return this._sizeInBytes
                }
            }, usage: {
                get: function () {
                    return this._usage
                }
            }
        }), s.prototype._getBuffer = function () {
            return this._buffer
        }, s.prototype.copyFromArrayView = function (t, i) {
            i = e(i, 0);
            var n = this._gl, r = this._bufferTarget;
            n.bindBuffer(r, this._buffer), n.bufferSubData(r, i, t), n.bindBuffer(r, null)
        }, s.prototype.isDestroyed = function () {
            return !1
        }, s.prototype.destroy = function () {
            return this._gl.deleteBuffer(this._buffer), n(this)
        }, s
    }),define("Cesium/Renderer/VertexArray", ["../Core/ComponentDatatype", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Geometry", "../Core/IndexDatatype", "../Core/Math", "../Core/RuntimeError", "./Buffer", "./BufferUsage"], function (e, t, i, n, r, o, a, s, u, l, c, h) {
        "use strict";
        function d(n, r, o) {
            var a = i(r.vertexBuffer), s = i(r.value), u = r.value ? r.value.length : r.componentsPerAttribute, l = {
                index: t(r.index, o),
                enabled: t(r.enabled, !0),
                vertexBuffer: r.vertexBuffer,
                value: s ? r.value.slice(0) : void 0,
                componentsPerAttribute: u,
                componentDatatype: t(r.componentDatatype, e.FLOAT),
                normalize: t(r.normalize, !1),
                offsetInBytes: t(r.offsetInBytes, 0),
                strideInBytes: t(r.strideInBytes, 0)
            };
            if (a)l.vertexAttrib = function (e) {
                e.bindBuffer(e.ARRAY_BUFFER, this.vertexBuffer._getBuffer()), e.vertexAttribPointer(this.index, this.componentsPerAttribute, this.componentDatatype, this.normalize, this.strideInBytes, this.offsetInBytes), e.enableVertexAttribArray(this.index)
            }, l.disableVertexAttribArray = function (e) {
                e.disableVertexAttribArray(this.index)
            }; else {
                switch (l.componentsPerAttribute) {
                    case 1:
                        l.vertexAttrib = function (e) {
                            e.vertexAttrib1fv(this.index, this.value)
                        };
                        break;
                    case 2:
                        l.vertexAttrib = function (e) {
                            e.vertexAttrib2fv(this.index, this.value)
                        };
                        break;
                    case 3:
                        l.vertexAttrib = function (e) {
                            e.vertexAttrib3fv(this.index, this.value)
                        };
                        break;
                    case 4:
                        l.vertexAttrib = function (e) {
                            e.vertexAttrib4fv(this.index, this.value)
                        }
                }
                l.disableVertexAttribArray = function (e) {
                }
            }
            n.push(l)
        }

        function m(e, t, n) {
            for (var r = 0; r < t.length; ++r) {
                var o = t[r];
                o.enabled && o.vertexAttrib(e)
            }
            i(n) && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, n._getBuffer())
        }

        function p(e) {
            return e.values.length / e.componentsPerAttribute
        }

        function f(t) {
            return e.getSizeInBytes(t.componentDatatype) * t.componentsPerAttribute
        }

        function _(t) {
            var n, r, o, a = [];
            for (r in t)t.hasOwnProperty(r) && i(t[r]) && i(t[r].values) && (a.push(r), t[r].componentDatatype === e.DOUBLE && (t[r].componentDatatype = e.FLOAT, t[r].values = e.createTypedArray(e.FLOAT, t[r].values)));
            var s, u = a.length;
            if (u > 0)for (s = p(t[a[0]]),
                               n = 1; u > n; ++n) {
                var c = p(t[a[n]]);
                if (c !== s)throw new l("Each attribute list must have the same number of vertices.  Attribute " + a[n] + " has a different number of vertices (" + c.toString() + ") than attribute " + a[0] + " (" + s.toString() + ").")
            }
            a.sort(function (i, n) {
                return e.getSizeInBytes(t[n].componentDatatype) - e.getSizeInBytes(t[i].componentDatatype)
            });
            var h = 0, d = {};
            for (n = 0; u > n; ++n)r = a[n], o = t[r], d[r] = h, h += f(o);
            if (h > 0) {
                var m = e.getSizeInBytes(t[a[0]].componentDatatype), _ = h % m;
                0 !== _ && (h += m - _);
                var v = s * h, g = new ArrayBuffer(v), y = {};
                for (n = 0; u > n; ++n) {
                    r = a[n];
                    var C = e.getSizeInBytes(t[r].componentDatatype);
                    y[r] = {
                        pointer: e.createTypedArray(t[r].componentDatatype, g),
                        index: d[r] / C,
                        strideInComponentType: h / C
                    }
                }
                for (n = 0; s > n; ++n)for (var E = 0; u > E; ++E) {
                    r = a[E], o = t[r];
                    for (var S = o.values, T = y[r], b = T.pointer, w = o.componentsPerAttribute, x = 0; w > x; ++x)b[T.index + x] = S[n * w + x];
                    T.index += T.strideInComponentType
                }
                return {buffer: g, offsetsInBytes: d, vertexSizeInBytes: h}
            }
            return void 0
        }

        var v = function (n) {
            n = t(n, t.EMPTY_OBJECT);
            var r, a = n.context, s = a._gl, u = a._vertexArrayObject, l = n.attributes, c = n.indexBuffer, h = [], p = 1;
            for (r = 0; r < l.length; ++r)d(h, l[r], r);
            for (r = 0; r < h.length; ++r) {
                var f = h[r];
                if (i(f.vertexBuffer)) {
                    var _ = f.strideInBytes || f.componentsPerAttribute * e.getSizeInBytes(f.componentDatatype);
                    p = f.vertexBuffer.sizeInBytes / _;
                    break
                }
            }
            for (var v = {}, g = 0; g < h.length; ++g) {
                var y = h[g].index;
                if (v[y])throw new o("Index " + y + " is used by more than one attribute.");
                v[y] = !0
            }
            var C;
            i(u) && (C = u.createVertexArrayOES(), u.bindVertexArrayOES(C), m(s, h, c), u.bindVertexArrayOES(null)), this._numberOfVertices = p, this._gl = s, this._vaoExtension = u, this._vao = C, this._attributes = h, this._indexBuffer = c
        };
        return v.fromGeometry = function (n) {
            n = t(n, t.EMPTY_OBJECT);
            var r, o, l, d = n.context, m = t(n.geometry, t.EMPTY_OBJECT), p = t(n.bufferUsage, h.DYNAMIC_DRAW), f = t(n.attributeLocations, t.EMPTY_OBJECT), g = t(n.interleave, !1), y = n.vertexArrayAttributes, C = i(y) ? y : [], E = m.attributes;
            if (g) {
                var S = _(E);
                if (i(S)) {
                    l = c.createVertexBuffer({context: d, typedArray: S.buffer, usage: p});
                    var T = S.offsetsInBytes, b = S.vertexSizeInBytes;
                    for (r in E)E.hasOwnProperty(r) && i(E[r]) && (o = E[r], i(o.values) ? C.push({
                        index: f[r],
                        vertexBuffer: l,
                        componentDatatype: o.componentDatatype,
                        componentsPerAttribute: o.componentsPerAttribute,
                        normalize: o.normalize,
                        offsetInBytes: T[r],
                        strideInBytes: b
                    }) : C.push({
                        index: f[r],
                        value: o.value,
                        componentDatatype: o.componentDatatype,
                        normalize: o.normalize
                    }))
                }
            } else for (r in E)if (E.hasOwnProperty(r) && i(E[r])) {
                o = E[r];
                var w = o.componentDatatype;
                w === e.DOUBLE && (w = e.FLOAT), l = void 0, i(o.values) && (l = c.createVertexBuffer({
                    context: d,
                    typedArray: e.createTypedArray(w, o.values),
                    usage: p
                })), C.push({
                    index: f[r],
                    vertexBuffer: l,
                    value: o.value,
                    componentDatatype: w,
                    componentsPerAttribute: o.componentsPerAttribute,
                    normalize: o.normalize
                })
            }
            var x, A = m.indices;
            return i(A) && (x = a.computeNumberOfVertices(m) > u.SIXTY_FOUR_KILOBYTES && d.elementIndexUint ? c.createIndexBuffer({
                context: d,
                typedArray: new Uint32Array(A),
                usage: p,
                indexDatatype: s.UNSIGNED_INT
            }) : c.createIndexBuffer({
                context: d,
                typedArray: new Uint16Array(A),
                usage: p,
                indexDatatype: s.UNSIGNED_SHORT
            })), new v({context: d, attributes: C, indexBuffer: x})
        }, n(v.prototype, {
            numberOfAttributes: {
                get: function () {
                    return this._attributes.length
                }
            }, numberOfVertices: {
                get: function () {
                    return this._numberOfVertices
                }
            }, indexBuffer: {
                get: function () {
                    return this._indexBuffer
                }
            }
        }), v.prototype.getAttribute = function (e) {
            return this._attributes[e]
        }, v.prototype._bind = function () {
            i(this._vao) ? this._vaoExtension.bindVertexArrayOES(this._vao) : m(this._gl, this._attributes, this._indexBuffer)
        }, v.prototype._unBind = function () {
            if (i(this._vao))this._vaoExtension.bindVertexArrayOES(null); else {
                for (var e = this._attributes, t = this._gl, n = 0; n < e.length; ++n) {
                    var r = e[n];
                    r.enabled && r.disableVertexAttribArray(t)
                }
                this._indexBuffer && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, null)
            }
        }, v.prototype.isDestroyed = function () {
            return !1
        }, v.prototype.destroy = function () {
            for (var e = this._attributes, t = 0; t < e.length; ++t) {
                var n = e[t].vertexBuffer;
                i(n) && !n.isDestroyed() && n.vertexArrayDestroyable && n.destroy()
            }
            var o = this._indexBuffer;
            return i(o) && !o.isDestroyed() && o.vertexArrayDestroyable && o.destroy(), i(this._vao) && this._vaoExtension.deleteVertexArrayOES(this._vao), r(this)
        }, v
    }),define("Cesium/Renderer/Context", ["../Core/clone", "../Core/Color", "../Core/ComponentDatatype", "../Core/createGuid", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/FeatureDetection", "../Core/Geometry", "../Core/GeometryAttribute", "../Core/Math", "../Core/Matrix4", "../Core/PrimitiveType", "../Core/RuntimeError", "../Shaders/ViewportQuadVS", "./BufferUsage", "./ClearCommand", "./ContextLimits", "./CubeMap", "./DrawCommand", "./PassState", "./PickFramebuffer", "./PixelDatatype", "./RenderbufferFormat", "./RenderState", "./ShaderCache", "./ShaderProgram", "./Texture", "./UniformState", "./VertexArray", "./WebGLConstants"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S, T, b, w, x, A, P, I, D, M, O) {
        "use strict";
        function R(e, t) {
            var i = "WebGL Error:  ";
            switch (t) {
                case e.INVALID_ENUM:
                    i += "INVALID_ENUM";
                    break;
                case e.INVALID_VALUE:
                    i += "INVALID_VALUE";
                    break;
                case e.INVALID_OPERATION:
                    i += "INVALID_OPERATION";
                    break;
                case e.OUT_OF_MEMORY:
                    i += "OUT_OF_MEMORY";
                    break;
                case e.CONTEXT_LOST_WEBGL:
                    i += "CONTEXT_LOST_WEBGL lost";
                    break;
                default:
                    i += "Unknown (" + t + ")"
            }
            return i
        }

        function N(e, t, i, n) {
            for (var r = R(e, n) + ": " + t.name + "(", o = 0; o < i.length; ++o)0 !== o && (r += ", "), r += i[o];
            return r += ");"
        }

        function L(e, t, i) {
            var n = e.getError();
            if (n !== e.NO_ERROR)throw new f(N(e, t, i, n))
        }

        function F(e, t, i) {
            return {
                get: function () {
                    var n = e[t];
                    return i(e, "get: " + t, n), e[t]
                }, set: function (n) {
                    e[t] = n, i(e, "set: " + t, n)
                }
            }
        }

        function B(e, t) {
            function i(i) {
                return function () {
                    var n = i.apply(e, arguments);
                    return t(e, i, arguments), n
                }
            }

            if (!t)return e;
            var n = {};
            for (var r in e) {
                var o = e[r];
                "function" == typeof o ? n[r] = i(o) : Object.defineProperty(n, r, F(e, r, t))
            }
            return n
        }

        function z(e, t) {
            for (var i = t.length, n = 0; i > n; ++n) {
                var r = e.getExtension(t[n]);
                if (r)return r
            }
            return void 0
        }

        function V(e, t) {
            if (e.validateFramebuffer) {
                var i = e._gl, n = i.checkFramebufferStatus(i.FRAMEBUFFER);
                if (n !== i.FRAMEBUFFER_COMPLETE) {
                    var r;
                    switch (n) {
                        case i.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                            r = "Framebuffer is not complete.  Incomplete attachment: at least one attachment point with a renderbuffer or texture attached has its attached object no longer in existence or has an attached image with a width or height of zero, or the color attachment point has a non-color-renderable image attached, or the depth attachment point has a non-depth-renderable image attached, or the stencil attachment point has a non-stencil-renderable image attached.  Color-renderable formats include GL_RGBA4, GL_RGB5_A1, and GL_RGB565. GL_DEPTH_COMPONENT16 is the only depth-renderable format. GL_STENCIL_INDEX8 is the only stencil-renderable format.";
                            break;
                        case i.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                            r = "Framebuffer is not complete.  Incomplete dimensions: not all attached images have the same width and height.";
                            break;
                        case i.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                            r = "Framebuffer is not complete.  Missing attachment: no images are attached to the framebuffer.";
                            break;
                        case i.FRAMEBUFFER_UNSUPPORTED:
                            r = "Framebuffer is not complete.  Unsupported: the combination of internal formats of the attached images violates an implementation-dependent set of restrictions."
                    }
                    throw new u(r)
                }
            }
        }

        function U(e, t, i, n) {
            var r = e._currentRenderState, o = e._currentPassState;
            e._currentRenderState = t, e._currentPassState = i, x.partialApply(e._gl, r, t, o, i, n)
        }

        function k(e, t) {
            if (t !== e._currentFramebuffer) {
                e._currentFramebuffer = t;
                var i = Y;
                if (o(t))t._bind(), V(e, t), i = t._getActiveColorAttachments(); else {
                    var n = e._gl;
                    n.bindFramebuffer(n.FRAMEBUFFER, null)
                }
                e.drawBuffers && e._drawBuffers.drawBuffersWEBGL(i)
            }
        }

        function G(e, t, i, n, o, a) {
            var s = r(r(o, i.renderState), e._defaultRenderState);
            k(e, t), U(e, s, n, !1);
            var u = r(a, i.shaderProgram);
            u._bind(), e._maxFrameTextureUnitIndex = Math.max(e._maxFrameTextureUnitIndex, u.maximumTextureUnitIndex)
        }

        function H(e, t, i) {
            var n = t.primitiveType, a = t.vertexArray, s = t.offset, u = t.count;
            e._us.model = r(t.modelMatrix, m.IDENTITY);
            var l = r(i, t.shaderProgram);
            l._setUniforms(t.uniformMap, e._us, e.validateShaderProgram), a._bind();
            var c = a.indexBuffer;
            o(c) ? (s *= c.bytesPerIndex, u = r(u, c.numberOfIndices), e._gl.drawElements(n, u, c.indexDatatype, s)) : (u = r(u, a.numberOfVertices), e._gl.drawArrays(n, s, u)), a._unBind()
        }

        function W(e, t, i) {
            this._pickObjects = e, this.key = t, this.color = i
        }

        var q = function (i, a) {
            if ("undefined" == typeof WebGLRenderingContext)throw new f("The browser does not support WebGL.  Visit http://get.webgl.org.");
            this._canvas = i, a = e(a, !0), a = r(a, {}), a.allowTextureFilterAnisotropic = r(a.allowTextureFilterAnisotropic, !0);
            var s = r(a.webgl, {});
            if (s.alpha = r(s.alpha, !1), s.failIfMajorPerformanceCaveat = r(s.failIfMajorPerformanceCaveat, !0), l.isFirefox() && l.isWindows()) {
                var u = l.firefoxVersion();
                35 === u[0] && (s.alpha = !0)
            }
            if (this._originalGLContext = i.getContext("webgl", s) || i.getContext("experimental-webgl", s) || void 0, !o(this._originalGLContext))throw new f("The browser supports WebGL, but initialization failed.");
            this._id = n(), this.validateFramebuffer = !1, this.validateShaderProgram = !1, this.logShaderCompilation = !1, this._throwOnWebGLError = !1, this._shaderCache = new A(this);
            var c = this._gl = this._originalGLContext;
            this._redBits = c.getParameter(c.RED_BITS), this._greenBits = c.getParameter(c.GREEN_BITS), this._blueBits = c.getParameter(c.BLUE_BITS), this._alphaBits = c.getParameter(c.ALPHA_BITS), this._depthBits = c.getParameter(c.DEPTH_BITS), this._stencilBits = c.getParameter(c.STENCIL_BITS), y._maximumCombinedTextureImageUnits = c.getParameter(c.MAX_COMBINED_TEXTURE_IMAGE_UNITS), y._maximumCubeMapSize = c.getParameter(c.MAX_CUBE_MAP_TEXTURE_SIZE), y._maximumFragmentUniformVectors = c.getParameter(c.MAX_FRAGMENT_UNIFORM_VECTORS), y._maximumTextureImageUnits = c.getParameter(c.MAX_TEXTURE_IMAGE_UNITS), y._maximumRenderbufferSize = c.getParameter(c.MAX_RENDERBUFFER_SIZE), y._maximumTextureSize = c.getParameter(c.MAX_TEXTURE_SIZE), y._maximumVaryingVectors = c.getParameter(c.MAX_VARYING_VECTORS), y._maximumVertexAttributes = c.getParameter(c.MAX_VERTEX_ATTRIBS), y._maximumVertexTextureImageUnits = c.getParameter(c.MAX_VERTEX_TEXTURE_IMAGE_UNITS), y._maximumVertexUniformVectors = c.getParameter(c.MAX_VERTEX_UNIFORM_VECTORS);
            var h = c.getParameter(c.ALIASED_LINE_WIDTH_RANGE);
            y._minimumAliasedLineWidth = h[0], y._maximumAliasedLineWidth = h[1];
            var d = c.getParameter(c.ALIASED_POINT_SIZE_RANGE);
            y._minimumAliasedPointSize = d[0], y._maximumAliasedPointSize = d[1];
            var m = c.getParameter(c.MAX_VIEWPORT_DIMS);
            y._maximumViewportWidth = m[0], y._maximumViewportHeight = m[1];
            var p = c.getShaderPrecisionFormat(c.FRAGMENT_SHADER, c.HIGH_FLOAT);
            y._highpFloatSupported = 0 !== p.precision;
            var _ = c.getShaderPrecisionFormat(c.FRAGMENT_SHADER, c.HIGH_INT);
            y._highpIntSupported = 0 !== _.rangeMax, this._antialias = c.getContextAttributes().antialias, this._standardDerivatives = z(c, ["OES_standard_derivatives"]), this._elementIndexUint = z(c, ["OES_element_index_uint"]), this._depthTexture = z(c, ["WEBGL_depth_texture", "WEBKIT_WEBGL_depth_texture"]), this._textureFloat = z(c, ["OES_texture_float"]);
            var v = a.allowTextureFilterAnisotropic ? z(c, ["EXT_texture_filter_anisotropic", "WEBKIT_EXT_texture_filter_anisotropic"]) : void 0;
            this._textureFilterAnisotropic = v, y._maximumTextureFilterAnisotropy = o(v) ? c.getParameter(v.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1, this._vertexArrayObject = z(c, ["OES_vertex_array_object"]), this._fragDepth = z(c, ["EXT_frag_depth"]), this._drawBuffers = z(c, ["WEBGL_draw_buffers"]), y._maximumDrawBuffers = o(this._drawBuffers) ? c.getParameter(this._drawBuffers.MAX_DRAW_BUFFERS_WEBGL) : 1, y._maximumColorAttachments = o(this._drawBuffers) ? c.getParameter(this._drawBuffers.MAX_COLOR_ATTACHMENTS_WEBGL) : 1, this._debugShaders = z(c, ["WEBGL_debug_shaders"]);
            var g = c.getParameter(c.COLOR_CLEAR_VALUE);
            this._clearColor = new t(g[0], g[1], g[2], g[3]), this._clearDepth = c.getParameter(c.DEPTH_CLEAR_VALUE), this._clearStencil = c.getParameter(c.STENCIL_CLEAR_VALUE);
            var C = new D, E = new S(this), T = x.fromCache();
            this._defaultPassState = E, this._defaultRenderState = T, this._defaultTexture = void 0, this._defaultCubeMap = void 0, this._us = C, this._currentRenderState = T, this._currentPassState = E, this._currentFramebuffer = void 0, this._maxFrameTextureUnitIndex = 0, this._pickObjects = {}, this._nextPickColor = new Uint32Array(1), this.options = a, this.cache = {}, x.apply(c, T, E)
        }, j = {};
        a(q.prototype, {
            id: {
                get: function () {
                    return this._id
                }
            }, canvas: {
                get: function () {
                    return this._canvas
                }
            }, shaderCache: {
                get: function () {
                    return this._shaderCache
                }
            }, uniformState: {
                get: function () {
                    return this._us
                }
            }, redBits: {
                get: function () {
                    return this._redBits
                }
            }, greenBits: {
                get: function () {
                    return this._greenBits
                }
            }, blueBits: {
                get: function () {
                    return this._blueBits
                }
            }, alphaBits: {
                get: function () {
                    return this._alphaBits
                }
            }, depthBits: {
                get: function () {
                    return this._depthBits
                }
            }, stencilBits: {
                get: function () {
                    return this._stencilBits
                }
            }, antialias: {
                get: function () {
                    return this._antialias
                }
            }, standardDerivatives: {
                get: function () {
                    return !!this._standardDerivatives
                }
            }, elementIndexUint: {
                get: function () {
                    return !!this._elementIndexUint
                }
            }, depthTexture: {
                get: function () {
                    return !!this._depthTexture
                }
            }, floatingPointTexture: {
                get: function () {
                    return !!this._textureFloat
                }
            }, textureFilterAnisotropic: {
                get: function () {
                    return !!this._textureFilterAnisotropic
                }
            }, vertexArrayObject: {
                get: function () {
                    return !!this._vertexArrayObject
                }
            }, fragmentDepth: {
                get: function () {
                    return !!this._fragDepth
                }
            }, drawBuffers: {
                get: function () {
                    return !!this._drawBuffers
                }
            }, debugShaders: {
                get: function () {
                    return this._debugShaders
                }
            }, throwOnWebGLError: {
                get: function () {
                    return this._throwOnWebGLError
                }, set: function (e) {
                    this._throwOnWebGLError = e, this._gl = B(this._originalGLContext, e ? L : null)
                }
            }, defaultTexture: {
                get: function () {
                    return void 0 === this._defaultTexture && (this._defaultTexture = new I({
                        context: this,
                        source: {width: 1, height: 1, arrayBufferView: new Uint8Array([255, 255, 255, 255])}
                    })), this._defaultTexture
                }
            }, defaultCubeMap: {
                get: function () {
                    if (void 0 === this._defaultCubeMap) {
                        var e = {width: 1, height: 1, arrayBufferView: new Uint8Array([255, 255, 255, 255])};
                        this._defaultCubeMap = new C({
                            context: this,
                            source: {positiveX: e, negativeX: e, positiveY: e, negativeY: e, positiveZ: e, negativeZ: e}
                        })
                    }
                    return this._defaultCubeMap
                }
            }, drawingBufferHeight: {
                get: function () {
                    return this._gl.drawingBufferHeight
                }
            }, drawingBufferWidth: {
                get: function () {
                    return this._gl.drawingBufferWidth
                }
            }, defaultFramebuffer: {
                get: function () {
                    return j
                }
            }
        });
        var Y;
        "undefined" != typeof WebGLRenderingContext && (Y = [O.BACK]);
        var X = new g;
        q.prototype.clear = function (e, i) {
            e = r(e, X), i = r(i, this._defaultPassState);
            var n = this._gl, a = 0, s = e.color, u = e.depth, l = e.stencil;
            o(s) && (t.equals(this._clearColor, s) || (t.clone(s, this._clearColor), n.clearColor(s.red, s.green, s.blue, s.alpha)), a |= n.COLOR_BUFFER_BIT), o(u) && (u !== this._clearDepth && (this._clearDepth = u, n.clearDepth(u)), a |= n.DEPTH_BUFFER_BIT), o(l) && (l !== this._clearStencil && (this._clearStencil = l, n.clearStencil(l)), a |= n.STENCIL_BUFFER_BIT);
            var c = r(e.renderState, this._defaultRenderState);
            U(this, c, i, !0);
            var h = r(e.framebuffer, i.framebuffer);
            k(this, h), n.clear(a)
        }, q.prototype.draw = function (e, t, i, n) {
            t = r(t, this._defaultPassState);
            var o = r(e.framebuffer, t.framebuffer);
            G(this, o, e, t, i, n), H(this, e, n)
        }, q.prototype.endFrame = function () {
            var e = this._gl;
            e.useProgram(null), this._currentFramebuffer = void 0, e.bindFramebuffer(e.FRAMEBUFFER, null);
            this.drawBuffers && this._drawBuffers.drawBuffersWEBGL(Y);
            var t = this._maxFrameTextureUnitIndex;
            this._maxFrameTextureUnitIndex = 0;
            for (var i = 0; t > i; ++i)e.activeTexture(e.TEXTURE0 + i), e.bindTexture(e.TEXTURE_2D, null), e.bindTexture(e.TEXTURE_CUBE_MAP, null)
        }, q.prototype.readPixels = function (e) {
            var t = this._gl;
            e = e || {};
            var i = Math.max(e.x || 0, 0), n = Math.max(e.y || 0, 0), r = e.width || t.drawingBufferWidth, o = e.height || t.drawingBufferHeight, a = e.framebuffer, s = new Uint8Array(4 * r * o);
            return k(this, a), t.readPixels(i, n, r, o, t.RGBA, t.UNSIGNED_BYTE, s), s
        };
        var Z = {position: 0, textureCoordinates: 1};
        return q.prototype.getViewportQuadVertexArray = function () {
            var e = this.cache.viewportQuad_vertexArray;
            if (!o(e)) {
                var t = new c({
                    attributes: {
                        position: new h({
                            componentDatatype: i.FLOAT,
                            componentsPerAttribute: 2,
                            values: [-1, -1, 1, -1, 1, 1, -1, 1]
                        }),
                        textureCoordinates: new h({
                            componentDatatype: i.FLOAT,
                            componentsPerAttribute: 2,
                            values: [0, 0, 1, 0, 1, 1, 0, 1]
                        })
                    }, indices: new Uint16Array([0, 1, 2, 0, 2, 3]), primitiveType: p.TRIANGLES
                });
                e = M.fromGeometry({
                    context: this,
                    geometry: t,
                    attributeLocations: Z,
                    bufferUsage: v.STATIC_DRAW,
                    interleave: !0
                }), this.cache.viewportQuad_vertexArray = e
            }
            return e
        }, q.prototype.createViewportQuadCommand = function (e, t) {
            return t = r(t, r.EMPTY_OBJECT), new E({
                vertexArray: this.getViewportQuadVertexArray(),
                primitiveType: p.TRIANGLES,
                renderState: t.renderState,
                shaderProgram: P.fromCache({
                    context: this,
                    vertexShaderSource: _,
                    fragmentShaderSource: e,
                    attributeLocations: Z
                }),
                uniformMap: t.uniformMap,
                owner: t.owner,
                framebuffer: t.framebuffer
            })
        }, q.prototype.createPickFramebuffer = function () {
            return new T(this)
        }, q.prototype.getObjectByPickColor = function (e) {
            return this._pickObjects[e.toRgba()]
        }, a(W.prototype, {
            object: {
                get: function () {
                    return this._pickObjects[this.key]
                }, set: function (e) {
                    this._pickObjects[this.key] = e
                }
            }
        }), W.prototype.destroy = function () {
            return void delete this._pickObjects[this.key]
        }, q.prototype.createPickId = function (e) {
            ++this._nextPickColor[0];
            var i = this._nextPickColor[0];
            if (0 === i)throw new f("Out of unique Pick IDs.");
            return this._pickObjects[i] = e, new W(this._pickObjects, i, t.fromRgba(i))
        }, q.prototype.isDestroyed = function () {
            return !1
        }, q.prototype.destroy = function () {
            var e = this.cache;
            for (var t in e)if (e.hasOwnProperty(t)) {
                var i = e[t];
                o(i.destroy) && i.destroy()
            }
            return this._shaderCache = this._shaderCache.destroy(), this._defaultTexture = this._defaultTexture && this._defaultTexture.destroy(), this._defaultCubeMap = this._defaultCubeMap && this._defaultCubeMap.destroy(), s(this)
        }, q
    }),define("Cesium/Scene/Cesium3DTileContentState", ["../Core/freezeObject"], function (e) {
        "use strict";
        var t = {UNLOADED: 0, LOADING: 1, PROCESSING: 2, READY: 3, FAILED: 4};
        return e(t)
    }),define("Cesium/Core/getBasePath", [], function () {
        "use strict";
        var e = function (e) {
            var t = "", i = e.lastIndexOf("/");
            return -1 !== i && (t = e.substring(0, i + 1)), t
        };
        return e
    }),define("Cesium/Core/isCrossOriginUrl", ["./defined"], function (e) {
        "use strict";
        var t, i = function (i) {
            e(t) || (t = document.createElement("a")), t.href = window.location.href;
            var n = t.host, r = t.protocol;
            return t.href = i, t.href = t.href, r !== t.protocol || n !== t.host
        };
        return i
    }),define("Cesium/Core/loadImage", ["../ThirdParty/when", "./defaultValue", "./defined", "./DeveloperError", "./isCrossOriginUrl"], function (e, t, i, n, r) {
        "use strict";
        var o = /^data:/, a = function (i, n) {
            return n = t(n, !0), e(i, function (t) {
                var i;
                i = o.test(t) || !n ? !1 : r(t);
                var s = e.defer();
                return a.createImage(t, i, s), s.promise
            })
        };
        return a.createImage = function (e, t, i) {
            var n = new Image;
            n.onload = function () {
                i.resolve(n)
            }, n.onerror = function (e) {
                i.reject(e)
            }, t && (n.crossOrigin = ""), n.src = e
        }, a.defaultCreateImage = a.createImage, a
    }),define("Cesium/Core/loadImageFromTypedArray", ["../ThirdParty/when", "./defined", "./DeveloperError", "./loadImage"], function (e, t, i, n) {
        "use strict";
        var r = function (t, i) {
            var r = new Blob([t], {type: i}), o = window.URL.createObjectURL(r);
            return n(o, !1).then(function (e) {
                return window.URL.revokeObjectURL(o), e
            }, function (t) {
                return window.URL.revokeObjectURL(o), e.reject(t)
            })
        };
        return r
    }),define("Cesium/Core/TaskProcessor", ["../ThirdParty/Uri", "../ThirdParty/when", "./buildModuleUrl", "./defaultValue", "./defined", "./destroyObject", "./DeveloperError", "./isCrossOriginUrl", "./RuntimeError", "require"], function (e, t, i, n, r, o, a, s, u, l) {
        "use strict";
        function c() {
            if (!r(_._canTransferArrayBuffer)) {
                var e = new Worker(d("Workers/transferTypedArrayTest.js"));
                e.postMessage = n(e.webkitPostMessage, e.postMessage);
                var i = 99, o = new Int8Array([i]);
                try {
                    e.postMessage({array: o}, [o.buffer])
                } catch (a) {
                    return _._canTransferArrayBuffer = !1, _._canTransferArrayBuffer
                }
                var s = t.defer();
                e.onmessage = function (t) {
                    var n = t.data.array, o = r(n) && n[0] === i;
                    s.resolve(o), e.terminate(), _._canTransferArrayBuffer = o
                }, _._canTransferArrayBuffer = s.promise
            }
            return _._canTransferArrayBuffer
        }

        function h(e, t) {
            --e._activeTasks;
            var i = t.id;
            if (r(i)) {
                var n = e._deferreds, o = n[i];
                if (r(t.error)) {
                    var s = t.error;
                    "RuntimeError" === s.name ? (s = new u(t.error.message), s.stack = t.error.stack) : "DeveloperError" === s.name && (s = new a(t.error.message), s.stack = t.error.stack), o.reject(s)
                } else o.resolve(t.result);
                delete n[i]
            }
        }

        function d(e) {
            var t = i(e);
            if (s(t)) {
                var n, r = 'importScripts("' + t + '");';
                try {
                    n = new Blob([r], {type: "application/javascript"})
                } catch (o) {
                    var a = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder, u = new a;
                    u.append(r), n = u.getBlob("application/javascript")
                }
                var l = window.URL || window.webkitURL;
                t = l.createObjectURL(n)
            }
            return t
        }

        function m() {
            return r(f) || (f = d("Workers/cesiumWorkerBootstrapper.js")), f
        }

        function p(t) {
            var o = new Worker(m());
            o.postMessage = n(o.webkitPostMessage, o.postMessage);
            var a = {loaderConfig: {}, workerModule: _._workerModulePrefix + t._workerName};
            if (r(_._loaderConfig))a.loaderConfig = _._loaderConfig; else if (r(l.toUrl)) {
                var s = new e("..").resolve(new e(i("Workers/cesiumWorkerBootstrapper.js"))).toString();
                a.loaderConfig.baseUrl = s
            } else a.loaderConfig.paths = {Workers: i("Workers")};
            return o.postMessage(a), o.onmessage = function (e) {
                h(t, e.data)
            }, o
        }

        var f, _ = function (e, t) {
            this._workerName = e, this._maximumActiveTasks = n(t, 5), this._activeTasks = 0, this._deferreds = {}, this._nextID = 0
        }, v = [];
        return _.prototype.scheduleTask = function (e, i) {
            if (r(this._worker) || (this._worker = p(this)), this._activeTasks >= this._maximumActiveTasks)return void 0;
            ++this._activeTasks;
            var n = this;
            return t(c(), function (o) {
                r(i) ? o || (i.length = 0) : i = v;
                var a = n._nextID++, s = t.defer();
                return n._deferreds[a] = s, n._worker.postMessage({
                    id: a,
                    parameters: e,
                    canTransferArrayBuffer: o
                }, i), s.promise
            })
        }, _.prototype.isDestroyed = function () {
            return !1
        }, _.prototype.destroy = function () {
            return r(this._worker) && this._worker.terminate(), o(this)
        }, _._defaultWorkerModulePrefix = "Workers/", _._workerModulePrefix = _._defaultWorkerModulePrefix, _._loaderConfig = void 0, _._canTransferArrayBuffer = void 0, _
    }),define("Cesium/ThirdParty/gltfDefaults", ["../Core/defaultValue", "../Core/defined", "../Renderer/WebGLConstants"], function (e, t, i) {
        "use strict";
        function n(i) {
            t(i.accessors) || (i.accessors = {});
            var n = i.accessors;
            for (var r in n)if (n.hasOwnProperty(r)) {
                var o = n[r];
                o.byteStride = e(o.byteStride, 0)
            }
        }

        function r(i) {
            t(i.animations) || (i.animations = {});
            var n = i.animations;
            for (var r in n)if (n.hasOwnProperty(r)) {
                var o = n[r];
                t(o.channels) || (o.channels = []), t(o.parameters) || (o.parameters = {}), t(o.samplers) || (o.samplers = {});
                var a = n.samplers;
                for (var s in a)if (a.hasOwnProperty(s)) {
                    var u = a[s];
                    u.interpolation = e(u.interpolation, "LINEAR")
                }
            }
        }

        function o(i) {
            t(i.asset) || (i.asset = {});
            var n = i.asset;
            t(n.profile) && "string" != typeof n.profile || (n.profile = {});
            var r = n.profile;
            n.premultipliedAlpha = e(i.asset.premultipliedAlpha, !1), r.api = e(r.api, "WebGL"), r.version = e(r.version, "1.0.2"), n.version = e(i.version, "0.9")
        }

        function a(i) {
            t(i.buffers) || (i.buffers = {});
            var n = i.buffers;
            for (var r in n)if (n.hasOwnProperty(r)) {
                var o = n[r];
                o.type = e(o.type, "arraybuffer")
            }
        }

        function s(e) {
            t(e.bufferViews) || (e.bufferViews = {})
        }

        function u(e) {
            t(e.cameras) || (e.cameras = {})
        }

        function l(e) {
            t(e.images) || (e.images = {})
        }

        function c(i) {
            t(i.lights) || (i.lights = {});
            var n = i.lights;
            for (var r in n)if (n.hasOwnProperty(r)) {
                var o = n[r];
                if ("ambient" === o.type) {
                    t(o.ambient) || (o.ambient = {});
                    var a = o.ambient;
                    t(a.color) || (a.color = [1, 1, 1])
                } else if ("directional" === o.type) {
                    t(o.directional) || (o.directional = {});
                    var s = o.directional;
                    t(s.color) || (s.color = [1, 1, 1])
                } else if ("point" === o.type) {
                    t(o.point) || (o.point = {});
                    var u = o.point;
                    t(u.color) || (u.color = [1, 1, 1]), u.constantAttenuation = e(u.constantAttenuation, 1), u.linearAttenuation = e(u.linearAttenuation, 0), u.quadraticAttenuation = e(u.quadraticAttenuation, 0)
                } else if ("spot" === o.type) {
                    t(o.spot) || (o.spot = {});
                    var l = o.spot;
                    t(l.color) || (l.color = [1, 1, 1]), l.constantAttenuation = e(l.constantAttenuation, 1), l.fallOffAngle = e(l.fallOffAngle, 3.14159265), l.fallOffExponent = e(l.fallOffExponent, 0), l.linearAttenuation = e(l.linearAttenuation, 0), l.quadraticAttenuation = e(l.quadraticAttenuation, 0)
                }
            }
        }

        function h(e) {
            t(e.materials) || (e.materials = {});
            var i = e.materials;
            for (var n in i)if (i.hasOwnProperty(n)) {
                var r = i[n].instanceTechnique;
                t(r.values) || (r.values = {})
            }
        }

        function d(n) {
            t(n.meshes) || (n.meshes = {});
            var r = n.meshes;
            for (var o in r)if (r.hasOwnProperty(o)) {
                var a = r[o];
                t(a.primitives) || (a.primitives = []);
                for (var s = a.primitives.length, u = s.length, l = 0; u > l; ++l) {
                    var c = s[l];
                    t(c.attributes) || (c.attributes = {});
                    var h = e(c.primitive, i.TRIANGLES);
                    c.mode = e(c.mode, h)
                }
            }
        }

        function m(e) {
            t(e.nodes) || (e.nodes = {});
            var i = e.nodes;
            for (var n in i)if (i.hasOwnProperty(n)) {
                var r = i[n];
                t(r.children) || (r.children = []), t(r.matrix) || (t(r.translation) && t(r.rotation) && t(r.scale) ? (t(r.translation) || (r.translation = [0, 0, 0]), t(r.rotation) || (r.rotation = [1, 0, 0, 0]), t(r.scale) || (r.scale = [1, 1, 1])) : r.matrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
            }
        }

        function p(e) {
            t(e.programs) || (e.programs = {});
            var i = e.programs;
            for (var n in i)if (i.hasOwnProperty(n)) {
                var r = i[n];
                t(r.attributes) || (r.attributes = [])
            }
        }

        function f(n) {
            t(n.samplers) || (n.samplers = {});
            var r = n.samplers;
            for (var o in r)if (r.hasOwnProperty(o)) {
                var a = r[o];
                a.magFilter = e(a.magFilter, i.LINEAR), a.minFilter = e(a.minFilter, i.NEAREST_MIPMAP_LINEAR), a.wrapS = e(a.wrapS, i.REPEAT), a.wrapT = e(a.wrapT, i.REPEAT)
            }
        }

        function _(e) {
            t(e.scenes) || (e.scenes = {});
            var i = e.scenes;
            for (var n in i)if (i.hasOwnProperty(n)) {
                var r = i[n];
                t(r.node) || (r.node = [])
            }
        }

        function v(e) {
            t(e.shaders) || (e.shaders = {})
        }

        function g(e) {
            t(e.skins) || (e.skins = {});
            var i = e.skins;
            for (var n in i)if (i.hasOwnProperty(n)) {
                var r = i[n];
                t(r.bindShapeMatrix) && (r.bindShapeMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
            }
        }

        function y(e) {
            t(e.enable) || (e.enable = []), t(e.disable) || (e.disable = [])
        }

        function C(e) {
            t(e.techniques) || (e.techniques = {});
            var i = e.techniques;
            for (var n in i)if (i.hasOwnProperty(n)) {
                var r = i[n];
                t(r.parameters) || (r.parameters = {});
                var o = r.passes;
                for (var a in o)if (o.hasOwnProperty(a)) {
                    var s = o[a], u = s.instanceProgram;
                    t(u.attributes) || (u.attributes = {}), t(u.uniforms) || (u.uniforms = {}), t(s.states) || (s.states = {}), y(s.states)
                }
            }
        }

        function E(n) {
            t(n.textures) || (n.textures = {});
            var r = n.textures;
            for (var o in r)if (r.hasOwnProperty(o)) {
                var a = r[o];
                a.format = e(a.format, i.RGBA), a.internalFormat = e(a.internalFormat, a.format), a.target = e(a.target, i.TEXTURE_2D), a.type = e(a.type, i.UNSIGNED_BYTE)
            }
        }

        var S = function (e) {
            return t(e) ? (t(e.allExtensions) || (e.allExtensions = []), n(e), r(e), o(e), a(e), s(e), u(e), l(e), c(e), h(e), d(e), m(e), p(e), f(e), _(e), v(e), g(e), C(e), E(e), e) : void 0
        };
        return S
    }),define("Cesium/ThirdParty/o3dgc", [], function () {
        "use strict";
        function e() {
            var e, t, i;
            return t = new ArrayBuffer(4), e = new Uint32Array(t), i = new Uint8Array(t), e[0] = 1, 1 === i[0] ? l.O3DGC_LITTLE_ENDIAN : l.O3DGC_BIG_ENDIAN
        }

        function t(e, t, i, n) {
            var r, o, a, s, u, c, h;
            for (r = -1, o = !1, s = t.m_value, u = 0, a = u; s > a; ++a) {
                if (e.Equal(i[a].m_id)) {
                    o = !0;
                    break
                }
                if (e.Less(i[a].m_id)) {
                    for (t.m_value < l.O3DGC_SC3DMC_MAX_PREDICTION_NEIGHBORS && ++t.m_value, c = t.m_value - 1; c > a; --c)for (i[c].m_id.m_a = i[c - 1].m_id.m_a, i[c].m_id.m_b = i[c - 1].m_id.m_b, i[c].m_id.m_c = i[c - 1].m_id.m_c, h = 0; n > h; ++h)i[c].m_pred[h] = i[c - 1].m_pred[h];
                    i[a].m_id.m_a = e.m_a, i[a].m_id.m_b = e.m_b, i[a].m_id.m_c = e.m_c, r = a, o = !0;
                    break
                }
            }
            return !o && t.m_value < l.O3DGC_SC3DMC_MAX_PREDICTION_NEIGHBORS && (r = t.m_value++, i[r].m_id.m_a = e.m_a, i[r].m_id.m_b = e.m_b, i[r].m_id.m_c = e.m_c), r
        }

        function i(e, t) {
            var i, n, r;
            i = Math.abs(e.m_x), n = Math.abs(e.m_y), r = Math.abs(e.m_z), r >= i && r >= n ? e.m_z >= 0 ? (t.m_z = 0, t.m_x = e.m_x, t.m_y = e.m_y) : (t.m_z = 1, t.m_x = -e.m_x, t.m_y = -e.m_y) : n >= i && n >= r ? e.m_y >= 0 ? (t.m_z = 2, t.m_x = e.m_z, t.m_y = e.m_x) : (t.m_z = 3, t.m_x = -e.m_z, t.m_y = -e.m_x) : e.m_x >= 0 ? (t.m_z = 4, t.m_x = e.m_y, t.m_y = e.m_z) : (t.m_z = 5, t.m_x = -e.m_y, t.m_y = -e.m_z)
        }

        function n(e) {
            return 0 > e ? -1 - 2 * e : 2 * e
        }

        function r(e) {
            return 1 & e ? -(e + 1 >>> 1) : e >>> 1
        }

        function o(e, i, n, r, o, a, s, l) {
            var c, h, d, m, p, f;
            for (f = new u.SC3DMCTriplet(-1, -1, -1), h = 0; 3 > h; ++h)if (m = e[3 * i + h], n > m && (f.m_a = -1, f.m_b = -1, f.m_c = m, d = t(f, r, o, a), -1 !== d))for (c = m * l, p = 0; a > p; ++p)o[d].m_pred[p] = s[c + p]
        }

        function a(e, i, n, r, o, a, s, l, c, h) {
            var d, m, p, f, _, v, g, y, C, E, S, T, b, w, x, A, P, I;
            if (d = 3 * i, I = new u.SC3DMCTriplet(-1, -1, -1), e[d] === n ? (v = e[d + 1], g = e[d + 2]) : e[d + 1] === n ? (v = e[d], g = e[d + 2]) : (v = e[d], g = e[d + 1]), n > v && n > g)for (T = c.Begin(v), b = c.End(v), w = T; b > w && (x = h[w], !(0 > x)); ++w) {
                for (m = 3 * x, y = -1, A = !1, S = 0; 3 > S; ++S)C = e[m + S], C === g ? A = !0 : n > C && C !== v && (y = C);
                if (-1 !== y && A && (g > v ? (I.m_a = v, I.m_b = g) : (I.m_a = g, I.m_b = v), I.m_c = -y - 1, P = t(I, r, o, a), -1 !== P))for (p = v * l, f = g * l, _ = y * l, E = 0; a > E; ++E)o[P].m_pred[E] = s[p + E] + s[f + E] - s[_ + E]
            }
        }

        function s(e, t, i, n, r) {
            var o, a, s, l, c, h, d, m, p, f;
            for (f = new u.Vec3, m = new u.Vec3, p = new u.Vec3, s = 3 * n, a = 0; s > a; ++a)r[a] = 0;
            for (l = 0; t > l; ++l)o = 3 * l, c = 3 * e[o], h = 3 * e[o + 1], d = 3 * e[o + 2], m.m_x = i[h] - i[c], m.m_y = i[h + 1] - i[c + 1], m.m_z = i[h + 2] - i[c + 2], p.m_x = i[d] - i[c], p.m_y = i[d + 1] - i[c + 1], p.m_z = i[d + 2] - i[c + 2], f.m_x = m.m_y * p.m_z - m.m_z * p.m_y, f.m_y = m.m_z * p.m_x - m.m_x * p.m_z, f.m_z = m.m_x * p.m_y - m.m_y * p.m_x, r[c] += f.m_x, r[c + 1] += f.m_y, r[c + 2] += f.m_z, r[h] += f.m_x, r[h + 1] += f.m_y, r[h + 2] += f.m_z, r[d] += f.m_x, r[d + 1] += f.m_y, r[d + 2] += f.m_z
        }

        var u, l;
        u = {}, l = {}, l.O3DGC_BINARY_STREAM_BITS_PER_SYMBOL0 = 7, l.O3DGC_BINARY_STREAM_MAX_SYMBOL0 = 127, l.O3DGC_BINARY_STREAM_BITS_PER_SYMBOL1 = 6, l.O3DGC_BINARY_STREAM_MAX_SYMBOL1 = 63, l.O3DGC_BINARY_STREAM_NUM_SYMBOLS_UINT32 = 5, l.O3DGC_BIG_ENDIAN = 0, l.O3DGC_LITTLE_ENDIAN = 1, l.O3DGC_MAX_DOUBLE = 1.79769e308, l.O3DGC_MIN_LONG = -2147483647, l.O3DGC_MAX_LONG = 2147483647, l.O3DGC_MAX_UCHAR8 = 255, l.O3DGC_MAX_TFAN_SIZE = 256, l.O3DGC_MAX_ULONG = 4294967295, l.O3DGC_SC3DMC_START_CODE = 497, l.O3DGC_DV_START_CODE = 498, l.O3DGC_SC3DMC_MAX_NUM_FLOAT_ATTRIBUTES = 256, l.O3DGC_SC3DMC_MAX_NUM_INT_ATTRIBUTES = 256, l.O3DGC_SC3DMC_MAX_DIM_ATTRIBUTES = 32, l.O3DGC_SC3DMC_MAX_PREDICTION_NEIGHBORS = 2, l.O3DGC_SC3DMC_BINARIZATION_FL = 0, l.O3DGC_SC3DMC_BINARIZATION_BP = 1, l.O3DGC_SC3DMC_BINARIZATION_FC = 2, l.O3DGC_SC3DMC_BINARIZATION_AC = 3, l.O3DGC_SC3DMC_BINARIZATION_AC_EGC = 4, l.O3DGC_SC3DMC_BINARIZATION_ASCII = 5, l.O3DGC_STREAM_TYPE_UNKOWN = 0, l.O3DGC_STREAM_TYPE_ASCII = 1, l.O3DGC_STREAM_TYPE_BINARY = 2, l.O3DGC_SC3DMC_NO_PREDICTION = 0, l.O3DGC_SC3DMC_DIFFERENTIAL_PREDICTION = 1, l.O3DGC_SC3DMC_XOR_PREDICTION = 2, l.O3DGC_SC3DMC_ADAPTIVE_DIFFERENTIAL_PREDICTION = 3, l.O3DGC_SC3DMC_CIRCULAR_DIFFERENTIAL_PREDICTION = 4, l.O3DGC_SC3DMC_PARALLELOGRAM_PREDICTION = 5, l.O3DGC_SC3DMC_SURF_NORMALS_PREDICTION = 6, l.O3DGC_SC3DMC_ENCODE_MODE_QBCR = 0, l.O3DGC_SC3DMC_ENCODE_MODE_SVA = 1, l.O3DGC_SC3DMC_ENCODE_MODE_TFAN = 2, l.O3DGC_DYNAMIC_VECTOR_ENCODE_MODE_LIFT = 0, l.O3DGC_MIN_NEIGHBORS_SIZE = 128, l.O3DGC_MIN_NUM_NEIGHBORS_SIZE = 16, l.O3DGC_TFANS_MIN_SIZE_ALLOCATED_VERTICES_BUFFER = 128, l.O3DGC_TFANS_MIN_SIZE_TFAN_SIZE_BUFFER = 8, l.O3DGC_DEFAULT_VECTOR_SIZE = 32, u.O3DGC_IFS_FLOAT_ATTRIBUTE_TYPE_UNKOWN = 0, u.O3DGC_IFS_FLOAT_ATTRIBUTE_TYPE_POSITION = 1, u.O3DGC_IFS_FLOAT_ATTRIBUTE_TYPE_NORMAL = 2, u.O3DGC_IFS_FLOAT_ATTRIBUTE_TYPE_COLOR = 3, u.O3DGC_IFS_FLOAT_ATTRIBUTE_TYPE_TEXCOORD = 4, u.O3DGC_IFS_FLOAT_ATTRIBUTE_TYPE_WEIGHT = 5, u.O3DGC_IFS_INT_ATTRIBUTE_TYPE_UNKOWN = 0, u.O3DGC_IFS_INT_ATTRIBUTE_TYPE_INDEX = 1, u.O3DGC_IFS_INT_ATTRIBUTE_TYPE_JOINT_ID = 2, u.O3DGC_IFS_INT_ATTRIBUTE_TYPE_INDEX_BUFFER_ID = 3, u.O3DGC_OK = 0, u.O3DGC_ERROR_BUFFER_FULL = 1, u.O3DGC_ERROR_CORRUPTED_STREAM = 5, u.O3DGC_ERROR_NON_SUPPORTED_FEATURE = 6, u.O3DGC_ERROR_AC = 7, u.SC3DMCStats = function () {
            this.m_timeCoord = 0, this.m_timeNormal = 0, this.m_timeCoordIndex = 0, this.m_timeFloatAttribute = new Float32Array(l.O3DGC_SC3DMC_MAX_NUM_FLOAT_ATTRIBUTES), this.m_timeIntAttribute = new Float32Array(l.O3DGC_SC3DMC_MAX_NUM_INT_ATTRIBUTES), this.m_timeReorder = 0, this.m_streamSizeCoord = 0, this.m_streamSizeNormal = 0, this.m_streamSizeCoordIndex = 0, this.m_streamSizeFloatAttribute = new Uint32Array(l.O3DGC_SC3DMC_MAX_NUM_FLOAT_ATTRIBUTES), this.m_streamSizeIntAttribute = new Uint32Array(l.O3DGC_SC3DMC_MAX_NUM_INT_ATTRIBUTES)
        }, u.SC3DMCTriplet = function (e, t, i) {
            this.m_a = e, this.m_b = t, this.m_c = i
        }, u.SC3DMCTriplet.prototype.Less = function (e) {
            var t;
            return t = this.m_c !== e.m_c ? this.m_c < e.m_c : this.m_b !== e.m_b ? this.m_b < e.m_b : this.m_a < e.m_a
        }, u.SC3DMCTriplet.prototype.Equal = function (e) {
            return this.m_c === e.m_c && this.m_b === e.m_b && this.m_a === e.m_a
        }, u.SC3DMCPredictor = function () {
            this.m_id = new u.SC3DMCTriplet(-1, -1, -1), this.m_pred = new Float32Array(l.O3DGC_SC3DMC_MAX_DIM_ATTRIBUTES)
        };
        var c = function () {
            if ("undefined" != typeof performance && "undefined" != typeof performance.now)return function () {
                return performance.now()
            };
            var e = Date.now();
            return function () {
                return Date.now() - e
            }
        }();
        return u.Timer = function () {
            this.m_start = 0, this.m_end = 0
        }, u.Timer.prototype.Tic = function () {
            this.m_start = c()
        }, u.Timer.prototype.Toc = function () {
            this.m_end = c()
        }, u.Timer.prototype.GetElapsedTime = function () {
            return this.m_end - this.m_start;
        }, u.Vec3 = function (e, t, i) {
            this.m_x = e, this.m_y = t, this.m_z = i
        }, u.Vec3.prototype.Set = function (e, t, i) {
            this.m_x = e, this.m_y = t, this.m_z = i
        }, u.Vec3.prototype.Sub = function (e, t) {
            this.m_x = e.m_x - t.m_x, this.m_y = e.m_y - t.m_y, this.m_z = e.m_z - t.m_z
        }, u.Vec3.prototype.Add = function (e, t) {
            this.m_x = e.m_x + t.m_x, this.m_y = e.m_y + t.m_y, this.m_z = e.m_z + t.m_z
        }, u.Vec3.prototype.SelfAdd = function (e) {
            this.m_x += e.m_x, this.m_y += e.m_y, this.m_z += e.m_z
        }, u.Vec3.prototype.Cross = function (e, t) {
            this.m_x = e.m_y * t.m_z - e.m_z * t.m_y, this.m_y = e.m_z * t.m_x - e.m_x * t.m_z, this.m_z = e.m_x * t.m_y - e.m_y * t.m_x
        }, u.Vec3.prototype.GetNorm = function () {
            return Math.sqrt(this.m_x * this.m_x + this.m_y * this.m_y + this.m_z * this.m_z)
        }, l.CubeToSphere = {
            0: function (e, t) {
                t.m_x = e.m_x, t.m_y = e.m_y, t.m_z = Math.sqrt(Math.max(0, 1 - t.m_x * t.m_x - t.m_y * t.m_y))
            }, 1: function (e, t) {
                t.m_x = -e.m_x, t.m_y = -e.m_y, t.m_z = -Math.sqrt(Math.max(0, 1 - t.m_x * t.m_x - t.m_y * t.m_y))
            }, 2: function (e, t) {
                t.m_z = e.m_x, t.m_x = e.m_y, t.m_y = Math.sqrt(Math.max(0, 1 - t.m_x * t.m_x - t.m_z * t.m_z))
            }, 3: function (e, t) {
                t.m_z = -e.m_x, t.m_x = -e.m_y, t.m_y = -Math.sqrt(Math.max(0, 1 - t.m_x * t.m_x - t.m_z * t.m_z))
            }, 4: function (e, t) {
                t.m_y = e.m_x, t.m_z = e.m_y, t.m_x = Math.sqrt(Math.max(0, 1 - t.m_y * t.m_y - t.m_z * t.m_z))
            }, 5: function (e, t) {
                t.m_y = -e.m_x, t.m_z = -e.m_y, t.m_x = -Math.sqrt(Math.max(0, 1 - t.m_y * t.m_y - t.m_z * t.m_z))
            }
        }, u.Iterator = function () {
            this.m_count = 0
        }, u.NumberRef = function () {
            this.m_value = 0
        }, u.BinaryStream = function (t) {
            this.m_endianness = e(), this.m_buffer = t, this.m_stream = new Uint8Array(this.m_buffer), this.m_localBuffer = new ArrayBuffer(4), this.m_localBufferViewUChar8 = new Uint8Array(this.m_localBuffer), this.m_localBufferViewFloat32 = new Float32Array(this.m_localBuffer), this.m_localBufferViewUInt32 = new Uint32Array(this.m_localBuffer)
        }, u.BinaryStream.prototype.ReadFloat32Bin = function (e) {
            return this.m_endianness === l.O3DGC_BIG_ENDIAN ? (this.m_localBufferViewUChar8[3] = this.m_stream[e.m_count++], this.m_localBufferViewUChar8[2] = this.m_stream[e.m_count++], this.m_localBufferViewUChar8[1] = this.m_stream[e.m_count++], this.m_localBufferViewUChar8[0] = this.m_stream[e.m_count++]) : (this.m_localBufferViewUChar8[0] = this.m_stream[e.m_count++], this.m_localBufferViewUChar8[1] = this.m_stream[e.m_count++], this.m_localBufferViewUChar8[2] = this.m_stream[e.m_count++], this.m_localBufferViewUChar8[3] = this.m_stream[e.m_count++]), this.m_localBufferViewFloat32[0]
        }, u.BinaryStream.prototype.ReadUInt32Bin = function (e) {
            return this.m_endianness === l.O3DGC_BIG_ENDIAN ? (this.m_localBufferViewUChar8[3] = this.m_stream[e.m_count++], this.m_localBufferViewUChar8[2] = this.m_stream[e.m_count++], this.m_localBufferViewUChar8[1] = this.m_stream[e.m_count++], this.m_localBufferViewUChar8[0] = this.m_stream[e.m_count++]) : (this.m_localBufferViewUChar8[0] = this.m_stream[e.m_count++], this.m_localBufferViewUChar8[1] = this.m_stream[e.m_count++], this.m_localBufferViewUChar8[2] = this.m_stream[e.m_count++], this.m_localBufferViewUChar8[3] = this.m_stream[e.m_count++]), this.m_localBufferViewUInt32[0]
        }, u.BinaryStream.prototype.ReadUChar8Bin = function (e) {
            return this.m_stream[e.m_count++]
        }, u.BinaryStream.prototype.ReadUInt32ASCII = function (e) {
            var t, i, n;
            for (t = 0, i = 0, n = 0; n < l.O3DGC_BINARY_STREAM_NUM_SYMBOLS_UINT32; ++n)t += this.m_stream[e.m_count++] << i >>> 0, i += l.O3DGC_BINARY_STREAM_BITS_PER_SYMBOL0;
            return t
        }, u.BinaryStream.prototype.ReadFloat32ASCII = function (e) {
            var t = this.ReadUInt32ASCII(e);
            return this.m_endianness === l.O3DGC_BIG_ENDIAN ? (this.m_localBufferViewUChar8[3] = t & l.O3DGC_MAX_UCHAR8, t >>>= 8, this.m_localBufferViewUChar8[2] = t & l.O3DGC_MAX_UCHAR8, t >>>= 8, this.m_localBufferViewUChar8[1] = t & l.O3DGC_MAX_UCHAR8, t >>>= 8, this.m_localBufferViewUChar8[0] = t & l.O3DGC_MAX_UCHAR8) : (this.m_localBufferViewUChar8[0] = t & l.O3DGC_MAX_UCHAR8, t >>>= 8, this.m_localBufferViewUChar8[1] = t & l.O3DGC_MAX_UCHAR8, t >>>= 8, this.m_localBufferViewUChar8[2] = t & l.O3DGC_MAX_UCHAR8, t >>>= 8, this.m_localBufferViewUChar8[3] = t & l.O3DGC_MAX_UCHAR8), this.m_localBufferViewFloat32[0]
        }, u.BinaryStream.prototype.ReadIntASCII = function (e) {
            return r(this.ReadUIntASCII(e))
        }, u.BinaryStream.prototype.ReadUIntASCII = function (e) {
            var t, i, n;
            if (n = this.m_stream[e.m_count++], n === l.O3DGC_BINARY_STREAM_MAX_SYMBOL0) {
                t = 0;
                do i = this.m_stream[e.m_count++], n += i >>> 1 << t >>> 0, t += l.O3DGC_BINARY_STREAM_BITS_PER_SYMBOL1; while (1 & i)
            }
            return n
        }, u.BinaryStream.prototype.ReadUCharASCII = function (e) {
            return this.m_stream[e.m_count++]
        }, u.BinaryStream.prototype.ReadFloat32 = function (e, t) {
            return t === l.O3DGC_STREAM_TYPE_ASCII ? this.ReadFloat32ASCII(e) : this.ReadFloat32Bin(e)
        }, u.BinaryStream.prototype.ReadUInt32 = function (e, t) {
            return t === l.O3DGC_STREAM_TYPE_ASCII ? this.ReadUInt32ASCII(e) : this.ReadUInt32Bin(e)
        }, u.BinaryStream.prototype.ReadUChar = function (e, t) {
            return t === l.O3DGC_STREAM_TYPE_ASCII ? this.ReadUCharASCII(e) : this.ReadUChar8Bin(e)
        }, u.BinaryStream.prototype.GetBuffer = function (e, t) {
            return new Uint8Array(this.m_buffer, e.m_count, t)
        }, l.O3DGC_AC_MIN_LENGTH = 16777216, l.O3DGC_AC_MAX_LENGTH = 4294967295, l.O3DGC_AC_BM_LENGTH_SHIFT = 13, l.O3DGC_AC_BM_MAX_COUNT = 1 << l.O3DGC_AC_BM_LENGTH_SHIFT >>> 0, l.O3DGC_AC_DM_LENGTH_SHIFT = 15, l.O3DGC_AC_DM_MAX_COUNT = 1 << l.O3DGC_AC_DM_LENGTH_SHIFT >>> 0, u.StaticBitModel = function () {
            this.m_bit0Prob = 1 << l.O3DGC_AC_BM_LENGTH_SHIFT - 1 >>> 0
        }, u.StaticBitModel.prototype.SetProbability = function (e) {
            this.m_bit0Prob = Math.floor(e * (1 << l.O3DGC_AC_BM_LENGTH_SHIFT >>> 0))
        }, u.AdaptiveBitModel = function () {
            this.m_updateCycle = 4, this.m_bitsUntilUpdate = 4, this.m_bit0Prob = 1 << l.O3DGC_AC_BM_LENGTH_SHIFT - 1 >>> 0, this.m_bit0Count = 1, this.m_bitCount = 2
        }, u.AdaptiveBitModel.prototype.Reset = function () {
            this.m_updateCycle = 4, this.m_bitsUntilUpdate = 4, this.m_bit0Prob = 1 << l.O3DGC_AC_BM_LENGTH_SHIFT - 1 >>> 0, this.m_bit0Count = 1, this.m_bitCount = 2
        }, u.AdaptiveBitModel.prototype.Update = function () {
            (this.m_bitCount += this.m_updateCycle) > l.O3DGC_AC_BM_MAX_COUNT && (this.m_bitCount = this.m_bitCount + 1 >>> 1, this.m_bit0Count = this.m_bit0Count + 1 >>> 1, this.m_bit0Count === this.m_bitCount && ++this.m_bitCount);
            var e = Math.floor(2147483648 / this.m_bitCount);
            this.m_bit0Prob = this.m_bit0Count * e >>> 31 - l.O3DGC_AC_BM_LENGTH_SHIFT, this.m_updateCycle = 5 * this.m_updateCycle >>> 2, this.m_updateCycle > 64 && (this.m_updateCycle = 64), this.m_bitsUntilUpdate = this.m_updateCycle
        }, u.AdaptiveDataModel = function () {
            this.m_buffer = {}, this.m_distribution = {}, this.m_symbolCount = {}, this.m_decoderTable = {}, this.m_totalCount = 0, this.m_updateCycle = 0, this.m_symbolsUntilUpdate = 0, this.m_dataSymbols = 0, this.m_lastSymbol = 0, this.m_tableSize = 0, this.m_tableShift = 0
        }, u.AdaptiveDataModel.prototype.Update = function () {
            var e, t, i, n, r, o, a;
            if ((this.m_totalCount += this.m_updateCycle) > l.O3DGC_AC_DM_MAX_COUNT)for (this.m_totalCount = 0, e = 0; e < this.m_dataSymbols; ++e)this.m_totalCount += this.m_symbolCount[e] = this.m_symbolCount[e] + 1 >>> 1;
            if (t = 0, i = 0, n = Math.floor(2147483648 / this.m_totalCount), 0 === this.m_tableSize)for (r = 0; r < this.m_dataSymbols; ++r)this.m_distribution[r] = n * t >>> 31 - l.O3DGC_AC_DM_LENGTH_SHIFT, t += this.m_symbolCount[r]; else {
                for (r = 0; r < this.m_dataSymbols; ++r)for (this.m_distribution[r] = n * t >>> 31 - l.O3DGC_AC_DM_LENGTH_SHIFT, t += this.m_symbolCount[r], a = this.m_distribution[r] >>> this.m_tableShift; a > i;)this.m_decoderTable[++i] = r - 1;
                for (this.m_decoderTable[0] = 0; i <= this.m_tableSize;)this.m_decoderTable[++i] = this.m_dataSymbols - 1
            }
            this.m_updateCycle = 5 * this.m_updateCycle >>> 2, o = this.m_dataSymbols + 6 << 3 >>> 0, this.m_updateCycle > o && (this.m_updateCycle = o), this.m_symbolsUntilUpdate = this.m_updateCycle
        }, u.AdaptiveDataModel.prototype.Reset = function () {
            var e;
            if (0 !== this.m_dataSymbols) {
                for (this.m_totalCount = 0, this.m_updateCycle = this.m_dataSymbols, e = 0; e < this.m_dataSymbols; ++e)this.m_symbolCount[e] = 1;
                this.Update(), this.m_symbolsUntilUpdate = this.m_updateCycle = this.m_dataSymbols + 6 >>> 1
            }
        }, u.AdaptiveDataModel.prototype.SetAlphabet = function (e) {
            if (2 > e || e > 2048)return Console.log("invalid number of data symbols"), u.O3DGC_ERROR_AC;
            if (this.m_dataSymbols !== e)if (this.m_dataSymbols = e, this.m_lastSymbol = this.m_dataSymbols - 1, this.m_dataSymbols > 16) {
                for (var t = 3; this.m_dataSymbols > 1 << t + 2 >>> 0;)++t;
                this.m_tableSize = 1 << t >>> 0, this.m_tableShift = l.O3DGC_AC_DM_LENGTH_SHIFT - t, this.m_buffer = new ArrayBuffer(4 * (2 * this.m_dataSymbols + this.m_tableSize + 2)), this.m_distribution = new Uint32Array(this.m_buffer, 0, this.m_dataSymbols), this.m_symbolCount = new Uint32Array(this.m_buffer, 4 * this.m_dataSymbols, this.m_dataSymbols), this.m_decoderTable = new Uint32Array(this.m_buffer, 8 * this.m_dataSymbols, this.m_tableSize + 2)
            } else this.m_tableSize = this.m_tableShift = 0, this.m_buffer = new ArrayBuffer(8 * this.m_dataSymbols), this.m_distribution = new Uint32Array(this.m_buffer, 0, this.m_dataSymbols), this.m_symbolCount = new Uint32Array(this.m_buffer, 4 * this.m_dataSymbols, this.m_dataSymbols), this.m_decoderTable = {};
            return this.Reset(), u.O3DGC_OK
        }, u.ArithmeticDecoder = function () {
            this.m_codeBuffer = {}, this.m_acShift = 0, this.m_base = 0, this.m_value = 0, this.m_length = 0, this.m_bufferSize = 0, this.m_mode = 0
        }, u.ArithmeticDecoder.prototype.SetBuffer = function (e, t) {
            return 0 === e ? (Console.log("invalid codec buffer size"), u.O3DGC_ERROR_AC) : 0 !== this.m_mode ? (Console.log("cannot set buffer while encoding or decoding"), u.O3DGC_ERROR_AC) : (this.m_bufferSize = e, void(this.m_codeBuffer = t))
        }, u.ArithmeticDecoder.prototype.StartDecoder = function () {
            return 0 !== this.m_mode ? (Console.log("cannot start decoder"), u.O3DGC_ERROR_AC) : 0 === this.m_bufferSize ? (Console.log("no code buffer set"), u.O3DGC_ERROR_AC) : (this.m_mode = 2, this.m_length = l.O3DGC_AC_MAX_LENGTH, this.m_acShift = 3, void(this.m_value = (this.m_codeBuffer[0] << 24 | this.m_codeBuffer[1] << 16 | this.m_codeBuffer[2] << 8 | this.m_codeBuffer[3]) >>> 0))
        }, u.ArithmeticDecoder.prototype.StopDecoder = function () {
            return 2 !== this.m_mode ? (Console.log("invalid to stop decoder"), u.O3DGC_ERROR_AC) : void(this.m_mode = 0)
        }, u.ArithmeticDecoder.prototype.GetBit = function () {
            this.m_length >>>= 1;
            var e = this.m_value >= this.m_length;
            return e && (this.m_value -= this.m_length), this.m_length < l.O3DGC_AC_MIN_LENGTH && this.RenormDecInterval(), e
        }, u.ArithmeticDecoder.prototype.GetBits = function (e) {
            var t = Math.floor(this.m_value / (this.m_length >>>= e));
            return this.m_value -= this.m_length * t, this.m_length < l.O3DGC_AC_MIN_LENGTH && this.RenormDecInterval(), t
        }, u.ArithmeticDecoder.prototype.DecodeStaticBitModel = function (e) {
            var t, i;
            return t = e.m_bit0Prob * (this.m_length >>> l.O3DGC_AC_BM_LENGTH_SHIFT), i = this.m_value >= t, i ? (this.m_value -= t, this.m_length -= t) : this.m_length = t, this.m_length < l.O3DGC_AC_MIN_LENGTH && this.RenormDecInterval(), i
        }, u.ArithmeticDecoder.prototype.DecodeAdaptiveBitModel = function (e) {
            var t, i;
            return t = e.m_bit0Prob * (this.m_length >>> l.O3DGC_AC_BM_LENGTH_SHIFT), i = this.m_value >= t, i ? (this.m_value -= t, this.m_length -= t) : (this.m_length = t, ++e.m_bit0Count), this.m_length < l.O3DGC_AC_MIN_LENGTH && this.RenormDecInterval(), 0 === --e.m_bitsUntilUpdate && e.Update(), i
        }, u.ArithmeticDecoder.prototype.DecodeAdaptiveDataModel = function (e) {
            var t, i, n, r, o, a, s, u;
            if (r = this.m_length, e.m_tableSize > 0) {
                for (a = Math.floor(this.m_value / (this.m_length >>>= l.O3DGC_AC_DM_LENGTH_SHIFT)), o = a >>> e.m_tableShift, i = e.m_decoderTable[o], t = e.m_decoderTable[o + 1] + 1; t > i + 1;)u = i + t >>> 1, e.m_distribution[u] > a ? t = u : i = u;
                n = e.m_distribution[i] * this.m_length, i !== e.m_lastSymbol && (r = e.m_distribution[i + 1] * this.m_length)
            } else {
                n = i = 0, this.m_length >>>= l.O3DGC_AC_DM_LENGTH_SHIFT, u = (t = e.m_dataSymbols) >>> 1;
                do s = this.m_length * e.m_distribution[u], s > this.m_value ? (t = u, r = s) : (i = u, n = s); while ((u = i + t >>> 1) !== i)
            }
            return this.m_value -= n, this.m_length = r - n, this.m_length < l.O3DGC_AC_MIN_LENGTH && this.RenormDecInterval(), ++e.m_symbolCount[i], 0 === --e.m_symbolsUntilUpdate && e.Update(!1), i
        }, u.ArithmeticDecoder.prototype.ExpGolombDecode = function (e, t, i) {
            var n, r, o;
            n = 0, r = 0;
            do o = this.DecodeAdaptiveBitModel(i), o && (n += 1 << e >>> 0, e++); while (o);
            for (; e--;)this.DecodeStaticBitModel(t) && (r = (r | 1 << e) >>> 0);
            return n + r
        }, u.ArithmeticDecoder.prototype.RenormDecInterval = function () {
            do this.m_value = (this.m_value << 8 | this.m_codeBuffer[++this.m_acShift]) >>> 0, this.m_length = this.m_length << 8 >>> 0; while (this.m_length < l.O3DGC_AC_MIN_LENGTH)
        }, u.ArithmeticDecoder.prototype.DecodeIntACEGC = function (e, t, i, n, o) {
            var a = this.DecodeAdaptiveDataModel(e);
            return a === o && (a += this.ExpGolombDecode(n, t, i)), r(a)
        }, u.ArithmeticDecoder.prototype.DecodeUIntACEGC = function (e, t, i, n, r) {
            var o = this.DecodeAdaptiveDataModel(e);
            return o === r && (o += this.ExpGolombDecode(n, t, i)), o
        }, u.FIFO = function () {
            this.m_data = {}, this.m_allocated = 0, this.m_size = 0, this.m_start = 0, this.m_end = 0
        }, u.FIFO.prototype.Clear = function () {
            this.m_start = this.m_end = this.m_size = 0
        }, u.FIFO.prototype.GetAllocatedSize = function () {
            return this.m_allocated
        }, u.FIFO.prototype.GetSize = function () {
            return this.m_size
        }, u.FIFO.prototype.Allocate = function (e) {
            return e > this.m_allocated && (this.m_allocated = e, this.m_data = new Int32Array(this.m_allocated)), this.Clear(), u.O3DGC_OK
        }, u.FIFO.prototype.PopFirst = function () {
            --this.m_size;
            var e = this.m_start++;
            return this.m_start === this.m_allocated && (this.m_end = 0), this.m_data[e]
        }, u.FIFO.prototype.PushBack = function (e) {
            --this.m_size, this.m_data[this.m_end] = e, ++this.m_size, ++this.m_end, this.m_end === this.m_allocated && (this.m_end = 0)
        }, u.IndexedFaceSet = function () {
            this.m_nCoordIndex = 0, this.m_nCoord = 0, this.m_nNormal = 0, this.m_numFloatAttributes = 0, this.m_numIntAttributes = 0, this.m_creaseAngle = 30, this.m_ccw = !0, this.m_solid = !0, this.m_convex = !0, this.m_isTriangularMesh = !0, this.m_coordMin = new Float32Array(3), this.m_coordMax = new Float32Array(3), this.m_normalMin = new Float32Array(3), this.m_normalMax = new Float32Array(3), this.m_nFloatAttribute = new Uint32Array(l.O3DGC_SC3DMC_MAX_NUM_FLOAT_ATTRIBUTES), this.m_nIntAttribute = new Uint32Array(l.O3DGC_SC3DMC_MAX_NUM_INT_ATTRIBUTES), this.m_dimFloatAttribute = new Uint32Array(l.O3DGC_SC3DMC_MAX_NUM_FLOAT_ATTRIBUTES), this.m_dimIntAttribute = new Uint32Array(l.O3DGC_SC3DMC_MAX_NUM_INT_ATTRIBUTES), this.m_typeFloatAttribute = new Uint32Array(l.O3DGC_SC3DMC_MAX_NUM_FLOAT_ATTRIBUTES), this.m_typeIntAttribute = new Uint32Array(l.O3DGC_SC3DMC_MAX_NUM_INT_ATTRIBUTES), this.m_minFloatAttributeBuffer = new ArrayBuffer(4 * l.O3DGC_SC3DMC_MAX_NUM_FLOAT_ATTRIBUTES * l.O3DGC_SC3DMC_MAX_DIM_ATTRIBUTES), this.m_minFloatAttribute = new Float32Array(this.m_minFloatAttributeBuffer), this.m_maxFloatAttributeBuffer = new ArrayBuffer(4 * l.O3DGC_SC3DMC_MAX_NUM_FLOAT_ATTRIBUTES * l.O3DGC_SC3DMC_MAX_DIM_ATTRIBUTES), this.m_maxFloatAttribute = new Float32Array(this.m_maxFloatAttributeBuffer), this.m_coordIndex = {}, this.m_coord = {}, this.m_normal = {}, this.m_floatAttribute = [], this.m_intAttribute = []
        }, u.IndexedFaceSet.prototype.GetNCoordIndex = function () {
            return this.m_nCoordIndex
        }, u.IndexedFaceSet.prototype.GetNCoordIndex = function () {
            return this.m_nCoordIndex
        }, u.IndexedFaceSet.prototype.GetNCoord = function () {
            return this.m_nCoord
        }, u.IndexedFaceSet.prototype.GetNNormal = function () {
            return this.m_nNormal
        }, u.IndexedFaceSet.prototype.GetNFloatAttribute = function (e) {
            return this.m_nFloatAttribute[e]
        }, u.IndexedFaceSet.prototype.GetNIntAttribute = function (e) {
            return this.m_nIntAttribute[e]
        }, u.IndexedFaceSet.prototype.GetNumFloatAttributes = function () {
            return this.m_numFloatAttributes
        }, u.IndexedFaceSet.prototype.GetNumIntAttributes = function () {
            return this.m_numIntAttributes
        }, u.IndexedFaceSet.prototype.GetCoordMinArray = function () {
            return this.m_coordMin
        }, u.IndexedFaceSet.prototype.GetCoordMaxArray = function () {
            return this.m_coordMax
        }, u.IndexedFaceSet.prototype.GetNormalMinArray = function () {
            return this.m_normalMin
        }, u.IndexedFaceSet.prototype.GetNormalMaxArray = function () {
            return this.m_normalMax
        }, u.IndexedFaceSet.prototype.GetFloatAttributeMinArray = function (e) {
            return new Float32Array(this.m_minFloatAttributeBuffer, e * l.O3DGC_SC3DMC_MAX_DIM_ATTRIBUTES * 4, this.GetFloatAttributeDim(e))
        }, u.IndexedFaceSet.prototype.GetFloatAttributeMaxArray = function (e) {
            return new Float32Array(this.m_maxFloatAttributeBuffer, e * l.O3DGC_SC3DMC_MAX_DIM_ATTRIBUTES * 4, this.GetFloatAttributeDim(e))
        }, u.IndexedFaceSet.prototype.GetFloatAttributeDim = function (e) {
            return this.m_dimFloatAttribute[e]
        }, u.IndexedFaceSet.prototype.GetIntAttributeDim = function (e) {
            return this.m_dimIntAttribute[e]
        }, u.IndexedFaceSet.prototype.GetFloatAttributeType = function (e) {
            return this.m_typeFloatAttribute[e]
        }, u.IndexedFaceSet.prototype.GetIntAttributeType = function (e) {
            return this.m_typeIntAttribute[e]
        }, u.IndexedFaceSet.prototype.GetFloatAttributeMax = function (e, t) {
            return this.m_maxFloatAttribute[e * l.O3DGC_SC3DMC_MAX_DIM_ATTRIBUTES + t]
        }, u.IndexedFaceSet.prototype.GetCreaseAngle = function () {
            return this.m_creaseAngle
        }, u.IndexedFaceSet.prototype.GetCreaseAngle = function () {
            return this.m_creaseAngle
        }, u.IndexedFaceSet.prototype.GetCCW = function () {
            return this.m_ccw
        }, u.IndexedFaceSet.prototype.GetSolid = function () {
            return this.m_solid
        }, u.IndexedFaceSet.prototype.GetConvex = function () {
            return this.m_convex
        }, u.IndexedFaceSet.prototype.GetIsTriangularMesh = function () {
            return this.m_isTriangularMesh
        }, u.IndexedFaceSet.prototype.GetCoordIndex = function () {
            return this.m_coordIndex
        }, u.IndexedFaceSet.prototype.GetCoordIndex = function () {
            return this.m_coordIndex
        }, u.IndexedFaceSet.prototype.GetCoord = function () {
            return this.m_coord
        }, u.IndexedFaceSet.prototype.GetNormal = function () {
            return this.m_normal
        }, u.IndexedFaceSet.prototype.GetFloatAttribute = function (e) {
            return this.m_floatAttribute[e]
        }, u.IndexedFaceSet.prototype.GetIntAttribute = function (e) {
            return this.m_intAttribute[e]
        }, u.IndexedFaceSet.prototype.SetNCoordIndex = function (e) {
            this.m_nCoordIndex = e
        }, u.IndexedFaceSet.prototype.SetNNormalIndex = function (e) {
        }, u.IndexedFaceSet.prototype.SetNormalPerVertex = function (e) {
        }, u.IndexedFaceSet.prototype.SetNFloatAttributeIndex = function (e) {
        }, u.IndexedFaceSet.prototype.SetNIntAttributeIndex = function (e) {
        }, u.IndexedFaceSet.prototype.SetFloatAttributePerVertex = function (e) {
        }, u.IndexedFaceSet.prototype.SetIntAttributePerVertex = function (e) {
        },u.IndexedFaceSet.prototype.SetNCoord = function (e) {
            this.m_nCoord = e
        },u.IndexedFaceSet.prototype.SetNNormal = function (e) {
            this.m_nNormal = e
        },u.IndexedFaceSet.prototype.SetNumFloatAttributes = function (e) {
            this.m_numFloatAttributes = e
        },u.IndexedFaceSet.prototype.SetNumIntAttributes = function (e) {
            this.m_numIntAttributes = e
        },u.IndexedFaceSet.prototype.SetCreaseAngle = function (e) {
            this.m_creaseAngle = e
        },u.IndexedFaceSet.prototype.SetCCW = function (e) {
            this.m_ccw = e
        },u.IndexedFaceSet.prototype.SetSolid = function (e) {
            this.m_solid = e
        },u.IndexedFaceSet.prototype.SetConvex = function (e) {
            this.m_convex = e
        },u.IndexedFaceSet.prototype.SetIsTriangularMesh = function (e) {
            this.m_isTriangularMesh = e
        },u.IndexedFaceSet.prototype.SetCoordMin = function (e, t) {
            this.m_coordMin[e] = t
        },u.IndexedFaceSet.prototype.SetCoordMax = function (e, t) {
            this.m_coordMax[e] = t
        },u.IndexedFaceSet.prototype.SetNormalMin = function (e, t) {
            this.m_normalMin[e] = t
        },u.IndexedFaceSet.prototype.SetNormalMax = function (e, t) {
            this.m_normalMax[e] = t
        },u.IndexedFaceSet.prototype.SetNFloatAttribute = function (e, t) {
            this.m_nFloatAttribute[e] = t
        },u.IndexedFaceSet.prototype.SetNIntAttribute = function (e, t) {
            this.m_nIntAttribute[e] = t
        },u.IndexedFaceSet.prototype.SetFloatAttributeDim = function (e, t) {
            this.m_dimFloatAttribute[e] = t
        },u.IndexedFaceSet.prototype.SetIntAttributeDim = function (e, t) {
            this.m_dimIntAttribute[e] = t
        },u.IndexedFaceSet.prototype.SetFloatAttributeType = function (e, t) {
            this.m_typeFloatAttribute[e] = t
        },u.IndexedFaceSet.prototype.SetIntAttributeType = function (e, t) {
            this.m_typeIntAttribute[e] = t
        },u.IndexedFaceSet.prototype.SetFloatAttributeMin = function (e, t, i) {
            this.m_minFloatAttribute[e * l.O3DGC_SC3DMC_MAX_DIM_ATTRIBUTES + t] = i
        },u.IndexedFaceSet.prototype.SetFloatAttributeMax = function (e, t, i) {
            this.m_maxFloatAttribute[e * l.O3DGC_SC3DMC_MAX_DIM_ATTRIBUTES + t] = i
        },u.IndexedFaceSet.prototype.SetCoordIndex = function (e) {
            this.m_coordIndex = e
        },u.IndexedFaceSet.prototype.SetCoord = function (e) {
            this.m_coord = e
        },u.IndexedFaceSet.prototype.SetNormal = function (e) {
            this.m_normal = e
        },u.IndexedFaceSet.prototype.SetFloatAttribute = function (e, t) {
            this.m_floatAttribute[e] = t
        },u.IndexedFaceSet.prototype.SetIntAttribute = function (e, t) {
            this.m_intAttribute[e] = t
        },u.SC3DMCEncodeParams = function () {
            var e;
            for (this.m_numFloatAttributes = 0, this.m_numIntAttributes = 0, this.m_floatAttributeQuantBits = new Uint32Array(l.O3DGC_SC3DMC_MAX_NUM_FLOAT_ATTRIBUTES), this.m_floatAttributePredMode = new Uint32Array(l.O3DGC_SC3DMC_MAX_NUM_FLOAT_ATTRIBUTES), this.m_intAttributePredMode = new Uint32Array(l.O3DGC_SC3DMC_MAX_NUM_INT_ATTRIBUTES), this.m_encodeMode = l.O3DGC_SC3DMC_ENCODE_MODE_TFAN, this.m_streamTypeMode = l.O3DGC_STREAM_TYPE_ASCII, this.m_coordQuantBits = 14, this.m_normalQuantBits = 8, this.m_coordPredMode = l.O3DGC_SC3DMC_PARALLELOGRAM_PREDICTION, this.m_normalPredMode = l.O3DGC_SC3DMC_SURF_NORMALS_PREDICTION, e = 0; e < l.O3DGC_SC3DMC_MAX_NUM_FLOAT_ATTRIBUTES; ++e)this.m_floatAttributePredMode[e] = l.O3DGC_SC3DMC_PARALLELOGRAM_PREDICTION;
            for (e = 0; e < l.O3DGC_SC3DMC_MAX_NUM_INT_ATTRIBUTES; ++e)this.m_intAttributePredMode[e] = l.O3DGC_SC3DMC_DIFFERENTIAL_PREDICTION
        },u.SC3DMCEncodeParams.prototype.GetStreamType = function () {
            return this.m_streamTypeMode
        },u.SC3DMCEncodeParams.prototype.GetEncodeMode = function () {
            return this.m_encodeMode
        },u.SC3DMCEncodeParams.prototype.GetNumFloatAttributes = function () {
            return this.m_numFloatAttributes
        },u.SC3DMCEncodeParams.prototype.GetNumIntAttributes = function () {
            return this.m_numIntAttributes
        },u.SC3DMCEncodeParams.prototype.GetCoordQuantBits = function () {
            return this.m_coordQuantBits
        },u.SC3DMCEncodeParams.prototype.GetNormalQuantBits = function () {
            return this.m_normalQuantBits
        },u.SC3DMCEncodeParams.prototype.GetFloatAttributeQuantBits = function (e) {
            return this.m_floatAttributeQuantBits[e]
        },u.SC3DMCEncodeParams.prototype.GetCoordPredMode = function () {
            return this.m_coordPredMode
        },u.SC3DMCEncodeParams.prototype.GetNormalPredMode = function () {
            return this.m_normalPredMode
        },u.SC3DMCEncodeParams.prototype.GetFloatAttributePredMode = function (e) {
            return this.m_floatAttributePredMode[e]
        },u.SC3DMCEncodeParams.prototype.GetIntAttributePredMode = function (e) {
            return this.m_intAttributePredMode[e]
        },u.SC3DMCEncodeParams.prototype.GetCoordPredMode = function () {
            return this.m_coordPredMode
        },u.SC3DMCEncodeParams.prototype.GetNormalPredMode = function () {
            return this.m_normalPredMode
        },u.SC3DMCEncodeParams.prototype.GetFloatAttributePredMode = function (e) {
            return this.m_floatAttributePredMode[e]
        },u.SC3DMCEncodeParams.prototype.GetIntAttributePredMode = function (e) {
            return this.m_intAttributePredMode[e]
        },u.SC3DMCEncodeParams.prototype.SetStreamType = function (e) {
            this.m_streamTypeMode = e
        },u.SC3DMCEncodeParams.prototype.SetEncodeMode = function (e) {
            this.m_encodeMode = e
        },u.SC3DMCEncodeParams.prototype.SetNumFloatAttributes = function (e) {
            this.m_numFloatAttributes = e
        },u.SC3DMCEncodeParams.prototype.SetNumIntAttributes = function (e) {
            this.m_numIntAttributes = e
        },u.SC3DMCEncodeParams.prototype.SetCoordQuantBits = function (e) {
            this.m_coordQuantBits = e
        },u.SC3DMCEncodeParams.prototype.SetNormalQuantBits = function (e) {
            this.m_normalQuantBits = e
        },u.SC3DMCEncodeParams.prototype.SetFloatAttributeQuantBits = function (e, t) {
            this.m_floatAttributeQuantBits[e] = t
        },u.SC3DMCEncodeParams.prototype.SetCoordPredMode = function (e) {
            this.m_coordPredMode = e
        },u.SC3DMCEncodeParams.prototype.SetNormalPredMode = function (e) {
            this.m_normalPredMode = e
        },u.SC3DMCEncodeParams.prototype.SetFloatAttributePredMode = function (e, t) {
            this.m_floatAttributePredMode[e] = t
        },u.SC3DMCEncodeParams.prototype.SetIntAttributePredMode = function (e, t) {
            this.m_intAttributePredMode[e] = t
        },u.AdjacencyInfo = function () {
            this.m_neighborsSize = 0, this.m_numNeighborsSize = 0, this.m_numElements = 0, this.m_neighbors = {}, this.m_numNeighbors = {}
        },u.AdjacencyInfo.prototype.Allocate = function (e, t) {
            return this.m_numElements = e, t > this.m_neighborsSize && (this.m_neighborsSize = t, this.m_neighbors = new Int32Array(this.m_neighborsSize)), e > this.m_numNeighborsSize && (this.m_numNeighborsSize = e, this.m_numNeighbors = new Int32Array(this.m_numNeighborsSize)), u.O3DGC_OK
        },u.AdjacencyInfo.prototype.AllocateNumNeighborsArray = function (e) {
            return e > this.m_numNeighborsSize && (this.m_numNeighborsSize = e, this.m_numNeighbors = new Int32Array(this.m_numNeighborsSize)), this.m_numElements = e, u.O3DGC_OK
        },u.AdjacencyInfo.prototype.AllocateNeighborsArray = function () {
            var e;
            for (e = 1; e < this.m_numElements; ++e)this.m_numNeighbors[e] += this.m_numNeighbors[e - 1];
            return this.m_numNeighbors[this.m_numElements - 1] > this.m_neighborsSize && (this.m_neighborsSize = this.m_numNeighbors[this.m_numElements - 1], this.m_neighbors = new Int32Array(this.m_neighborsSize)), u.O3DGC_OK
        },u.AdjacencyInfo.prototype.ClearNumNeighborsArray = function () {
            var e;
            for (e = 0; e < this.m_numElements; ++e)this.m_numNeighbors[e] = 0;
            return u.O3DGC_OK
        },u.AdjacencyInfo.prototype.ClearNeighborsArray = function () {
            var e;
            for (e = 0; e < this.m_neighborsSize; ++e)this.m_neighbors[e] = -1;
            return u.O3DGC_OK
        },u.AdjacencyInfo.prototype.Begin = function (e) {
            return e > 0 ? this.m_numNeighbors[e - 1] : 0
        },u.AdjacencyInfo.prototype.End = function (e) {
            return this.m_numNeighbors[e]
        },u.AdjacencyInfo.prototype.AddNeighbor = function (e, t) {
            var i, n, r;
            for (n = this.Begin(e), r = this.End(e), i = n; r > i; ++i)if (-1 === this.m_neighbors[i])return this.m_neighbors[i] = t, u.O3DGC_OK;
            return u.O3DGC_ERROR_BUFFER_FULL
        },u.AdjacencyInfo.prototype.GetNeighbor = function (e) {
            return this.m_neighbors[e]
        },u.AdjacencyInfo.prototype.GetNumNeighbors = function (e) {
            return this.End(e) - this.Begin(e)
        },u.AdjacencyInfo.prototype.GetNumNeighborsBuffer = function () {
            return this.m_numNeighbors
        },u.AdjacencyInfo.prototype.GetNeighborsBuffer = function () {
            return this.m_neighbors
        },u.Vector = function () {
            this.m_data = {}, this.m_allocated = 0, this.m_size = 0
        },u.Vector.prototype.Clear = function () {
            this.m_size = 0
        },u.Vector.prototype.Get = function (e) {
            return this.m_data[e]
        },u.Vector.prototype.GetAllocatedSize = function () {
            return this.m_allocated
        },u.Vector.prototype.GetSize = function () {
            return this.m_size
        },u.Vector.prototype.GetBuffer = function () {
            return this.m_data
        },u.Vector.prototype.SetSize = function (e) {
            this.m_size = e
        },u.Vector.prototype.Allocate = function (e) {
            var t, i;
            if (e > this.m_allocated) {
                if (this.m_allocated = e, i = new Int32Array(this.m_allocated), this.m_size > 0)for (t = 0; t < this.m_size; ++t)i[t] = this.m_data[t];
                this.m_data = i
            }
        },u.Vector.prototype.PushBack = function (e) {
            var t, i;
            if (this.m_size === this.m_allocated) {
                if (this.m_allocated *= 2, this.m_allocated < l.O3DGC_DEFAULT_VECTOR_SIZE && (this.m_allocated = l.O3DGC_DEFAULT_VECTOR_SIZE), i = new Int32Array(this.m_allocated), this.m_size > 0)for (t = 0; t < this.m_size; ++t)i[t] = this.m_data[t];
                this.m_data = i
            }
            this.m_data[this.m_size++] = e
        },u.CompressedTriangleFans = function () {
            this.m_numTFANs = new u.Vector, this.m_degrees = new u.Vector, this.m_configs = new u.Vector, this.m_operations = new u.Vector, this.m_indices = new u.Vector, this.m_trianglesOrder = new u.Vector, this.m_streamType = l.O3DGC_STREAM_TYPE_UNKOWN
        },u.CompressedTriangleFans.prototype.GetStreamType = function () {
            return this.m_streamType
        },u.CompressedTriangleFans.prototype.SetStreamType = function (e) {
            this.m_streamType = e
        },u.CompressedTriangleFans.prototype.Clear = function () {
            return this.m_numTFANs.Clear(), this.m_degrees.Clear(), this.m_configs.Clear(), this.m_operations.Clear(), this.m_indices.Clear(), u.O3DGC_OK
        },u.CompressedTriangleFans.prototype.Allocate = function (e, t) {
            return this.m_numTFANs.Allocate(e), this.m_degrees.Allocate(2 * e), this.m_configs.Allocate(2 * e), this.m_operations.Allocate(2 * e), this.m_indices.Allocate(2 * e), this.m_trianglesOrder.Allocate(t), this.Clear(), u.O3DGC_OK
        },u.CompressedTriangleFans.prototype.PushNumTFans = function (e) {
            this.m_numTFANs.PushBack(e)
        },u.CompressedTriangleFans.prototype.ReadNumTFans = function (e) {
            return this.m_numTFANs.Get(e.m_count++)
        },u.CompressedTriangleFans.prototype.PushDegree = function (e) {
            this.m_degrees.PushBack(e)
        },u.CompressedTriangleFans.prototype.ReadDegree = function (e) {
            return this.m_degrees.Get(e.m_count++)
        },u.CompressedTriangleFans.prototype.PushConfig = function (e) {
            this.m_configs.PushBack(e)
        },u.CompressedTriangleFans.prototype.ReadConfig = function (e) {
            return this.m_configs.Get(e.m_count++)
        },u.CompressedTriangleFans.prototype.PushOperation = function (e) {
            this.m_operations.PushBack(e)
        },u.CompressedTriangleFans.prototype.ReadOperation = function (e) {
            return this.m_operations.Get(e.m_count++)
        },u.CompressedTriangleFans.prototype.PushIndex = function (e) {
            this.m_indices.PushBack(e)
        },u.CompressedTriangleFans.prototype.ReadIndex = function (e) {
            return this.m_indices.Get(e.m_count++)
        },u.CompressedTriangleFans.prototype.PushTriangleIndex = function (e) {
            this.m_trianglesOrder.PushBack(n(e))
        },u.CompressedTriangleFans.prototype.ReadTriangleIndex = function (e) {
            return r(this.m_trianglesOrder.Get(e.m_count++))
        },u.CompressedTriangleFans.prototype.LoadUIntData = function (e, t, i) {
            var n, r;
            for (t.ReadUInt32ASCII(i), n = t.ReadUInt32ASCII(i), e.Allocate(n), e.Clear(), r = 0; n > r; ++r)e.PushBack(t.ReadUIntASCII(i));
            return u.O3DGC_OK
        },u.CompressedTriangleFans.prototype.LoadIntData = function (e, t, i) {
            var n, r;
            for (t.ReadUInt32ASCII(i), n = t.ReadUInt32ASCII(i), e.Allocate(n), e.Clear(), r = 0; n > r; ++r)e.PushBack(t.ReadIntASCII(i));
            return u.O3DGC_OK
        },u.CompressedTriangleFans.prototype.LoadBinData = function (e, t, i) {
            var n, r, o, a;
            for (t.ReadUInt32ASCII(i), n = t.ReadUInt32ASCII(i), e.Allocate(n * l.O3DGC_BINARY_STREAM_BITS_PER_SYMBOL0), e.Clear(), o = 0; n > o;)for (r = t.ReadUCharASCII(i), a = 0; a < l.O3DGC_BINARY_STREAM_BITS_PER_SYMBOL0; ++a)e.PushBack(1 & r), r >>>= 1, ++o;
            return u.O3DGC_OK
        },u.CompressedTriangleFans.prototype.LoadUIntAC = function (e, t, i, n) {
            var r, o, a, s, l, c, h;
            if (r = i.ReadUInt32Bin(n) - 12, o = i.ReadUInt32Bin(n), 0 === o)return u.O3DGC_OK;
            for (a = i.ReadUInt32Bin(n), s = i.GetBuffer(n, r), n.m_count += r, e.Allocate(o), l = new u.ArithmeticDecoder, l.SetBuffer(r, s), l.StartDecoder(), c = new u.AdaptiveDataModel, c.SetAlphabet(t + 1), h = 0; o > h; ++h)e.PushBack(l.DecodeAdaptiveDataModel(c) + a);
            return u.O3DGC_OK
        },u.CompressedTriangleFans.prototype.LoadIntACEGC = function (e, t, i, n) {
            var r, o, a, s, c, h, d, m, p, f;
            if (r = i.ReadUInt32Bin(n) - 12, o = i.ReadUInt32Bin(n), 0 === o)return u.O3DGC_OK;
            for (a = i.ReadUInt32Bin(n) - l.O3DGC_MAX_LONG, s = i.GetBuffer(n, r), n.m_count += r, e.Allocate(o), c = new u.ArithmeticDecoder, c.SetBuffer(r, s), c.StartDecoder(), h = new u.AdaptiveDataModel, h.SetAlphabet(t + 2), d = new u.StaticBitModel, m = new u.AdaptiveBitModel, f = 0; o > f; ++f)p = c.DecodeAdaptiveDataModel(h), p === t && (p += c.ExpGolombDecode(0, d, m)), e.PushBack(p + a);
            return u.O3DGC_OK
        },u.CompressedTriangleFans.prototype.LoadBinAC = function (e, t, i) {
            var n, r, o, a, s, l;
            if (n = t.ReadUInt32Bin(i) - 8, r = t.ReadUInt32Bin(i), 0 === r)return u.O3DGC_OK;
            for (o = t.GetBuffer(i, n), i.m_count += n, e.Allocate(r), a = new u.ArithmeticDecoder, a.SetBuffer(n, o), a.StartDecoder(), s = new u.AdaptiveBitModel, l = 0; r > l; ++l)e.PushBack(a.DecodeAdaptiveBitModel(s));
            return u.O3DGC_OK
        },u.CompressedTriangleFans.prototype.Load = function (e, t, i, n) {
            return n === l.O3DGC_STREAM_TYPE_ASCII ? (this.LoadUIntData(this.m_numTFANs, e, t), this.LoadUIntData(this.m_degrees, e, t), this.LoadUIntData(this.m_configs, e, t), this.LoadBinData(this.m_operations, e, t), this.LoadIntData(this.m_indices, e, t), i && this.LoadUIntData(this.m_trianglesOrder, e, t)) : (this.LoadIntACEGC(this.m_numTFANs, 4, e, t), this.LoadIntACEGC(this.m_degrees, 16, e, t), this.LoadUIntAC(this.m_configs, 10, e, t), this.LoadBinAC(this.m_operations, e, t), this.LoadIntACEGC(this.m_indices, 8, e, t), i && this.LoadIntACEGC(this.m_trianglesOrder, 16, e, t)), u.O3DGC_OK
        },u.TriangleFans = function () {
            this.m_verticesAllocatedSize = 0, this.m_sizeTFANAllocatedSize = 0, this.m_numTFANs = 0, this.m_numVertices = 0, this.m_sizeTFAN = {}, this.m_vertices = {}
        },u.TriangleFans.prototype.Allocate = function (e, t) {
            return this.m_numTFANs = 0, this.m_numVertices = 0, this.m_verticesAllocatedSize < t && (this.m_verticesAllocatedSize = t, this.m_vertices = new Int32Array(this.m_verticesAllocatedSize)), this.m_sizeTFANAllocatedSize < e && (this.m_sizeTFANAllocatedSize = e, this.m_sizeTFAN = new Int32Array(this.m_sizeTFANAllocatedSize)), u.O3DGC_OK
        },u.TriangleFans.prototype.Clear = function () {
            return this.m_numTFANs = 0, this.m_numVertices = 0, u.O3DGC_OK
        },u.TriangleFans.prototype.AddVertex = function (e) {
            var t, i;
            if (++this.m_numVertices, this.m_numVertices > this.m_verticesAllocatedSize) {
                for (this.m_verticesAllocatedSize *= 2, i = new Int32Array(this.m_verticesAllocatedSize), t = 0; t < this.m_numVertices; ++t)i[t] = this.m_vertices[t];
                this.m_vertices = i
            }
            return this.m_vertices[this.m_numVertices - 1] = e, ++this.m_sizeTFAN[this.m_numTFANs - 1], u.O3DGC_OK
        },u.TriangleFans.prototype.AddTFAN = function () {
            var e, t;
            if (++this.m_numTFANs, this.m_numTFANs > this.m_sizeTFANAllocatedSize) {
                for (this.m_sizeTFANAllocatedSize *= 2, t = new Int32Array(this.m_sizeTFANAllocatedSize), e = 0; e < this.m_numTFANs; ++e)t[e] = this.m_sizeTFAN[e];
                this.m_sizeTFAN = t
            }
            return this.m_sizeTFAN[this.m_numTFANs - 1] = this.m_numTFANs > 1 ? this.m_sizeTFAN[this.m_numTFANs - 2] : 0, u.O3DGC_OK
        },u.TriangleFans.prototype.Begin = function (e) {
            return e > 0 ? this.m_sizeTFAN[e - 1] : 0
        },u.TriangleFans.prototype.End = function (e) {
            return this.m_sizeTFAN[e]
        },u.TriangleFans.prototype.GetVertex = function (e) {
            return this.m_vertices[e];
        },u.TriangleFans.prototype.GetTFANSize = function (e) {
            return this.End(e) - this.Begin(e)
        },u.TriangleFans.prototype.GetNumTFANs = function () {
            return this.m_numTFANs
        },u.TriangleFans.prototype.GetNumVertices = function () {
            return this.m_numVertices
        },u.TriangleListDecoder = function () {
            this.m_itNumTFans = new u.Iterator, this.m_itDegree = new u.Iterator, this.m_itConfig = new u.Iterator, this.m_itOperation = new u.Iterator, this.m_itIndex = new u.Iterator, this.m_maxNumVertices = 0, this.m_maxNumTriangles = 0, this.m_numTriangles = 0, this.m_numVertices = 0, this.m_tempTrianglesSize = 0, this.m_vertexCount = 0, this.m_triangleCount = 0, this.m_numConqueredTriangles = 0, this.m_numVisitedVertices = 0, this.m_triangles = {}, this.m_tempTriangles = {}, this.m_visitedVertices = {}, this.m_visitedVerticesValence = {}, this.m_vertexToTriangle = new u.AdjacencyInfo, this.m_ctfans = new u.CompressedTriangleFans, this.m_tfans = new u.TriangleFans, this.m_streamType = l.O3DGC_STREAM_TYPE_ASCII, this.m_decodeTrianglesOrder = !1, this.m_decodeVerticesOrder = !1, this.m_processConfig = {
                0: function (e, t) {
                    var i;
                    for (e.m_tfans.AddVertex(e.m_visitedVertices[0]), i = 1; t - 1 > i; ++i)e.m_visitedVertices[e.m_numVisitedVertices++] = e.m_vertexCount, e.m_tfans.AddVertex(e.m_vertexCount++);
                    e.m_tfans.AddVertex(e.m_visitedVertices[1])
                }, 1: function (e, t, i) {
                    var n, r, o;
                    for (e.m_tfans.AddVertex(e.m_visitedVertices[0]), n = 1; t - 1 > n; ++n)r = e.m_ctfans.ReadOperation(e.m_itOperation), 1 === r ? (o = e.m_ctfans.ReadIndex(e.m_itIndex), 0 > o ? e.m_tfans.AddVertex(e.m_visitedVertices[-o - 1]) : e.m_tfans.AddVertex(o + i)) : (e.m_visitedVertices[e.m_numVisitedVertices++] = e.m_vertexCount, e.m_tfans.AddVertex(e.m_vertexCount++));
                    e.m_tfans.AddVertex(e.m_visitedVertices[1])
                }, 2: function (e, t) {
                    var i;
                    for (i = 0; t - 1 > i; ++i)e.m_visitedVertices[e.m_numVisitedVertices++] = e.m_vertexCount, e.m_tfans.AddVertex(e.m_vertexCount++);
                    e.m_tfans.AddVertex(e.m_visitedVertices[0])
                }, 3: function (e, t) {
                    var i;
                    for (i = 0; t - 1 > i; ++i)e.m_visitedVertices[e.m_numVisitedVertices++] = e.m_vertexCount, e.m_tfans.AddVertex(e.m_vertexCount++);
                    e.m_tfans.AddVertex(e.m_visitedVertices[1])
                }, 4: function (e, t) {
                    var i;
                    for (e.m_tfans.AddVertex(e.m_visitedVertices[0]), i = 1; t > i; ++i)e.m_visitedVertices[e.m_numVisitedVertices++] = e.m_vertexCount, e.m_tfans.AddVertex(e.m_vertexCount++)
                }, 5: function (e, t) {
                    var i;
                    for (e.m_tfans.AddVertex(e.m_visitedVertices[1]), i = 1; t > i; ++i)e.m_visitedVertices[e.m_numVisitedVertices++] = e.m_vertexCount, e.m_tfans.AddVertex(e.m_vertexCount++)
                }, 6: function (e, t) {
                    var i;
                    for (i = 0; t > i; ++i)e.m_visitedVertices[e.m_numVisitedVertices++] = e.m_vertexCount, e.m_tfans.AddVertex(e.m_vertexCount++)
                }, 7: function (e, t) {
                    var i;
                    for (e.m_tfans.AddVertex(e.m_visitedVertices[1]), i = 1; t - 1 > i; ++i)e.m_visitedVertices[e.m_numVisitedVertices++] = e.m_vertexCount, e.m_tfans.AddVertex(e.m_vertexCount++);
                    e.m_tfans.AddVertex(e.m_visitedVertices[0])
                }, 8: function (e, t, i) {
                    var n, r, o;
                    for (e.m_tfans.AddVertex(e.m_visitedVertices[1]), n = 1; t - 1 > n; ++n)r = e.m_ctfans.ReadOperation(e.m_itOperation), 1 === r ? (o = e.m_ctfans.ReadIndex(e.m_itIndex), 0 > o ? e.m_tfans.AddVertex(e.m_visitedVertices[-o - 1]) : e.m_tfans.AddVertex(o + i)) : (e.m_visitedVertices[e.m_numVisitedVertices++] = e.m_vertexCount, e.m_tfans.AddVertex(e.m_vertexCount++));
                    e.m_tfans.AddVertex(e.m_visitedVertices[0])
                }, 9: function (e, t, i) {
                    var n, r, o;
                    for (n = 0; t > n; ++n)r = e.m_ctfans.ReadOperation(e.m_itOperation), 1 === r ? (o = e.m_ctfans.ReadIndex(e.m_itIndex), 0 > o ? e.m_tfans.AddVertex(e.m_visitedVertices[-o - 1]) : e.m_tfans.AddVertex(o + i)) : (e.m_visitedVertices[e.m_numVisitedVertices++] = e.m_vertexCount, e.m_tfans.AddVertex(e.m_vertexCount++))
                }
            }
        },u.TriangleListDecoder.prototype.GetStreamType = function () {
            return this.m_streamType
        },u.TriangleListDecoder.prototype.GetReorderTriangles = function () {
            return this.m_decodeTrianglesOrder
        },u.TriangleListDecoder.prototype.GetReorderVertices = function () {
            return this.m_decodeVerticesOrder
        },u.TriangleListDecoder.prototype.SetStreamType = function (e) {
            this.m_streamType = e
        },u.TriangleListDecoder.prototype.GetVertexToTriangle = function () {
            return this.m_vertexToTriangle
        },u.TriangleListDecoder.prototype.Reorder = function () {
            var e, t, i, n, o, a, s, l;
            if (this.m_decodeTrianglesOrder)for (e = this.m_triangles, t = this.m_numTriangles, i = this.m_ctfans.m_trianglesOrder.m_data, a = this.m_tempTriangles, a.set(e), n = 0, o = 0, l = 0; t > l; ++l)s = r(i[n++]) + o, e[3 * s] = a[3 * l], e[3 * s + 1] = a[3 * l + 1], e[3 * s + 2] = a[3 * l + 2], o = s + 1;
            return u.O3DGC_OK
        },u.TriangleListDecoder.prototype.CompueLocalConnectivityInfo = function (e) {
            var t, i, n, r, o, a, s, l, c, h, d, m, p, f, _, v, g, y, C;
            for (t = this.m_visitedVertices, i = this.m_visitedVerticesValence, n = this.m_triangles, r = this.m_vertexToTriangle, o = r.Begin(e), a = r.End(e), s = 0, c = 0, g = 0, d = o; g >= 0 && a > d; ++d)if (g = r.GetNeighbor(d), g >= 0)for (++s, y = 3 * g, p = 0; 3 > p; ++p)if (C = n[y + p], C > e) {
                for (l = !1, m = 0; c > m; ++m) {
                    if (C === t[m]) {
                        i[m]++, l = !0;
                        break
                    }
                    if (C < t[m]) {
                        for (++c, f = c - 1; f > m; --f)t[f] = t[f - 1], i[f] = i[f - 1];
                        t[m] = C, i[m] = 1, l = !0;
                        break
                    }
                }
                l || (t[c] = C, i[c] = 1, c++)
            }
            if (c > 2)for (_ = 1; c > _; ++_)if (1 === i[_])for (v = _; v > 0 && i[v] < i[v - 1];)h = i[v], i[v] = i[v - 1], i[v - 1] = h, h = t[v], t[v] = t[v - 1], t[v - 1] = h, --v;
            return this.m_numConqueredTriangles = s, this.m_numVisitedVertices = c, u.O3DGC_OK
        },u.TriangleListDecoder.prototype.DecompressTFAN = function (e) {
            var t, i, n, r, o, a, s, l, c, h, d, m, p, f, _, v, g, y, C;
            if (t = this.m_vertexToTriangle, i = this.m_triangles, n = this.m_itDegree, r = this.m_itConfig, o = this.m_tfans, s = this.m_processConfig, l = this.m_ctfans, c = this.m_triangleCount, h = this.m_numConqueredTriangles, a = l.ReadNumTFans(this.m_itNumTFans), a > 0)for (y = 0; a > y; ++y)for (o.AddTFAN(), d = l.ReadDegree(n) + 2 - h, m = l.ReadConfig(r), p = o.GetNumVertices(), o.AddVertex(e), s[m](this, d, e), f = o.GetNumVertices(), _ = o.GetVertex(p + 1), C = p + 2; f > C; ++C)v = o.GetVertex(C), g = 3 * c, i[g++] = e, i[g++] = _, i[g] = v, t.AddNeighbor(e, c), t.AddNeighbor(_, c), t.AddNeighbor(v, c), _ = v, c++;
            return this.m_triangleCount = c, u.O3DGC_OK
        },u.TriangleListDecoder.prototype.Decompress = function () {
            var e;
            for (e = 0; e < this.m_numVertices; ++e)e === this.m_vertexCount && this.m_vertexCount++, this.CompueLocalConnectivityInfo(e), this.DecompressTFAN(e);
            return u.O3DGC_OK
        },u.TriangleListDecoder.prototype.Init = function (e, t, i, n) {
            var r, o;
            for (this.m_numTriangles = t, this.m_numVertices = i, this.m_triangles = e, this.m_vertexCount = 0, this.m_triangleCount = 0, this.m_itNumTFans.m_count = 0, this.m_itDegree.m_count = 0, this.m_itConfig.m_count = 0, this.m_itOperation.m_count = 0, this.m_itIndex.m_count = 0, this.m_numVertices > this.m_maxNumVertices && (this.m_maxNumVertices = this.m_numVertices, this.m_visitedVerticesValence = new Int32Array(this.m_numVertices), this.m_visitedVertices = new Int32Array(this.m_numVertices)), this.m_decodeTrianglesOrder && this.m_tempTrianglesSize < this.m_numTriangles && (this.m_tempTrianglesSize = this.m_numTriangles, this.m_tempTriangles = new Int32Array(3 * this.m_tempTrianglesSize)), this.m_ctfans.SetStreamType(this.m_streamType), this.m_ctfans.Allocate(this.m_numVertices, this.m_numTriangles), this.m_tfans.Allocate(2 * this.m_numVertices, 8 * this.m_numVertices), this.m_vertexToTriangle.AllocateNumNeighborsArray(i), o = this.m_vertexToTriangle.GetNumNeighborsBuffer(), r = 0; i > r; ++r)o[r] = n;
            return this.m_vertexToTriangle.AllocateNeighborsArray(), this.m_vertexToTriangle.ClearNeighborsArray(), u.O3DGC_OK
        },u.TriangleListDecoder.prototype.Decode = function (e, t, i, n, r) {
            var o, a;
            return o = n.ReadUChar(r, this.m_streamType), this.m_decodeTrianglesOrder = 0 !== (2 & o), this.m_decodeVerticesOrder = 0 !== (1 & o), this.m_decodeVerticesOrder ? u.O3DGC_ERROR_NON_SUPPORTED_FEATURE : (a = n.ReadUInt32(r, this.m_streamType), this.Init(e, t, i, a), this.m_ctfans.Load(n, r, this.m_decodeTrianglesOrder, this.m_streamType), this.Decompress(), u.O3DGC_OK)
        },u.SC3DMCDecoder = function () {
            var e;
            for (this.m_iterator = new u.Iterator, this.m_streamSize = 0, this.m_params = new u.SC3DMCEncodeParams, this.m_triangleListDecoder = new u.TriangleListDecoder, this.m_quantFloatArray = {}, this.m_orientation = {}, this.m_normals = {}, this.m_quantFloatArraySize = 0, this.m_normalsSize = 0, this.m_orientationSize = 0, this.m_stats = new u.SC3DMCStats, this.m_streamType = l.O3DGC_STREAM_TYPE_UNKOWN, this.m_neighbors = [], this.m_idelta = new Float32Array(l.O3DGC_SC3DMC_MAX_DIM_ATTRIBUTES), this.m_minNormal = new Float32Array(2), this.m_maxNormal = new Float32Array(2), this.m_minNormal[0] = this.m_minNormal[1] = -2, this.m_maxNormal[0] = this.m_maxNormal[1] = 2, e = 0; e < l.O3DGC_SC3DMC_MAX_DIM_ATTRIBUTES; ++e)this.m_neighbors[e] = new u.SC3DMCPredictor
        },u.SC3DMCDecoder.prototype.GetStats = function () {
            return this.m_stats
        },u.SC3DMCDecoder.prototype.DecodeHeader = function (e, t) {
            var i, n, r, o, a, s;
            if (i = this.m_iterator.m_count, n = t.ReadUInt32(this.m_iterator, l.O3DGC_STREAM_TYPE_BINARY), n !== l.O3DGC_SC3DMC_START_CODE) {
                if (this.m_iterator.m_count = i, n = t.ReadUInt32(this.m_iterator, l.O3DGC_STREAM_TYPE_ASCII), n !== l.O3DGC_SC3DMC_START_CODE)return u.O3DGC_ERROR_CORRUPTED_STREAM;
                this.m_streamType = l.O3DGC_STREAM_TYPE_ASCII
            } else this.m_streamType = l.O3DGC_STREAM_TYPE_BINARY;
            if (this.m_streamSize = t.ReadUInt32(this.m_iterator, this.m_streamType), this.m_params.SetEncodeMode(t.ReadUChar(this.m_iterator, this.m_streamType)), e.SetCreaseAngle(t.ReadFloat32(this.m_iterator, this.m_streamType)), r = t.ReadUChar(this.m_iterator, this.m_streamType), e.SetCCW(1 === (1 & r)), e.SetSolid(1 === (2 & r)), e.SetConvex(1 === (4 & r)), e.SetIsTriangularMesh(1 === (8 & r)), e.SetNCoord(t.ReadUInt32(this.m_iterator, this.m_streamType)), e.SetNNormal(t.ReadUInt32(this.m_iterator, this.m_streamType)), e.SetNumFloatAttributes(t.ReadUInt32(this.m_iterator, this.m_streamType)), e.SetNumIntAttributes(t.ReadUInt32(this.m_iterator, this.m_streamType)), e.GetNCoord() > 0) {
                for (e.SetNCoordIndex(t.ReadUInt32(this.m_iterator, this.m_streamType)), o = 0; 3 > o; ++o)e.SetCoordMin(o, t.ReadFloat32(this.m_iterator, this.m_streamType)), e.SetCoordMax(o, t.ReadFloat32(this.m_iterator, this.m_streamType));
                this.m_params.SetCoordQuantBits(t.ReadUChar(this.m_iterator, this.m_streamType))
            }
            if (e.GetNNormal() > 0) {
                for (e.SetNNormalIndex(t.ReadUInt32(this.m_iterator, this.m_streamType)), o = 0; 3 > o; ++o)e.SetNormalMin(o, t.ReadFloat32(this.m_iterator, this.m_streamType)), e.SetNormalMax(o, t.ReadFloat32(this.m_iterator, this.m_streamType));
                e.SetNormalPerVertex(1 === t.ReadUChar(this.m_iterator, this.m_streamType)), this.m_params.SetNormalQuantBits(t.ReadUChar(this.m_iterator, this.m_streamType))
            }
            for (a = 0; a < e.GetNumFloatAttributes(); ++a)if (e.SetNFloatAttribute(a, t.ReadUInt32(this.m_iterator, this.m_streamType)), e.GetNFloatAttribute(a) > 0) {
                for (e.SetNFloatAttributeIndex(a, t.ReadUInt32(this.m_iterator, this.m_streamType)), s = t.ReadUChar(this.m_iterator, this.m_streamType), e.SetFloatAttributeDim(a, s), o = 0; s > o; ++o)e.SetFloatAttributeMin(a, o, t.ReadFloat32(this.m_iterator, this.m_streamType)), e.SetFloatAttributeMax(a, o, t.ReadFloat32(this.m_iterator, this.m_streamType));
                e.SetFloatAttributePerVertex(a, 1 === t.ReadUChar(this.m_iterator, this.m_streamType)), e.SetFloatAttributeType(a, t.ReadUChar(this.m_iterator, this.m_streamType)), this.m_params.SetFloatAttributeQuantBits(a, t.ReadUChar(this.m_iterator, this.m_streamType))
            }
            for (a = 0; a < e.GetNumIntAttributes(); ++a)e.SetNIntAttribute(a, t.ReadUInt32(this.m_iterator, this.m_streamType)), e.GetNIntAttribute(a) > 0 && (e.SetNIntAttributeIndex(a, t.ReadUInt32(this.m_iterator, this.m_streamType)), e.SetIntAttributeDim(a, t.ReadUChar(this.m_iterator, this.m_streamType)), e.SetIntAttributePerVertex(a, 1 === t.ReadUChar(this.m_iterator, this.m_streamType)), e.SetIntAttributeType(a, t.ReadUChar(this.m_iterator, this.m_streamType)));
            return u.O3DGC_OK
        },u.SC3DMCDecoder.prototype.DecodeIntArrayBinary = function (e, t, i, n, r, a, s) {
            var c, h, d, m, p, f, _, v, g, y, C, E, S, T, b, w, x, A, P, I, D, M, O, R, N, L, F, B, z, V, U, k;
            if (g = this.m_iterator, y = this.m_streamType, E = new u.ArithmeticDecoder, S = new u.StaticBitModel, T = new u.AdaptiveBitModel, b = new u.AdaptiveDataModel, b.SetAlphabet(l.O3DGC_SC3DMC_MAX_PREDICTION_NEIGHBORS + 1), w = this.m_triangleListDecoder.GetVertexToTriangle(), x = w.m_neighbors, A = r.GetCoordIndex(), P = t * i, I = g.m_count, D = s.ReadUInt32(g, y), M = s.ReadUChar(g, y), O = M >>> 4 & 7, a.m_value = 7 & M, D -= g.m_count - I, R = new u.Iterator, R.m_count = g.m_count + D, N = 0, L = 0, F = new u.SC3DMCTriplet(-1, -1, -1), O !== l.O3DGC_SC3DMC_BINARIZATION_AC_EGC)return u.O3DGC_ERROR_CORRUPTED_STREAM;
            for (v = s.GetBuffer(g, D), g.m_count += D, E.SetBuffer(D, v), E.StartDecoder(), N = E.ExpGolombDecode(0, S, T), L = E.ExpGolombDecode(0, S, T), B = new u.AdaptiveDataModel, B.SetAlphabet(L + 2), z = this.m_neighbors, V = this.m_normals, U = new u.NumberRef, c = a.m_value !== l.O3DGC_SC3DMC_NO_PREDICTION, k = 0; t > k; ++k) {
                if (U.m_value = 0, w.GetNumNeighbors(k) > 0 && c)for (f = w.Begin(k), _ = w.End(k), m = f; _ > m && (p = x[m], !(0 > p)); ++m)o(A, p, k, U, z, i, e, n);
                if (U.m_value > 1)for (h = E.DecodeAdaptiveDataModel(b), d = 0; i > d; ++d)C = E.DecodeIntACEGC(B, S, T, N, L), e[k * n + d] = C + z[h].m_pred[d]; else if (k > 0 && a.m_value !== l.O3DGC_SC3DMC_NO_PREDICTION)for (d = 0; i > d; ++d)C = E.DecodeIntACEGC(B, S, T, N, L), e[k * n + d] = C + e[(k - 1) * n + d]; else for (d = 0; i > d; ++d)C = E.DecodeUIntACEGC(B, S, T, N, L), e[k * n + d] = C
            }
            return g.m_count = R.m_count, u.O3DGC_OK
        },u.SC3DMCDecoder.prototype.DecodeIntArrayASCII = function (e, t, i, n, r, a, s) {
            var c, h, d, m, p, f, _, v, g, y, C, E, S, T, b, w, x, A, P, I, D, M, O, R;
            if (h = this.m_iterator, d = this.m_streamType, p = this.m_triangleListDecoder.GetVertexToTriangle(), f = p.m_neighbors, _ = r.GetCoordIndex(), v = t * i, g = h.m_count, y = s.ReadUInt32(h, d), C = s.ReadUChar(h, d), E = C >>> 4 & 7, a.m_value = 7 & C, y -= h.m_count - g, S = new u.Iterator, S.m_count = h.m_count + y, T = new u.SC3DMCTriplet(-1, -1, -1), E !== l.O3DGC_SC3DMC_BINARIZATION_ASCII)return u.O3DGC_ERROR_CORRUPTED_STREAM;
            for (s.ReadUInt32(S, d), b = this.m_neighbors, w = this.m_normals, x = new u.NumberRef, c = a.m_value !== l.O3DGC_SC3DMC_NO_PREDICTION, A = 0; t > A; ++A) {
                if (x.m_value = 0, p.GetNumNeighbors(A) > 0 && c)for (P = p.Begin(A), I = p.End(A), D = P; I > D && (M = f[D], !(0 > M)); ++D)o(_, M, A, x, b, i, e, n);
                if (x.m_value > 1)for (R = s.ReadUCharASCII(S), O = 0; i > O; ++O)m = s.ReadIntASCII(h), e[A * n + O] = m + b[R].m_pred[O]; else if (A > 0 && a.m_value !== l.O3DGC_SC3DMC_NO_PREDICTION)for (O = 0; i > O; ++O)m = s.ReadIntASCII(h), e[A * n + O] = m + e[(A - 1) * n + O]; else for (O = 0; i > O; ++O)m = s.ReadUIntASCII(h), e[A * n + O] = m
            }
            return h.m_count = S.m_count, u.O3DGC_OK
        },u.SC3DMCDecoder.prototype.DecodeIntArray = function (e, t, i, n, r, o, a) {
            return this.m_streamType === l.O3DGC_STREAM_TYPE_ASCII ? this.DecodeIntArrayASCII(e, t, i, n, r, o, a) : this.DecodeIntArrayBinary(e, t, i, n, r, o, a)
        },u.SC3DMCDecoder.prototype.ProcessNormals = function (e) {
            var t, n, r, o, a, l, c, h, d, m, p, f, _, v, g;
            for (r = e.GetNNormal(), o = 3 * e.GetNNormal(), this.m_normalsSize < o && (this.m_normalsSize = o, this.m_normals = new Float32Array(this.m_normalsSize)), a = this.m_normals, l = this.m_quantFloatArray, c = this.m_orientation, h = e.GetCoordIndex(), s(h, e.GetNCoordIndex(), l, r, a), d = new u.Vec3, m = new u.Vec3, p = 0; r > p; ++p)t = 3 * p, d.m_x = a[t], d.m_y = a[t + 1], d.m_z = a[t + 2], g = Math.sqrt(d.m_x * d.m_x + d.m_y * d.m_y + d.m_z * d.m_z), 0 === g && (g = 1), i(d, m), f = m.m_x / g, _ = m.m_y / g, v = m.m_z + c[p], c[p] = v, v >>> 1 !== m.m_z >>> 1 && (f = 0, _ = 0), n = 2 * p, a[n] = f, a[n + 1] = _;
            return u.O3DGC_OK
        },u.SC3DMCDecoder.prototype.IQuantize = function (e, t, i, n, r, o, a, s) {
            var c, h, d, m, p, f;
            if (s.m_value === l.O3DGC_SC3DMC_SURF_NORMALS_PREDICTION)for (f = l.CubeToSphere, m = this.m_orientation, p = this.m_normals, h = new u.Vec3(0, 0, 0), d = new u.Vec3(0, 0, 0), this.IQuantizeFloatArray(e, t, i, n, this.m_minNormal, this.m_maxNormal, a + 1), c = 0; t > c; ++c)h.m_x = e[n * c] + p[2 * c], h.m_y = e[n * c + 1] + p[2 * c + 1], h.m_z = m[c], f[h.m_z](h, d), e[n * c] = d.m_x, e[n * c + 1] = d.m_y, e[n * c + 2] = d.m_z; else this.IQuantizeFloatArray(e, t, i, n, r, o, a)
        },u.SC3DMCDecoder.prototype.DecodeFloatArrayBinary = function (e, t, i, n, s, c, h, d, m, p) {
            var f, _, v, g, y, C, E, S, T, b, w, x, A, P, I, D, M, O, R, N, L, F, B, z, V, U, k, G, H, W, q, j, Y, X, Z, K;
            if (M = this.m_iterator, O = this.m_orientation, R = this.m_streamType, L = new u.ArithmeticDecoder, F = new u.StaticBitModel, B = new u.AdaptiveBitModel, z = new u.AdaptiveDataModel, f = l.O3DGC_SC3DMC_MAX_PREDICTION_NEIGHBORS, z.SetAlphabet(f + 1), V = this.m_triangleListDecoder.GetVertexToTriangle(), U = V.m_neighbors, k = d.GetCoordIndex(), G = t * i, H = M.m_count, W = p.ReadUInt32(M, R), q = p.ReadUChar(M, R), j = q >>> 4 & 7, m.m_value = 7 & q, W -= M.m_count - H, Y = new u.Iterator, Y.m_count = M.m_count + W, X = 0, Z = 0, j !== l.O3DGC_SC3DMC_BINARIZATION_AC_EGC)return u.O3DGC_ERROR_CORRUPTED_STREAM;
            if (C = p.GetBuffer(M, W), M.m_count += W, L.SetBuffer(W, C), L.StartDecoder(), X = L.ExpGolombDecode(0, F, B), Z = L.ExpGolombDecode(0, F, B), K = new u.AdaptiveDataModel, K.SetAlphabet(Z + 2), m.m_value === l.O3DGC_SC3DMC_SURF_NORMALS_PREDICTION) {
                for (this.m_orientationSize < G && (this.m_orientationSize = G, this.m_orientation = new Int8Array(this.m_orientationSize), O = this.m_orientation), y = new u.AdaptiveDataModel, y.SetAlphabet(12), x = 0; t > x; ++x)O[x] = r(L.DecodeAdaptiveDataModel(y));
                this.ProcessNormals(d), i = 2
            }
            for (this.m_quantFloatArraySize < G && (this.m_quantFloatArraySize = G, this.m_quantFloatArray = new Int32Array(this.m_quantFloatArraySize)), E = this.m_quantFloatArray, S = this.m_neighbors, T = this.m_normals, b = new u.NumberRef, _ = m.m_value !== l.O3DGC_SC3DMC_NO_PREDICTION, v = m.m_value === l.O3DGC_SC3DMC_PARALLELOGRAM_PREDICTION, A = 0; t > A; ++A) {
                if (b.m_value = 0, V.GetNumNeighbors(A) > 0 && _) {
                    if (I = V.Begin(A), D = V.End(A), v)for (P = I; D > P && (w = U[P], !(0 > w)); ++P)a(k, w, A, b, S, i, E, n, V, U);
                    if (b.m_value < f)for (P = I; D > P && (w = U[P], !(0 > w)); ++P)o(k, w, A, b, S, i, E, n)
                }
                if (b.m_value > 1)for (g = L.DecodeAdaptiveDataModel(z), x = 0; i > x; ++x)N = L.DecodeIntACEGC(K, F, B, X, Z), E[A * n + x] = N + S[g].m_pred[x]; else if (A > 0 && _)for (x = 0; i > x; ++x)N = L.DecodeIntACEGC(K, F, B, X, Z), E[A * n + x] = N + E[(A - 1) * n + x]; else for (x = 0; i > x; ++x)N = L.DecodeUIntACEGC(K, F, B, X, Z), E[A * n + x] = N
            }
            return M.m_count = Y.m_count, this.IQuantize(e, t, i, n, s, c, h, m), u.O3DGC_OK
        },u.SC3DMCDecoder.prototype.DecodeFloatArrayASCII = function (e, t, i, n, r, s, c, h, d, m) {
            var p, f, _, v, g, y, C, E, S, T, b, w, x, A, P, I, D, M, O, R, N, L, F, B, z, V, U;
            if (p = l.O3DGC_SC3DMC_MAX_PREDICTION_NEIGHBORS, v = this.m_iterator, g = this.m_orientation, y = this.m_streamType, E = this.m_triangleListDecoder.GetVertexToTriangle(), S = E.m_neighbors, T = h.GetCoordIndex(), b = t * i, w = v.m_count, x = m.ReadUInt32(v, y), A = m.ReadUChar(v, y), P = A >>> 4 & 7, d.m_value = 7 & A, x -= v.m_count - w, I = new u.Iterator, I.m_count = v.m_count + x, P !== l.O3DGC_SC3DMC_BINARIZATION_ASCII)return u.O3DGC_ERROR_CORRUPTED_STREAM;
            if (m.ReadUInt32(I, y), d.m_value === l.O3DGC_SC3DMC_SURF_NORMALS_PREDICTION) {
                for (this.m_orientationSize < t && (this.m_orientationSize = t, this.m_orientation = new Int8Array(this.m_orientationSize), g = this.m_orientation), V = 0; t > V; ++V)g[V] = m.ReadIntASCII(v);
                this.ProcessNormals(h), i = 2
            }
            for (this.m_quantFloatArraySize < b && (this.m_quantFloatArraySize = b, this.m_quantFloatArray = new Int32Array(this.m_quantFloatArraySize)), D = this.m_quantFloatArray, M = this.m_neighbors, O = this.m_normals, R = new u.NumberRef, f = d.m_value !== l.O3DGC_SC3DMC_NO_PREDICTION, _ = d.m_value === l.O3DGC_SC3DMC_PARALLELOGRAM_PREDICTION, N = 0; t > N; ++N) {
                if (R.m_value = 0, E.GetNumNeighbors(N) > 0 && f) {
                    if (F = E.Begin(N), B = E.End(N), _)for (L = F; B > L && (z = S[L], !(0 > z)); ++L)a(T, z, N, R, M, i, D, n, E, S);
                    if (R.m_value < p)for (L = F; B > L && (z = S[L], !(0 > z)); ++L)o(T, z, N, R, M, i, D, n)
                }
                if (R.m_value > 1)for (U = m.ReadUCharASCII(I), V = 0; i > V; ++V)C = m.ReadIntASCII(v), D[N * n + V] = C + M[U].m_pred[V]; else if (N > 0 && d.m_value !== l.O3DGC_SC3DMC_NO_PREDICTION)for (V = 0; i > V; ++V)C = m.ReadIntASCII(v), D[N * n + V] = C + D[(N - 1) * n + V]; else for (V = 0; i > V; ++V)C = m.ReadUIntASCII(v), D[N * n + V] = C
            }
            return v.m_count = I.m_count, this.IQuantize(e, t, i, n, r, s, c, d), u.O3DGC_OK
        },u.SC3DMCDecoder.prototype.DecodeFloatArray = function (e, t, i, n, r, o, a, s, u, c) {
            return this.m_streamType === l.O3DGC_STREAM_TYPE_ASCII ? this.DecodeFloatArrayASCII(e, t, i, n, r, o, a, s, u, c) : this.DecodeFloatArrayBinary(e, t, i, n, r, o, a, s, u, c)
        },u.SC3DMCDecoder.prototype.IQuantizeFloatArray = function (e, t, i, n, r, o, a) {
            var s, l, c, h, d;
            for (s = this.m_idelta, l = this.m_quantFloatArray, c = 0; i > c; ++c)h = o[c] - r[c], h > 0 ? s[c] = h / ((1 << a >>> 0) - 1) : s[c] = 1;
            for (d = 0; t > d; ++d)for (c = 0; i > c; ++c)e[d * n + c] = l[d * n + c] * s[c] + r[c];
            return u.O3DGC_OK
        },u.SC3DMCDecoder.prototype.DecodePlayload = function (e, t) {
            var i, n, r, o, a, s, l;
            if (i = this.m_params, n = this.m_iterator, r = this.m_stats, o = new u.NumberRef, a = new u.Timer, s = u.O3DGC_OK, this.m_triangleListDecoder.SetStreamType(this.m_streamType), r.m_streamSizeCoordIndex = n.m_count, a.Tic(), this.m_triangleListDecoder.Decode(e.GetCoordIndex(), e.GetNCoordIndex(), e.GetNCoord(), t, n), a.Toc(), r.m_timeCoordIndex = a.GetElapsedTime(), r.m_streamSizeCoordIndex = n.m_count - r.m_streamSizeCoordIndex, r.m_streamSizeCoord = n.m_count, a.Tic(), e.GetNCoord() > 0 && (s = this.DecodeFloatArray(e.GetCoord(), e.GetNCoord(), 3, 3, e.GetCoordMinArray(), e.GetCoordMaxArray(), i.GetCoordQuantBits(), e, o, t), i.SetCoordPredMode(o.m_value)), s !== u.O3DGC_OK)return s;
            if (a.Toc(), r.m_timeCoord = a.GetElapsedTime(), r.m_streamSizeCoord = n.m_count - r.m_streamSizeCoord, r.m_streamSizeNormal = n.m_count, a.Tic(), e.GetNNormal() > 0 && (s = this.DecodeFloatArray(e.GetNormal(), e.GetNNormal(), 3, 3, e.GetNormalMinArray(), e.GetNormalMaxArray(), i.GetNormalQuantBits(), e, o, t), i.SetNormalPredMode(o.m_value)), s !== u.O3DGC_OK)return s;
            for (a.Toc(), r.m_timeNormal = a.GetElapsedTime(), r.m_streamSizeNormal = n.m_count - r.m_streamSizeNormal, l = 0; l < e.GetNumFloatAttributes(); ++l)r.m_streamSizeFloatAttribute[l] = n.m_count, a.Tic(), s = this.DecodeFloatArray(e.GetFloatAttribute(l), e.GetNFloatAttribute(l), e.GetFloatAttributeDim(l), e.GetFloatAttributeDim(l), e.GetFloatAttributeMinArray(l), e.GetFloatAttributeMaxArray(l), i.GetFloatAttributeQuantBits(l), e, o, t), i.SetFloatAttributePredMode(l, o.m_value), a.Toc(), r.m_timeFloatAttribute[l] = a.GetElapsedTime(), r.m_streamSizeFloatAttribute[l] = n.m_count - r.m_streamSizeFloatAttribute[l];
            if (s !== u.O3DGC_OK)return s;
            for (l = 0; l < e.GetNumIntAttributes(); ++l)r.m_streamSizeIntAttribute[l] = n.m_count, a.Tic(), s = this.DecodeIntArray(e.GetIntAttribute(l), e.GetNIntAttribute(l), e.GetIntAttributeDim(l), e.GetIntAttributeDim(l), e, o, t), i.SetIntAttributePredMode(l, o.m_value), a.Toc(), r.m_timeIntAttribute[l] = a.GetElapsedTime(), r.m_streamSizeIntAttribute[l] = n.m_count - r.m_streamSizeIntAttribute[l];
            return s !== u.O3DGC_OK ? s : (a.Tic(), this.m_triangleListDecoder.Reorder(), a.Toc(), r.m_timeReorder = a.GetElapsedTime(), s)
        },u.DVEncodeParams = function () {
            this.m_encodeMode = l.O3DGC_DYNAMIC_VECTOR_ENCODE_MODE_LIFT, this.m_streamTypeMode = l.O3DGC_STREAM_TYPE_ASCII, this.m_quantBits = 10
        },u.DVEncodeParams.prototype.GetStreamType = function () {
            return this.m_streamTypeMode
        },u.DVEncodeParams.prototype.GetEncodeMode = function () {
            return this.m_encodeMode
        },u.DVEncodeParams.prototype.GetQuantBits = function () {
            return this.m_quantBits
        },u.DVEncodeParams.prototype.SetStreamType = function (e) {
            this.m_streamTypeMode = e
        },u.DVEncodeParams.prototype.SetEncodeMode = function (e) {
            this.m_encodeMode = e
        },u.DVEncodeParams.prototype.SetQuantBits = function (e) {
            this.m_quantBits = e
        },u.DynamicVector = function () {
            this.m_num = 0, this.m_dim = 0, this.m_stride = 0, this.m_max = {}, this.m_min = {}, this.m_vectors = {}
        },u.DynamicVector.prototype.GetNVector = function () {
            return this.m_num
        },u.DynamicVector.prototype.GetDimVector = function () {
            return this.m_dim
        },u.DynamicVector.prototype.GetStride = function () {
            return this.m_stride
        },u.DynamicVector.prototype.GetMinArray = function () {
            return this.m_min
        },u.DynamicVector.prototype.GetMaxArray = function () {
            return this.m_max
        },u.DynamicVector.prototype.GetVectors = function () {
            return this.m_vectors
        },u.DynamicVector.prototype.GetMin = function (e) {
            return this.m_min[e]
        },u.DynamicVector.prototype.GetMax = function (e) {
            return this.m_max[e]
        },u.DynamicVector.prototype.SetNVector = function (e) {
            this.m_num = e
        },u.DynamicVector.prototype.SetDimVector = function (e) {
            this.m_dim = e
        },u.DynamicVector.prototype.SetStride = function (e) {
            this.m_stride = e
        },u.DynamicVector.prototype.SetMinArray = function (e) {
            this.m_min = e
        },u.DynamicVector.prototype.SetMaxArray = function (e) {
            this.m_max = e
        },u.DynamicVector.prototype.SetMin = function (e, t) {
            this.m_min[e] = t
        },u.DynamicVector.prototype.SetMax = function (e, t) {
            this.m_max[e] = t
        },u.DynamicVector.prototype.SetVectors = function (e) {
            this.m_vectors = e
        },u.DynamicVectorDecoder = function () {
            this.m_streamSize = 0, this.m_maxNumVectors = 0, this.m_numVectors = 0, this.m_dimVectors = 0, this.m_quantVectors = {}, this.m_iterator = new u.Iterator, this.m_streamType = l.O3DGC_STREAM_TYPE_UNKOWN, this.m_params = new u.DVEncodeParams
        },u.DynamicVectorDecoder.prototype.GetStreamType = function () {
            return this.m_streamType
        },u.DynamicVectorDecoder.prototype.GetIterator = function () {
            return this.m_iterator
        },u.DynamicVectorDecoder.prototype.SetStreamType = function (e) {
            this.m_streamType = e
        },u.DynamicVectorDecoder.prototype.SetIterator = function (e) {
            this.m_iterator = e
        },u.DynamicVectorDecoder.prototype.IUpdate = function (e, t, i) {
            var n, r;
            for (r = i - 1, n = 2, e[t] -= e[t + 1] >> 1; r > n;)e[t + n] -= e[t + n - 1] + e[t + n + 1] + 2 >> 2, n += 2;
            return n === r && (e[t + n] -= e[t + n - 1] >> 1), u.O3DGC_OK
        },u.DynamicVectorDecoder.prototype.IPredict = function (e, t, i) {
            var n, r;
            for (r = i - 1, n = 1; r > n;)e[t + n] += e[t + n - 1] + e[t + n + 1] + 1 >> 1, n += 2;
            return n === r && (e[t + n] += e[t + n - 1]), u.O3DGC_OK
        },u.DynamicVectorDecoder.prototype.Merge = function (e, t, i) {
            var n, r, o, a, s;
            for (r = (i >> 1) + (1 & i), o = r - 1, a = r; o > 0;) {
                for (n = o; a > n; n += 2)s = e[t + n], e[t + n] = e[t + n + 1], e[t + n + 1] = s;
                --o, ++a
            }
            return u.O3DGC_OK
        },u.DynamicVectorDecoder.prototype.ITransform = function (e, t, i) {
            var n, r, o, a;
            for (n = i, r = 0, o = 0, r += (1 & n) << o++ >>> 0; n > 1;)n = (n >> 1) + ((1 & n) >>> 0), r += (1 & n) << o++ >>> 0;
            for (a = o - 2; a >= 0; --a)n = (n << 1 >>> 0) - (r >>> a & 1) >>> 0, this.Merge(e, t, n), this.IUpdate(e, t, n), this.IPredict(e, t, n);
            return u.O3DGC_OK
        },u.DynamicVectorDecoder.prototype.IQuantize = function (e, t, i, n, r, o, a) {
            var s, l, c, h, d, m;
            for (s = this.m_quantVectors, h = t * i, d = 0; i > d; ++d)for (l = o[d] - r[d], c = l > 0 ? l / ((1 << a >>> 0) - 1) : 1, m = 0; t > m; ++m)e[m * n + d] = s[m + d * t] * c + r[d];
            return u.O3DGC_OK
        },u.DynamicVectorDecoder.prototype.DecodeHeader = function (e, t) {
            var i, n, r, o;
            if (i = this.m_iterator, n = i.m_count, r = t.ReadUInt32(i, l.O3DGC_STREAM_TYPE_BINARY), r !== l.O3DGC_DV_START_CODE) {
                if (i.m_count = n, r = t.ReadUInt32(i, l.O3DGC_STREAM_TYPE_ASCII), r !== l.O3DGC_DV_START_CODE)return u.O3DGC_ERROR_CORRUPTED_STREAM;
                this.m_streamType = l.O3DGC_STREAM_TYPE_ASCII
            } else this.m_streamType = l.O3DGC_STREAM_TYPE_BINARY;
            return o = this.m_streamType, this.m_streamSize = t.ReadUInt32(i, o), this.m_params.SetEncodeMode(t.ReadUChar(i, o)), e.SetNVector(t.ReadUInt32(i, o)), e.GetNVector() > 0 && (e.SetDimVector(t.ReadUInt32(i, o)), this.m_params.SetQuantBits(t.ReadUChar(i, o))), u.O3DGC_OK
        },u.DynamicVectorDecoder.prototype.DecodePlayload = function (e, t) {
            var i, n, r, o, a, s, c, h, d, m, p, f, _, v, g, y, C, E, S;
            for (n = this.m_iterator, r = this.m_streamType, o = u.O3DGC_OK, a = n.m_count, s = t.ReadUInt32(n, r), c = e.GetDimVector(), h = e.GetNVector(), i = c * h, d = 0; d < e.GetDimVector(); ++d)e.SetMin(d, t.ReadFloat32(n, r)), e.SetMax(d, t.ReadFloat32(n, r));
            if (m = new u.ArithmeticDecoder, p = new u.StaticBitModel, f = new u.AdaptiveBitModel, s -= n.m_count - a, _ = 0, v = 0, r === l.O3DGC_STREAM_TYPE_BINARY && (g = t.GetBuffer(n, s), n.m_count += s, m.SetBuffer(s, g), m.StartDecoder(), _ = m.ExpGolombDecode(0, p, f), v = m.ExpGolombDecode(0, p, f)), y = new u.AdaptiveDataModel, y.SetAlphabet(v + 2), this.m_maxNumVectors < i && (this.m_maxNumVectors = i, this.m_quantVectors = new Int32Array(this.m_maxNumVectors)), C = this.m_quantVectors, r === l.O3DGC_STREAM_TYPE_ASCII)for (E = 0; h > E; ++E)for (S = 0; c > S; ++S)C[S * h + E] = t.ReadIntASCII(n); else for (E = 0; h > E; ++E)for (S = 0; c > S; ++S)C[S * h + E] = m.DecodeIntACEGC(y, p, f, _, v);
            for (S = 0; c > S; ++S)this.ITransform(C, S * h, h);
            return this.IQuantize(e.GetVectors(), h, c, e.GetStride(), e.GetMinArray(), e.GetMaxArray(), this.m_params.GetQuantBits()), o
        },u
    }),define("Cesium/Scene/decompressOpen3DGC", ["../ThirdParty/o3dgc"], function (e) {
        "use strict";
        function t(e, t) {
            return e = 0 | e, t = 0 | t, Math.ceil(e / t) * t | 0
        }

        function i(i, n) {
            var r = new ArrayBuffer(i), o = new e.BinaryStream(n), a = new e.SC3DMCDecoder, s = new e.IndexedFaceSet;
            a.DecodeHeader(s, o);
            var u, l, c = 0;
            s.GetNCoordIndex() > 0 && (l = 3 * s.GetNCoordIndex(), s.SetCoordIndex(new Uint16Array(r, c, l)), c += l * Uint16Array.BYTES_PER_ELEMENT), c = t(c, Float32Array.BYTES_PER_ELEMENT), s.GetNCoord() > 0 && (l = 3 * s.GetNCoord(), s.SetCoord(new Float32Array(r, c, l)), c += l * Float32Array.BYTES_PER_ELEMENT), s.GetNNormal() > 0 && (l = 3 * s.GetNNormal(), s.SetNormal(new Float32Array(r, c, l)), c += l * Float32Array.BYTES_PER_ELEMENT);
            var h = s.GetNumFloatAttributes();
            for (u = 0; h > u; u++)s.GetNFloatAttribute(u) > 0 && (l = s.GetFloatAttributeDim(u) * s.GetNFloatAttribute(u), s.SetFloatAttribute(u, new Float32Array(r, c, l)), c += l * Float32Array.BYTES_PER_ELEMENT);
            c = t(c, Int32Array.BYTES_PER_ELEMENT);
            var d = s.GetNumIntAttributes();
            for (u = 0; d > u; u++)s.GetNIntAttribute(u) > 0 && (l = s.GetIntAttributeDim(u) * s.GetNIntAttribute(u), s.SetIntAttribute(u, new Int16Array(r, c, l)), c += l * Int32Array.BYTES_PER_ELEMENT);
            return a.DecodePlayload(s, o), r
        }

        return i
    }),define("Cesium/Scene/getModelAccessor", ["../Core/ComponentDatatype"], function (e) {
        "use strict";
        var t = {SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16}, i = function (i) {
            var n = i.componentType, r = t[i.type];
            return {
                componentsPerAttribute: r, createArrayBufferView: function (t, i, o) {
                    return e.createArrayBufferView(n, t, i, r * o)
                }
            }
        };
        return i
    }),define("Cesium/Scene/JobType", ["../Core/freezeObject"], function (e) {
        "use strict";
        var t = {TEXTURE: 0, PROGRAM: 1, BUFFER: 2, NUMBER_OF_JOB_TYPES: 3};
        return e(t)
    }),define("Cesium/Core/Spline", ["./defaultValue", "./defined", "./DeveloperError"], function (e, t, i) {
        "use strict";
        var n = function () {
            this.times = void 0, this.points = void 0, i.throwInstantiationError()
        };
        return n.prototype.evaluate = i.throwInstantiationError, n.prototype.findTimeInterval = function (t, i) {
            var n = this.times, r = n.length;
            if (i = e(i, 0), t >= n[i]) {
                if (r > i + 1 && t < n[i + 1])return i;
                if (r > i + 2 && t < n[i + 2])return i + 1
            } else if (i - 1 >= 0 && t >= n[i - 1])return i - 1;
            var o;
            if (t > n[i])for (o = i; r - 1 > o && !(t >= n[o] && t < n[o + 1]); ++o); else for (o = i - 1; o >= 0 && !(t >= n[o] && t < n[o + 1]); --o);
            return o === r - 1 && (o = r - 2), o
        }, n
    }),define("Cesium/Core/LinearSpline", ["./Cartesian3", "./defaultValue", "./defined", "./defineProperties", "./DeveloperError", "./Spline"], function (e, t, i, n, r, o) {
        "use strict";
        var a = function (e) {
            e = t(e, t.EMPTY_OBJECT);
            var i = e.points, n = e.times;
            this._times = n, this._points = i, this._lastTimeIndex = 0
        };
        return n(a.prototype, {
            times: {
                get: function () {
                    return this._times
                }
            }, points: {
                get: function () {
                    return this._points
                }
            }
        }), a.prototype.findTimeInterval = o.prototype.findTimeInterval, a.prototype.evaluate = function (t, n) {
            var r = this.points, o = this.times, a = this._lastTimeIndex = this.findTimeInterval(t, this._lastTimeIndex), s = (t - o[a]) / (o[a + 1] - o[a]);
            return i(n) || (n = new e), e.lerp(r[a], r[a + 1], s, n)
        }, a
    }),define("Cesium/Core/QuaternionSpline", ["./defaultValue", "./defined", "./defineProperties", "./DeveloperError", "./Quaternion", "./Spline"], function (e, t, i, n, r, o) {
        "use strict";
        function a(e, i, n) {
            var o = e.length, a = new Array(o);
            a[0] = t(i) ? i : e[0], a[o - 1] = t(n) ? n : e[o - 1];
            for (var s = 1; o - 1 > s; ++s)a[s] = r.computeInnerQuadrangle(e[s - 1], e[s], e[s + 1], new r);
            return a
        }

        function s(e) {
            var i = e.points, n = e.innerQuadrangles, o = e.times;
            if (i.length < 3) {
                var a = o[0], s = 1 / (o[1] - a), u = i[0], l = i[1];
                return function (e, i) {
                    t(i) || (i = new r);
                    var n = (e - a) * s;
                    return r.fastSlerp(u, l, n, i)
                }
            }
            return function (a, s) {
                t(s) || (s = new r);
                var u = e._lastTimeIndex = e.findTimeInterval(a, e._lastTimeIndex), l = (a - o[u]) / (o[u + 1] - o[u]), c = i[u], h = i[u + 1], d = n[u], m = n[u + 1];
                return r.fastSquad(c, h, d, m, l, s)
            }
        }

        var u = function (t) {
            t = e(t, e.EMPTY_OBJECT);
            var i = t.points, n = t.times, r = t.firstInnerQuadrangle, o = t.lastInnerQuadrangle, u = a(i, r, o);
            this._times = n, this._points = i, this._innerQuadrangles = u, this._evaluateFunction = s(this), this._lastTimeIndex = 0
        };
        return i(u.prototype, {
            times: {
                get: function () {
                    return this._times
                }
            }, points: {
                get: function () {
                    return this._points
                }
            }, innerQuadrangles: {
                get: function () {
                    return this._innerQuadrangles
                }
            }
        }), u.prototype.findTimeInterval = o.prototype.findTimeInterval, u.prototype.evaluate = function (e, t) {
            return this._evaluateFunction(e, t)
        }, u
    }),define("Cesium/Scene/ModelAnimationCache", ["../Core/Cartesian3", "../Core/defaultValue", "../Core/defined", "../Core/LinearSpline", "../Core/Matrix4", "../Core/Quaternion", "../Core/QuaternionSpline", "../Renderer/WebGLConstants", "./getModelAccessor"], function (e, t, i, n, r, o, a, s, u) {
        "use strict";
        function l(e, i) {
            var n = e.gltf, r = n.buffers, o = n.bufferViews, a = o[i.bufferView], s = r[a.buffer], l = a.byteOffset + i.byteOffset, c = i.count * u(i).componentsPerAttribute;
            return e.cacheKey + "//" + t(s.path, "") + "/" + l + "/" + c
        }

        function c(e, t, i) {
            return e.cacheKey + "//" + t + "/" + i
        }

        var h = function () {
        }, d = {}, m = new e;
        h.getAnimationParameterValues = function (t, n) {
            var r = l(t, n), a = d[r];
            if (!i(a)) {
                var c, h = t._loadResources, p = t.gltf, f = p.bufferViews, _ = f[n.bufferView], v = n.componentType, g = n.type, y = n.count, C = h.getBuffer(_), E = u(n).createArrayBufferView(C.buffer, C.byteOffset + n.byteOffset, y);
                if (v === s.FLOAT && "SCALAR" === g)a = E; else if (v === s.FLOAT && "VEC3" === g)for (a = new Array(y), c = 0; y > c; ++c)a[c] = e.fromArray(E, 3 * c); else if (v === s.FLOAT && "VEC4" === g)for (a = new Array(y), c = 0; y > c; ++c) {
                    var S = 4 * c;
                    a[c] = o.fromAxisAngle(e.fromArray(E, S, m), E[S + 3])
                }
                i(t.cacheKey) && (d[r] = a)
            }
            return a
        };
        var p = {}, f = function (e) {
            this._value = e
        };
        f.prototype.evaluate = function (e, t) {
            return this._value
        }, h.getAnimationSpline = function (e, t, r, o, u, l) {
            var h = c(e, t, o), d = p[h];
            if (!i(d)) {
                var m = l[u.input], _ = e.gltf.accessors[r.parameters[u.output]], v = l[u.output];
                if (1 === m.length && 1 === v.length)d = new f(v[0]); else {
                    var g = _.componentType, y = _.type;
                    "LINEAR" === u.interpolation && (g === s.FLOAT && "VEC3" === y ? d = new n({
                        times: m,
                        points: v
                    }) : g === s.FLOAT && "VEC4" === y && (d = new a({times: m, points: v})))
                }
                i(e.cacheKey) && (p[h] = d)
            }
            return d
        };
        var _ = {};
        return h.getSkinInverseBindMatrices = function (e, t) {
            var n = l(e, t), o = _[n];
            if (!i(o)) {
                var a = e._loadResources, c = e.gltf, h = c.bufferViews, d = h[t.bufferView], m = t.componentType, p = t.type, f = t.count, v = a.getBuffer(d), g = u(t).createArrayBufferView(v.buffer, v.byteOffset + t.byteOffset, f);
                if (o = new Array(f), m === s.FLOAT && "MAT4" === p)for (var y = 0; f > y; ++y)o[y] = r.fromArray(g, 16 * y);
                _[n] = o
            }
            return o
        }, h
    }),define("Cesium/Scene/ModelAnimationLoop", ["../Core/freezeObject"], function (e) {
        "use strict";
        var t = {NONE: 0, REPEAT: 1, MIRRORED_REPEAT: 2};
        return e(t)
    }),define("Cesium/Scene/ModelAnimationState", ["../Core/freezeObject"], function (e) {
        "use strict";
        return e({STOPPED: 0, ANIMATING: 1})
    }),define("Cesium/Scene/ModelAnimation", ["../Core/defaultValue", "../Core/defineProperties", "../Core/Event", "../Core/JulianDate", "./ModelAnimationLoop", "./ModelAnimationState"], function (e, t, i, n, r, o) {
        "use strict";
        var a = function (t, a, s) {
            this._name = t.name, this._startTime = n.clone(t.startTime), this._delay = e(t.delay, 0), this._stopTime = t.stopTime, this.removeOnStop = e(t.removeOnStop, !1), this._speedup = e(t.speedup, 1), this._reverse = e(t.reverse, !1), this._loop = e(t.loop, r.NONE), this.start = new i, this.update = new i, this.stop = new i, this._state = o.STOPPED, this._runtimeAnimation = s, this._computedStartTime = void 0, this._duration = void 0;
            var u = this;
            this._raiseStartEvent = function () {
                u.start.raiseEvent(a, u)
            }, this._updateEventTime = 0, this._raiseUpdateEvent = function () {
                u.update.raiseEvent(a, u, u._updateEventTime)
            }, this._raiseStopEvent = function () {
                u.stop.raiseEvent(a, u)
            }
        };
        return t(a.prototype, {
            name: {
                get: function () {
                    return this._name
                }
            }, startTime: {
                get: function () {
                    return this._startTime
                }
            }, delay: {
                get: function () {
                    return this._delay
                }
            }, stopTime: {
                get: function () {
                    return this._stopTime
                }
            }, speedup: {
                get: function () {
                    return this._speedup
                }
            }, reverse: {
                get: function () {
                    return this._reverse
                }
            }, loop: {
                get: function () {
                    return this._loop
                }
            }
        }), a
    }),define("Cesium/Scene/ModelAnimationCollection", ["../Core/clone", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "../Core/JulianDate", "../Core/Math", "./ModelAnimation", "./ModelAnimationLoop", "./ModelAnimationState"], function (e, t, i, n, r, o, a, s, u, l, c) {
        "use strict";
        function h(e, t) {
            for (var i = e.channelEvaluators, n = i.length, r = 0; n > r; ++r)i[r](t)
        }

        function d(e, t, i) {
            return function () {
                e.animationRemoved.raiseEvent(t, i)
            }
        }

        var m = function (e) {
            this.animationAdded = new o, this.animationRemoved = new o, this._model = e, this._scheduledAnimations = [], this._previousTime = void 0
        };
        n(m.prototype, {
            length: {
                get: function () {
                    return this._scheduledAnimations.length
                }
            }
        }), m.prototype.add = function (e) {
            e = t(e, t.EMPTY_OBJECT);
            var i = this._model, n = i._runtime.animations, r = n[e.name], o = new u(e, i, r);
            return this._scheduledAnimations.push(o), this.animationAdded.raiseEvent(i, o), o
        }, m.prototype.addAll = function (i) {
            i = t(i, t.EMPTY_OBJECT), i = e(i);
            for (var n = [], r = this._model._animationIds, o = r.length, a = 0; o > a; ++a)i.name = r[a], n.push(this.add(i));
            return n
        }, m.prototype.remove = function (e) {
            if (i(e)) {
                var t = this._scheduledAnimations, n = t.indexOf(e);
                if (-1 !== n)return t.splice(n, 1), this.animationRemoved.raiseEvent(this._model, e), !0
            }
            return !1
        }, m.prototype.removeAll = function () {
            var e = this._model, t = this._scheduledAnimations, i = t.length;
            this._scheduledAnimations = [];
            for (var n = 0; i > n; ++n)this.animationRemoved.raiseEvent(e, t[n])
        }, m.prototype.contains = function (e) {
            return i(e) ? -1 !== this._scheduledAnimations.indexOf(e) : !1
        }, m.prototype.get = function (e) {
            return this._scheduledAnimations[e]
        };
        var p = [];
        return m.prototype.update = function (e) {
            var n = this._scheduledAnimations, r = n.length;
            if (0 === r)return this._previousTime = void 0, !1;
            if (a.equals(e.time, this._previousTime))return !1;
            this._previousTime = a.clone(e.time, this._previousTime);
            for (var o = !1, u = e.time, m = this._model, f = 0; r > f; ++f) {
                var _ = n[f], v = _._runtimeAnimation;
                i(_._computedStartTime) || (_._computedStartTime = a.addSeconds(t(_.startTime, u), _.delay, new a)), i(_._duration) || (_._duration = v.stopTime * (1 / _.speedup));
                var g = _._computedStartTime, y = _._duration, C = _.stopTime, E = 0 !== y ? a.secondsDifference(u, g) / y : 0, S = E >= 0, T = S && (1 >= E || _.loop === l.REPEAT || _.loop === l.MIRRORED_REPEAT) && (!i(C) || a.lessThanOrEquals(u, C));
                if (T) {
                    if (_._state === c.STOPPED && (_._state = c.ANIMATING, _.start.numberOfListeners > 0 && e.afterRender.push(_._raiseStartEvent)), _.loop === l.REPEAT)E -= Math.floor(E); else if (_.loop === l.MIRRORED_REPEAT) {
                        var b = Math.floor(E), w = E - b;
                        E = b % 2 === 1 ? 1 - w : w
                    }
                    _.reverse && (E = 1 - E);
                    var x = E * y * _.speedup;
                    x = s.clamp(x, v.startTime, v.stopTime), h(v, x), _.update.numberOfListeners > 0 && (_._updateEventTime = x, e.afterRender.push(_._raiseUpdateEvent)), o = !0
                } else S && _._state === c.ANIMATING && (_._state = c.STOPPED, _.stop.numberOfListeners > 0 && e.afterRender.push(_._raiseStopEvent), _.removeOnStop && p.push(_))
            }
            r = p.length;
            for (var A = 0; r > A; ++A) {
                var P = p[A];
                n.splice(n.indexOf(P), 1), e.afterRender.push(d(this, m, P))
            }
            return p.length = 0, o
        }, m
    }),define("Cesium/Scene/ModelMaterial", ["../Core/defined", "../Core/defineProperties", "../Core/DeveloperError"], function (e, t, i) {
        "use strict";
        var n = function (e, t, i) {
            this._name = t.name, this._id = i, this._uniformMap = e._uniformMaps[i]
        };
        return t(n.prototype, {
            name: {
                get: function () {
                    return this._name
                }
            }, id: {
                get: function () {
                    return this._id
                }
            }
        }), n.prototype.setValue = function (e, t) {
            var i = this._uniformMap.values[e];
            i.value = i.clone(t, i.value)
        }, n.prototype.getValue = function (t) {
            var i = this._uniformMap.values[t];
            return e(i) ? i.value : void 0
        }, n
    }),define("Cesium/Scene/ModelMesh", ["../Core/defineProperties"], function (e) {
        "use strict";
        var t = function (e, t, i) {
            for (var n = [], r = e.primitives, o = r.length, a = 0; o > a; ++a) {
                var s = r[a];
                n[a] = t[s.material]
            }
            this._name = e.name, this._materials = n, this._id = i
        };
        return e(t.prototype, {
            name: {
                get: function () {
                    return this._name
                }
            }, id: {
                get: function () {
                    return this._id
                }
            }, materials: {
                get: function () {
                    return this._materials
                }
            }
        }), t
    }),define("Cesium/Scene/ModelNode", ["../Core/defaultValue", "../Core/defineProperties", "../Core/Matrix4"], function (e, t, i) {
        "use strict";
        var n = function (e, t, n, r, o) {
            this._model = e, this._runtimeNode = n, this._name = t.name, this._id = r, this.useMatrix = !1, this._show = !0, this._matrix = i.clone(o)
        };
        return t(n.prototype, {
            name: {
                get: function () {
                    return this._name
                }
            }, id: {
                get: function () {
                    return this._id
                }
            }, show: {
                get: function () {
                    return this._show
                }, set: function (e) {
                    this._show !== e && (this._show = e, this._model._perNodeShowDirty = !0)
                }
            }, matrix: {
                get: function () {
                    return this._matrix
                }, set: function (e) {
                    this._matrix = i.clone(e, this._matrix), this.useMatrix = !0;
                    var t = this._model;
                    t._cesiumAnimationsDirty = !0, this._runtimeNode.dirtyNumber = t._maxDirtyNumber
                }
            }
        }), n.prototype.setMatrix = function (e) {
            i.clone(e, this._matrix)
        }, n
    }),define("Cesium/Scene/Pass", ["../Core/freezeObject"], function (e) {
        "use strict";
        var t = {COMPUTE: 0, GLOBE: 1, GROUND: 2, OPAQUE: 3, TRANSLUCENT: 4, OVERLAY: 5, NUMBER_OF_PASSES: 6};
        return e(t)
    }),define("Cesium/Scene/Model", ["../Core/BoundingSphere", "../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/clone", "../Core/combine", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/FeatureDetection", "../Core/getBasePath", "../Core/getStringFromTypedArray", "../Core/IndexDatatype", "../Core/loadArrayBuffer", "../Core/loadImage", "../Core/loadImageFromTypedArray", "../Core/loadText", "../Core/Math", "../Core/Matrix2", "../Core/Matrix3", "../Core/Matrix4", "../Core/PrimitiveType", "../Core/Quaternion", "../Core/Queue", "../Core/RuntimeError", "../Core/TaskProcessor", "../Renderer/Buffer", "../Renderer/BufferUsage", "../Renderer/DrawCommand", "../Renderer/RenderState", "../Renderer/Sampler", "../Renderer/ShaderProgram", "../Renderer/ShaderSource", "../Renderer/Texture", "../Renderer/TextureMinificationFilter", "../Renderer/TextureWrap", "../Renderer/VertexArray", "../Renderer/WebGLConstants", "../ThirdParty/gltfDefaults", "../ThirdParty/Uri", "../ThirdParty/when", "./decompressOpen3DGC", "./getModelAccessor", "./JobType", "./ModelAnimationCache", "./ModelAnimationCollection", "./ModelMaterial", "./ModelMesh", "./ModelNode", "./Pass", "./SceneMode"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S, T, b, w, x, A, P, I, D, M, O, R, N, L, F, B, z, V, U, k, G, H, W, q, j, Y, X, Z, K, J, Q) {
        "use strict";
        function $() {
            this.vertexBuffersToCreate = new w, this.indexBuffersToCreate = new w, this.buffers = {}, this.pendingBufferLoads = 0, this.decompressedViewsToCreate = new w, this.decompressedViews = {}, this.decompressionInFlight = !1, this.programsToCreate = new w, this.shaders = {}, this.pendingShaderLoads = 0, this.texturesToCreate = new w, this.pendingTextureLoads = 0, this.texturesToCreateFromBufferView = new w, this.pendingBufferViewToImage = 0, this.createSamplers = !0, this.createSkins = !0, this.createRuntimeAnimations = !0, this.createVertexArrays = !0, this.createRenderStates = !0, this.createUniformMaps = !0, this.createRuntimeNodes = !0, this.skinnedNodesIds = []
        }

        function ee(e, t) {
            e._cachedGltf = t, e._animationIds = te(t)
        }

        function te(e) {
            var t = [];
            if (s(e) && s(e.gltf)) {
                var i = e.gltf.animations;
                for (var n in i)i.hasOwnProperty(n) && t.push(n)
            }
            return t
        }

        function ie(e) {
            var t = new k(document.location.href), i = new k(e);
            return i.resolve(t).toString()
        }

        function ne(e, t, i) {
            return e.subarray(t, t + i)
        }

        function re(e, t, i) {
            t += e.byteOffset / e.BYTES_PER_ELEMENT;
            var n = e.buffer.slice(t, t + i);
            return new e.constructor(n)
        }

        function oe(e) {
            return e.byteLength < 4 ? !1 : "glTF" === m(e.subarray(0, 4))
        }

        function ae(e) {
            if (!oe(e))throw new c("bgltf is not a valid Binary glTF file.");
            var t = new DataView(e.buffer, e.byteOffset, e.byteLength), i = 0;
            i += Mt, i += Mt, i += Mt;
            var n = t.getUint32(i, !0);
            i += Mt;
            var r = t.getUint32(i, !0);
            i += Mt;
            var o = m(ne(e, n, r));
            return JSON.parse(o)
        }

        function se(e, t, i) {
            return e._runtime[t][i]
        }

        function ue(t) {
            for (var n = t.nodes, r = t.meshes, o = t.accessors, u = t.scenes[t.scene].nodes, l = u.length, c = [], h = new i(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), d = new i(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE), m = 0; l > m; ++m) {
                var p = n[u[m]];
                for (p._transformToRoot = ye(p), c.push(p); c.length > 0;) {
                    p = c.pop();
                    var f = p._transformToRoot, _ = a(p.meshes, s(p.instanceSkin) ? p.instanceSkin.meshes : void 0);
                    if (s(_))for (var v = _.length, g = 0; v > g; ++g)for (var y = r[_[g]].primitives, C = y.length, E = 0; C > E; ++E) {
                        var T = y[E].attributes.POSITION;
                        if (s(T)) {
                            var b = o[T], w = i.fromArray(b.min, 0, Ot), x = i.fromArray(b.max, 0, Rt);
                            s(h) && s(d) && (S.multiplyByPoint(f, w, w), S.multiplyByPoint(f, x, x), i.minimumByComponent(h, w, h), i.maximumByComponent(d, x, d))
                        }
                    }
                    for (var A = p.children, P = A.length, I = 0; P > I; ++I) {
                        var D = n[A[I]];
                        D._transformToRoot = ye(D), S.multiplyTransformation(f, D._transformToRoot, D._transformToRoot), c.push(D)
                    }
                    delete p._transformToRoot
                }
            }
            var M = e.fromCornerPoints(h, d);
            return e.transformWithoutScale(M, bt, M)
        }

        function le(e, t, i) {
            return function () {
                e._loadError = new x("Failed to load " + t + ": " + i), e._state = xt.FAILED
            }
        }

        function ce(e, t) {
            return function (i) {
                var n = e._loadResources;
                n.buffers[t] = new Uint8Array(i), --n.pendingBufferLoads
            }
        }

        function he(e) {
            var t = e.gltf.buffers;
            for (var i in t)if (t.hasOwnProperty(i)) {
                var n = t[i];
                if ("CESIUM_binary_glTF" === i) {
                    var r = e._loadResources;
                    r.buffers[i] = e._cachedGltf.bgltf
                } else if ("arraybuffer" === n.type) {
                    ++e._loadResources.pendingBufferLoads;
                    var o = new k(n.uri), a = o.resolve(e._baseUri).toString();
                    f(a).then(ce(e, i)).otherwise(le(e, "buffer", a))
                }
            }
        }

        function de(e) {
            var t = e.gltf.extensions;
            if (s(t) && s(t.mesh_compression_open3dgc)) {
                var i = t.mesh_compression_open3dgc.decompressedViews;
                for (var n in i)i.hasOwnProperty(n) && e._loadResources.decompressedViewsToCreate.enqueue(n)
            }
        }

        function me(e) {
            var t, i = e.gltf.bufferViews, n = e._loadResources.vertexBuffersToCreate;
            for (t in i)i.hasOwnProperty(t) && i[t].target === V.ARRAY_BUFFER && n.enqueue(t);
            var r = e._loadResources.indexBuffersToCreate, o = {}, a = e.gltf.accessors;
            for (t in a)if (a.hasOwnProperty(t)) {
                var u = a[t], l = u.bufferView, c = i[l];
                c.target !== V.ELEMENT_ARRAY_BUFFER || s(o[l]) || (o[l] = !0, r.enqueue({
                    id: l,
                    componentType: u.componentType
                }))
            }
        }

        function pe(e, t, i) {
            return function (n) {
                var r = e._loadResources;
                r.shaders[i] = {source: n, type: t, bufferView: void 0}, --r.pendingShaderLoads
            }
        }

        function fe(e) {
            var t = e.gltf.shaders;
            for (var i in t)if (t.hasOwnProperty(i)) {
                var n = t[i];
                if (s(n.extensions) && s(n.extensions.CESIUM_binary_glTF))e._loadResources.shaders[i] = {
                    source: void 0,
                    type: n.type,
                    bufferView: n.extensions.CESIUM_binary_glTF.bufferView
                }; else {
                    ++e._loadResources.pendingShaderLoads;
                    var r = new k(n.uri), o = r.resolve(e._baseUri).toString();
                    g(o).then(pe(e, n.type, i)).otherwise(le(e, "shader", o))
                }
            }
        }

        function _e(e) {
            var t = e.gltf.programs;
            for (var i in t)t.hasOwnProperty(i) && e._loadResources.programsToCreate.enqueue(i)
        }

        function ve(e, t) {
            return function (i) {
                var n = e._loadResources;
                --n.pendingTextureLoads, n.texturesToCreate.enqueue({id: t, image: i, bufferView: void 0})
            }
        }

        function ge(e) {
            var t = e.gltf.images, i = e.gltf.textures;
            for (var n in i)if (i.hasOwnProperty(n)) {
                var r = t[i[n].source];
                if (s(r.extensions) && s(r.extensions.CESIUM_binary_glTF)) {
                    var o = r.extensions.CESIUM_binary_glTF;
                    e._loadResources.texturesToCreateFromBufferView.enqueue({
                        id: n,
                        image: void 0,
                        bufferView: o.bufferView,
                        mimeType: o.mimeType
                    })
                } else {
                    ++e._loadResources.pendingTextureLoads;
                    var a = new k(r.uri), u = a.resolve(e._baseUri).toString();
                    _(u).then(ve(e, n)).otherwise(le(e, "image", u))
                }
            }
        }

        function ye(e) {
            if (s(e.matrix))return S.fromArray(e.matrix);
            var t = i.fromArray(e.rotation, 0, Nt);
            return S.fromTranslationQuaternionRotationScale(i.fromArray(e.translation, 0, Lt), b.fromAxisAngle(t, e.rotation[3], Ft), i.fromArray(e.scale, 0, Bt))
        }

        function Ce(e) {
            var t = {}, i = {}, n = [], r = e._loadResources.skinnedNodesIds, o = e.gltf.nodes;
            for (var a in o)if (o.hasOwnProperty(a)) {
                var u = o[a], l = {
                    matrix: void 0,
                    translation: void 0,
                    rotation: void 0,
                    scale: void 0,
                    computedShow: !0,
                    transformToRoot: new S,
                    computedMatrix: new S,
                    dirtyNumber: 0,
                    commands: [],
                    inverseBindMatrices: void 0,
                    bindShapeMatrix: void 0,
                    joints: [],
                    computedJointMatrices: [],
                    jointName: u.jointName,
                    children: [],
                    parents: [],
                    publicNode: void 0
                };
                l.publicNode = new K(e, u, l, a, ye(u)), t[a] = l, i[u.name] = l, s(u.instanceSkin) && (r.push(a), n.push(l))
            }
            e._runtime.nodes = t, e._runtime.nodesByName = i, e._runtime.skinnedNodes = n
        }

        function Ee(e) {
            var t = {}, i = {}, n = e.gltf.materials, r = e._uniformMaps;
            for (var o in n)if (n.hasOwnProperty(o)) {
                r[o] = {uniformMap: void 0, values: void 0, jointMatrixUniformName: void 0};
                var a = n[o], s = new X(e, a, o);
                t[a.name] = s, i[o] = s
            }
            e._runtime.materialsByName = t, e._runtime.materialsById = i
        }

        function Se(e) {
            var t = {}, i = e._runtime.materialsById, n = e.gltf.meshes;
            for (var r in n)if (n.hasOwnProperty(r)) {
                var o = n[r];
                t[o.name] = new Z(o, i, r)
            }
            e._runtime.meshesByName = t
        }

        function Te(e) {
            e._loadRendererResourcesFromCache || (he(e), de(e), me(e), fe(e), _e(e), ge(e)), Ee(e), Se(e), Ce(e)
        }

        function be(e, t) {
            var i = ne(e, t.byteOffset, t.byteLength), n = H(t.decompressedByteLength, i);
            return G(n)
        }

        function we(e, t) {
            var i = re(e, t.byteOffset, t.byteLength);
            if (!s(Vt)) {
                Ut = h.hardwareConcurrency, Vt = new Array(Ut);
                for (var n = 0; n < Vt.length; n++)Vt[n] = new A("decompressOpen3DGC", Number.POSITIVE_INFINITY)
            }
            var r = Vt[kt++].scheduleTask({
                decompressedByteLength: t.decompressedByteLength,
                compressedBuffer: i
            }, [i.buffer]);
            return kt === Ut && (kt = 0), r
        }

        function xe(e, t) {
            var i = e.gltf.extensions.mesh_compression_open3dgc.decompressedViews, n = e._loadResources, r = i[t], o = n.buffers[r.buffer], a = !1;
            if (a)return be(o, r);
            var s = we(o, r);
            return G(s).then(function (e) {
                return e.decompressedArrayBuffer
            })
        }

        function Ae(e, t) {
            return function (i) {
                e.decompressedViews[t] = new Uint8Array(i)
            }
        }

        function Pe(e) {
            for (var t = [], i = e._loadResources; i.decompressedViewsToCreate.length > 0;) {
                var n = i.decompressedViewsToCreate.dequeue(), r = xe(e, n);
                t.push(r.then(Ae(i, n)))
            }
            G.all(t, function () {
                i.decompressionInFlight = !1
            })
        }

        function Ie(e, t) {
            var i = e._loadResources;
            if (0 === i.pendingBufferLoads) {
                var n = e.gltf.extensions;
                s(n) && s(n.mesh_compression_open3dgc) && (e._loadResources.decompressionInFlight = !0, Pe(e))
            }
        }

        function De(e, t, i) {
            var n = t._loadResources, r = t.gltf.bufferViews, o = r[e], a = P.createVertexBuffer({
                context: i,
                typedArray: n.getBuffer(o),
                usage: I.STATIC_DRAW
            });
            a.vertexArrayDestroyable = !1, t._rendererResources.buffers[e] = a
        }

        function Me(e, t, i, n) {
            var r = i._loadResources, o = i.gltf.bufferViews, a = o[e], s = P.createIndexBuffer({
                context: n,
                typedArray: r.getBuffer(a),
                usage: I.STATIC_DRAW,
                indexDatatype: t
            });
            s.vertexArrayDestroyable = !1, i._rendererResources.buffers[e] = s
        }

        function Oe(e, t, i) {
            var n = e._loadResources;
            if (0 === n.pendingBufferLoads && 0 === n.decompressedViewsToCreate.length && !n.decompressionInFlight) {
                var r, o = n.vertexBuffersToCreate, a = n.indexBuffersToCreate;
                if (e.asynchronous) {
                    for (; o.length > 0 && (Ht.set(o.peek(), e, t), i.jobScheduler.execute(Ht, q.BUFFER));)o.dequeue();
                    for (; a.length > 0 && (r = a.peek(), Wt.set(r.id, r.componentType, e, t), i.jobScheduler.execute(Wt, q.BUFFER));)a.dequeue()
                } else {
                    for (; o.length > 0;)De(o.dequeue(), e, t);
                    for (; a.length > 0;)r = a.dequeue(), Me(r.id, r.componentType, e, t)
                }
            }
        }

        function Re(e) {
            for (var t = {}, i = e.length, n = 0; i > n; ++n)t[e[n]] = n;
            return t
        }

        function Ne(e, t, i) {
            var n;
            if (s(t.source))n = t.source; else {
                var r = e._loadResources, o = e.gltf, a = o.bufferViews[t.bufferView];
                n = m(r.getBuffer(a))
            }
            return s(i) && (n = i(n)), n
        }

        function Le(e, t, i) {
            var n = t.gltf.programs, r = t._loadResources.shaders, o = n[e], a = Re(o.attributes), u = Ne(t, r[o.vertexShader], t.vertexShaderLoaded), l = Ne(t, r[o.fragmentShader], t.fragmentShaderLoaded);
            if (t._rendererResources.programs[e] = R.fromCache({
                    context: i,
                    vertexShaderSource: u,
                    fragmentShaderSource: l,
                    attributeLocations: a
                }), t.allowPicking) {
                var c, h;
                s(t.pickFragmentShaderLoaded) ? (c = Ne(t, r[o.vertexShader], t.pickVertexShaderLoaded), h = Ne(t, r[o.fragmentShader], t.pickFragmentShaderLoaded)) : (c = u, h = new N({
                    sources: [l],
                    pickColorQualifier: "uniform"
                })), t._rendererResources.pickPrograms[e] = R.fromCache({
                    context: i,
                    vertexShaderSource: c,
                    fragmentShaderSource: h,
                    attributeLocations: a
                })
            }
        }

        function Fe(e, t, i) {
            var n = e._loadResources, r = n.programsToCreate;
            if (0 === n.pendingShaderLoads && 0 === n.pendingBufferLoads)if (e.asynchronous)for (; r.length > 0 && (jt.set(r.peek(), e, t), i.jobScheduler.execute(jt, q.PROGRAM));)r.dequeue(); else for (; r.length > 0;)Le(r.dequeue(), e, t)
        }

        function Be(e, t) {
            return function (i) {
                e.texturesToCreate.enqueue({id: t.id, image: i, bufferView: void 0}), --e.pendingBufferViewToImage
            }
        }

        function ze(e) {
            var t = e._loadResources;
            if (0 === t.pendingBufferLoads)for (; t.texturesToCreateFromBufferView.length > 0;) {
                var i = t.texturesToCreateFromBufferView.dequeue(), n = e.gltf, r = n.bufferViews[i.bufferView], o = Be(t, i), a = le(e, "image", "id: " + i.id + ", bufferView: " + i.bufferView);
                v(t.getBuffer(r), i.mimeType).then(o).otherwise(a), ++t.pendingBufferViewToImage
            }
        }

        function Ve(e, t) {
            var i = e._loadResources;
            if (i.createSamplers) {
                i.createSamplers = !1;
                var n = e._rendererResources.samplers, r = e.gltf.samplers;
                for (var o in r)if (r.hasOwnProperty(o)) {
                    var a = r[o];
                    n[o] = new O({
                        wrapS: a.wrapS,
                        wrapT: a.wrapT,
                        minificationFilter: a.minFilter,
                        magnificationFilter: a.magFilter
                    })
                }
            }
        }

        function Ue(e, t, i) {
            var n = t.gltf.textures, r = n[e.id], o = t._rendererResources.samplers, a = o[r.sampler], s = a.minificationFilter === F.NEAREST_MIPMAP_NEAREST || a.minificationFilter === F.NEAREST_MIPMAP_LINEAR || a.minificationFilter === F.LINEAR_MIPMAP_NEAREST || a.minificationFilter === F.LINEAR_MIPMAP_LINEAR, u = s || a.wrapS === B.REPEAT || a.wrapS === B.MIRRORED_REPEAT || a.wrapT === B.REPEAT || a.wrapT === B.MIRRORED_REPEAT, l = e.image, c = !y.isPowerOfTwo(l.width) || !y.isPowerOfTwo(l.height);
            if (u && c) {
                var h = document.createElement("canvas");
                h.width = y.nextPowerOfTwo(l.width), h.height = y.nextPowerOfTwo(l.height);
                var d = h.getContext("2d");
                d.drawImage(l, 0, 0, l.width, l.height, 0, 0, h.width, h.height), l = h
            }
            var m;
            r.target === V.TEXTURE_2D && (m = new L({
                context: i,
                source: l,
                pixelFormat: r.internalFormat,
                pixelDatatype: r.type,
                sampler: a,
                flipY: !1
            })), s && m.generateMipmap(), t._rendererResources.textures[e.id] = m
        }

        function ke(e, t, i) {
            var n = e._loadResources.texturesToCreate;
            if (e.asynchronous)for (; n.length > 0 && (Xt.set(n.peek(), e, t), i.jobScheduler.execute(Xt, q.TEXTURE));)n.dequeue(); else for (; n.length > 0;)Ue(n.dequeue(), e, t)
        }

        function Ge(e, t) {
            var i = e.gltf, n = (i.programs, i.techniques), r = i.materials, o = {}, a = n[r[t.material].instanceTechnique.technique], s = a.parameters, u = a.passes[a.pass], l = u.instanceProgram, c = l.attributes, h = e._rendererResources.programs[l.program].vertexAttributes;
            for (var d in h)if (h.hasOwnProperty(d)) {
                var m = s[c[d]];
                o[m.semantic] = h[d].index
            }
            return o
        }

        function He(e, t) {
            for (var i = e.length, n = 0; i > n; ++n)for (var r = [e[n]]; r.length > 0;) {
                var o = r.pop();
                if (o.jointName === t)return o;
                for (var a = o.children, s = a.length, u = 0; s > u; ++u)r.push(a[u])
            }
            return void 0
        }

        function We(e, t) {
            for (var i = e.gltf, n = i.skins, r = i.nodes, o = e._runtime.nodes, a = e._loadResources.skinnedNodesIds, s = a.length, u = 0; s > u; ++u) {
                var l = a[u], c = o[l], h = r[l].instanceSkin, d = t[h.skin];
                c.inverseBindMatrices = d.inverseBindMatrices, c.bindShapeMatrix = d.bindShapeMatrix;
                for (var m = [], p = h.skeletons, f = p.length, _ = 0; f > _; ++_)m.push(o[p[_]]);
                for (var v = n[h.skin].jointNames, g = v.length, y = 0; g > y; ++y) {
                    var C = v[y];
                    c.joints.push(He(m, C))
                }
            }
        }

        function qe(e) {
            var t = e._loadResources;
            if (0 === t.pendingBufferLoads && t.createSkins) {
                t.createSkins = !1;
                var i = e.gltf, n = i.accessors, r = i.skins, o = {};
                for (var a in r)if (r.hasOwnProperty(a)) {
                    var s, u = r[a], l = n[u.inverseBindMatrices];
                    S.equals(u.bindShapeMatrix, S.IDENTITY) || (s = S.clone(u.bindShapeMatrix)), o[a] = {
                        inverseBindMatrices: j.getSkinInverseBindMatrices(e, l),
                        bindShapeMatrix: s
                    }
                }
                We(e, o)
            }
        }

        function je(e, t, i, n) {
            return function (r) {
                t[i] = n.evaluate(r, t[i]), t.dirtyNumber = e._maxDirtyNumber
            }
        }

        function Ye(e) {
            var t = e._loadResources;
            if (t.finishedPendingBufferLoads() && t.createRuntimeAnimations) {
                t.createRuntimeAnimations = !1, e._runtime.animations = {};
                var i = e._runtime.nodes, n = e.gltf.animations, r = e.gltf.accessors;
                for (var o in n)if (n.hasOwnProperty(o)) {
                    var a = n[o], s = a.channels, u = a.parameters, l = a.samplers, c = {};
                    for (var h in u)u.hasOwnProperty(h) && (c[h] = j.getAnimationParameterValues(e, r[u[h]]));
                    for (var d = Number.MAX_VALUE, m = -Number.MAX_VALUE, p = s.length, f = new Array(p), _ = 0; p > _; ++_) {
                        var v = s[_], g = v.target, y = l[v.sampler], C = c[y.input];
                        d = Math.min(d, C[0]), m = Math.max(m, C[C.length - 1]);
                        var E = j.getAnimationSpline(e, o, a, v.sampler, y, c);
                        f[_] = je(e, i[g.id], g.path, E)
                    }
                    e._runtime.animations[o] = {startTime: d, stopTime: m, channelEvaluators: f}
                }
            }
        }

        function Xe(e, t) {
            var i = e._loadResources;
            if (i.finishedBuffersCreation() && i.finishedProgramCreation() && i.createVertexArrays) {
                i.createVertexArrays = !1;
                var n = e._rendererResources.buffers, r = e._rendererResources.vertexArrays, o = e.gltf, a = o.accessors, u = o.meshes;
                for (var l in u)if (u.hasOwnProperty(l))for (var c = u[l].primitives, h = c.length, d = 0; h > d; ++d) {
                    var m = c[d], p = Ge(e, m), f = [], _ = m.attributes;
                    for (var v in _)if (_.hasOwnProperty(v)) {
                        var g = p[v];
                        if (s(g)) {
                            var y = a[_[v]], C = y.componentType;
                            C = 5125 === C ? 5123 : C, f.push({
                                index: g,
                                vertexBuffer: n[y.bufferView],
                                componentsPerAttribute: W(y).componentsPerAttribute,
                                componentDatatype: C,
                                normalize: !1,
                                offsetInBytes: y.byteOffset,
                                strideInBytes: y.byteStride
                            })
                        }
                    }
                    var E = a[m.indices], S = n[E.bufferView];
                    r[l + ".primitive." + d] = new z({context: t, attributes: f, indexBuffer: S})
                }
            }
        }

        function Ze(e) {
            var t = {};
            t[V.BLEND] = !1, t[V.CULL_FACE] = !1, t[V.DEPTH_TEST] = !1, t[V.POLYGON_OFFSET_FILL] = !1, t[V.SCISSOR_TEST] = !1;
            var i, n = e.enable, r = n.length;
            for (i = 0; r > i; ++i)t[n[i]] = !0;
            return t
        }

        function Ke(e, t) {
            var i = e._loadResources;
            if (i.createRenderStates) {
                i.createRenderStates = !1;
                var n = e._rendererResources.renderStates, r = e.gltf.techniques;
                for (var o in r)if (r.hasOwnProperty(o)) {
                    var u = r[o], l = u.passes[u.pass], c = l.states, h = Ze(c), d = a(c.functions, a.EMPTY_OBJECT), m = a(d.blendColor, [0, 0, 0, 0]), p = a(d.blendEquationSeparate, [V.FUNC_ADD, V.FUNC_ADD]), f = a(d.blendFuncSeparate, [V.ONE, V.ONE, V.ZERO, V.ZERO]), _ = a(d.colorMask, [!0, !0, !0, !0]), v = a(d.depthRange, [0, 1]), g = a(d.polygonOffset, [0, 0]), y = a(d.scissor, [0, 0, 0, 0]);
                    n[o] = M.fromCache({
                        frontFace: s(d.frontFace) ? d.frontFace[0] : V.CCW,
                        cull: {enabled: h[V.CULL_FACE], face: s(d.cullFace) ? d.cullFace[0] : V.BACK},
                        lineWidth: s(d.lineWidth) ? d.lineWidth[0] : 1,
                        polygonOffset: {enabled: h[V.POLYGON_OFFSET_FILL], factor: g[0], units: g[1]},
                        scissorTest: {
                            enabled: h[V.SCISSOR_TEST],
                            rectangle: {x: y[0], y: y[1], width: y[2], height: y[3]}
                        },
                        depthRange: {near: v[0], far: v[1]},
                        depthTest: {enabled: h[V.DEPTH_TEST], func: s(d.depthFunc) ? d.depthFunc[0] : V.LESS},
                        colorMask: {red: _[0], green: _[1], blue: _[2], alpha: _[3]},
                        depthMask: s(d.depthMask) ? d.depthMask[0] : !0,
                        blending: {
                            enabled: h[V.BLEND],
                            color: {red: m[0], green: m[1], blue: m[2], alpha: m[3]},
                            equationRgb: p[0],
                            equationAlpha: p[1],
                            functionSourceRgb: f[0],
                            functionSourceAlpha: f[1],
                            functionDestinationRgb: f[2],
                            functionDestinationAlpha: f[3]
                        }
                    })
                }
            }
        }

        function Je(e, t) {
            var i = {
                value: e, clone: function (e, t) {
                    return e
                }, func: function () {
                    return i.value
                }
            };
            return i
        }

        function Qe(e, i) {
            var n = {
                value: t.fromArray(e), clone: t.clone, func: function () {
                    return n.value
                }
            };
            return n
        }

        function $e(e, t) {
            var n = {
                value: i.fromArray(e), clone: i.clone, func: function () {
                    return n.value
                }
            };
            return n
        }

        function et(e, t) {
            var i = {
                value: n.fromArray(e), clone: n.clone, func: function () {
                    return i.value
                }
            };
            return i
        }

        function tt(e, t) {
            var i = {
                value: C.fromColumnMajorArray(e), clone: C.clone, func: function () {
                    return i.value
                }
            };
            return i
        }

        function it(e, t) {
            var i = {
                value: E.fromColumnMajorArray(e), clone: E.clone, func: function () {
                    return i.value
                }
            };
            return i
        }

        function nt(e, t) {
            var i = {
                value: S.fromColumnMajorArray(e), clone: S.clone, func: function () {
                    return i.value
                }
            };
            return i
        }

        function rt(e, t) {
            var i = new Jt(e, t);
            return i.func = function () {
                return i.value
            }, i
        }

        function ot(e, t) {
            var i = t._runtime.nodes[e];
            return function () {
                return i.computedMatrix
            }
        }

        function at(e, t) {
            var i = e._loadResources;
            if (i.finishedProgramCreation() && i.createUniformMaps) {
                i.createUniformMaps = !1;
                var n = e.gltf, r = n.materials, o = n.techniques, a = (n.programs, e._uniformMaps);
                for (var u in r)if (r.hasOwnProperty(u)) {
                    var l, c = r[u], h = c.instanceTechnique, d = h.values, m = o[h.technique], p = m.parameters, f = m.passes[m.pass], _ = f.instanceProgram, v = _.uniforms, g = {}, y = {};
                    for (var C in v)if (v.hasOwnProperty(C)) {
                        var E = v[C], S = p[E];
                        if (s(d[E])) {
                            var T = Qt[S.type](d[E], e);
                            g[C] = T.func, y[E] = T
                        } else if (s(S.semantic))"JOINTMATRIX" !== S.semantic ? g[C] = Kt[S.semantic](t.uniformState, e) : l = C; else if (s(S.source))g[C] = ot(S.source, e); else if (s(S.value)) {
                            var b = Qt[S.type](S.value, e);
                            g[C] = b.func, y[E] = b
                        }
                    }
                    s(e.uniformMapLoaded) && (g = e.uniformMapLoaded(g));
                    var w = a[u];
                    w.uniformMap = g, w.values = y, w.jointMatrixUniformName = l
                }
            }
        }

        function st(e) {
            return function () {
                return e
            }
        }

        function ut(e) {
            return function () {
                return e.computedJointMatrices
            }
        }

        function lt(t, n, r, u) {
            for (var l = t._nodeCommands, c = t._pickIds, h = t.allowPicking, d = t._runtime.meshesByName, m = (t.debugShowBoundingVolume, t._rendererResources), f = m.vertexArrays, _ = m.programs, v = m.pickPrograms, g = m.renderStates, y = t._uniformMaps, C = t.gltf, E = C.accessors, T = C.meshes, b = C.techniques, w = C.materials, x = s(n.meshes) ? n.meshes : n.instanceSkin.meshes, A = x.length, P = 0; A > P; ++P)for (var I = x[P], M = T[I], O = M.primitives, R = O.length, N = 0; R > N; ++N) {
                var L, F = O[N], B = E[F.indices], z = w[F.material].instanceTechnique, V = b[z.technique], U = V.passes[V.pass], k = U.instanceProgram, G = F.attributes.POSITION;
                if (s(G)) {
                    var H = E[G];
                    L = e.fromCornerPoints(i.fromArray(H.min), i.fromArray(H.max))
                }
                var W = f[I + ".primitive." + N], q = B.count, j = B.byteOffset / p.getSizeInBytes(B.componentType), Y = y[F.material], X = Y.uniformMap;
                if (s(Y.jointMatrixUniformName)) {
                    var Z = {};
                    Z[Y.jointMatrixUniformName] = ut(r), X = o(X, Z)
                }
                var K, Q = g[z.technique], $ = Q.blending.enabled, ee = {
                    primitive: a(t.pickPrimitive, t),
                    id: t.id,
                    node: r.publicNode,
                    mesh: d[M.name]
                }, te = new D({
                    boundingVolume: new e,
                    cull: t.cull,
                    modelMatrix: new S,
                    primitiveType: F.mode,
                    vertexArray: W,
                    count: q,
                    offset: j,
                    shaderProgram: _[k.program],
                    uniformMap: X,
                    renderState: Q,
                    owner: ee,
                    pass: $ ? J.TRANSLUCENT : J.OPAQUE
                });
                if (h) {
                    var ie;
                    if (s(t.pickFragmentShaderLoaded))ie = s(t.pickUniformMapLoaded) ? t.pickUniformMapLoaded(X) : o(X); else {
                        var ne = u.createPickId(ee);
                        c.push(ne);
                        var re = {czm_pickColor: st(ne.color)};
                        ie = o(X, re)
                    }
                    K = new D({
                        boundingVolume: new e,
                        cull: t.cull,
                        modelMatrix: new S,
                        primitiveType: F.mode,
                        vertexArray: W,
                        count: q,
                        offset: j,
                        shaderProgram: v[k.program],
                        uniformMap: ie,
                        renderState: Q,
                        owner: ee,
                        pass: $ ? J.TRANSLUCENT : J.OPAQUE
                    })
                }
                var oe = {show: !0, boundingSphere: L, command: te, pickCommand: K};
                r.commands.push(oe), l.push(oe)
            }
        }

        function ct(e, t) {
            var n = e._loadResources;
            if (n.finishedEverythingButTextureCreation() && n.createRuntimeNodes) {
                n.createRuntimeNodes = !1;
                for (var r = [], o = e._runtime.nodes, a = e.gltf, u = a.nodes, l = a.scenes[a.scene], c = l.nodes, h = c.length, d = [], m = new i, p = 0; h > p; ++p)for (d.push({
                    parentRuntimeNode: void 0,
                    gltfNode: u[c[p]],
                    id: c[p]
                }); d.length > 0;) {
                    var f = d.pop(), _ = f.parentRuntimeNode, v = f.gltfNode, g = o[f.id];
                    0 === g.parents.length && (s(v.matrix) ? g.matrix = S.fromColumnMajorArray(v.matrix) : (m = i.fromArray(v.rotation, 0, m), g.translation = i.fromArray(v.translation), g.rotation = b.fromAxisAngle(m, v.rotation[3]), g.scale = i.fromArray(v.scale))), s(_) ? (_.children.push(g), g.parents.push(_)) : r.push(g), (s(v.meshes) || s(v.instanceSkin)) && lt(e, v, g, t);
                    for (var y = v.children, C = y.length, E = 0; C > E; ++E)d.push({
                        parentRuntimeNode: g,
                        gltfNode: u[y[E]],
                        id: y[E]
                    })
                }
                e._runtime.rootNodes = r, e._runtime.nodes = o
            }
        }

        function ht(e, t, i) {
            if (e._loadRendererResourcesFromCache) {
                var n = e._rendererResources, r = e._cachedRendererResources;
                n.buffers = r.buffers, n.vertexArrays = r.vertexArrays, n.programs = r.programs, n.pickPrograms = r.pickPrograms, n.textures = r.textures, n.samplers = r.samplers, n.renderStates = r.renderStates
            } else Ie(e, t), Oe(e, t, i), Fe(e, t, i), Ve(e, t), ze(e), ke(e, t, i);
            qe(e), Ye(e), e._loadRendererResourcesFromCache || (Xe(e, t), Ke(e, t)), at(e, t), ct(e, t)
        }

        function dt(e, t) {
            var i = e.publicNode, n = i.matrix;
            i.useMatrix && s(n) ? S.clone(n, t) : s(e.matrix) ? S.clone(e.matrix, t) : (S.fromTranslationQuaternionRotationScale(e.translation, e.rotation, e.scale, t), i.setMatrix(t))
        }

        function mt(t, n, r) {
            for (var o = t._maxDirtyNumber, a = t.allowPicking, u = t._runtime.rootNodes, l = u.length, c = $t, h = t._computedModelMatrix, d = 0; l > d; ++d) {
                var m = u[d];
                for (dt(m, m.transformToRoot), c.push(m); c.length > 0;) {
                    m = c.pop();
                    var p = m.transformToRoot, f = m.commands;
                    if (m.dirtyNumber === o || n || r) {
                        var _ = f.length;
                        if (_ > 0)for (var v = 0; _ > v; ++v) {
                            var g = f[v], y = g.command;
                            if (S.multiplyTransformation(h, p, y.modelMatrix), e.transform(g.boundingSphere, y.modelMatrix, y.boundingVolume), s(t._rtcCenter) && i.add(t._rtcCenter, y.boundingVolume.center, y.boundingVolume.center), a) {
                                var C = g.pickCommand;
                                S.clone(y.modelMatrix, C.modelMatrix), e.clone(y.boundingVolume, C.boundingVolume)
                            }
                        } else m.computedMatrix = S.multiplyTransformation(h, p, m.computedMatrix)
                    }
                    for (var E = m.children, T = E.length, b = 0; T > b; ++b) {
                        var w = E[b];
                        w.dirtyNumber = Math.max(w.dirtyNumber, m.dirtyNumber), (w.dirtyNumber === o || r) && (dt(w, w.transformToRoot), S.multiplyTransformation(p, w.transformToRoot, w.transformToRoot)), c.push(w)
                    }
                }
            }
            ++t._maxDirtyNumber
        }

        function pt(e) {
            for (var t = e._runtime.skinnedNodes, i = t.length, n = 0; i > n; ++n) {
                var r = t[n];
                ei = S.inverseTransformation(r.transformToRoot, ei);
                for (var o = r.computedJointMatrices, a = r.joints, u = r.bindShapeMatrix, l = r.inverseBindMatrices, c = l.length, h = 0; c > h; ++h)s(o[h]) || (o[h] = new S), o[h] = S.multiplyTransformation(ei, a[h].transformToRoot, o[h]), o[h] = S.multiplyTransformation(o[h], l[h], o[h]), s(u) && (o[h] = S.multiplyTransformation(o[h], u, o[h]))
            }
        }

        function ft(e) {
            for (var t = e._runtime.rootNodes, i = t.length, n = $t, r = 0; i > r; ++r) {
                var o = t[r];
                for (o.computedShow = o.publicNode.show, n.push(o); n.length > 0;) {
                    o = n.pop();
                    for (var a = o.computedShow, s = o.commands, u = s.length, l = 0; u > l; ++l)s[l].show = a;
                    for (var c = o.children, h = c.length, d = 0; h > d; ++d) {
                        var m = c[d];
                        m.computedShow = a && m.publicNode.show, n.push(m)
                    }
                }
            }
        }

        function _t(e, t) {
            var i = e.id;
            if (e._id !== i) {
                e._id = i;
                for (var n = e._pickIds, r = n.length, o = 0; r > o; ++o)n[o].object.id = i
            }
        }

        function vt(e) {
            if (e._debugWireframe !== e.debugWireframe) {
                e._debugWireframe = e.debugWireframe;
                for (var t = e.debugWireframe ? T.LINES : T.TRIANGLES, i = e._nodeCommands, n = i.length, r = 0; n > r; ++r)i[r].command.primitiveType = t
            }
        }

        function gt(e) {
            if (e.debugShowBoundingVolume !== e._debugShowBoundingVolume) {
                e._debugShowBoundingVolume = e.debugShowBoundingVolume;
                for (var t = e.debugShowBoundingVolume, i = e._nodeCommands, n = i.length, r = 0; n > r; r++)i[r].command.debugShowBoundingVolume = t
            }
        }

        function yt(e, t, i, n) {
            ni.center = e, ni.radius = t;
            var r = n.camera, o = r.distanceToBoundingSphere(ni);
            ti.x = i.drawingBufferWidth, ti.y = i.drawingBufferHeight;
            var a = r.frustum.getPixelSize(ti, o, ii), s = Math.max(a.x, a.y);
            return s
        }

        function Ct(e, t, n) {
            var r = e.scale;
            if (0 !== e.minimumPixelSize) {
                var o = Math.max(t.drawingBufferWidth, t.drawingBufferHeight), a = e.modelMatrix;
                ri.x = a[12], ri.y = a[13], ri.z = a[14], s(e._rtcCenter) && i.add(e._rtcCenter, ri, ri);
                var u = e.boundingSphere.radius, l = yt(ri, u, t, n), c = 1 / l, h = Math.min(2 * c * u, o);
                h < e.minimumPixelSize && (r = e.minimumPixelSize * l / (2 * e._initialRadius))
            }
            return r
        }

        function Et(e) {
            s(e._cacheKey) && s(e._cachedGltf) && 0 === --e._cachedGltf.count && delete It[e._cacheKey], e._cachedGltf = void 0
        }

        function St(e) {
            for (var t in e)e.hasOwnProperty(t) && e[t].destroy()
        }

        function Tt(e) {
            St(e.buffers), St(e.vertexArrays), St(e.programs), St(e.pickPrograms), St(e.textures)
        }

        if (!h.supportsTypedArrays())return {};
        var bt = S.fromRotationTranslation(E.fromRotationX(y.PI_OVER_TWO)), wt = new i, xt = {
            NEEDS_LOAD: 0,
            LOADING: 1,
            LOADED: 2,
            FAILED: 3
        }, At = "model/vnd.gltf.binary,model/vnd.gltf+json;q=0.8,application/json;q=0.2,*/*;q=0.01";
        $.prototype.getBuffer = function (e) {
            if (s(e.extensions) && s(e.extensions.mesh_compression_open3dgc)) {
                var t = e.extensions.mesh_compression_open3dgc.decompressedView;
                return ne(this.decompressedViews[t], e.byteOffset, e.byteLength)
            }
            return ne(this.buffers[e.buffer], e.byteOffset, e.byteLength)
        }, $.prototype.finishedPendingBufferLoads = function () {
            return 0 === this.pendingBufferLoads
        }, $.prototype.finishedBuffersCreation = function () {
            return 0 === this.pendingBufferLoads && 0 === this.decompressedViewsToCreate.length && !this.decompressionInFlight && 0 === this.vertexBuffersToCreate.length && 0 === this.indexBuffersToCreate.length
        }, $.prototype.finishedProgramCreation = function () {
            return 0 === this.pendingShaderLoads && 0 === this.programsToCreate.length
        }, $.prototype.finishedTextureCreation = function () {
            var e = 0 === this.pendingTextureLoads, t = 0 === this.texturesToCreate.length && 0 === this.texturesToCreateFromBufferView.length;
            return e && t
        }, $.prototype.finishedEverythingButTextureCreation = function () {
            var e = 0 === this.pendingBufferLoads && 0 === this.pendingShaderLoads, t = 0 === this.vertexBuffersToCreate.length && 0 === this.indexBuffersToCreate.length && 0 === this.programsToCreate.length && 0 === this.pendingBufferViewToImage;
            return e && t
        }, $.prototype.finished = function () {
            return this.finishedTextureCreation() && this.finishedEverythingButTextureCreation()
        };
        var Pt = function (e) {
            this._gltf = U(e.gltf), this._bgltf = e.bgltf, this.ready = e.ready, this.modelsToLoad = [], this.count = 0
        };
        u(Pt.prototype, {
            gltf: {
                set: function (e) {
                    this._gltf = U(e)
                }, get: function () {
                    return this._gltf
                }
            }, bgltf: {
                get: function () {
                    return this._bgltf
                }
            }
        }), Pt.prototype.makeReady = function (e, t) {
            this.gltf = e, this._bgltf = t;
            for (var i = this.modelsToLoad, n = i.length, r = 0; n > r; ++r) {
                var o = i[r];
                o.isDestroyed() || ee(o, this)
            }
            this.modelsToLoad = void 0, this.ready = !0
        };
        var It = {}, Dt = function (t) {
            t = a(t, a.EMPTY_OBJECT);
            var i = t.cacheKey;
            this._cacheKey = i, this._cachedGltf = void 0, this._releaseGltfJson = a(t.releaseGltfJson, !1), this._animationIds = void 0;
            var n;
            if (s(i) && s(It[i]) && It[i].ready)n = It[i], ++n.count; else {
                var r = t.gltf;
                s(r) && (r instanceof ArrayBuffer && (r = new Uint8Array(r)), n = new Pt(r instanceof Uint8Array ? {
                    gltf: ae(r),
                    bgltf: r,
                    ready: !0
                } : {gltf: t.gltf, ready: !0}), n.count = 1, s(i) && (It[i] = n))
            }
            ee(this, n), this._basePath = a(t.basePath, "");
            var o = new k(document.location.href), u = new k(this._basePath);
            this._baseUri = u.resolve(o), this.show = a(t.show, !0), this.displayCondition = t.displayCondition, this.loadOnlyIfDisplayCondition = a(t.loadOnlyIfDisplayCondition, !1), this.modelMatrix = S.clone(a(t.modelMatrix, S.IDENTITY)), this._modelMatrix = S.clone(this.modelMatrix), this.scale = a(t.scale, 1), this._scale = this.scale, this.minimumPixelSize = a(t.minimumPixelSize, 0), this._minimumPixelSize = this.minimumPixelSize, this.id = t.id, this._id = t.id, this.vertexShaderLoaded = t.vertexShaderLoaded, this.fragmentShaderLoaded = t.fragmentShaderLoaded, this.uniformMapLoaded = t.uniformMapLoaded, this.pickVertexShaderLoaded = t.pickVertexShaderLoaded, this.pickFragmentShaderLoaded = t.pickFragmentShaderLoaded, this.pickUniformMapLoaded = t.pickUniformMapLoaded, this.pickPrimitive = t.pickPrimitive, this._allowPicking = a(t.allowPicking, !0), this._ready = !1, this._readyPromise = G.defer(), this.activeAnimations = new Y(this), this._defaultTexture = void 0, this._incrementallyLoadTextures = a(t.incrementallyLoadTextures, !0), this._asynchronous = !0, this.debugShowBoundingVolume = a(t.debugShowBoundingVolume, !1), this._debugShowBoundingVolume = !1, this.debugWireframe = a(t.debugWireframe, !1), this._debugWireframe = !1, this.cull = a(t.cull, !0), this._computedModelMatrix = new S, this._initialRadius = void 0, this._boundingSphere = void 0, this._scaledBoundingSphere = new e, this._state = xt.NEEDS_LOAD, this._loadError = void 0, this._loadResources = void 0, this._perNodeShowDirty = !1, this._cesiumAnimationsDirty = !1, this._maxDirtyNumber = 0, this._runtime = {
                animations: void 0,
                rootNodes: void 0,
                nodes: void 0,
                nodesByName: void 0,
                skinnedNodes: void 0,
                meshesByName: void 0,
                materialsByName: void 0,
                materialsById: void 0
            }, this._uniformMaps = {}, this._rendererResources = {
                buffers: {},
                vertexArrays: {},
                programs: {},
                pickPrograms: {},
                textures: {},
                samplers: {},
                renderStates: {}
            }, this._cachedRendererResources = void 0, this._loadRendererResourcesFromCache = !1, this._nodeCommands = [], this._pickIds = [], this._rtcCenter = void 0
        };
        u(Dt.prototype, {
            gltf: {
                get: function () {
                    return s(this._cachedGltf) ? this._cachedGltf.gltf : void 0
                }
            }, releaseGltfJson: {
                get: function () {
                    return this._releaseGltfJson
                }
            }, cacheKey: {
                get: function () {
                    return this._cacheKey
                }
            }, basePath: {
                get: function () {
                    return this._basePath
                }
            }, boundingSphere: {
                get: function () {
                    var e = S.getScale(this.modelMatrix, wt);
                    i.multiplyByScalar(e, this.scale, e);
                    var t = this._scaledBoundingSphere;
                    return t.center = i.multiplyComponents(this._boundingSphere.center, e, t.center), t.radius = i.maximumComponent(e) * this._initialRadius, s(this._rtcCenter) && i.add(this._rtcCenter, t.center, t.center), t
                }
            }, ready: {
                get: function () {
                    return this._ready
                }
            }, readyPromise: {
                get: function () {
                    return this._readyPromise
                }
            }, asynchronous: {
                get: function () {
                    return this._asynchronous
                }
            }, allowPicking: {
                get: function () {
                    return this._allowPicking
                }
            }, incrementallyLoadTextures: {
                get: function () {
                    return this._incrementallyLoadTextures
                }
            }
        });
        var Mt = Uint32Array.BYTES_PER_ELEMENT;
        Dt.fromGltf = function (e) {
            var t = e.url, i = a(e.cacheKey, ie(t));
            e = r(e), e.basePath = d(t), e.cacheKey = i;
            var n = new Dt(e);
            e.headers = s(e.headers) ? r(e.headers) : {}, s(e.headers.Accept) || (e.headers.Accept = At);
            var o = It[i];
            return s(o) ? o.ready || (++o.count, o.modelsToLoad.push(n)) : (o = new Pt({ready: !1}), o.count = 1, o.modelsToLoad.push(n), ee(n, o), It[i] = o, f(t, e.headers).then(function (e) {
                var t = new Uint8Array(e);
                if (oe(t))o.makeReady(ae(t), t); else {
                    var i = m(t);
                    o.makeReady(JSON.parse(i))
                }
            }).otherwise(le(n, "model", t))), n
        }, Dt._gltfCache = It, Dt.prototype.getNode = function (e) {
            var t = se(this, "nodesByName", e);
            return s(t) ? t.publicNode : void 0
        }, Dt.prototype.getMesh = function (e) {
            return se(this, "meshesByName", e)
        }, Dt.prototype.getMaterial = function (e) {
            return se(this, "materialsByName", e)
        };
        var Ot = new i, Rt = new i, Nt = new i, Lt = new i, Ft = new b, Bt = new i, zt = function () {
            this.id = void 0, this.model = void 0, this.context = void 0
        };
        zt.prototype.set = function (e, t, i) {
            this.id = e, this.model = t, this.context = i
        }, zt.prototype.execute = function () {
            De(this.id, this.model, this.context)
        };
        var Vt, Ut, kt = 0, Gt = function () {
            this.id = void 0, this.componentType = void 0, this.model = void 0, this.context = void 0
        };
        Gt.prototype.set = function (e, t, i, n) {
            this.id = e, this.componentType = t, this.model = i, this.context = n
        }, Gt.prototype.execute = function () {
            Me(this.id, this.componentType, this.model, this.context)
        };
        var Ht = new zt, Wt = new Gt, qt = function () {
            this.id = void 0, this.model = void 0, this.context = void 0
        };
        qt.prototype.set = function (e, t, i) {
            this.id = e, this.model = t, this.context = i
        }, qt.prototype.execute = function () {
            Le(this.id, this.model, this.context)
        };
        var jt = new qt, Yt = function () {
            this.gltfTexture = void 0, this.model = void 0, this.context = void 0
        };
        Yt.prototype.set = function (e, t, i) {
            this.gltfTexture = e, this.model = t, this.context = i
        }, Yt.prototype.execute = function () {
            Ue(this.gltfTexture, this.model, this.context)
        };
        var Xt = new Yt, Zt = new i, Kt = {
            MODEL: function (e, t) {
                return function () {
                    return e.model
                }
            }, VIEW: function (e, t) {
                return function () {
                    return e.view
                }
            }, PROJECTION: function (e, t) {
                return function () {
                    return e.projection
                }
            }, MODELVIEW: function (e, t) {
                return function () {
                    return e.modelView
                }
            }, CESIUM_RTC_MODELVIEW: function (e, t) {
                var n = new S;
                return function () {
                    return S.getTranslation(e.model, Zt), i.add(Zt, t._rtcCenter, Zt), S.multiplyByPoint(e.view, Zt, Zt), S.setTranslation(e.modelView, Zt, n)
                }
            }, MODELVIEWPROJECTION: function (e, t) {
                return function () {
                    return e.modelViewProjection
                }
            }, MODELINVERSE: function (e, t) {
                return function () {
                    return e.inverseModel
                }
            }, VIEWINVERSE: function (e, t) {
                return function () {
                    return e.inverseView
                }
            }, PROJECTIONINVERSE: function (e, t) {
                return function () {
                    return e.inverseProjection
                }
            }, MODELVIEWINVERSE: function (e, t) {
                return function () {
                    return e.inverseModelView
                }
            }, MODELVIEWPROJECTIONINVERSE: function (e, t) {
                return function () {
                    return e.inverseModelViewProjection
                }
            }, MODELINVERSETRANSPOSE: function (e, t) {
                return function () {
                    return e.inverseTranposeModel
                }
            }, MODELVIEWINVERSETRANSPOSE: function (e, t) {
                return function () {
                    return e.normal
                }
            }, VIEWPORT: function (e, t) {
                return function () {
                    return e.viewportCartesian4
                }
            }
        }, Jt = function (e, t) {
            this._value = void 0, this._textureId = e, this._model = t
        };
        u(Jt.prototype, {
            value: {
                get: function () {
                    if (!s(this._value)) {
                        var e = this._model._rendererResources.textures[this._textureId];
                        if (!s(e))return this._model._defaultTexture;
                        this._value = e
                    }
                    return this._value
                }, set: function (e) {
                    this._value = e
                }
            }
        }), Jt.prototype.clone = function (e, t) {
            return e
        }, Jt.prototype.func = void 0;
        var Qt = {};
        Qt[V.FLOAT] = Je, Qt[V.FLOAT_VEC2] = Qe, Qt[V.FLOAT_VEC3] = $e, Qt[V.FLOAT_VEC4] = et, Qt[V.INT] = Je, Qt[V.INT_VEC2] = Qe, Qt[V.INT_VEC3] = $e, Qt[V.INT_VEC4] = et, Qt[V.BOOL] = Je, Qt[V.BOOL_VEC2] = Qe, Qt[V.BOOL_VEC3] = $e, Qt[V.BOOL_VEC4] = et, Qt[V.FLOAT_MAT2] = tt, Qt[V.FLOAT_MAT3] = it, Qt[V.FLOAT_MAT4] = nt, Qt[V.SAMPLER_2D] = rt;
        var $t = [], ei = new S, ti = new t, ii = new t, ni = new e, ri = new i, oi = function (e, t) {
            this.buffers = void 0, this.vertexArrays = void 0, this.programs = void 0, this.pickPrograms = void 0, this.textures = void 0, this.samplers = void 0, this.renderStates = void 0, this.ready = !1, this.context = e, this.cacheKey = t, this.count = 0
        };
        return oi.prototype.release = function () {
            return 0 === --this.count ? (s(this.cacheKey) && delete this.context.cache.modelRendererResourceCache[this.cacheKey], Tt(this), l(this)) : void 0
        }, Dt.prototype.update = function (e, t, n) {
            if (t.mode === Q.SCENE3D) {
                var r = s(this.displayCondition) ? this.displayCondition.isVisible(this, t) : !0;
                if (!this.loadOnlyIfDisplayCondition || r) {
                    if (this._defaultTexture = e.defaultTexture, this._state === xt.NEEDS_LOAD && s(this.gltf)) {
                        var o, u = this.cacheKey;
                        if (s(u)) {
                            e.cache.modelRendererResourceCache = a(e.cache.modelRendererResourceCache, {});
                            var l = e.cache.modelRendererResourceCache;
                            if (o = l[this.cacheKey], s(o)) {
                                if (!o.ready)return;
                                ++o.count, this._loadRendererResourcesFromCache = !0
                            } else o = new oi(e, u), o.count = 1, l[this.cacheKey] = o;
                            this._cachedRendererResources = o
                        } else o = new oi(e), o.count = 1, this._cachedRendererResources = o;
                        this._state = xt.LOADING, this._boundingSphere = ue(this.gltf), this._initialRadius = this._boundingSphere.radius;
                        var c = this.gltf.extensions;
                        s(c) && s(c.CESIUM_RTC) && (this._rtcCenter = i.fromArray(c.CESIUM_RTC.center)), this._loadResources = new $, Te(this)
                    }
                    if (this._state === xt.FAILED)throw this._loadError;
                    var h = this._loadResources, d = this._incrementallyLoadTextures, m = !1;
                    if (this._state === xt.LOADING) {
                        if (h.decompressionInFlight)return;
                        ht(this, e, t), (h.finished() || d && h.finishedEverythingButTextureCreation()) && (this._state = xt.LOADED, m = !0)
                    }
                    if (s(h) && this._state === xt.LOADED && (d && !m && ht(this, e, t), h.finished())) {
                        this._loadResources = void 0;
                        var p = this._rendererResources, f = this._cachedRendererResources;
                        f.buffers = p.buffers, f.vertexArrays = p.vertexArrays, f.programs = p.programs, f.pickPrograms = p.pickPrograms, f.textures = p.textures, f.samplers = p.samplers, f.renderStates = p.renderStates, f.ready = !0, this.releaseGltfJson && Et(this)
                    }
                    var _ = this.show && 0 !== this.scale && r && (!s(h) || !h.decompressionInFlight);
                    if (_ && this._state === xt.LOADED || m) {
                        var v = this.activeAnimations.update(t) || this._cesiumAnimationsDirty;
                        this._cesiumAnimationsDirty = !1;
                        var g = !S.equals(this._modelMatrix, this.modelMatrix) || this._scale !== this.scale || this._minimumPixelSize !== this.minimumPixelSize || 0 !== this.minimumPixelSize;
                        if (g || m) {
                            S.clone(this.modelMatrix, this._modelMatrix), this._scale = this.scale, this._minimumPixelSize = this.minimumPixelSize;
                            var y = Ct(this, e, t), C = this._computedModelMatrix;
                            S.multiplyByUniformScale(this.modelMatrix, y, C), S.multiplyTransformation(C, bt, C)
                        }
                        (v || g || m) && (mt(this, g, m), (v || m) && pt(this)), this._perNodeShowDirty && (this._perNodeShowDirty = !1, ft(this)), _t(this, e), vt(this), gt(this)
                    }
                    if (m) {
                        var E = this;
                        return void t.afterRender.push(function () {
                            E._ready = !0, E.readyPromise.resolve(E)
                        })
                    }
                    if (_) {
                        var T, b, w = t.passes, x = this._nodeCommands, A = x.length;
                        if (w.render)for (T = 0; A > T; ++T)b = x[T], b.show && n.push(b.command);
                        if (w.pick)for (T = 0; A > T; ++T)b = x[T], b.show && n.push(b.pickCommand)
                    }
                }
            }
        }, Dt.prototype.isDestroyed = function () {
            return !1
        }, Dt.prototype.destroy = function () {
            this._rendererResources = void 0, this._cachedRendererResources = this._cachedRendererResources && this._cachedRendererResources.release();
            for (var e = this._pickIds, t = e.length, i = 0; t > i; ++i)e[i].destroy();
            return Et(this), l(this)
        }, Dt
    }),define("Cesium/Scene/BatchedModel", ["../Core/Color", "../Core/defineProperties"], function (e, t) {
        "use strict";
        var i = function (e, t, i) {
            this._content = t, this._batchId = i, this._color = void 0, this.primitive = e
        };
        return t(i.prototype, {
            show: {
                get: function () {
                    return this._content.getShow(this._batchId)
                }, set: function (e) {
                    this._content.setShow(this._batchId, e)
                }
            }, color: {
                get: function () {
                    return this._color || (this._color = new e), this._content.getColor(this._batchId, this._color)
                }, set: function (e) {
                    this._content.setColor(this._batchId, e)
                }
            }
        }), i.prototype.getProperty = function (e) {
            return this._content.getProperty(this._batchId, e)
        }, i.prototype.setProperty = function (e, t) {
            this._content.setProperty(this._batchId, e, t)
        }, i
    }),define("Cesium/Scene/Batched3DModel3DTileContentProvider", ["../Core/Cartesian2", "../Core/Cartesian4", "../Core/clone", "../Core/Color", "../Core/combine", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/getStringFromTypedArray", "../Core/loadArrayBuffer", "../Core/PixelFormat", "../Renderer/Context", "../Renderer/ContextLimits", "../Renderer/PixelDatatype", "../Renderer/Sampler", "../Renderer/ShaderSource", "../Renderer/Texture", "../Renderer/TextureMinificationFilter", "../Renderer/TextureMagnificationFilter", "./Cesium3DTileContentState", "./Model", "./BatchedModel", "../ThirdParty/when"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S, T, b) {
        "use strict";
        function w(e) {
            var t = e._textureDimensions;
            return t.x * t.y * 4
        }

        function x(e) {
            if (!a(e._batchValues)) {
                for (var t = w(e), i = new Uint8Array(t), n = 0; t > n; ++n)i[n] = 255;
                e._batchValues = i
            }
            return e._batchValues
        }

        function A(e) {
            var t = e._tileset, i = e._batchSize;
            if (!a(e._models) && i > 0) {
                for (var n = new Array(i), r = 0; i > r; ++r)n[r] = new T(t, e, r);
                e._models = n
            }
        }

        function P(e) {
            return 1 === e._textureDimensions.y ? "uniform vec4 tiles3d_textureStep; \nvec2 computeSt(float batchId) \n{ \n    float stepX = tiles3d_textureStep.x; \n    float centerX = tiles3d_textureStep.y; \n    return vec2(centerX + (batchId * stepX), 0.5); \n} \n" : "uniform vec4 tiles3d_textureStep; \nuniform vec2 tiles3d_textureDimensions; \nvec2 computeSt(float batchId) \n{ \n    float stepX = tiles3d_textureStep.x; \n    float centerX = tiles3d_textureStep.y; \n    float stepY = tiles3d_textureStep.z; \n    float centerY = tiles3d_textureStep.w; \n    float xId = mod(batchId, tiles3d_textureDimensions.x); \n    float yId = floor(batchId / tiles3d_textureDimensions.x); \n    return vec2(centerX + (xId * stepX), 1.0 - (centerY + (yId * stepY))); \n} \n"
        }

        function I(e) {
            return 0 === e._batchSize ? void 0 : function (t) {
                var i, n = v.replaceMain(t, "gltf_main");
                return i = p.maximumVertexTextureImageUnits > 0 ? "uniform sampler2D tiles3d_batchTexture; \nvarying vec3 tiles3d_modelColor; \nvoid main() \n{ \n    gltf_main(); \n    vec2 st = computeSt(a_batchId); \n    vec4 modelProperties = texture2D(tiles3d_batchTexture, st); \n    float show = modelProperties.a; \n    gl_Position *= show; \n    tiles3d_modelColor = modelProperties.rgb; \n}" : "varying vec2 tiles3d_modelSt; \nvoid main() \n{ \n    gltf_main(); \n    tiles3d_modelSt = computeSt(a_batchId); \n}", n + "\n" + P(e) + i
            }
        }

        function D(e) {
            return 0 === e._batchSize ? void 0 : function (e) {
                var t, i = v.replaceMain(e, "gltf_main");
                return t = p.maximumVertexTextureImageUnits > 0 ? "varying vec3 tiles3d_modelColor; \nvoid main() \n{ \n    gltf_main(); \n    gl_FragColor.rgb *= tiles3d_modelColor; \n}" : "uniform sampler2D tiles3d_batchTexture; \nvarying vec2 tiles3d_modelSt; \nvoid main() \n{ \n    vec4 modelProperties = texture2D(tiles3d_batchTexture, tiles3d_modelSt); \n    if (modelProperties.a == 0.0) { \n        discard; \n    } \n    gltf_main(); \n    gl_FragColor.rgb *= modelProperties.rgb; \n}", i + "\n" + t
            }
        }

        function M(e) {
            return 0 === e._batchSize ? void 0 : function (t) {
                var i = {
                    tiles3d_batchTexture: function () {
                        return o(e._batchTexture, e._defaultTexture)
                    }, tiles3d_textureDimensions: function () {
                        return e._textureDimensions
                    }, tiles3d_textureStep: function () {
                        return e._textureStep
                    }
                };
                return r(t, i)
            }
        }

        function O(e) {
            return 0 === e._batchSize ? void 0 : function (t) {
                var i, n = v.replaceMain(t, "gltf_main");
                return i = p.maximumVertexTextureImageUnits > 0 ? "uniform sampler2D tiles3d_batchTexture; \nvarying vec2 tiles3d_modelSt; \nvoid main() \n{ \n    gltf_main(); \n    vec2 st = computeSt(a_batchId); \n    vec4 modelProperties = texture2D(tiles3d_batchTexture, st); \n    float show = modelProperties.a; \n    gl_Position *= show; \n    tiles3d_modelSt = st; \n}" : "varying vec2 tiles3d_modelSt; \nvoid main() \n{ \n    gltf_main(); \n    tiles3d_modelSt = computeSt(a_batchId); \n}", n + "\n" + P(e) + i
            }
        }

        function R(e) {
            return 0 === e._batchSize ? void 0 : function (e) {
                var t, i = v.replaceMain(e, "gltf_main");
                return t = p.maximumVertexTextureImageUnits > 0 ? "uniform sampler2D tiles3d_pickTexture; \nvarying vec2 tiles3d_modelSt; \nvoid main() \n{ \n    gltf_main(); \n    if (gl_FragColor.a == 0.0) { \n        discard; \n    } \n    gl_FragColor = texture2D(tiles3d_pickTexture, tiles3d_modelSt); \n}" : "uniform sampler2D tiles3d_pickTexture; \nuniform sampler2D tiles3d_batchTexture; \nvarying vec2 tiles3d_modelSt; \nvoid main() \n{ \n    vec4 modelProperties = texture2D(tiles3d_batchTexture, tiles3d_modelSt); \n    if (modelProperties.a == 0.0) { \n        discard; \n    } \n    gltf_main(); \n    if (gl_FragColor.a == 0.0) { \n        discard; \n    } \n    gl_FragColor = texture2D(tiles3d_pickTexture, tiles3d_modelSt); \n}", i + "\n" + t
            }
        }

        function N(e) {
            return 0 === e._batchSize ? void 0 : function (t) {
                var i = {
                    tiles3d_batchTexture: function () {
                        return o(e._batchTexture, e._defaultTexture)
                    }, tiles3d_textureDimensions: function () {
                        return e._textureDimensions
                    }, tiles3d_textureStep: function () {
                        return e._textureStep
                    }, tiles3d_pickTexture: function () {
                        return e._pickTexture
                    }
                };
                return r(t, i)
            }
        }

        function L(e, t, i) {
            return e.subarray(t, t + i)
        }

        function F(e, t) {
            t.state === E.READY && (e.debugColorizeTiles && !t._debugColorizeTiles ? (t._debugColorizeTiles = !0, t.setAllColor(t._debugColor)) : !e.debugColorizeTiles && t._debugColorizeTiles && (t._debugColorizeTiles = !1, t.setAllColor(n.WHITE)))
        }

        function B(e, t, i) {
            var n = e._textureDimensions;
            return new g({
                context: t,
                pixelFormat: d.RGBA,
                pixelDatatype: f.UNSIGNED_BYTE,
                source: {width: n.x, height: n.y, arrayBufferView: i},
                sampler: new _({minificationFilter: y.NEAREST, magnificationFilter: C.NEAREST})
            })
        }

        function z(e, t) {
            var i = e._batchSize;
            if (!a(e._pickTexture) && i > 0) {
                A(e);
                for (var r = e._models, o = e._pickIds, s = w(e), u = new Uint8Array(s), l = 0; i > l; ++l) {
                    var c = t.createPickId(r[l]);
                    o.push(c);
                    var h = c.color, d = 4 * l;
                    u[d] = n.floatToByte(h.red), u[d + 1] = n.floatToByte(h.green), u[d + 2] = n.floatToByte(h.blue), u[d + 3] = n.floatToByte(h.alpha)
                }
                e._pickTexture = B(e, t, u)
            }
        }

        function V(e, t) {
            a(e._batchTexture) || (e._batchTexture = B(e, t, e._batchValues), e._batchValuesDirty = !1)
        }

        function U(e, t) {
            if (e._batchValuesDirty) {
                var i = e._textureDimensions;
                e._batchTexture.copyFrom({width: i.x, height: i.y, arrayBufferView: e._batchValues})
            }
        }

        var k = function (i, r, a) {
            this._model = void 0, this._url = r, this._tileset = i, this.state = E.UNLOADED, this.processingPromise = b.defer(), this.readyPromise = b.defer();
            var s = o(a.batchSize, 0);
            this._batchSize = s, this._batchValues = void 0, this._batchValuesDirty = !1, this._batchTexture = void 0, this._defaultTexture = void 0, this._pickTexture = void 0, this._pickIds = [], this._batchTable = void 0, this._models = void 0;
            var u, l;
            if (s > 0) {
                var c = Math.min(s, p.maximumTextureSize), h = Math.ceil(s / p.maximumTextureSize), d = 1 / c, m = .5 * d, f = 1 / h, _ = .5 * f;
                u = new e(c, h), l = new t(d, m, f, _)
            }
            this._textureDimensions = u, this._textureStep = l, this._debugColor = n.fromRandom({alpha: 1}), this._debugColorizeTiles = !1
        };
        s(k.prototype, {
            batchSize: {
                get: function () {
                    return this._batchSize
                }
            }
        }), k.prototype.setShow = function (e, t) {
            this._batchSize;
            if (!t || a(this._batchValues)) {
                var i = x(this), n = 4 * e + 3, r = t ? 255 : 0;
                i[n] !== r && (i[n] = r, this._batchValuesDirty = !0)
            }
        }, k.prototype.getShow = function (e) {
            this._batchSize;
            if (!a(this._batchValues))return !0;
            var t = 4 * e + 3;
            return 255 === this._batchValues[t]
        };
        var G = new Array(4);
        k.prototype.setColor = function (e, t) {
            this._batchSize;
            if (!n.equals(t, n.WHITE) || a(this._batchValues)) {
                var i = x(this), r = 4 * e, o = t.toBytes(G);
                (i[r] !== o[0] || i[r + 1] !== o[1] || i[r + 2] !== o[2]) && (i[r] = o[0], i[r + 1] = o[1], i[r + 2] = o[2], this._batchValuesDirty = !0)
            }
        }, k.prototype.setAllColor = function (e) {
            for (var t = this._batchSize, i = 0; t > i; ++i)this.setColor(i, e)
        }, k.prototype.getColor = function (e, t) {
            this._batchSize;
            if (!a(this._batchValues))return n.clone(n.WHITE, t);
            var i = this._batchValues, r = 4 * e;
            return n.fromBytes(i[r], i[r + 1], i[r + 2], 255, t)
        }, k.prototype.hasProperty = function (e) {
            var t = this._batchTable;
            return a(t) && a(t[e])
        }, k.prototype.getPropertyNames = function () {
            var e = [], t = this._batchTable;
            if (!t)return e;
            for (var i in t)t.hasOwnProperty(i) && e.push(i);
            return e
        }, k.prototype.getProperty = function (e, t) {
            this._batchSize;
            if (!a(this._batchTable))return void 0;
            var n = this._batchTable[t];
            return a(n) ? i(n[e], !0) : void 0
        }, k.prototype.setProperty = function (e, t, n) {
            var r = this._batchSize;
            a(this._batchTable) || (this._batchTable = {});
            var o = this._batchTable[t];
            a(o) || (this._batchTable[t] = new Array(r), o = this._batchTable[t]), o[e] = i(n, !0)
        }, k.prototype.getModel = function (e) {
            this._batchSize;
            return A(this), this._models[e]
        };
        var H = Uint32Array.BYTES_PER_ELEMENT;
        return k.prototype.request = function () {
            function e(e) {
                t.state = E.FAILED, t.readyPromise.reject(e)
            }

            var t = this;
            this.state = E.LOADING, h(this._url).then(function (i) {
                var n = new Uint8Array(i), r = c(L(n, 0, Math.min(4, n.length)));
                if ("b3dm" !== r)throw new l("Invalid Batched 3D Model.  Expected magic=b3dm.  Read magic=" + r);
                var o = new DataView(i), a = 0;
                a += H, a += H;
                var s = o.getUint32(a, !0);
                if (a += H, s > 0) {
                    var u = c(L(n, a, s));
                    a += s, t._batchTable = JSON.parse(u)
                }
                var h = new Uint8Array(i, a, i.byteLength - a), d = new S({
                    gltf: h,
                    cull: !1,
                    releaseGltfJson: !0,
                    vertexShaderLoaded: I(t),
                    fragmentShaderLoaded: D(t),
                    uniformMapLoaded: M(t),
                    pickVertexShaderLoaded: O(t),
                    pickFragmentShaderLoaded: R(t),
                    pickUniformMapLoaded: N(t),
                    basePath: t._url
                });
                t._model = d, t.state = E.PROCESSING, t.processingPromise.resolve(t), b(d.readyPromise).then(function (e) {
                    t.state = E.READY, t.readyPromise.resolve(t)
                }).otherwise(e)
            }).otherwise(e)
        }, k.prototype.update = function (e, t, i, n) {
            F(e, this), this._defaultTexture = t.defaultTexture, i.passes.pick && z(this, t), this._batchValuesDirty && (V(this, t), U(this, t), this._batchValuesDirty = !1), this._model.update(t, i, n)
        }, k.prototype.isDestroyed = function () {
            return !1
        }, k.prototype.destroy = function () {
            this._model = this._model && this._model.destroy(), this._batchTexture = this._batchTexture && this._batchTexture.destroy(), this._pickTexture = this._pickTexture && this._pickTexture.destroy();
            for (var e = this._pickIds, t = e.length, i = 0; t > i; ++i)e[i].destroy();
            return u(this)
        }, k
    }),define("Cesium/Core/PointGeometry", ["./defaultValue", "./defined", "./ComponentDatatype", "./PrimitiveType", "./BoundingSphere", "./GeometryAttribute", "./GeometryAttributes", "./Geometry"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        var u = function (t) {
            t = e(t, e.EMPTY_OBJECT), this._positionsTypedArray = t.positionsTypedArray, this._colorsTypedArray = t.colorsTypedArray, this._boundingSphere = r.clone(t.boundingSphere), this._workerName = "createPointGeometry"
        };
        return u.createGeometry = function (e) {
            var u = new a;
            u.position = new o({
                componentDatatype: i.FLOAT,
                componentsPerAttribute: 3,
                values: e._positionsTypedArray
            }), u.color = new o({
                componentDatatype: i.UNSIGNED_BYTE,
                componentsPerAttribute: 3,
                values: e._colorsTypedArray,
                normalize: !0
            });
            var l = e._boundingSphere;
            return t(l) || (l = r.fromVertices(e._positionsTypedArray)), new s({
                attributes: u,
                primitiveType: n.POINTS,
                boundingSphere: l
            })
        }, u
    }),define("Cesium/Scene/getMagic", ["../Core/getStringFromTypedArray"], function (e) {
        "use strict";
        function t(e, t, i) {
            return e.subarray(t, t + i)
        }

        var i = function (i) {
            var n = new Uint8Array(i), r = e(t(n, 0, Math.min(4, n.length)));
            return r
        };
        return i
    }),define("Cesium/Core/VertexFormat", ["./defaultValue", "./defined", "./DeveloperError", "./freezeObject"], function (e, t, i, n) {
        "use strict";
        var r = function (t) {
            t = e(t, e.EMPTY_OBJECT), this.position = e(t.position, !1), this.normal = e(t.normal, !1), this.st = e(t.st, !1), this.binormal = e(t.binormal, !1), this.tangent = e(t.tangent, !1), this.color = e(t.color, !1)
        };
        return r.POSITION_ONLY = n(new r({position: !0})), r.POSITION_AND_NORMAL = n(new r({
            position: !0,
            normal: !0
        })), r.POSITION_NORMAL_AND_ST = n(new r({
            position: !0,
            normal: !0,
            st: !0
        })), r.POSITION_AND_ST = n(new r({position: !0, st: !0})), r.POSITION_AND_COLOR = n(new r({
            position: !0,
            color: !0
        })), r.ALL = n(new r({
            position: !0,
            normal: !0,
            st: !0,
            binormal: !0,
            tangent: !0
        })), r.DEFAULT = r.POSITION_NORMAL_AND_ST, r.packedLength = 6, r.pack = function (t, i, n) {
            n = e(n, 0), i[n++] = t.position ? 1 : 0, i[n++] = t.normal ? 1 : 0, i[n++] = t.st ? 1 : 0, i[n++] = t.binormal ? 1 : 0, i[n++] = t.tangent ? 1 : 0, i[n++] = t.color ? 1 : 0
        }, r.unpack = function (i, n, o) {
            return n = e(n, 0), t(o) || (o = new r), o.position = 1 === i[n++], o.normal = 1 === i[n++], o.st = 1 === i[n++], o.binormal = 1 === i[n++], o.tangent = 1 === i[n++], o.color = 1 === i[n++], o
        }, r.clone = function (e, i) {
            return t(e) ? (t(i) || (i = new r), i.position = e.position, i.normal = e.normal, i.st = e.st, i.binormal = e.binormal, i.tangent = e.tangent, i.color = e.color, i) : void 0
        }, r
    }),define("Cesium/Scene/BlendEquation", ["../Core/freezeObject", "../Renderer/WebGLConstants"], function (e, t) {
        "use strict";
        var i = {ADD: t.FUNC_ADD, SUBTRACT: t.FUNC_SUBTRACT, REVERSE_SUBTRACT: t.FUNC_REVERSE_SUBTRACT};
        return e(i)
    }),define("Cesium/Scene/BlendFunction", ["../Core/freezeObject", "../Renderer/WebGLConstants"], function (e, t) {
        "use strict";
        var i = {
            ZERO: t.ZERO,
            ONE: t.ONE,
            SOURCE_COLOR: t.SRC_COLOR,
            ONE_MINUS_SOURCE_COLOR: t.ONE_MINUS_SRC_COLOR,
            DESTINATION_COLOR: t.DST_COLOR,
            ONE_MINUS_DESTINATION_COLOR: t.ONE_MINUS_DST_COLOR,
            SOURCE_ALPHA: t.SRC_ALPHA,
            ONE_MINUS_SOURCE_ALPHA: t.ONE_MINUS_SRC_ALPHA,
            DESTINATION_ALPHA: t.DST_ALPHA,
            ONE_MINUS_DESTINATION_ALPHA: t.ONE_MINUS_DST_ALPHA,
            CONSTANT_COLOR: t.CONSTANT_COLOR,
            ONE_MINUS_CONSTANT_COLOR: t.ONE_MINUS_CONSTANT_ALPHA,
            CONSTANT_ALPHA: t.CONSTANT_ALPHA,
            ONE_MINUS_CONSTANT_ALPHA: t.ONE_MINUS_CONSTANT_ALPHA,
            SOURCE_ALPHA_SATURATE: t.SRC_ALPHA_SATURATE
        };
        return e(i)
    }),define("Cesium/Scene/BlendingState", ["../Core/freezeObject", "./BlendEquation", "./BlendFunction"], function (e, t, i) {
        "use strict";
        var n = {
            DISABLED: e({enabled: !1}),
            ALPHA_BLEND: e({
                enabled: !0,
                equationRgb: t.ADD,
                equationAlpha: t.ADD,
                functionSourceRgb: i.SOURCE_ALPHA,
                functionSourceAlpha: i.SOURCE_ALPHA,
                functionDestinationRgb: i.ONE_MINUS_SOURCE_ALPHA,
                functionDestinationAlpha: i.ONE_MINUS_SOURCE_ALPHA
            }),
            PRE_MULTIPLIED_ALPHA_BLEND: e({
                enabled: !0,
                equationRgb: t.ADD,
                equationAlpha: t.ADD,
                functionSourceRgb: i.ONE,
                functionSourceAlpha: i.ONE,
                functionDestinationRgb: i.ONE_MINUS_SOURCE_ALPHA,
                functionDestinationAlpha: i.ONE_MINUS_SOURCE_ALPHA
            }),
            ADDITIVE_BLEND: e({
                enabled: !0,
                equationRgb: t.ADD,
                equationAlpha: t.ADD,
                functionSourceRgb: i.SOURCE_ALPHA,
                functionSourceAlpha: i.SOURCE_ALPHA,
                functionDestinationRgb: i.ONE,
                functionDestinationAlpha: i.ONE
            })
        };
        return e(n)
    }),define("Cesium/Scene/CullFace", ["../Core/freezeObject", "../Renderer/WebGLConstants"], function (e, t) {
        "use strict";
        var i = {FRONT: t.FRONT, BACK: t.BACK, FRONT_AND_BACK: t.FRONT_AND_BACK};
        return e(i)
    }),define("Cesium/Scene/Appearance", ["../Core/clone", "../Core/combine", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "./BlendingState", "./CullFace"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = function (e) {
            e = i(e, i.EMPTY_OBJECT), this.material = e.material, this.translucent = i(e.translucent, !0), this._vertexShaderSource = e.vertexShaderSource, this._fragmentShaderSource = e.fragmentShaderSource, this._renderState = e.renderState, this._closed = i(e.closed, !1)
        };
        return r(s.prototype, {
            vertexShaderSource: {
                get: function () {
                    return this._vertexShaderSource
                }
            }, fragmentShaderSource: {
                get: function () {
                    return this._fragmentShaderSource
                }
            }, renderState: {
                get: function () {
                    return this._renderState
                }
            }, closed: {
                get: function () {
                    return this._closed
                }
            }
        }), s.prototype.getFragmentShaderSource = function () {
            var e = [];
            return this.flat && e.push("#define FLAT"), this.faceForward && e.push("#define FACE_FORWARD"), n(this.material) && e.push(this.material.shaderSource), e.push(this.fragmentShaderSource), e.join("\n")
        }, s.prototype.isTranslucent = function () {
            return n(this.material) && this.material.isTranslucent() || !n(this.material) && this.translucent
        }, s.prototype.getRenderState = function () {
            var t = this.isTranslucent(), i = e(this.renderState, !1);
            return t ? (i.depthMask = !1, i.blending = o.ALPHA_BLEND) : i.depthMask = !0, i
        }, s.getDefaultRenderState = function (e, i, r) {
            var s = {depthTest: {enabled: !0}};
            return e && (s.depthMask = !1, s.blending = o.ALPHA_BLEND), i && (s.cull = {
                enabled: !0,
                face: a.BACK
            }), n(r) && (s = t(r, s, !0)), s
        }, s
    }),define("Cesium/Shaders/Appearances/PointAppearanceVS", [], function () {
        "use strict";
        return "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 color;\n\nuniform float pointSize;\n\nvarying vec3 v_positionEC;\nvarying vec3 v_color;\n\nvoid main() \n{\n    v_color = color;\n    gl_Position = czm_modelViewProjectionRelativeToEye * czm_computePosition();\n    gl_PointSize = pointSize;\n}\n"
    }),define("Cesium/Shaders/Appearances/PointAppearanceFS", [], function () {
        "use strict";
        return "uniform vec4 highlightColor;\n\nvarying vec3 v_color;\n\nvoid main()\n{\n    // TODO: custom optimized shader\n\n    gl_FragColor = vec4(v_color * highlightColor.rgb, highlightColor.a);\n}\n"
    }),define("Cesium/Scene/PointAppearance", ["../Core/Color", "../Core/clone", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/VertexFormat", "./Appearance", "../Shaders/Appearances/PointAppearanceVS", "../Shaders/Appearances/PointAppearanceFS"], function (e, t, i, n, r, o, a, s, u) {
        "use strict";
        var l = function (r) {
            r = i(r, i.EMPTY_OBJECT), this._vertexShaderSource = i(r.vertexShaderSource, s), this._fragmentShaderSource = i(r.fragmentShaderSource, u), this._renderState = a.getDefaultRenderState(!0, !1, r.renderState), this.translucent = i(r.translucent, !1), this.uniforms = {
                highlightColor: new e,
                pointSize: 2
            };
            var o = r.uniforms;
            if (n(o))for (var l in o)o.hasOwnProperty(l) && (this.uniforms[l] = t(o[l]))
        };
        return l.VERTEX_FORMAT = o.POSITION_AND_COLOR, r(l.prototype, {
            vertexShaderSource: {
                get: function () {
                    return this._vertexShaderSource
                }
            }, fragmentShaderSource: {
                get: function () {
                    return this._fragmentShaderSource
                }
            }, renderState: {
                get: function () {
                    return this._renderState
                }
            }, closed: {
                get: function () {
                    return !1
                }
            }, vertexFormat: {
                get: function () {
                    return l.VERTEX_FORMAT
                }
            }
        }), l.prototype.getFragmentShaderSource = a.prototype.getFragmentShaderSource, l.prototype.isTranslucent = a.prototype.isTranslucent, l.prototype.getRenderState = a.prototype.getRenderState, l
    }),define("Cesium/Core/GeometryInstanceAttribute", ["./defaultValue", "./defined", "./DeveloperError"], function (e, t, i) {
        "use strict";
        var n = function (t) {
            t = e(t, e.EMPTY_OBJECT), this.componentDatatype = t.componentDatatype, this.componentsPerAttribute = t.componentsPerAttribute, this.normalize = e(t.normalize, !1), this.value = t.value
        };
        return n
    }),define("Cesium/Core/subdivideArray", ["./defined", "./DeveloperError"], function (e, t) {
        "use strict";
        var i = function (e, t) {
            for (var i = [], n = e.length, r = 0; n > r;) {
                var o = Math.ceil((n - r) / t--);
                i.push(e.slice(r, r + o)), r += o
            }
            return i
        };
        return i
    }),define("Cesium/Core/AttributeCompression", ["./Cartesian2", "./Cartesian3", "./defined", "./DeveloperError", "./Math"], function (e, t, i, n, r) {
        "use strict";
        var o = {};
        o.octEncode = function (e, t) {
            if (t.x = e.x / (Math.abs(e.x) + Math.abs(e.y) + Math.abs(e.z)), t.y = e.y / (Math.abs(e.x) + Math.abs(e.y) + Math.abs(e.z)), e.z < 0) {
                var i = t.x, n = t.y;
                t.x = (1 - Math.abs(n)) * r.signNotZero(i), t.y = (1 - Math.abs(i)) * r.signNotZero(n)
            }
            return t.x = r.toSNorm(t.x), t.y = r.toSNorm(t.y), t
        }, o.octDecode = function (e, i, n) {
            if (n.x = r.fromSNorm(e), n.y = r.fromSNorm(i), n.z = 1 - (Math.abs(n.x) + Math.abs(n.y)), n.z < 0) {
                var o = n.x;
                n.x = (1 - Math.abs(n.y)) * r.signNotZero(o), n.y = (1 - Math.abs(o)) * r.signNotZero(n.y)
            }
            return t.normalize(n, n)
        }, o.octPackFloat = function (e) {
            return 256 * e.x + e.y
        };
        var a = new e;
        return o.octEncodeFloat = function (e) {
            return o.octEncode(e, a), o.octPackFloat(a)
        }, o.octDecodeFloat = function (e, t) {
            var i = e / 256, n = Math.floor(i), r = 256 * (i - n);
            return o.octDecode(n, r, t)
        }, o.octPack = function (e, t, i, n) {
            var r = o.octEncodeFloat(e), s = o.octEncodeFloat(t), u = o.octEncode(i, a);
            return n.x = 65536 * u.x + r, n.y = 65536 * u.y + s, n
        }, o.octUnpack = function (e, t, i, n) {
            var r = e.x / 65536, a = Math.floor(r), s = 65536 * (r - a);
            r = e.y / 65536;
            var u = Math.floor(r), l = 65536 * (r - u);
            o.octDecodeFloat(s, t), o.octDecodeFloat(l, i), o.octDecode(a, u, n)
        }, o.compressTextureCoordinates = function (e) {
            var t = 1 === e.x ? 4095 : 4096 * e.x | 0, i = 1 === e.y ? 4095 : 4096 * e.y | 0;
            return 4096 * t + i
        }, o.decompressTextureCoordinates = function (e, t) {
            var i = e / 4096;
            return t.x = Math.floor(i) / 4096,
                t.y = i - Math.floor(i), t
        }, o
    }),define("Cesium/Core/Tipsify", ["./defaultValue", "./defined", "./DeveloperError"], function (e, t, i) {
        "use strict";
        var n = {};
        return n.calculateACMR = function (i) {
            i = e(i, e.EMPTY_OBJECT);
            var n = i.indices, r = i.maximumIndex, o = e(i.cacheSize, 24), a = n.length;
            if (!t(r)) {
                r = 0;
                for (var s = 0, u = n[s]; a > s;)u > r && (r = u), ++s, u = n[s]
            }
            for (var l = [], c = 0; r + 1 > c; c++)l[c] = 0;
            for (var h = o + 1, d = 0; a > d; ++d)h - l[n[d]] > o && (l[n[d]] = h, ++h);
            return (h - o + 1) / (a / 3)
        }, n.tipsify = function (i) {
            function n(e, t, i, n) {
                for (; t.length >= 1;) {
                    var r = t[t.length - 1];
                    if (t.splice(t.length - 1, 1), e[r].numLiveTriangles > 0)return r
                }
                for (; n > o;) {
                    if (e[o].numLiveTriangles > 0)return ++o, o - 1;
                    ++o
                }
                return -1
            }

            function r(e, t, i, r, o, a, s) {
                for (var u, l = -1, c = -1, h = 0; h < i.length;) {
                    var d = i[h];
                    r[d].numLiveTriangles && (u = 0, o - r[d].timeStamp + 2 * r[d].numLiveTriangles <= t && (u = o - r[d].timeStamp), (u > c || -1 === c) && (c = u, l = d)), ++h
                }
                return -1 === l ? n(r, a, e, s) : l
            }

            i = e(i, e.EMPTY_OBJECT);
            var o, a = i.indices, s = i.maximumIndex, u = e(i.cacheSize, 24), l = a.length, c = 0, h = 0, d = a[h], m = l;
            if (t(s))c = s + 1; else {
                for (; m > h;)d > c && (c = d), ++h, d = a[h];
                if (-1 === c)return 0;
                ++c
            }
            for (var p = [], f = 0; c > f; f++)p[f] = {numLiveTriangles: 0, timeStamp: 0, vertexTriangles: []};
            h = 0;
            for (var _ = 0; m > h;)p[a[h]].vertexTriangles.push(_), ++p[a[h]].numLiveTriangles, p[a[h + 1]].vertexTriangles.push(_), ++p[a[h + 1]].numLiveTriangles, p[a[h + 2]].vertexTriangles.push(_), ++p[a[h + 2]].numLiveTriangles, ++_, h += 3;
            var v = 0, g = u + 1;
            o = 1;
            var y, C, E = [], S = [], T = 0, b = [], w = l / 3, x = [];
            for (f = 0; w > f; f++)x[f] = !1;
            for (var A, P; -1 !== v;) {
                E = [], C = p[v], P = C.vertexTriangles.length;
                for (var I = 0; P > I; ++I)if (_ = C.vertexTriangles[I], !x[_]) {
                    x[_] = !0, h = _ + _ + _;
                    for (var D = 0; 3 > D; ++D)A = a[h], E.push(A), S.push(A), b[T] = A, ++T, y = p[A], --y.numLiveTriangles, g - y.timeStamp > u && (y.timeStamp = g, ++g), ++h
                }
                v = r(a, u, E, p, g, S, c)
            }
            return b
        }, n
    }),define("Cesium/Core/GeometryPipeline", ["./AttributeCompression", "./barycentricCoordinates", "./BoundingSphere", "./Cartesian2", "./Cartesian3", "./Cartesian4", "./Cartographic", "./ComponentDatatype", "./defaultValue", "./defined", "./DeveloperError", "./EncodedCartesian3", "./GeographicProjection", "./Geometry", "./GeometryAttribute", "./GeometryInstance", "./GeometryType", "./IndexDatatype", "./Intersect", "./IntersectionTests", "./Math", "./Matrix3", "./Matrix4", "./Plane", "./PrimitiveType", "./Tipsify"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S, T, b, w) {
        "use strict";
        function x(e, t, i, n, r) {
            e[t++] = i, e[t++] = n, e[t++] = n, e[t++] = r, e[t++] = r, e[t] = i
        }

        function A(e) {
            for (var t = e.length, i = t / 3 * 6, n = v.createTypedArray(t, i), r = 0, o = 0; t > o; o += 3, r += 6)x(n, r, e[o], e[o + 1], e[o + 2]);
            return n
        }

        function P(e) {
            var t = e.length;
            if (t >= 3) {
                var i = 6 * (t - 2), n = v.createTypedArray(t, i);
                x(n, 0, e[0], e[1], e[2]);
                for (var r = 6, o = 3; t > o; ++o, r += 6)x(n, r, e[o - 1], e[o], e[o - 2]);
                return n
            }
            return new Uint16Array
        }

        function I(e) {
            if (e.length > 0) {
                for (var t = e.length - 1, i = 6 * (t - 1), n = v.createTypedArray(t, i), r = e[0], o = 0, a = 1; t > a; ++a, o += 6)x(n, o, r, e[a], e[a + 1]);
                return n
            }
            return new Uint16Array
        }

        function D(e) {
            var t = {};
            for (var i in e)if (e.hasOwnProperty(i) && l(e[i]) && l(e[i].values)) {
                var n = e[i];
                t[i] = new p({
                    componentDatatype: n.componentDatatype,
                    componentsPerAttribute: n.componentsPerAttribute,
                    normalize: n.normalize,
                    values: []
                })
            }
            return t
        }

        function M(e, t, i) {
            for (var n in t)if (t.hasOwnProperty(n) && l(t[n]) && l(t[n].values))for (var r = t[n], o = 0; o < r.componentsPerAttribute; ++o)e[n].values.push(r.values[i * r.componentsPerAttribute + o])
        }

        function O(e, t) {
            if (l(t))for (var i = t.values, n = i.length, o = 0; n > o; o += 3)r.unpack(i, o, oe), S.multiplyByPoint(e, oe, oe), r.pack(oe, i, o)
        }

        function R(e, t) {
            if (l(t))for (var i = t.values, n = i.length, o = 0; n > o; o += 3)r.unpack(i, o, oe), E.multiplyByVector(e, oe, oe), oe = r.normalize(oe, oe), r.pack(oe, i, o)
        }

        function N(e, t) {
            var i, n = e.length, r = {}, o = e[0][t].attributes;
            for (i in o)if (o.hasOwnProperty(i) && l(o[i]) && l(o[i].values)) {
                for (var a = o[i], u = a.values.length, c = !0, h = 1; n > h; ++h) {
                    var d = e[h][t].attributes[i];
                    if (!l(d) || a.componentDatatype !== d.componentDatatype || a.componentsPerAttribute !== d.componentsPerAttribute || a.normalize !== d.normalize) {
                        c = !1;
                        break
                    }
                    u += d.values.length
                }
                c && (r[i] = new p({
                    componentDatatype: a.componentDatatype,
                    componentsPerAttribute: a.componentsPerAttribute,
                    normalize: a.normalize,
                    values: s.createTypedArray(a.componentDatatype, u)
                }))
            }
            return r
        }

        function L(e, t) {
            var n, o, a, s, u, c, h, d = e.length, p = (e[0].modelMatrix, l(e[0][t].indices)), f = e[0][t].primitiveType, _ = N(e, t);
            for (n in _)if (_.hasOwnProperty(n))for (u = _[n].values, s = 0, o = 0; d > o; ++o)for (c = e[o][t].attributes[n].values, h = c.length, a = 0; h > a; ++a)u[s++] = c[a];
            var g;
            if (p) {
                var y = 0;
                for (o = 0; d > o; ++o)y += e[o][t].indices.length;
                var C = m.computeNumberOfVertices(new m({
                    attributes: _,
                    primitiveType: b.POINTS
                })), E = v.createTypedArray(C, y), S = 0, T = 0;
                for (o = 0; d > o; ++o) {
                    var w = e[o][t].indices, x = w.length;
                    for (s = 0; x > s; ++s)E[S++] = T + w[s];
                    T += m.computeNumberOfVertices(e[o][t])
                }
                g = E
            }
            var A, P = new r, I = 0;
            for (o = 0; d > o; ++o) {
                if (A = e[o][t].boundingSphere, !l(A)) {
                    P = void 0;
                    break
                }
                r.add(A.center, P, P)
            }
            if (l(P))for (r.divideByScalar(P, d, P), o = 0; d > o; ++o) {
                A = e[o][t].boundingSphere;
                var D = r.magnitude(r.subtract(A.center, P, ue)) + A.radius;
                D > I && (I = D)
            }
            return new m({attributes: _, indices: g, primitiveType: f, boundingSphere: l(P) ? new i(P, I) : void 0})
        }

        function F(e) {
            if (l(e.indices))return e;
            for (var t = m.computeNumberOfVertices(e), i = v.createTypedArray(t, t), n = 0; t > n; ++n)i[n] = n;
            return e.indices = i, e
        }

        function B(e) {
            var t = m.computeNumberOfVertices(e), i = v.createTypedArray(t, 3 * (t - 2));
            i[0] = 1, i[1] = 0, i[2] = 2;
            for (var n = 3, r = 3; t > r; ++r)i[n++] = r - 1, i[n++] = 0, i[n++] = r;
            return e.indices = i, e.primitiveType = b.TRIANGLES, e
        }

        function z(e) {
            var t = m.computeNumberOfVertices(e), i = v.createTypedArray(t, 3 * (t - 2));
            i[0] = 0, i[1] = 1, i[2] = 2, t > 3 && (i[3] = 0, i[4] = 2, i[5] = 3);
            for (var n = 6, r = 3; t - 1 > r; r += 2)i[n++] = r, i[n++] = r - 1, i[n++] = r + 1, t > r + 2 && (i[n++] = r, i[n++] = r + 1, i[n++] = r + 2);
            return e.indices = i, e.primitiveType = b.TRIANGLES, e
        }

        function V(e) {
            if (l(e.indices))return e;
            for (var t = m.computeNumberOfVertices(e), i = v.createTypedArray(t, t), n = 0; t > n; ++n)i[n] = n;
            return e.indices = i, e
        }

        function U(e) {
            var t = m.computeNumberOfVertices(e), i = v.createTypedArray(t, 2 * (t - 1));
            i[0] = 0, i[1] = 1;
            for (var n = 2, r = 2; t > r; ++r)i[n++] = r - 1, i[n++] = r;
            return e.indices = i, e.primitiveType = b.LINES, e
        }

        function k(e) {
            var t = m.computeNumberOfVertices(e), i = v.createTypedArray(t, 2 * t);
            i[0] = 0, i[1] = 1;
            for (var n = 2, r = 2; t > r; ++r)i[n++] = r - 1, i[n++] = r;
            return i[n++] = t - 1, i[n] = 0, e.indices = i, e.primitiveType = b.LINES, e
        }

        function G(e) {
            switch (e.primitiveType) {
                case b.TRIANGLE_FAN:
                    return B(e);
                case b.TRIANGLE_STRIP:
                    return z(e);
                case b.TRIANGLES:
                    return F(e);
                case b.LINE_STRIP:
                    return U(e);
                case b.LINE_LOOP:
                    return k(e);
                case b.LINES:
                    return V(e)
            }
            return e
        }

        function H(e, t) {
            Math.abs(e.y) < C.EPSILON6 && (t ? e.y = -C.EPSILON6 : e.y = C.EPSILON6)
        }

        function W(e, t, i) {
            if (0 !== e.y && 0 !== t.y && 0 !== i.y)return H(e, e.y < 0), H(t, t.y < 0), void H(i, i.y < 0);
            var n, r = Math.abs(e.y), o = Math.abs(t.y), a = Math.abs(i.y);
            n = r > o ? r > a ? C.sign(e.y) : C.sign(i.y) : o > a ? C.sign(t.y) : C.sign(i.y);
            var s = 0 > n;
            H(e, s), H(t, s), H(i, s)
        }

        function q(e, t, i, n) {
            r.add(e, r.multiplyByScalar(r.subtract(t, e, Ce), e.y / (e.y - t.y), Ce), i), r.clone(i, n), H(i, !0), H(n, !1)
        }

        function j(e, t, i) {
            if (e.x >= 0 || t.x >= 0 || i.x >= 0)return void 0;
            W(e, t, i);
            var n = e.y < 0, r = t.y < 0, o = i.y < 0, a = 0;
            a += n ? 1 : 0, a += r ? 1 : 0, a += o ? 1 : 0;
            var s = we.indices;
            1 === a ? (s[1] = 3, s[2] = 4, s[5] = 6, s[7] = 6, s[8] = 5, n ? (q(e, t, Ee, Te), q(e, i, Se, be), s[0] = 0, s[3] = 1, s[4] = 2, s[6] = 1) : r ? (q(t, i, Ee, Te), q(t, e, Se, be), s[0] = 1, s[3] = 2, s[4] = 0, s[6] = 2) : o && (q(i, e, Ee, Te), q(i, t, Se, be), s[0] = 2, s[3] = 0, s[4] = 1, s[6] = 0)) : 2 === a && (s[2] = 4, s[4] = 4, s[5] = 3, s[7] = 5, s[8] = 6, n ? r ? o || (q(i, e, Ee, Te), q(i, t, Se, be), s[0] = 0, s[1] = 1, s[3] = 0, s[6] = 2) : (q(t, i, Ee, Te), q(t, e, Se, be), s[0] = 2, s[1] = 0, s[3] = 2, s[6] = 1) : (q(e, t, Ee, Te), q(e, i, Se, be), s[0] = 1, s[1] = 2, s[3] = 1, s[6] = 0));
            var u = we.positions;
            return u[0] = e, u[1] = t, u[2] = i, u.length = 3, (1 === a || 2 === a) && (u[3] = Ee, u[4] = Se, u[5] = Te, u[6] = be, u.length = 7), we
        }

        function Y(e, t) {
            var n = e.attributes;
            if (0 === n.position.values.length)return void 0;
            for (var r in n)if (n.hasOwnProperty(r) && l(n[r]) && l(n[r].values)) {
                var o = n[r];
                o.values = s.createTypedArray(o.componentDatatype, o.values)
            }
            var a = m.computeNumberOfVertices(e);
            return e.indices = v.createTypedArray(a, e.indices), t && (e.boundingSphere = i.fromVertices(n.position.values)), e
        }

        function X(e) {
            var t = e.attributes, i = {};
            for (var n in t)if (t.hasOwnProperty(n) && l(t[n]) && l(t[n].values)) {
                var r = t[n];
                i[n] = new p({
                    componentDatatype: r.componentDatatype,
                    componentsPerAttribute: r.componentsPerAttribute,
                    normalize: r.normalize,
                    values: []
                })
            }
            return new m({attributes: i, indices: [], primitiveType: e.primitiveType})
        }

        function Z(e, t, i) {
            var n = l(e.geometry.boundingSphere);
            t = Y(t, n), i = Y(i, n), l(i) && !l(t) ? e.geometry = i : !l(i) && l(t) ? e.geometry = t : (e.westHemisphereGeometry = t, e.eastHemisphereGeometry = i, e.geometry = void 0)
        }

        function K(e, i, o, a, s, u, c, h, d, m, p) {
            if (l(u) || l(c) || l(h) || l(d)) {
                var f = r.fromArray(s, 3 * e, xe), _ = r.fromArray(s, 3 * i, Ae), v = r.fromArray(s, 3 * o, Pe), g = t(a, f, _, v, Ie);
                if (l(u)) {
                    var y = r.fromArray(u, 3 * e, xe), C = r.fromArray(u, 3 * i, Ae), E = r.fromArray(u, 3 * o, Pe);
                    r.multiplyByScalar(y, g.x, y), r.multiplyByScalar(C, g.y, C), r.multiplyByScalar(E, g.z, E);
                    var S = r.add(y, C, y);
                    r.add(S, E, S), r.normalize(S, S), r.pack(S, m.normal.values, 3 * p)
                }
                if (l(c)) {
                    var T = r.fromArray(c, 3 * e, xe), b = r.fromArray(c, 3 * i, Ae), w = r.fromArray(c, 3 * o, Pe);
                    r.multiplyByScalar(T, g.x, T), r.multiplyByScalar(b, g.y, b), r.multiplyByScalar(w, g.z, w);
                    var x = r.add(T, b, T);
                    r.add(x, w, x), r.normalize(x, x), r.pack(x, m.binormal.values, 3 * p)
                }
                if (l(h)) {
                    var A = r.fromArray(h, 3 * e, xe), P = r.fromArray(h, 3 * i, Ae), I = r.fromArray(h, 3 * o, Pe);
                    r.multiplyByScalar(A, g.x, A), r.multiplyByScalar(P, g.y, P), r.multiplyByScalar(I, g.z, I);
                    var D = r.add(A, P, A);
                    r.add(D, I, D), r.normalize(D, D), r.pack(D, m.tangent.values, 3 * p)
                }
                if (l(d)) {
                    var M = n.fromArray(d, 2 * e, De), O = n.fromArray(d, 2 * i, Me), R = n.fromArray(d, 2 * o, Oe);
                    n.multiplyByScalar(M, g.x, M), n.multiplyByScalar(O, g.y, O), n.multiplyByScalar(R, g.z, R);
                    var N = n.add(M, O, M);
                    n.add(N, R, N), n.pack(N, m.st.values, 2 * p)
                }
            }
        }

        function J(e, t, i, n, r, o) {
            var a = e.position.values.length / 3;
            if (-1 !== r) {
                var s = n[r], u = i[s];
                return -1 === u ? (i[s] = a, e.position.values.push(o.x, o.y, o.z), t.push(a), a) : (t.push(u), u)
            }
            return e.position.values.push(o.x, o.y, o.z), t.push(a), a
        }

        function Q(e) {
            var t, i, n, o, a, s = e.geometry, u = s.attributes, c = u.position.values, h = l(u.normal) ? u.normal.values : void 0, d = l(u.binormal) ? u.binormal.values : void 0, m = l(u.tangent) ? u.tangent.values : void 0, p = l(u.st) ? u.st.values : void 0, f = s.indices, _ = X(s), v = X(s), g = [];
            g.length = c.length / 3;
            var y = [];
            for (y.length = c.length / 3, a = 0; a < g.length; ++a)g[a] = -1, y[a] = -1;
            var C = f.length;
            for (a = 0; C > a; a += 3) {
                var E = f[a], S = f[a + 1], T = f[a + 2], b = r.fromArray(c, 3 * E), w = r.fromArray(c, 3 * S), x = r.fromArray(c, 3 * T), A = j(b, w, x);
                if (l(A) && A.positions.length > 3)for (var P = A.positions, I = A.indices, D = I.length, M = 0; D > M; ++M) {
                    var O = I[M], R = P[O];
                    R.y < 0 ? (t = v.attributes, i = v.indices, n = g) : (t = _.attributes, i = _.indices, n = y), o = J(t, i, n, f, 3 > O ? a + O : -1, R), K(E, S, T, R, c, h, d, m, p, t, o)
                } else l(A) && (b = A.positions[0], w = A.positions[1], x = A.positions[2]), b.y < 0 ? (t = v.attributes, i = v.indices, n = g) : (t = _.attributes, i = _.indices, n = y), o = J(t, i, n, f, a, b), K(E, S, T, b, c, h, d, m, p, t, o), o = J(t, i, n, f, a + 1, w), K(E, S, T, w, c, h, d, m, p, t, o), o = J(t, i, n, f, a + 2, x), K(E, S, T, x, c, h, d, m, p, t, o)
            }
            Z(e, v, _)
        }

        function $(e) {
            var t, i = e.geometry, n = i.attributes, o = n.position.values, a = i.indices, s = X(i), u = X(i), c = a.length, h = [];
            h.length = o.length / 3;
            var d = [];
            for (d.length = o.length / 3, t = 0; t < h.length; ++t)h[t] = -1, d[t] = -1;
            for (t = 0; c > t; t += 2) {
                var m = a[t], p = a[t + 1], f = r.fromArray(o, 3 * m, xe), _ = r.fromArray(o, 3 * p, Ae);
                Math.abs(f.y) < C.EPSILON6 && (f.y < 0 ? f.y = -C.EPSILON6 : f.y = C.EPSILON6), Math.abs(_.y) < C.EPSILON6 && (_.y < 0 ? _.y = -C.EPSILON6 : _.y = C.EPSILON6);
                var v = s.attributes, g = s.indices, E = d, S = u.attributes, T = u.indices, b = h, w = y.lineSegmentPlane(f, _, Re, Pe);
                if (l(w)) {
                    var x = r.multiplyByScalar(r.UNIT_Y, 5 * C.EPSILON9, Ne);
                    f.y < 0 && (r.negate(x, x), v = u.attributes, g = u.indices, E = h, S = s.attributes, T = s.indices, b = d);
                    var A = r.add(w, x, Le);
                    J(v, g, E, a, t, f), J(v, g, E, a, -1, A), r.negate(x, x), r.add(w, x, A), J(S, T, b, a, -1, A), J(S, T, b, a, t + 1, _)
                } else {
                    var P, I, D;
                    f.y < 0 ? (P = u.attributes, I = u.indices, D = h) : (P = s.attributes, I = s.indices, D = d), J(P, I, D, a, t, f), J(P, I, D, a, t + 1, _)
                }
            }
            Z(e, u, s)
        }

        function ee(e) {
            var t, i, a, s = e.geometry, u = s.attributes, c = u.position.values, h = u.prevPosition.values, d = u.nextPosition.values, m = u.expandAndWidth.values, p = (s.indices, l(u.st) ? u.st.values : void 0), f = l(u.color) ? u.color.values : void 0, _ = X(s), v = X(s), g = c.length / 3;
            for (t = 0; g > t; t += 4) {
                var E = t, S = t + 1, T = t + 2, b = t + 3, w = r.fromArray(c, 3 * E, ze), x = r.fromArray(c, 3 * S, Ve), A = r.fromArray(c, 3 * T, Ue), P = r.fromArray(c, 3 * b, ke);
                Math.abs(w.y) < C.EPSILON6 && (w.y = C.EPSILON6 * (A.y < 0 ? -1 : 1), x.y = w.y), Math.abs(A.y) < C.EPSILON6 && (A.y = C.EPSILON6 * (w.y < 0 ? -1 : 1), P.y = A.y);
                var I = _.attributes, D = _.indices, M = v.attributes, O = v.indices, R = y.lineSegmentPlane(w, A, Re, Ge);
                if (l(R)) {
                    var N = r.multiplyByScalar(r.UNIT_Y, 5 * C.EPSILON9, He);
                    w.y < 0 && (r.negate(N, N), I = v.attributes, D = v.indices, M = _.attributes, O = _.indices);
                    var L = r.add(R, N, We);
                    for (I.position.values.push(w.x, w.y, w.z, x.x, x.y, x.z), I.position.values.push(L.x, L.y, L.z), I.position.values.push(L.x, L.y, L.z), r.negate(N, N), r.add(R, N, L), M.position.values.push(L.x, L.y, L.z), M.position.values.push(L.x, L.y, L.z), M.position.values.push(A.x, A.y, A.z, P.x, P.y, P.z), i = 3 * E; 3 * E + 6 > i; ++i)I.prevPosition.values.push(h[i]);
                    for (I.prevPosition.values.push(w.x, w.y, w.z, w.x, w.y, w.z), M.prevPosition.values.push(w.x, w.y, w.z, w.x, w.y, w.z), i = 3 * T; 3 * T + 6 > i; ++i)M.prevPosition.values.push(h[i]);
                    for (i = 3 * E; 3 * E + 6 > i; ++i)I.nextPosition.values.push(d[i]);
                    for (I.nextPosition.values.push(A.x, A.y, A.z, A.x, A.y, A.z), M.nextPosition.values.push(A.x, A.y, A.z, A.x, A.y, A.z), i = 3 * T; 3 * T + 6 > i; ++i)M.nextPosition.values.push(d[i]);
                    var F = n.fromArray(m, 2 * E, Fe), B = Math.abs(F.y);
                    I.expandAndWidth.values.push(-1, B, 1, B), I.expandAndWidth.values.push(-1, -B, 1, -B), M.expandAndWidth.values.push(-1, B, 1, B), M.expandAndWidth.values.push(-1, -B, 1, -B);
                    var z = r.magnitudeSquared(r.subtract(R, w, ke));
                    if (z /= r.magnitudeSquared(r.subtract(A, w, ke)), l(f)) {
                        var V = o.fromArray(f, 4 * E, qe), U = o.fromArray(f, 4 * T, qe), k = C.lerp(V.x, U.x, z), G = C.lerp(V.y, U.y, z), H = C.lerp(V.z, U.z, z), W = C.lerp(V.w, U.w, z);
                        for (i = 4 * E; 4 * E + 8 > i; ++i)I.color.values.push(f[i]);
                        for (I.color.values.push(k, G, H, W), I.color.values.push(k, G, H, W), M.color.values.push(k, G, H, W), M.color.values.push(k, G, H, W), i = 4 * T; 4 * T + 8 > i; ++i)M.color.values.push(f[i])
                    }
                    if (l(p)) {
                        var q = n.fromArray(p, 2 * E, Fe), j = n.fromArray(p, 2 * (t + 3), Be), Y = C.lerp(q.x, j.x, z);
                        for (i = 2 * E; 2 * E + 4 > i; ++i)I.st.values.push(p[i]);
                        for (I.st.values.push(Y, q.y), I.st.values.push(Y, j.y), M.st.values.push(Y, q.y), M.st.values.push(Y, j.y), i = 2 * T; 2 * T + 4 > i; ++i)M.st.values.push(p[i])
                    }
                    a = I.position.values.length / 3 - 4, D.push(a, a + 2, a + 1), D.push(a + 1, a + 2, a + 3), a = M.position.values.length / 3 - 4, O.push(a, a + 2, a + 1), O.push(a + 1, a + 2, a + 3)
                } else {
                    var K, J;
                    for (w.y < 0 ? (K = v.attributes, J = v.indices) : (K = _.attributes, J = _.indices), K.position.values.push(w.x, w.y, w.z), K.position.values.push(x.x, x.y, x.z), K.position.values.push(A.x, A.y, A.z), K.position.values.push(P.x, P.y, P.z), i = 3 * t; 3 * t + 12 > i; ++i)K.prevPosition.values.push(h[i]), K.nextPosition.values.push(d[i]);
                    for (i = 2 * t; 2 * t + 8 > i; ++i)K.expandAndWidth.values.push(m[i]), l(p) && K.st.values.push(p[i]);
                    if (l(f))for (i = 4 * t; 4 * t + 16 > i; ++i)K.color.values.push(f[i]);
                    a = K.position.values.length / 3 - 4, J.push(a, a + 2, a + 1), J.push(a + 1, a + 2, a + 3)
                }
            }
            Z(e, v, _)
        }

        var te = {};
        te.toWireframe = function (e) {
            var t = e.indices;
            if (l(t)) {
                switch (e.primitiveType) {
                    case b.TRIANGLES:
                        e.indices = A(t);
                        break;
                    case b.TRIANGLE_STRIP:
                        e.indices = P(t);
                        break;
                    case b.TRIANGLE_FAN:
                        e.indices = I(t);
                        break;
                    default:
                        throw new c("geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.")
                }
                e.primitiveType = b.LINES
            }
            return e
        }, te.createLineSegmentsForVectors = function (e, t, n) {
            t = u(t, "normal"), n = u(n, 1e4);
            for (var r = e.attributes.position.values, o = e.attributes[t].values, a = r.length, c = new Float64Array(2 * a), h = 0, d = 0; a > d; d += 3)c[h++] = r[d], c[h++] = r[d + 1], c[h++] = r[d + 2], c[h++] = r[d] + o[d] * n, c[h++] = r[d + 1] + o[d + 1] * n, c[h++] = r[d + 2] + o[d + 2] * n;
            var f, _ = e.boundingSphere;
            return l(_) && (f = new i(_.center, _.radius + n)), new m({
                attributes: {
                    position: new p({
                        componentDatatype: s.DOUBLE,
                        componentsPerAttribute: 3,
                        values: c
                    })
                }, primitiveType: b.LINES, boundingSphere: f
            })
        }, te.createAttributeLocations = function (e) {
            var t, i = ["position", "positionHigh", "positionLow", "position3DHigh", "position3DLow", "position2DHigh", "position2DLow", "pickColor", "normal", "st", "binormal", "tangent", "compressedAttributes"], n = e.attributes, r = {}, o = 0, a = i.length;
            for (t = 0; a > t; ++t) {
                var s = i[t];
                l(n[s]) && (r[s] = o++)
            }
            for (var u in n)n.hasOwnProperty(u) && !l(r[u]) && (r[u] = o++);
            return r
        }, te.reorderForPreVertexCache = function (e) {
            var t = m.computeNumberOfVertices(e), i = e.indices;
            if (l(i)) {
                for (var n = new Int32Array(t), r = 0; t > r; r++)n[r] = -1;
                for (var o, a = i, u = a.length, c = v.createTypedArray(t, u), h = 0, d = 0, p = 0; u > h;)o = n[a[h]], -1 !== o ? c[d] = o : (o = a[h], n[o] = p, c[d] = p, ++p), ++h, ++d;
                e.indices = c;
                var f = e.attributes;
                for (var _ in f)if (f.hasOwnProperty(_) && l(f[_]) && l(f[_].values)) {
                    for (var g = f[_], y = g.values, C = 0, E = g.componentsPerAttribute, S = s.createTypedArray(g.componentDatatype, p * E); t > C;) {
                        var T = n[C];
                        if (-1 !== T)for (r = 0; E > r; r++)S[E * T + r] = y[E * C + r];
                        ++C
                    }
                    g.values = S
                }
            }
            return e
        }, te.reorderForPostVertexCache = function (e, t) {
            var i = e.indices;
            if (e.primitiveType === b.TRIANGLES && l(i)) {
                for (var n = i.length, r = 0, o = 0; n > o; o++)i[o] > r && (r = i[o]);
                e.indices = w.tipsify({indices: i, maximumIndex: r, cacheSize: t})
            }
            return e
        }, te.fitToUnsignedShortIndices = function (e) {
            var t = [], i = m.computeNumberOfVertices(e);
            if (l(e.indices) && i > C.SIXTY_FOUR_KILOBYTES) {
                var n, r = [], o = [], a = 0, s = D(e.attributes), u = e.indices, c = u.length;
                e.primitiveType === b.TRIANGLES ? n = 3 : e.primitiveType === b.LINES ? n = 2 : e.primitiveType === b.POINTS && (n = 1);
                for (var h = 0; c > h; h += n) {
                    for (var d = 0; n > d; ++d) {
                        var p = u[h + d], f = r[p];
                        l(f) || (f = a++, r[p] = f, M(s, e.attributes, p)), o.push(f)
                    }
                    a + n > C.SIXTY_FOUR_KILOBYTES && (t.push(new m({
                        attributes: s,
                        indices: o,
                        primitiveType: e.primitiveType,
                        boundingSphere: e.boundingSphere,
                        boundingSphereCV: e.boundingSphereCV
                    })), r = [], o = [], a = 0, s = D(e.attributes))
                }
                0 !== o.length && t.push(new m({
                    attributes: s,
                    indices: o,
                    primitiveType: e.primitiveType,
                    boundingSphere: e.boundingSphere,
                    boundingSphereCV: e.boundingSphereCV
                }))
            } else t.push(e);
            return t
        };
        var ie = new r, ne = new a;
        te.projectTo2D = function (e, t, i, n, o) {
            var a = e.attributes[t];
            o = l(o) ? o : new d;
            for (var u = o.ellipsoid, h = a.values, m = new Float64Array(h.length), f = 0, _ = 0; _ < h.length; _ += 3) {
                var v = r.fromArray(h, _, ie), g = u.cartesianToCartographic(v, ne);
                if (!l(g))throw new c("Could not project point (" + v.x + ", " + v.y + ", " + v.z + ") to 2D.");
                var y = o.project(g, ie);
                m[f++] = y.x, m[f++] = y.y, m[f++] = y.z
            }
            return e.attributes[i] = a, e.attributes[n] = new p({
                componentDatatype: s.DOUBLE,
                componentsPerAttribute: 3,
                values: m
            }), delete e.attributes[t], e
        };
        var re = {high: 0, low: 0};
        te.encodeAttribute = function (e, t, i, n) {
            for (var r = e.attributes[t], o = r.values, a = o.length, u = new Float32Array(a), l = new Float32Array(a), c = 0; a > c; ++c)h.encode(o[c], re), u[c] = re.high, l[c] = re.low;
            var d = r.componentsPerAttribute;
            return e.attributes[i] = new p({
                componentDatatype: s.FLOAT,
                componentsPerAttribute: d,
                values: u
            }), e.attributes[n] = new p({
                componentDatatype: s.FLOAT,
                componentsPerAttribute: d,
                values: l
            }), delete e.attributes[t], e
        };
        var oe = new r, ae = new S, se = new E;
        te.transformToWorldCoordinates = function (e) {
            var t = e.modelMatrix;
            if (S.equals(t, S.IDENTITY))return e;
            var n = e.geometry.attributes;
            O(t, n.position), O(t, n.prevPosition), O(t, n.nextPosition), (l(n.normal) || l(n.binormal) || l(n.tangent)) && (S.inverse(t, ae), S.transpose(ae, ae), S.getRotation(ae, se), R(se, n.normal), R(se, n.binormal), R(se, n.tangent));
            var r = e.geometry.boundingSphere;
            return l(r) && (e.geometry.boundingSphere = i.transform(r, t, r)), e.modelMatrix = S.clone(S.IDENTITY), e
        };
        var ue = new r;
        te.combineInstances = function (e) {
            for (var t = [], i = [], n = e.length, r = 0; n > r; ++r) {
                var o = e[r];
                l(o.geometry) ? t.push(o) : i.push(o)
            }
            var a = [];
            return t.length > 0 && a.push(L(t, "geometry")), i.length > 0 && (a.push(L(i, "westHemisphereGeometry")), a.push(L(i, "eastHemisphereGeometry"))), a
        };
        var le = new r, ce = new r, he = new r, de = new r;
        te.computeNormal = function (e) {
            for (var t = e.indices, i = e.attributes, n = i.position.values, o = i.position.values.length / 3, a = t.length, u = new Array(o), l = new Array(a / 3), c = new Array(a), h = 0; o > h; h++)u[h] = {
                indexOffset: 0,
                count: 0,
                currentCount: 0
            };
            var d = 0;
            for (h = 0; a > h; h += 3) {
                var m = t[h], f = t[h + 1], _ = t[h + 2], v = 3 * m, g = 3 * f, y = 3 * _;
                ce.x = n[v], ce.y = n[v + 1], ce.z = n[v + 2], he.x = n[g], he.y = n[g + 1], he.z = n[g + 2], de.x = n[y], de.y = n[y + 1], de.z = n[y + 2], u[m].count++, u[f].count++, u[_].count++, r.subtract(he, ce, he), r.subtract(de, ce, de), l[d] = r.cross(he, de, new r), d++
            }
            var C = 0;
            for (h = 0; o > h; h++)u[h].indexOffset += C, C += u[h].count;
            d = 0;
            var E;
            for (h = 0; a > h; h += 3) {
                E = u[t[h]];
                var S = E.indexOffset + E.currentCount;
                c[S] = d, E.currentCount++, E = u[t[h + 1]], S = E.indexOffset + E.currentCount, c[S] = d, E.currentCount++, E = u[t[h + 2]], S = E.indexOffset + E.currentCount, c[S] = d, E.currentCount++, d++
            }
            var T = new Float32Array(3 * o);
            for (h = 0; o > h; h++) {
                var b = 3 * h;
                if (E = u[h], E.count > 0) {
                    for (r.clone(r.ZERO, le), d = 0; d < E.count; d++)r.add(le, l[c[E.indexOffset + d]], le);
                    r.normalize(le, le), T[b] = le.x, T[b + 1] = le.y, T[b + 2] = le.z
                } else T[b] = 0, T[b + 1] = 0, T[b + 2] = 1
            }
            return e.attributes.normal = new p({componentDatatype: s.FLOAT, componentsPerAttribute: 3, values: T}), e
        };
        var me = new r, pe = new r, fe = new r;
        te.computeBinormalAndTangent = function (e) {
            for (var t = (e.attributes, e.indices), i = e.attributes.position.values, n = e.attributes.normal.values, o = e.attributes.st.values, a = e.attributes.position.values.length / 3, u = t.length, l = new Array(3 * a), c = 0; c < l.length; c++)l[c] = 0;
            var h, d, m;
            for (c = 0; u > c; c += 3) {
                var f = t[c], _ = t[c + 1], v = t[c + 2];
                h = 3 * f, d = 3 * _, m = 3 * v;
                var g = 2 * f, y = 2 * _, C = 2 * v, E = i[h], S = i[h + 1], T = i[h + 2], b = o[g], w = o[g + 1], x = o[y + 1] - w, A = o[C + 1] - w, P = 1 / ((o[y] - b) * A - (o[C] - b) * x), I = (A * (i[d] - E) - x * (i[m] - E)) * P, D = (A * (i[d + 1] - S) - x * (i[m + 1] - S)) * P, M = (A * (i[d + 2] - T) - x * (i[m + 2] - T)) * P;
                l[h] += I, l[h + 1] += D, l[h + 2] += M, l[d] += I, l[d + 1] += D, l[d + 2] += M, l[m] += I, l[m + 1] += D, l[m + 2] += M
            }
            var O = new Float32Array(3 * a), R = new Float32Array(3 * a);
            for (c = 0; a > c; c++) {
                h = 3 * c, d = h + 1, m = h + 2;
                var N = r.fromArray(n, h, me), L = r.fromArray(l, h, fe), F = r.dot(N, L);
                r.multiplyByScalar(N, F, pe), r.normalize(r.subtract(L, pe, L), L), R[h] = L.x, R[d] = L.y, R[m] = L.z, r.normalize(r.cross(N, L, L), L), O[h] = L.x, O[d] = L.y, O[m] = L.z
            }
            return e.attributes.tangent = new p({
                componentDatatype: s.FLOAT,
                componentsPerAttribute: 3,
                values: R
            }), e.attributes.binormal = new p({componentDatatype: s.FLOAT, componentsPerAttribute: 3, values: O}), e
        };
        var _e = new n, ve = new r, ge = new r, ye = new r;
        te.compressVertices = function (t) {
            var i = t.attributes.normal, o = t.attributes.st;
            if (!l(i) && !l(o))return t;
            var a, u, c, h, d = t.attributes.tangent, m = t.attributes.binormal;
            l(i) && (a = i.values), l(o) && (u = o.values), l(d) && (c = d.values), m && (h = m.values);
            var f = l(a) ? a.length : u.length, _ = l(a) ? 3 : 2, v = f / _, g = v, y = l(u) && l(a) ? 2 : 1;
            y += l(c) || l(h) ? 1 : 0, g *= y;
            for (var C = new Float32Array(g), E = 0, S = 0; v > S; ++S) {
                l(u) && (n.fromArray(u, 2 * S, _e), C[E++] = e.compressTextureCoordinates(_e));
                var T = 3 * S;
                l(a) && l(c) && l(h) ? (r.fromArray(a, T, ve), r.fromArray(c, T, ge), r.fromArray(h, T, ye), e.octPack(ve, ge, ye, _e), C[E++] = _e.x, C[E++] = _e.y) : (l(a) && (r.fromArray(a, T, ve), C[E++] = e.octEncodeFloat(ve)), l(c) && (r.fromArray(c, T, ve), C[E++] = e.octEncodeFloat(ve)), l(h) && (r.fromArray(h, T, ve), C[E++] = e.octEncodeFloat(ve)))
            }
            return t.attributes.compressedAttributes = new p({
                componentDatatype: s.FLOAT,
                componentsPerAttribute: y,
                values: C
            }), l(a) && delete t.attributes.normal, l(u) && delete t.attributes.st, l(c) && delete t.attributes.tangent, l(h) && delete t.attributes.binormal, t
        };
        var Ce = new r, Ee = new r, Se = new r, Te = new r, be = new r, we = {
            positions: new Array(7),
            indices: new Array(9)
        }, xe = new r, Ae = new r, Pe = new r, Ie = new r, De = new n, Me = new n, Oe = new n, Re = T.fromPointNormal(r.ZERO, r.UNIT_Y), Ne = new r, Le = new r, Fe = new n, Be = new n, ze = new r, Ve = new r, Ue = new r, ke = new r, Ge = new r, He = new r, We = new r, qe = new o;
        new o;
        return te.splitLongitude = function (e) {
            var t = e.geometry, n = t.boundingSphere;
            if (l(n)) {
                var r = n.center.x - n.radius;
                if (r > 0 || i.intersectPlane(n, T.ORIGIN_ZX_PLANE) !== g.INTERSECTING)return e
            }
            if (t.geometryType !== _.NONE)switch (t.geometryType) {
                case _.POLYLINES:
                    ee(e);
                    break;
                case _.TRIANGLES:
                    Q(e);
                    break;
                case _.LINES:
                    $(e)
            } else G(t), t.primitiveType === b.TRIANGLES ? Q(e) : t.primitiveType === b.LINES && $(e);
            return e
        }, te
    }),define("Cesium/Core/WebMercatorProjection", ["./Cartesian3", "./Cartographic", "./defaultValue", "./defined", "./defineProperties", "./DeveloperError", "./Ellipsoid", "./Math"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        var u = function (e) {
            this._ellipsoid = i(e, a.WGS84), this._semimajorAxis = this._ellipsoid.maximumRadius, this._oneOverSemimajorAxis = 1 / this._semimajorAxis
        };
        return r(u.prototype, {
            ellipsoid: {
                get: function () {
                    return this._ellipsoid
                }
            }
        }), u.mercatorAngleToGeodeticLatitude = function (e) {
            return s.PI_OVER_TWO - 2 * Math.atan(Math.exp(-e))
        }, u.geodeticLatitudeToMercatorAngle = function (e) {
            e > u.MaximumLatitude ? e = u.MaximumLatitude : e < -u.MaximumLatitude && (e = -u.MaximumLatitude);
            var t = Math.sin(e);
            return .5 * Math.log((1 + t) / (1 - t))
        }, u.MaximumLatitude = u.mercatorAngleToGeodeticLatitude(Math.PI), u.prototype.project = function (t, i) {
            var r = this._semimajorAxis, o = t.longitude * r, a = u.geodeticLatitudeToMercatorAngle(t.latitude) * r, s = t.height;
            return n(i) ? (i.x = o, i.y = a, i.z = s, i) : new e(o, a, s)
        }, u.prototype.unproject = function (e, i) {
            var r = this._oneOverSemimajorAxis, o = e.x * r, a = u.mercatorAngleToGeodeticLatitude(e.y * r), s = e.z;
            return n(i) ? (i.longitude = o, i.latitude = a, i.height = s, i) : new t(o, a, s)
        }, u
    }),define("Cesium/Scene/PrimitivePipeline", ["../Core/BoundingSphere", "../Core/Color", "../Core/ComponentDatatype", "../Core/defaultValue", "../Core/defined", "../Core/DeveloperError", "../Core/Ellipsoid", "../Core/FeatureDetection", "../Core/GeographicProjection", "../Core/Geometry", "../Core/GeometryAttribute", "../Core/GeometryAttributes", "../Core/GeometryPipeline", "../Core/IndexDatatype", "../Core/Matrix4", "../Core/WebMercatorProjection"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f) {
        "use strict";
        function _(e, t, i) {
            var n, r = !i, o = e.length;
            if (!r && o > 1) {
                var a = e[0].modelMatrix;
                for (n = 1; o > n; ++n)if (!p.equals(a, e[n].modelMatrix)) {
                    r = !0;
                    break
                }
            }
            if (r)for (n = 0; o > n; ++n)d.transformToWorldCoordinates(e[n]); else p.multiplyTransformation(t, e[0].modelMatrix, t)
        }

        function v(e, n) {
            var r = e.attributes, o = r.position, a = 4 * (o.values.length / o.componentsPerAttribute);
            r.pickColor = new c({
                componentDatatype: i.UNSIGNED_BYTE,
                componentsPerAttribute: 4,
                normalize: !0,
                values: new Uint8Array(a)
            });
            for (var s = t.floatToByte(n.red), u = t.floatToByte(n.green), l = t.floatToByte(n.blue), h = t.floatToByte(n.alpha), d = r.pickColor.values, m = 0; a > m; m += 4)d[m] = s, d[m + 1] = u, d[m + 2] = l, d[m + 3] = h
        }

        function g(e, t) {
            for (var i = e.length, n = 0; i > n; ++n) {
                var o = e[n], a = t[n];
                r(o.geometry) ? v(o.geometry, a) : (v(o.westHemisphereGeometry, a), v(o.eastHemisphereGeometry, a))
            }
        }

        function y(e) {
            var t, i = e.length, n = [], o = e[0].attributes;
            for (t in o)if (o.hasOwnProperty(t)) {
                for (var a = o[t], s = !0, u = 1; i > u; ++u) {
                    var l = e[u].attributes[t];
                    if (!r(l) || a.componentDatatype !== l.componentDatatype || a.componentsPerAttribute !== l.componentsPerAttribute || a.normalize !== l.normalize) {
                        s = !1;
                        break
                    }
                }
                s && n.push(t)
            }
            return n
        }

        function C(e, t, n) {
            for (var r = l.computeNumberOfVertices(t), o = n.length, a = 0; o > a; ++a) {
                for (var s = n[a], u = e[s], h = u.componentDatatype, d = u.value, m = d.length, p = i.createTypedArray(h, r * m), f = 0; r > f; ++f)p.set(d, f * m);
                t.attributes[s] = new c({
                    componentDatatype: h,
                    componentsPerAttribute: m,
                    normalize: u.normalize,
                    values: p
                })
            }
        }

        function E(e, t) {
            for (var i = e.length, n = 0; i > n; ++n) {
                var o = e[n], a = o.attributes;
                r(o.geometry) ? C(a, o.geometry, t) : (C(a, o.westHemisphereGeometry, t), C(a, o.eastHemisphereGeometry, t))
            }
        }

        function S(t) {
            var n, o, a = t.instances, s = t.pickIds, u = t.projection, l = t.elementIndexUintSupported, c = t.scene3DOnly, h = t.allowPicking, m = t.vertexCacheOptimize, p = t.compressVertices, f = t.modelMatrix, v = a.length;
            a[0].geometry.primitiveType;
            if (_(a, f, c), !c)for (n = 0; v > n; ++n)d.splitLongitude(a[n]);
            h && g(a, s);
            var C = y(a);
            if (E(a, C), m)for (n = 0; v > n; ++n) {
                var S = a[n];
                r(S.geometry) ? (d.reorderForPostVertexCache(S.geometry), d.reorderForPreVertexCache(S.geometry)) : (d.reorderForPostVertexCache(S.westHemisphereGeometry), d.reorderForPreVertexCache(S.westHemisphereGeometry), d.reorderForPostVertexCache(S.eastHemisphereGeometry), d.reorderForPreVertexCache(S.eastHemisphereGeometry))
            }
            var T = d.combineInstances(a);
            for (v = T.length, n = 0; v > n; ++n) {
                o = T[n];
                var b, w = o.attributes;
                if (c)for (b in w)w.hasOwnProperty(b) && w[b].componentDatatype === i.DOUBLE && d.encodeAttribute(o, b, b + "3DHigh", b + "3DLow"); else for (b in w)if (w.hasOwnProperty(b) && w[b].componentDatatype === i.DOUBLE) {
                    var x = b + "3D", A = b + "2D";
                    d.projectTo2D(o, b, x, A, u), r(o.boundingSphere) && "position" === b && (o.boundingSphereCV = e.fromVertices(o.attributes.position2D.values)), d.encodeAttribute(o, x, x + "High", x + "Low"), d.encodeAttribute(o, A, A + "High", A + "Low")
                }
                p && d.compressVertices(o)
            }
            if (!l) {
                var P = [];
                for (v = T.length, n = 0; v > n; ++n)o = T[n], P = P.concat(d.fitToUnsignedShortIndices(o));
                T = P
            }
            return T
        }

        function T(e, t, n) {
            for (var r = [], o = e.attributes, a = n.length, s = 0; a > s; ++s) {
                var u = n[s], l = o[u], c = l.componentDatatype;
                c === i.DOUBLE && (c = i.FLOAT);
                var h = i.createTypedArray(c, l.values);
                r.push({
                    index: t[u],
                    componentDatatype: c,
                    componentsPerAttribute: l.componentsPerAttribute,
                    normalize: l.normalize,
                    values: h
                }), delete o[u]
            }
            return r
        }

        function b(e, t, i, o, a, s, u, c, h) {
            var d = l.computeNumberOfVertices(t);
            r(u[e]) || (u[e] = {boundingSphere: t.boundingSphere, boundingSphereCV: t.boundingSphereCV});
            for (var m = o.length, p = 0; m > p; ++p)for (var f = o[p], _ = a[f], v = d; v > 0;) {
                for (var g, y = n(h[f], 0), C = s[y], E = C.length, S = 0; E > S && (g = C[S], g.index !== _); ++S);
                r(u[e][f]) || (u[e][f] = {dirty: !1, valid: !0, value: i[f].value, indices: []});
                var T, b = g.values.length / g.componentsPerAttribute, w = n(c[f], 0);
                b > w + v ? (T = v, u[e][f].indices.push({
                    attribute: g,
                    offset: w,
                    count: T
                }), c[f] = w + v) : (T = b - w, u[e][f].indices.push({
                    attribute: g,
                    offset: w,
                    count: T
                }), c[f] = 0, h[f] = y + 1), v -= T
            }
        }

        function w(e, t, i, n, o) {
            var a, s, u, l = [], c = e.length, h = {}, d = {};
            for (a = 0; c > a; ++a)s = e[a], u = s.attributes, r(s.geometry) && b(a, s.geometry, u, o, n, i, l, h, d);
            for (a = 0; c > a; ++a)s = e[a], u = s.attributes, r(s.westHemisphereGeometry) && b(a, s.westHemisphereGeometry, u, o, n, i, l, h, d);
            for (a = 0; c > a; ++a)s = e[a], u = s.attributes, r(s.eastHemisphereGeometry) && b(a, s.eastHemisphereGeometry, u, o, n, i, l, h, d);
            for (c = t.length, a = 0; c > a; ++a) {
                s = t[a], u = s.attributes;
                var m = {};
                l.push(m);
                for (var p = o.length, f = 0; p > f; ++f) {
                    var _ = o[f];
                    m[_] = {dirty: !1, valid: !1, value: u[_].value, indices: []}
                }
            }
            return l
        }

        function x(e, t) {
            var i = e.attributes;
            for (var n in i)if (i.hasOwnProperty(n)) {
                var o = i[n];
                r(o) && r(o.values) && t.push(o.values.buffer)
            }
            r(e.indices) && t.push(e.indices.buffer)
        }

        function A(e, t) {
            for (var i = e.length, n = 0; i > n; ++n)x(e[n], t)
        }

        function P(e, t) {
            for (var i = e.length, n = 0; i > n; ++n)for (var r = e[n], o = r.length, a = 0; o > a; ++a)t.push(r[a].values.buffer)
        }

        function I(t) {
            for (var i = 1, n = t.length, o = 0; n > o; o++) {
                var a = t[o];
                if (++i, r(a)) {
                    var s = a.attributes;
                    i += 6 + 2 * e.packedLength + (r(a.indices) ? a.indices.length : 0);
                    for (var u in s)if (s.hasOwnProperty(u) && r(s[u])) {
                        var l = s[u];
                        i += 5 + l.values.length
                    }
                }
            }
            return i
        }

        function D(e, t) {
            for (var i = e.length, n = new Uint32Array(e.length), r = 0; i > r; ++r)n[r] = e[r].toRgba();
            return t.push(n.buffer), n
        }

        function M(e) {
            for (var i = e.length, n = new Array(i), r = 0; i > r; r++)n[r] = t.fromRgba(e[r]);
            return n
        }

        function O(e) {
            for (var t = e.length, i = 1 + 17 * t, n = 0; t > n; n++) {
                var o = e[n].attributes;
                for (var a in o)if (o.hasOwnProperty(a) && r(o[a])) {
                    var s = o[a];
                    i += 5 + s.value.length
                }
            }
            return i
        }

        function R(e, t) {
            var i = new Float64Array(O(e)), n = {}, o = [], a = e.length, s = 0;
            i[s++] = a;
            for (var u = 0; a > u; u++) {
                var l = e[u];
                p.pack(l.modelMatrix, i, s), s += p.packedLength;
                var c = l.attributes, h = [];
                for (var d in c)c.hasOwnProperty(d) && r(c[d]) && (h.push(d), r(n[d]) || (n[d] = o.length, o.push(d)));
                i[s++] = h.length;
                for (var m = 0; m < h.length; m++) {
                    var f = h[m], _ = c[f];
                    i[s++] = n[f], i[s++] = _.componentDatatype, i[s++] = _.componentsPerAttribute, i[s++] = _.normalize, i[s++] = _.value.length, i.set(_.value, s), s += _.value.length
                }
            }
            return t.push(i.buffer), {stringTable: o, packedData: i}
        }

        function N(e) {
            for (var t = e.packedData, n = e.stringTable, r = new Array(t[0]), o = 0, a = 1; a < t.length;) {
                var s = p.unpack(t, a);
                a += p.packedLength;
                for (var u = {}, l = t[a++], c = 0; l > c; c++) {
                    for (var h = n[t[a++]], d = t[a++], m = t[a++], f = 0 !== t[a++], _ = t[a++], v = i.createTypedArray(d, _), g = 0; _ > g; g++)v[g] = t[a++];
                    u[h] = {componentDatatype: d, componentsPerAttribute: m, normalize: f, value: v}
                }
                r[o++] = {attributes: u, modelMatrix: s}
            }
            return r
        }

        function L(t) {
            for (var i = t.length, n = 1 + i, o = 0; i > o; o++) {
                var a = t[o];
                n += 2, n += r(a.boundingSphere) ? e.packedLength : 0, n += r(a.boundingSphereCV) ? e.packedLength : 0;
                for (var s in a)if (a.hasOwnProperty(s) && r(a[s]) && "boundingSphere" !== s && "boundingSphereCV" !== s) {
                    var u = a[s];
                    n += 4 + 3 * u.indices.length + u.value.length
                }
            }
            return n
        }

        function F(t, i) {
            var n = new Float64Array(L(t)), o = [], a = [], s = {}, u = t.length, l = 0;
            n[l++] = u;
            for (var c = 0; u > c; c++) {
                var h = t[c], d = h.boundingSphere, m = r(d);
                n[l++] = m ? 1 : 0, m && (e.pack(d, n, l), l += e.packedLength), d = h.boundingSphereCV, m = r(d), n[l++] = m ? 1 : 0, m && (e.pack(d, n, l), l += e.packedLength);
                var p = [];
                for (var f in h)h.hasOwnProperty(f) && r(h[f]) && "boundingSphere" !== f && "boundingSphereCV" !== f && (p.push(f), r(s[f]) || (s[f] = o.length, o.push(f)));
                n[l++] = p.length;
                for (var _ = 0; _ < p.length; _++) {
                    var v = p[_], g = h[v];
                    n[l++] = s[v], n[l++] = g.valid ? 1 : 0;
                    var y = g.indices, C = y.length;
                    n[l++] = C;
                    for (var E = 0; C > E; E++) {
                        var S = y[E];
                        n[l++] = S.count, n[l++] = S.offset;
                        var T = a.indexOf(S.attribute);
                        -1 === T && (T = a.length, a.push(S.attribute)), n[l++] = T
                    }
                    n[l++] = g.value.length, n.set(g.value, l),
                        l += g.value.length
                }
            }
            return i.push(n.buffer), {stringTable: o, packedData: n, attributeTable: a}
        }

        function B(t, n) {
            for (var r = t.stringTable, o = t.attributeTable, a = t.packedData, s = new Array(a[0]), u = 0, l = 1, c = a.length; c > l;) {
                var h = {}, d = 1 === a[l++];
                d && (h.boundingSphere = e.unpack(a, l), l += e.packedLength), d = 1 === a[l++], d && (h.boundingSphereCV = e.unpack(a, l), l += e.packedLength);
                for (var m = a[l++], p = 0; m > p; p++) {
                    for (var f = r[a[l++]], _ = 1 === a[l++], v = a[l++], g = v > 0 ? new Array(v) : void 0, y = 0; v > y; y++) {
                        var C = {};
                        C.count = a[l++], C.offset = a[l++], C.attribute = o[a[l++]], g[y] = C
                    }
                    for (var E = a[l++], S = _ ? i.createTypedArray(g[0].attribute.componentDatatype, E) : new Array(E), T = 0; E > T; T++)S[T] = a[l++];
                    h[f] = {dirty: !1, valid: _, indices: g, value: S}
                }
                s[u++] = h
            }
            return s
        }

        if (!s.supportsTypedArrays())return {};
        var z = {};
        return z.combineGeometry = function (e) {
            var t, i, n, o, a, s = e.instances, u = e.invalidInstances;
            if (s.length > 0) {
                t = S(e), i = d.createAttributeLocations(t[0]), o = y(s), n = [], a = t.length;
                for (var l = 0; a > l; ++l) {
                    var c = t[l];
                    n.push(T(c, i, o))
                }
            }
            o = r(o) ? o : y(u);
            var h = w(s, u, n, i, o);
            return {
                geometries: t,
                modelMatrix: e.modelMatrix,
                attributeLocations: i,
                vaAttributes: n,
                vaAttributeLocations: h,
                validInstancesIndices: e.validInstancesIndices,
                invalidInstancesIndices: e.invalidInstancesIndices
            }
        }, z.packCreateGeometryResults = function (t, i) {
            var n = new Float64Array(I(t)), o = [], a = {}, s = t.length, u = 0;
            n[u++] = s;
            for (var l = 0; s > l; l++) {
                var c = t[l], h = r(c);
                if (n[u++] = h ? 1 : 0, h) {
                    n[u++] = c.primitiveType, n[u++] = c.geometryType;
                    var d = r(c.boundingSphere) ? 1 : 0;
                    n[u++] = d, d && e.pack(c.boundingSphere, n, u), u += e.packedLength;
                    var m = r(c.boundingSphereCV) ? 1 : 0;
                    n[u++] = m, m && e.pack(c.boundingSphereCV, n, u), u += e.packedLength;
                    var p = c.attributes, f = [];
                    for (var _ in p)p.hasOwnProperty(_) && r(p[_]) && (f.push(_), r(a[_]) || (a[_] = o.length, o.push(_)));
                    n[u++] = f.length;
                    for (var v = 0; v < f.length; v++) {
                        var g = f[v], y = p[g];
                        n[u++] = a[g], n[u++] = y.componentDatatype, n[u++] = y.componentsPerAttribute, n[u++] = y.normalize ? 1 : 0, n[u++] = y.values.length, n.set(y.values, u), u += y.values.length
                    }
                    var C = r(c.indices) ? c.indices.length : 0;
                    n[u++] = C, C > 0 && (n.set(c.indices, u), u += C)
                }
            }
            return i.push(n.buffer), {stringTable: o, packedData: n}
        }, z.unpackCreateGeometryResults = function (t) {
            for (var n, r = t.stringTable, o = t.packedData, a = new Array(o[0]), s = 0, u = 1; u < o.length;) {
                var d = 1 === o[u++];
                if (d) {
                    var p, f, _ = o[u++], v = o[u++], g = 1 === o[u++];
                    g && (p = e.unpack(o, u)), u += e.packedLength;
                    var y = 1 === o[u++];
                    y && (f = e.unpack(o, u)), u += e.packedLength;
                    var C, E, S, T = new h, b = o[u++];
                    for (n = 0; b > n; n++) {
                        var w = r[o[u++]], x = o[u++];
                        S = o[u++];
                        var A = 0 !== o[u++];
                        C = o[u++], E = i.createTypedArray(x, C);
                        for (var P = 0; C > P; P++)E[P] = o[u++];
                        T[w] = new c({componentDatatype: x, componentsPerAttribute: S, normalize: A, values: E})
                    }
                    var I;
                    if (C = o[u++], C > 0) {
                        var D = E.length / S;
                        for (I = m.createTypedArray(D, C), n = 0; C > n; n++)I[n] = o[u++]
                    }
                    a[s++] = new l({primitiveType: _, geometryType: v, boundingSphere: p, indices: I, attributes: T})
                } else a[s++] = void 0
            }
            return a
        }, z.packCombineGeometryParameters = function (e, t) {
            for (var i = e.createGeometryResults, n = i.length, r = 0; n > r; r++)t.push(i[r].packedData.buffer);
            var o;
            return e.allowPicking && (o = D(e.pickIds, t)), {
                createGeometryResults: e.createGeometryResults,
                packedInstances: R(e.instances, t),
                packedPickIds: o,
                ellipsoid: e.ellipsoid,
                isGeographic: e.projection instanceof u,
                elementIndexUintSupported: e.elementIndexUintSupported,
                scene3DOnly: e.scene3DOnly,
                allowPicking: e.allowPicking,
                vertexCacheOptimize: e.vertexCacheOptimize,
                compressVertices: e.compressVertices,
                modelMatrix: e.modelMatrix
            }
        }, z.unpackCombineGeometryParameters = function (e) {
            for (var t = N(e.packedInstances), i = e.allowPicking, n = i ? M(e.packedPickIds) : void 0, o = e.createGeometryResults, s = o.length, l = 0, c = [], h = [], d = [], m = [], _ = [], v = 0; s > v; v++)for (var g = z.unpackCreateGeometryResults(o[v]), y = g.length, C = 0; y > C; C++) {
                var E = g[C], S = t[l];
                r(E) ? (S.geometry = E, c.push(S), d.push(l), i && _.push(n[l])) : (h.push(S), m.push(l)), ++l
            }
            var T = a.clone(e.ellipsoid), b = e.isGeographic ? new u(T) : new f(T);
            return {
                instances: c,
                invalidInstances: h,
                validInstancesIndices: d,
                invalidInstancesIndices: m,
                pickIds: _,
                ellipsoid: T,
                projection: b,
                elementIndexUintSupported: e.elementIndexUintSupported,
                scene3DOnly: e.scene3DOnly,
                allowPicking: e.allowPicking,
                vertexCacheOptimize: e.vertexCacheOptimize,
                compressVertices: e.compressVertices,
                modelMatrix: p.clone(e.modelMatrix)
            }
        }, z.packCombineGeometryResults = function (e, t) {
            return r(e.geometries) && (A(e.geometries, t), P(e.vaAttributes, t)), {
                geometries: e.geometries,
                attributeLocations: e.attributeLocations,
                vaAttributes: e.vaAttributes,
                packedVaAttributeLocations: F(e.vaAttributeLocations, t),
                modelMatrix: e.modelMatrix,
                validInstancesIndices: e.validInstancesIndices,
                invalidInstancesIndices: e.invalidInstancesIndices
            }
        }, z.unpackCombineGeometryResults = function (e) {
            return {
                geometries: e.geometries,
                attributeLocations: e.attributeLocations,
                vaAttributes: e.vaAttributes,
                perInstanceAttributeLocations: B(e.packedVaAttributeLocations, e.vaAttributes),
                modelMatrix: e.modelMatrix
            }
        }, z
    }),define("Cesium/Scene/PrimitiveState", ["../Core/freezeObject"], function (e) {
        "use strict";
        var t = {READY: 0, CREATING: 1, CREATED: 2, COMBINING: 3, COMBINED: 4, COMPLETE: 5, FAILED: 6};
        return e(t)
    }),define("Cesium/Scene/Primitive", ["../Core/BoundingSphere", "../Core/Cartesian3", "../Core/clone", "../Core/combine", "../Core/ComponentDatatype", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/FeatureDetection", "../Core/Geometry", "../Core/GeometryAttribute", "../Core/GeometryAttributes", "../Core/GeometryInstance", "../Core/GeometryInstanceAttribute", "../Core/isArray", "../Core/Matrix4", "../Core/subdivideArray", "../Core/TaskProcessor", "../Renderer/Buffer", "../Renderer/BufferUsage", "../Renderer/DrawCommand", "../Renderer/RenderState", "../Renderer/ShaderProgram", "../Renderer/ShaderSource", "../Renderer/VertexArray", "../ThirdParty/when", "./CullFace", "./Pass", "./PrimitivePipeline", "./PrimitiveState", "./SceneMode"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S, T, b, w, x, A, P, I, D, M, O) {
        "use strict";
        function R(e) {
            return new d({
                componentDatatype: e.componentDatatype,
                componentsPerAttribute: e.componentsPerAttribute,
                normalize: e.normalize,
                values: new e.values.constructor(e.values)
            })
        }

        function N(t) {
            var i = t.attributes, n = new m;
            for (var r in i)i.hasOwnProperty(r) && a(i[r]) && (n[r] = R(i[r]));
            var o;
            if (a(t.indices)) {
                var s = t.indices;
                o = new s.constructor(s)
            }
            return new h({
                attributes: n,
                indices: o,
                primitiveType: t.primitiveType,
                boundingSphere: e.clone(t.boundingSphere)
            })
        }

        function L(e) {
            return new f({
                componentDatatype: e.componentDatatype,
                componentsPerAttribute: e.componentsPerAttribute,
                normalize: e.normalize,
                value: new e.value.constructor(e.value)
            })
        }

        function F(e, t) {
            var i = e.attributes, n = {};
            for (var r in i)i.hasOwnProperty(r) && (n[r] = L(i[r]));
            return new p({
                geometry: t,
                modelMatrix: v.clone(e.modelMatrix),
                attributes: n,
                pickPrimitive: e.pickPrimitive,
                id: e.id
            })
        }

        function B(e, t) {
            if (!e.compressVertices)return t;
            var i = -1 !== t.search(/attribute\s+vec3\s+normal;/g), n = -1 !== t.search(/attribute\s+vec2\s+st;/g);
            if (!i && !n)return t;
            var r = -1 !== t.search(/attribute\s+vec3\s+tangent;/g), o = -1 !== t.search(/attribute\s+vec3\s+binormal;/g), a = n && i ? 2 : 1;
            a += r || o ? 1 : 0;
            var s = a > 1 ? "vec" + a : "float", u = "compressedAttributes", l = "attribute " + s + " " + u + ";", c = "", h = "";
            if (n) {
                c += "vec2 st;\n";
                var d = a > 1 ? u + ".x" : u;
                h += "    st = czm_decompressTextureCoordinates(" + d + ");\n"
            }
            i && r && o ? (c += "vec3 normal;\nvec3 tangent;\nvec3 binormal;\n", h += "    czm_octDecode(" + u + "." + (n ? "yz" : "xy") + ", normal, tangent, binormal);\n") : (i && (c += "vec3 normal;\n", h += "    normal = czm_octDecode(" + u + (a > 1 ? "." + (n ? "y" : "x") : "") + ");\n"), r && (c += "vec3 tangent;\n", h += "    tangent = czm_octDecode(" + u + "." + (n && i ? "z" : "y") + ");\n"), o && (c += "vec3 binormal;\n", h += "    binormal = czm_octDecode(" + u + "." + (n && i ? "z" : "y") + ");\n"));
            var m = t;
            m = m.replace(/attribute\s+vec3\s+normal;/g, ""), m = m.replace(/attribute\s+vec2\s+st;/g, ""), m = m.replace(/attribute\s+vec3\s+tangent;/g, ""), m = m.replace(/attribute\s+vec3\s+binormal;/g, ""), m = w.replaceMain(m, "czm_non_compressed_main");
            var p = "void main() \n{ \n" + h + "    czm_non_compressed_main(); \n}";
            return [l, c, m, p].join("\n")
        }

        function z(e, t) {
            e.vertexAttributes
        }

        function V(e, t, i) {
            for (var n = [], r = i.length, s = 0; r > s; ++s) {
                var u = {primitive: o(i[s].pickPrimitive, t)};
                a(i[s].id) && (u.id = i[s].id);
                var l = e.createPickId(u);
                t._pickIds.push(l), n.push(l.color)
            }
            return n
        }

        function U(e, t) {
            return function () {
                return e[t]
            }
        }

        function k(e, t, i) {
            var n, r, s, u, l = e._instanceIds;
            if (e._state === M.READY) {
                n = _(e.geometryInstances) ? e.geometryInstances : [e.geometryInstances];
                var c = e._numberOfInstances = n.length, h = [], d = [];
                for (s = 0; c > s; ++s)r = n[s].geometry, l.push(n[s].id), d.push({
                    moduleName: r._workerName,
                    geometry: r
                });
                if (!a(ee))for (ee = new Array(te), s = 0; te > s; s++)ee[s] = new y("createGeometry", Number.POSITIVE_INFINITY);
                var m;
                for (d = g(d, te), s = 0; s < d.length; s++) {
                    var p = 0, f = d[s], C = f.length;
                    for (u = 0; C > u; ++u)m = f[u], r = m.geometry, a(r.constructor.pack) && (m.offset = p, p += o(r.constructor.packedLength, r.packedLength));
                    var E;
                    if (p > 0) {
                        var S = new Float64Array(p);
                        for (E = [S.buffer], u = 0; C > u; ++u)m = f[u], r = m.geometry, a(r.constructor.pack) && (r.constructor.pack(r, S, m.offset), m.geometry = S)
                    }
                    h.push(ee[s].scheduleTask({subTasks: d[s]}, E))
                }
                e._state = M.CREATING, A.all(h, function (t) {
                    e._createGeometryResults = t, e._state = M.CREATED
                }).otherwise(function (t) {
                    J(e, i, M.FAILED, t)
                })
            } else if (e._state === M.CREATED) {
                var T = [];
                n = _(e.geometryInstances) ? e.geometryInstances : [e.geometryInstances];
                var b = e.allowPicking, w = i.scene3DOnly, x = i.mapProjection, P = ie.scheduleTask(D.packCombineGeometryParameters({
                    createGeometryResults: e._createGeometryResults,
                    instances: n,
                    pickIds: b ? V(t, e, n) : void 0,
                    ellipsoid: x.ellipsoid,
                    projection: x,
                    elementIndexUintSupported: t.elementIndexUint,
                    scene3DOnly: w,
                    allowPicking: b,
                    vertexCacheOptimize: e.vertexCacheOptimize,
                    compressVertices: e.compressVertices,
                    modelMatrix: e.modelMatrix
                }, T), T);
                e._createGeometryResults = void 0, e._state = M.COMBINING, A(P, function (t) {
                    var n = D.unpackCombineGeometryResults(t);
                    e._geometries = n.geometries, e._attributeLocations = n.attributeLocations, e._vaAttributes = n.vaAttributes, e._perInstanceAttributeLocations = n.perInstanceAttributeLocations, e.modelMatrix = v.clone(n.modelMatrix, e.modelMatrix), e._validModelMatrix = !v.equals(e.modelMatrix, v.IDENTITY);
                    for (var r = t.validInstancesIndices, o = t.invalidInstancesIndices, s = e._instanceIds, u = new Array(s.length), l = r.length, c = 0; l > c; ++c)u[c] = s[r[c]];
                    for (var h = o.length, d = 0; h > d; ++d)u[l + d] = s[o[d]];
                    e._instanceIds = u, a(e._geometries) ? e._state = M.COMBINED : J(e, i, M.FAILED, void 0)
                }).otherwise(function (t) {
                    J(e, i, M.FAILED, t)
                })
            }
        }

        function G(e, t, i) {
            var n, r, o = _(e.geometryInstances) ? e.geometryInstances : [e.geometryInstances], s = e._numberOfInstances = o.length, u = new Array(s), l = new Array(s), c = [], h = e._instanceIds, d = 0;
            for (r = 0; s > r; r++) {
                n = o[r];
                var m, p = n.geometry;
                m = a(p.attributes) && a(p.primitiveType) ? N(p) : p.constructor.createGeometry(p), a(m) ? (u[d] = m, l[d++] = F(n, m), h.push(n.id)) : c.push(n)
            }
            u.length = d, l.length = d;
            var f = e.allowPicking, g = i.scene3DOnly, y = i.mapProjection, C = D.combineGeometry({
                instances: l,
                invalidInstances: c,
                pickIds: f ? V(t, e, l) : void 0,
                ellipsoid: y.ellipsoid,
                projection: y,
                elementIndexUintSupported: t.elementIndexUint,
                scene3DOnly: g,
                allowPicking: f,
                vertexCacheOptimize: e.vertexCacheOptimize,
                compressVertices: e.compressVertices,
                modelMatrix: e.modelMatrix
            });
            for (e._geometries = C.geometries, e._attributeLocations = C.attributeLocations, e._vaAttributes = C.vaAttributes, e._perInstanceAttributeLocations = C.vaAttributeLocations, e.modelMatrix = v.clone(C.modelMatrix, e.modelMatrix), e._validModelMatrix = !v.equals(e.modelMatrix, v.IDENTITY), r = 0; r < c.length; ++r)n = c[r], h.push(n.id);
            a(e._geometries) ? e._state = M.COMBINED : J(e, i, M.FAILED, void 0)
        }

        function H(t, i, n) {
            for (var r = t._attributeLocations, o = t._geometries, s = t._vaAttributes, u = n.scene3DOnly, l = [], c = o.length, h = 0; c > h; ++h) {
                for (var d = o[h], m = s[h], p = m.length, f = 0; p > f; ++f) {
                    var _ = m[f];
                    _.vertexBuffer = C.createVertexBuffer({
                        context: i,
                        typedArray: _.values,
                        usage: E.DYNAMIC_DRAW
                    }), delete _.values
                }
                if (l.push(x.fromGeometry({
                        context: i,
                        geometry: d,
                        attributeLocations: r,
                        bufferUsage: E.STATIC_DRAW,
                        interleave: t._interleave,
                        vertexArrayAttributes: m
                    })), a(t._createBoundingVolumeFunction))t._createBoundingVolumeFunction(n, d); else if (t._boundingSpheres.push(e.clone(d.boundingSphere)), t._boundingSphereWC.push(new e), !u) {
                    var v = d.boundingSphereCV.center, g = v.x, y = v.y, S = v.z;
                    v.x = S, v.y = g, v.z = y, t._boundingSphereCV.push(e.clone(d.boundingSphereCV)), t._boundingSphere2D.push(new e), t._boundingSphereMorph.push(new e)
                }
            }
            t._va = l, t._primitiveType = o[0].primitiveType, t.releaseGeometryInstances && (t.geometryInstances = void 0), t._geometries = void 0, J(t, n, M.COMPLETE, void 0)
        }

        function W(e, t, n, r) {
            var o, a = n.getRenderState();
            r ? (o = i(a, !1), o.cull = {
                enabled: !0,
                face: P.BACK
            }, e._frontFaceRS = T.fromCache(o), o.cull.face = P.FRONT, e._backFaceRS = T.fromCache(o)) : (e._frontFaceRS = T.fromCache(a), e._backFaceRS = e._frontFaceRS), e.allowPicking ? r ? (o = i(a, !1), o.cull = {enabled: !1}, e._pickRS = T.fromCache(o)) : e._pickRS = e._frontFaceRS : (o = i(a, !1), o.colorMask = {
                red: !1,
                green: !1,
                blue: !1,
                alpha: !1
            }, r ? (o.cull = {enabled: !1}, e._pickRS = T.fromCache(o)) : e._pickRS = T.fromCache(o))
        }

        function q(e, t, i, n) {
            var r = Q._modifyShaderPosition(e, n.vertexShaderSource, i.scene3DOnly);
            r = Q._appendShowToShader(e, r), r = B(e, r);
            var o = n.getFragmentShaderSource(), a = e._attributeLocations;
            if (e._sp = b.replaceCache({
                    context: t,
                    shaderProgram: e._sp,
                    vertexShaderSource: r,
                    fragmentShaderSource: o,
                    attributeLocations: a
                }), z(e._sp, a), e.allowPicking) {
                var s = new w({sources: [o], pickColorQualifier: "varying"});
                e._pickSP = b.replaceCache({
                    context: t,
                    shaderProgram: e._pickSP,
                    vertexShaderSource: Q._createPickVertexShaderSource(r),
                    fragmentShaderSource: s,
                    attributeLocations: a
                })
            } else e._pickSP = b.fromCache({
                context: t,
                vertexShaderSource: r,
                fragmentShaderSource: o,
                attributeLocations: a
            });
            z(e._pickSP, a)
        }

        function j(e, t, i, r, o, s, u) {
            var c = a(i) ? i._uniforms : void 0, h = {}, d = t.uniforms;
            if (a(d))for (var m in d)if (d.hasOwnProperty(m)) {
                if (a(c) && a(c[m]))throw new l("Appearance and material have a uniform with the same name: " + m);
                h[m] = U(d, m)
            }
            var p = n(h, c);
            a(e.rtcCenter) && (p.u_modifiedModelView = function () {
                return e._modifiedModelView
            });
            var f = r ? I.TRANSLUCENT : I.OPAQUE;
            s.length = e._va.length * (o ? 2 : 1), u.length = e._va.length;
            for (var _ = s.length, v = 0, g = 0, y = 0; _ > y; ++y) {
                var C;
                o && (C = s[y], a(C) || (C = s[y] = new S({
                    owner: e,
                    primitiveType: e._primitiveType
                })), C.vertexArray = e._va[g], C.renderState = e._backFaceRS, C.shaderProgram = e._sp, C.uniformMap = p, C.pass = f, ++y), C = s[y], a(C) || (C = s[y] = new S({
                    owner: e,
                    primitiveType: e._primitiveType
                })), C.vertexArray = e._va[g], C.renderState = e._frontFaceRS, C.shaderProgram = e._sp, C.uniformMap = p, C.pass = f;
                var E = u[v];
                a(E) || (E = u[v] = new S({
                    owner: e,
                    primitiveType: e._primitiveType
                })), E.vertexArray = e._va[g], E.renderState = e._pickRS, E.shaderProgram = e._pickSP, E.uniformMap = p, E.pass = f, ++v, ++g
            }
        }

        function Y(e) {
            if (0 !== e._dirtyAttributes.length) {
                for (var t = e._dirtyAttributes, i = t.length, n = 0; i > n; ++n) {
                    for (var o = t[n], a = o.value, s = o.indices, u = s.length, l = 0; u > l; ++l) {
                        for (var c = s[l], h = c.offset, d = c.count, m = c.attribute, p = m.componentDatatype, f = m.componentsPerAttribute, _ = r.createTypedArray(p, d * f), v = 0; d > v; ++v)_.set(a, v * f);
                        var g = h * f * r.getSizeInBytes(p);
                        m.vertexBuffer.copyFromArrayView(_, g)
                    }
                    o.dirty = !1
                }
                t.length = 0
            }
        }

        function X(t, i, n, r, o, s, u, l, c) {
            if (!v.equals(s, t._modelMatrix)) {
                v.clone(s, t._modelMatrix);
                for (var h = t._boundingSpheres.length, d = 0; h > d; ++d) {
                    var m = t._boundingSpheres[d];
                    a(m) && (t._boundingSphereWC[d] = e.transform(m, s, t._boundingSphereWC[d]), i.scene3DOnly || (t._boundingSphere2D[d] = e.clone(t._boundingSphereCV[d], t._boundingSphere2D[d]), t._boundingSphere2D[d].center.x = 0, t._boundingSphereMorph[d] = e.union(t._boundingSphereWC[d], t._boundingSphereCV[d])))
                }
            }
            if (a(t.rtcCenter)) {
                var p = i.camera.viewMatrix;
                v.multiply(p, t._modelMatrix, t._modifiedModelView), v.multiplyByPoint(t._modifiedModelView, t.rtcCenter, ne), v.setTranslation(t._modifiedModelView, ne, t._modifiedModelView)
            }
            var f;
            i.mode === O.SCENE3D ? f = t._boundingSphereWC : i.mode === O.COLUMBUS_VIEW ? f = t._boundingSphereCV : i.mode === O.SCENE2D && a(t._boundingSphere2D) ? f = t._boundingSphere2D : a(t._boundingSphereMorph) && (f = t._boundingSphereMorph);
            var _ = i.passes;
            if (_.render)for (var g = r.length, y = 0; g > y; ++y) {
                var C = c ? Math.floor(y / 2) : y;
                r[y].modelMatrix = s, r[y].boundingVolume = f[C], r[y].cull = u, r[y].debugShowBoundingVolume = l, n.push(r[y])
            }
            if (_.pick)for (var E = o.length, S = 0; E > S; ++S)o[S].modelMatrix = s, o[S].boundingVolume = f[S], o[S].cull = u, n.push(o[S])
        }

        function Z(e, t) {
            var i = t[e];
            return function () {
                return a(i) && a(i.value) ? t[e].value : i
            }
        }

        function K(e, t, i) {
            return function (n) {
                var r = t[e];
                r.value = n, !r.dirty && r.valid && (i.push(r), r.dirty = !0)
            }
        }

        function J(e, t, i, n) {
            e._error = n, e._state = i, t.afterRender.push(function () {
                e._ready = e._state === M.COMPLETE || e._state === M.FAILED, a(n) ? e._readyPromise.reject(n) : e._readyPromise.resolve(e)
            })
        }

        var Q = function (e) {
            e = o(e, o.EMPTY_OBJECT), this.geometryInstances = e.geometryInstances, this.appearance = e.appearance, this._appearance = void 0, this._material = void 0, this.modelMatrix = v.clone(o(e.modelMatrix, v.IDENTITY)), this._modelMatrix = new v, this.show = o(e.show, !0), this._vertexCacheOptimize = o(e.vertexCacheOptimize, !1), this._interleave = o(e.interleave, !1), this._releaseGeometryInstances = o(e.releaseGeometryInstances, !0), this._allowPicking = o(e.allowPicking, !0), this._asynchronous = o(e.asynchronous, !0), this._compressVertices = o(e.compressVertices, !0), this.cull = o(e.cull, !0), this.debugShowBoundingVolume = o(e.debugShowBoundingVolume, !1), this.rtcCenter = e.rtcCenter, this._modifiedModelView = new v, this._translucent = void 0, this._state = M.READY, this._geometries = [], this._vaAttributes = void 0, this._error = void 0, this._numberOfInstances = 0, this._validModelMatrix = !1, this._boundingSpheres = [], this._boundingSphereWC = [], this._boundingSphereCV = [], this._boundingSphere2D = [], this._boundingSphereMorph = [], this._perInstanceAttributeLocations = void 0, this._perInstanceAttributeCache = [], this._instanceIds = [], this._lastPerInstanceAttributeIndex = 0, this._dirtyAttributes = [], this._va = [], this._attributeLocations = void 0, this._primitiveType = void 0, this._frontFaceRS = void 0, this._backFaceRS = void 0, this._sp = void 0, this._pickRS = void 0, this._pickSP = void 0, this._pickIds = [], this._colorCommands = [], this._pickCommands = [], this._createBoundingVolumeFunction = e._createBoundingVolumeFunction, this._createRenderStatesFunction = e._createRenderStatesFunction, this._createShaderProgramFunction = e._createShaderProgramFunction, this._createCommandsFunction = e._createCommandsFunction, this._updateAndQueueCommandsFunction = e._updateAndQueueCommandsFunction, this._createGeometryResults = void 0, this._ready = !1, this._readyPromise = A.defer()
        };
        s(Q.prototype, {
            vertexCacheOptimize: {
                get: function () {
                    return this._vertexCacheOptimize
                }
            }, interleave: {
                get: function () {
                    return this._interleave
                }
            }, releaseGeometryInstances: {
                get: function () {
                    return this._releaseGeometryInstances
                }
            }, allowPicking: {
                get: function () {
                    return this._allowPicking
                }
            }, asynchronous: {
                get: function () {
                    return this._asynchronous
                }
            }, compressVertices: {
                get: function () {
                    return this._compressVertices
                }
            }, ready: {
                get: function () {
                    return this._ready
                }
            }, readyPromise: {
                get: function () {
                    return this._readyPromise
                }
            }
        });
        var $ = /attribute\s+vec(?:3|4)\s+(.*)3DHigh;/g;
        Q._modifyShaderPosition = function (e, t, i) {
            for (var n, r = "", o = "", s = ""; null !== (n = $.exec(t));) {
                var u = n[1], l = "vec4 czm_compute" + u[0].toUpperCase() + u.substr(1) + "()";
                "vec4 czm_computePosition()" !== l && (r += l + ";\n"), a(e.rtcCenter) ? (t = t.replace(/attribute\s+vec(?:3|4)\s+position3DHigh;/g, ""), t = t.replace(/attribute\s+vec(?:3|4)\s+position3DLow;/g, ""), r += "uniform mat4 u_modifiedModelView;\n", o += "attribute vec4 position;\n", s += l + "\n{\n    return u_modifiedModelView * position;\n}\n\n", t = t.replace(/czm_modelViewRelativeToEye\s+\*\s+/g, ""), t = t.replace(/czm_modelViewProjectionRelativeToEye/g, "czm_projection")) : i ? s += l + "\n{\n    return czm_translateRelativeToEye(" + u + "3DHigh, " + u + "3DLow);\n}\n\n" : (o += "attribute vec3 " + u + "2DHigh;\nattribute vec3 " + u + "2DLow;\n", s += l + "\n{\n    vec4 p;\n    if (czm_morphTime == 1.0)\n    {\n        p = czm_translateRelativeToEye(" + u + "3DHigh, " + u + "3DLow);\n    }\n    else if (czm_morphTime == 0.0)\n    {\n        p = czm_translateRelativeToEye(" + u + "2DHigh.zxy, " + u + "2DLow.zxy);\n    }\n    else\n    {\n        p = czm_columbusViewMorph(\n                czm_translateRelativeToEye(" + u + "2DHigh.zxy, " + u + "2DLow.zxy),\n                czm_translateRelativeToEye(" + u + "3DHigh, " + u + "3DLow),\n                czm_morphTime);\n    }\n    return p;\n}\n\n")
            }
            return [r, o, t, s].join("\n")
        }, Q._createPickVertexShaderSource = function (e) {
            var t = w.replaceMain(e, "czm_pick_main"), i = "attribute vec4 pickColor; \nvarying vec4 czm_pickColor; \nvoid main() \n{ \n    czm_pick_main(); \n    czm_pickColor = pickColor; \n}";
            return t + "\n" + i
        }, Q._appendShowToShader = function (e, t) {
            if (!a(e._attributeLocations.show))return t;
            var i = w.replaceMain(t, "czm_non_show_main"), n = "attribute float show;\nvoid main() \n{ \n    czm_non_show_main(); \n    gl_Position *= show; \n}";
            return i + "\n" + n
        };
        var ee, te = Math.max(c.hardwareConcurrency - 1, 1), ie = new y("combineGeometry", Number.POSITIVE_INFINITY), ne = new t;
        return Q.prototype.update = function (e, t, i) {
            if (!(!a(this.geometryInstances) && 0 === this._va.length || a(this.geometryInstances) && _(this.geometryInstances) && 0 === this.geometryInstances.length || !a(this.appearance) || t.mode !== O.SCENE3D && t.scene3DOnly || !t.passes.render && !t.passes.pick)) {
                if (a(this._error))throw this._error;
                if (a(this.rtcCenter) && !t.scene3DOnly)throw new l("RTC rendering is only available for 3D only scenes.");
                if (this._state !== M.FAILED && (this._state !== M.COMPLETE && this._state !== M.COMBINED && (this.asynchronous ? k(this, e, t) : G(this, e, t)), this._state === M.COMBINED && H(this, e, t), this.show && this._state === M.COMPLETE)) {
                    var n = this.appearance, r = n.material, s = !1, u = !1;
                    this._appearance !== n ? (this._appearance = n, this._material = r, s = !0, u = !0) : this._material !== r && (this._material = r, u = !0);
                    var c = this._appearance.isTranslucent();
                    this._translucent !== c && (this._translucent = c, s = !0), a(this._material) && this._material.update(e);
                    var h = n.closed && c;
                    if (s) {
                        var d = o(this._createRenderStatesFunction, W);
                        d(this, e, n, h)
                    }
                    if (u) {
                        var m = o(this._createShaderProgramFunction, q);
                        m(this, e, t, n)
                    }
                    if (s || u) {
                        var p = o(this._createCommandsFunction, j);
                        p(this, n, r, c, h, this._colorCommands, this._pickCommands)
                    }
                    Y(this);
                    var f = o(this._updateAndQueueCommandsFunction, X);
                    f(this, t, i, this._colorCommands, this._pickCommands, this.modelMatrix, this.cull, this.debugShowBoundingVolume, h)
                }
            }
        }, Q.prototype.getGeometryInstanceAttributes = function (e) {
            for (var t = -1, i = this._lastPerInstanceAttributeIndex, n = this._instanceIds, r = n.length, o = 0; r > o; ++o) {
                var u = (i + o) % r;
                if (e === n[u]) {
                    t = u;
                    break
                }
            }
            if (-1 === t)return void 0;
            var l = this._perInstanceAttributeCache[t];
            if (a(l))return l;
            var c = this._perInstanceAttributeLocations[t];
            l = {};
            var h = {}, d = !1;
            for (var m in c)c.hasOwnProperty(m) && (d = !0, h[m] = {get: Z(m, c)}, "boundingSphere" !== m && "boundingSphereCV" !== m && (h[m].set = K(m, c, this._dirtyAttributes)));
            return d && s(l, h), this._lastPerInstanceAttributeIndex = t, this._perInstanceAttributeCache[t] = l, l
        }, Q.prototype.isDestroyed = function () {
            return !1
        }, Q.prototype.destroy = function () {
            var e, t;
            this._sp = this._sp && this._sp.destroy(), this._pickSP = this._pickSP && this._pickSP.destroy();
            var i = this._va;
            for (e = i.length, t = 0; e > t; ++t)i[t].destroy();
            this._va = void 0;
            var n = this._pickIds;
            for (e = n.length, t = 0; e > t; ++t)n[t].destroy();
            return this._pickIds = void 0, this._instanceIds = void 0, this._perInstanceAttributeCache = void 0, this._perInstanceAttributeLocations = void 0, this._attributeLocations = void 0, this._dirtyAttributes = void 0, u(this)
        }, Q
    }),define("Cesium/Scene/Points3DTileContentProvider", ["../Core/Cartesian3", "../Core/Color", "../Core/destroyObject", "../Core/defined", "../Core/DeveloperError", "../Core/GeometryInstance", "../Core/loadArrayBuffer", "../Core/PointGeometry", "./Cesium3DTileContentState", "./getMagic", "./PointAppearance", "./Primitive", "../ThirdParty/when"], function (e, t, i, n, r, o, a, s, u, l, c, h, d) {
        "use strict";
        function m(e, i) {
            e.debugColorizeTiles && !i._debugColorizeTiles ? (i._debugColorizeTiles = !0, i._primitive.appearance.uniforms.highlightColor = i._debugColor) : !e.debugColorizeTiles && i._debugColorizeTiles && (i._debugColorizeTiles = !1, i._primitive.appearance.uniforms.highlightColor = t.WHITE)
        }

        var p = function (e, i, n) {
            this._primitive = void 0, this._url = i, this.state = u.UNLOADED, this.processingPromise = d.defer(), this.readyPromise = d.defer(), this.boundingSphere = n.boundingSphere, this._debugColor = t.fromRandom({alpha: 1}), this._debugColorizeTiles = !1
        }, f = Uint32Array.BYTES_PER_ELEMENT;
        return p.prototype.request = function () {
            function e(e) {
                t.state = u.FAILED, t.readyPromise.reject(e)
            }

            var t = this;
            this.state = u.LOADING, a(this._url).then(function (i) {
                var n = l(i);
                if ("pnts" !== n)throw new r("Invalid Points tile.  Expected magic=pnts.  Read magic=" + n);
                var a = new DataView(i), m = 0;
                m += f, m += f;
                var p = a.getUint32(m, !0);
                m += f;
                var _ = m, v = new Float32Array(i, _, 3 * p), g = _ + 3 * p * Float32Array.BYTES_PER_ELEMENT, y = new Uint8Array(i, g, 3 * p), C = new o({
                    geometry: new s({
                        positionsTypedArray: v,
                        colorsTypedArray: y,
                        boundingSphere: t.boundingSphere
                    })
                }), E = new h({
                    geometryInstances: C,
                    appearance: new c,
                    asynchronous: !1,
                    allowPicking: !1,
                    cull: !1,
                    rtcCenter: t.boundingSphere.center
                });
                t._primitive = E, t.state = u.PROCESSING, t.processingPromise.resolve(t), d(E.readyPromise).then(function (e) {
                    t.state = u.READY, t.readyPromise.resolve(t)
                }).otherwise(e)
            }).otherwise(e)
        }, p.prototype.update = function (e, t, i, n) {
            m(e, this), this._primitive.update(t, i, n)
        }, p.prototype.isDestroyed = function () {
            return !1
        }, p.prototype.destroy = function () {
            return this._primitive = this._primitive && this._primitive.destroy(), i(this)
        }, p
    }),define("Cesium/Scene/Cesium3DTileContentProviderFactory", ["./Batched3DModel3DTileContentProvider", "./Points3DTileContentProvider"], function (e, t) {
        "use strict";
        var i = {
            b3dm: function (t, i, n) {
                return new e(t, i, n)
            }, pnts: function (e, i, n) {
                return new t(e, i, n)
            }
        };
        return i
    }),define("Cesium/Scene/Cesium3DTileRefine", ["../Core/freezeObject"], function (e) {
        "use strict";
        var t = {ADD: 0, REPLACE: 1};
        return e(t)
    }),define("Cesium/Scene/Empty3DTileContentProvider", ["../Core/destroyObject", "./Cesium3DTileContentState", "../ThirdParty/when"], function (e, t, i) {
        "use strict";
        var n = function () {
            this.state = void 0, this.processingPromise = i.defer(), this.state = t.PROCESSING, this.processingPromise.resolve(this), this.readyPromise = i.defer(), this.state = t.READY, this.readyPromise.resolve(this)
        };
        return n.prototype.request = function () {
        }, n.prototype.update = function (e, t, i, n) {
        }, n.prototype.isDestroyed = function () {
            return !1
        }, n.prototype.destroy = function () {
            return e(this)
        }, n
    }),define("Cesium/Shaders/Appearances/PerInstanceColorAppearanceFS", [], function () {
        "use strict";
        return "varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec4 v_color;\n\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC;\n    \n    vec3 normalEC = normalize(v_normalEC);\n#ifdef FACE_FORWARD\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n#endif\n    \n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    material.diffuse = v_color.rgb;\n    material.alpha = v_color.a;\n    \n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\n}\n"
    }),define("Cesium/Shaders/Appearances/PerInstanceColorAppearanceVS", [], function () {
        "use strict";
        return "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec4 color;\n\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec4 v_color;\n\nvoid main() \n{\n    vec4 p = czm_computePosition();\n\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n    v_color = color;\n    \n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"
    }),define("Cesium/Shaders/Appearances/PerInstanceFlatColorAppearanceFS", [], function () {
        "use strict";
        return "varying vec4 v_color;\n\nvoid main()\n{\n    gl_FragColor = v_color;\n}\n"
    }),define("Cesium/Shaders/Appearances/PerInstanceFlatColorAppearanceVS", [], function () {
        "use strict";
        return "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec4 color;\n\nvarying vec4 v_color;\n\nvoid main() \n{\n    vec4 p = czm_computePosition();\n\n    v_color = color;\n    \n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"
    }),define("Cesium/Scene/PerInstanceColorAppearance", ["../Core/defaultValue", "../Core/defineProperties", "../Core/VertexFormat", "../Shaders/Appearances/PerInstanceColorAppearanceFS", "../Shaders/Appearances/PerInstanceColorAppearanceVS", "../Shaders/Appearances/PerInstanceFlatColorAppearanceFS", "../Shaders/Appearances/PerInstanceFlatColorAppearanceVS", "./Appearance"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        var u = function (t) {
            t = e(t, e.EMPTY_OBJECT);
            var i = e(t.translucent, !0), l = e(t.closed, !1), c = e(t.flat, !1), h = c ? a : r, d = c ? o : n, m = c ? u.FLAT_VERTEX_FORMAT : u.VERTEX_FORMAT;
            this.material = void 0, this.translucent = i, this._vertexShaderSource = e(t.vertexShaderSource, h), this._fragmentShaderSource = e(t.fragmentShaderSource, d), this._renderState = s.getDefaultRenderState(i, l, t.renderState), this._closed = l, this._vertexFormat = m, this._flat = c, this._faceForward = e(t.faceForward, !l)
        };
        return t(u.prototype, {
            vertexShaderSource: {
                get: function () {
                    return this._vertexShaderSource
                }
            }, fragmentShaderSource: {
                get: function () {
                    return this._fragmentShaderSource
                }
            }, renderState: {
                get: function () {
                    return this._renderState
                }
            }, closed: {
                get: function () {
                    return this._closed
                }
            }, vertexFormat: {
                get: function () {
                    return this._vertexFormat
                }
            }, flat: {
                get: function () {
                    return this._flat
                }
            }, faceForward: {
                get: function () {
                    return this._faceForward
                }
            }
        }), u.VERTEX_FORMAT = i.POSITION_AND_NORMAL, u.FLAT_VERTEX_FORMAT = i.POSITION_ONLY, u.prototype.getFragmentShaderSource = s.prototype.getFragmentShaderSource, u.prototype.isTranslucent = s.prototype.isTranslucent, u.prototype.getRenderState = s.prototype.getRenderState, u
    }),define("Cesium/Scene/TileBoundingBox", ["../Core/Cartesian3", "../Core/Cartographic", "../Core/defaultValue", "../Core/defined", "../Core/DeveloperError", "../Core/Ellipsoid", "../Core/Rectangle", "./SceneMode"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        function u(t, i, n) {
            n.cartographicToCartesian(a.southwest(i), t.southwestCornerCartesian), n.cartographicToCartesian(a.northeast(i), t.northeastCornerCartesian), p.longitude = i.west, p.latitude = .5 * (i.south + i.north), p.height = 0;
            var r = n.cartographicToCartesian(p, d), o = e.cross(r, e.UNIT_Z, c);
            e.normalize(o, t.westNormal), p.longitude = i.east;
            var s = n.cartographicToCartesian(p, m), u = e.cross(e.UNIT_Z, s, c);
            e.normalize(u, t.eastNormal);
            var l = n.geodeticSurfaceNormalCartographic(a.southeast(i), h), f = e.subtract(r, s, c), _ = e.cross(l, f, h);
            e.normalize(_, t.southNormal);
            var v = n.geodeticSurfaceNormalCartographic(a.northwest(i), h), g = e.cross(f, v, h);
            e.normalize(g, t.northNormal)
        }

        var l = function (t) {
            this.rectangle = a.clone(t.rectangle), this.minimumHeight = i(t.minimumHeight, 0), this.maximumHeight = i(t.maximumHeight, 0), this.southwestCornerCartesian = new e, this.northeastCornerCartesian = new e, this.westNormal = new e, this.southNormal = new e, this.eastNormal = new e, this.northNormal = new e;
            var n = i(t.ellipsoid, o.WGS84);
            u(this, t.rectangle, n)
        }, c = new e, h = new e, d = new e, m = new e, p = new t, f = new e, _ = new e, v = new e(0, -1, 0), g = new e(0, 0, -1), y = new e;
        return l.prototype.distanceToCamera = function (t) {
            var i = this.southwestCornerCartesian, n = this.northeastCornerCartesian, r = this.westNormal, o = this.southNormal, u = this.eastNormal, l = this.northNormal, c = this.maximumHeight;
            t.mode !== s.SCENE3D && (i = t.mapProjection.project(a.southwest(this.rectangle), f), i.z = i.y, i.y = i.x, i.x = 0, n = t.mapProjection.project(a.northeast(this.rectangle), _), n.z = n.y, n.y = n.x, n.x = 0, r = v, u = e.UNIT_Y, o = g, l = e.UNIT_Z, c = 0);
            var h, d = t.camera.positionWC, m = t.camera.positionCartographic, p = e.subtract(d, i, y), C = e.dot(p, r), E = e.dot(p, o), S = e.subtract(d, n, y), T = e.dot(S, u), b = e.dot(S, l);
            h = t.mode === s.SCENE3D ? m.height : d.x;
            var w = h - c, x = 0;
            return C > 0 ? x += C * C : T > 0 && (x += T * T), E > 0 ? x += E * E : b > 0 && (x += b * b), w > 0 && (x += w * w), Math.sqrt(x)
        }, l
    }),define("Cesium/Scene/Cesium3DTile", ["../Core/RectangleOutlineGeometry", "../Core/Cartesian3", "../Core/Color", "../Core/ColorGeometryInstanceAttribute", "../Core/DeveloperError", "../Core/GeometryInstance", "../Core/BoxOutlineGeometry", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/Intersect", "../Core/Matrix4", "../Core/OrientedBoundingBox", "../Core/Rectangle", "./Cesium3DTileContentProviderFactory", "./Cesium3DTileContentState", "./Cesium3DTileRefine", "./Empty3DTileContentProvider", "./PerInstanceColorAppearance", "./Primitive", "./TileBoundingBox", "../ThirdParty/Uri", "../ThirdParty/when"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S) {
        "use strict";
        function T(e, t, i) {
            var r = new o({geometry: e, modelMatrix: i, attributes: {color: n.fromColor(t)}});
            return new y({geometryInstances: r, appearance: new g({translucent: !1, flat: !0}), asynchronous: !1})
        }

        function b(t, i) {
            var n = new e({rectangle: new m(t[0], t[1], t[2], t[3]), height: t[4], extrudedHeight: t[5]});
            return T(n, i)
        }

        function w(e, i) {
            var n = a.fromDimensions({dimensions: new t(2, 2, 2)});
            return T(n, i, h.fromRotationTranslation(e.halfAxes, e.center))
        }

        function x(e) {
            return e[1] !== e[3] && e[0] !== e[2]
        }

        function A(e, t, n, r, o) {
            var a = s(e._header.content) && s(e._header.content.box), u = t.debugShowBox || t.debugShowcontentBox && !a;
            u && x(e._header.box) ? (s(e._debugBox) || (e._debugBox = b(e._header.box, a ? i.WHITE : i.RED)), e._debugBox.update(n, r, o)) : !u && s(e._debugBox) && (e._debugBox = e._debugBox.destroy()), t.debugShowcontentBox && a && x(e._header.content.box) ? (s(e._debugcontentBox) || (e._debugcontentBox = b(e._header.content.box, i.BLUE)), e._debugcontentBox.update(n, r, o)) : !t.debugShowcontentBox && s(e._debugcontentBox) && (e._debugcontentBox = e._debugcontentBox.destroy()), t.debugShowBoundingVolume ? (s(e._debugOrientedBoundingBox) || (e._debugOrientedBoundingBox = w(e._orientedBoundingBox, a ? i.WHITE : i.RED)), e._debugOrientedBoundingBox.update(n, r, o)) : !t.debugShowBoundingVolume && s(e._debugOrientedBoundingBox) && (e._debugOrientedBoundingBox = e._debugOrientedBoundingBox.destroy()), t.debugShowContentsBoundingVolume && a ? (s(e._debugContentsOrientedBoundingBox) || (e._debugContentsOrientedBoundingBox = w(e._contentsOrientedBoundingBox, i.BLUE)), e._debugContentsOrientedBoundingBox.update(n, r, o)) : !t.debugShowContentsBoundingVolume && s(e._debugContentsOrientedBoundingBox) && (e._debugContentsOrientedBoundingBox = e._debugContentsOrientedBoundingBox.destroy())
        }

        var P = function (e, t, i, n) {
            this._header = i;
            var o = i.content, a = i.box, u = new m(a[0], a[1], a[2], a[3]);
            this._tileBoundingBox = new C({
                rectangle: u,
                minimumHeight: a[4],
                maximumHeight: a[5]
            }), this._orientedBoundingBox = d.fromRectangle(u, a[4], a[5]);
            var l;
            if (s(o) && s(o.box)) {
                var c = o.box;
                l = d.fromRectangle(new m(c[0], c[1], c[2], c[3]), c[4], c[5])
            }
            this._contentsOrientedBoundingBox = l, this.geometricError = i.geometricError, this.refine = "replace" === i.refine ? _.REPLACE : _.ADD, this.children = [], this.parent = n, this.numberOfChildrenWithoutContent = s(i.children) ? i.children.length : 0, this.readyPromise = S.defer();
            var h;
            if (s(o)) {
                var f = o.url, g = new E(f).isAbsolute() ? f : t + f, y = p[o.type];
                if (!s(y))throw new r("Unknown tile content type, " + o.type + ", for " + g);
                h = y(e, g, o)
            } else h = new v;
            this._content = h;
            var T = this;
            S(h.readyPromise).then(function (e) {
                s(T.parent) && --T.parent.numberOfChildrenWithoutContent, T.readyPromise.resolve(T)
            }).otherwise(function (e) {
                T.readyPromise.reject(e)
            }), this.distanceToCamera = 0, this.parentPlaneMask = 0, this._debugBox = void 0, this._debugcontentBox = void 0, this._debugOrientedBoundingBox = void 0, this._debugContentsOrientedBoundingBox = void 0
        };
        u(P.prototype, {
            content: {
                get: function () {
                    return this._content
                }
            }, processingPromise: {
                get: function () {
                    return this._content.processingPromise
                }
            }
        }), P.prototype.isReady = function () {
            return this._content.state === f.READY
        }, P.prototype.isContentUnloaded = function () {
            return this._content.state === f.UNLOADED
        }, P.prototype.requestContent = function () {
            this._content.request()
        }, P.prototype.visibility = function (e) {
            return e.computeVisibilityWithPlaneMask(this._orientedBoundingBox, this.parentPlaneMask)
        }, P.prototype.contentsVisibility = function (e) {
            return s(this._contentsOrientedBoundingBox) ? e.computeVisibility(this._contentsOrientedBoundingBox) : c.INSIDE
        }, P.prototype.distanceToTile = function (e) {
            return this._tileBoundingBox.distanceToCamera(e)
        }, P.prototype.update = function (e, t, i, n) {
            A(this, e, t, i, n), this._content.update(e, t, i, n)
        };
        var I = [];
        return P.prototype.process = function (e, t, i) {
            this._content.update(e, t, i, I)
        }, P.prototype.isDestroyed = function () {
            return !1
        }, P.prototype.destroy = function () {
            return this._content = this._content && this._content.destroy(), this._debugBox = this._debugBox && this._debugBox.destroy(), this._debugcontentBox = this._debugcontentBox && this._debugcontentBox.destroy(), this._debugOrientedBoundingBox = this._debugOrientedBoundingBox && this._debugOrientedBoundingBox.destroy(), this._debugContentsOrientedBoundingBox = this._debugContentsOrientedBoundingBox && this._debugContentsOrientedBoundingBox.destroy(), l(this)
        }, P
    }),define("Cesium/Scene/CullingVolume", ["../Core/defaultValue", "../Core/defined", "../Core/Cartesian3", "../Core/DeveloperError", "../Core/Intersect", "../Core/Plane"], function (e, t, i, n, r, o) {
        "use strict";
        var a = function (t) {
            this.planes = e(t, [])
        }, s = new o(new i, 0);
        return a.prototype.computeVisibility = function (e) {
            for (var t = this.planes, i = !1, n = 0, a = t.length; a > n; ++n) {
                var u = e.intersectPlane(o.fromCartesian4(t[n], s));
                if (u === r.OUTSIDE)return r.OUTSIDE;
                u === r.INTERSECTING && (i = !0)
            }
            return i ? r.INTERSECTING : r.INSIDE
        }, a.prototype.computeVisibilityWithPlaneMask = function (e, t) {
            if (t === a.MASK_OUTSIDE || t === a.MASK_INSIDE)return t;
            for (var i = a.MASK_INSIDE, n = this.planes, u = 0, l = n.length; l > u; ++u) {
                var c = 31 > u ? 1 << u : 0;
                if (!(31 > u && 0 === (t & c))) {
                    var h = e.intersectPlane(o.fromCartesian4(n[u], s));
                    if (h === r.OUTSIDE)return a.MASK_OUTSIDE;
                    h === r.INTERSECTING && (i |= c)
                }
            }
            return i
        }, a.MASK_OUTSIDE = 4294967295, a.MASK_INSIDE = 0, a.MASK_INDETERMINATE = 2147483647, a
    }),define("Cesium/Scene/Cesium3DTileset", ["../Core/appendForwardSlash", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Event", "../Core/loadJson", "../Core/Math", "./Cesium3DTile", "./Cesium3DTileRefine", "./CullingVolume", "./SceneMode", "../ThirdParty/when"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m) {
        "use strict";
        function p(e, t, i, n) {
            if (0 === e)return 0;
            var r = Math.max(t.distanceToCamera, u.EPSILON7), o = i.drawingBufferHeight, a = n.camera.frustum.sseDenominator;
            return e * o / (r * a)
        }

        function f(e, t) {
            for (var i = (t.camera, e.length), n = 0; i > n; ++n) {
                var r = e[n];
                r.distanceToCamera = r.distanceToTile(t)
            }
        }

        function _(e, t) {
            return t.distanceToCamera - e.distanceToCamera
        }

        function v(e, t) {
            if (O.hasAvailableRequests()) {
                ++O.numberOfPendingRequests;
                var i = e._statistics;
                ++i.numberOfPendingRequests, A(e), t.requestContent();
                var n = E(e, t);
                m(t.processingPromise).then(C(e, t)).otherwise(S(e, t)), m(t.readyPromise).then(n).otherwise(n)
            }
        }

        function g(e, t, i, n) {
            t.isReady() && (i || t.contentsVisibility(n.cullingVolume) !== h.MASK_OUTSIDE) && e.push(t)
        }

        function y(e, t, i, n, r) {
            if (!e.debugFreezeFrame) {
                var o = e.maximumScreenSpaceError, a = i.cullingVolume, s = e._selectedTiles;
                s.length = 0;
                var u = e._root;
                if (u.distanceToCamera = u.distanceToTile(i), u.parentPlaneMask = h.MASK_INDETERMINATE, !(p(e._geometricError, u, t, i) <= o)) {
                    if (u.isContentUnloaded())return void(r && v(e, u));
                    var l = e._statistics, d = R;
                    for (d.push(u); d.length > 0;) {
                        var m = d.pop();
                        ++l.visited;
                        var y = m.visibility(a);
                        if (y !== h.MASK_OUTSIDE) {
                            var C, E, S = y === h.MASK_INSIDE, T = p(m.geometricError, m, t, i), b = m.children, w = b.length;
                            if (m.refine === c.ADD) {
                                if (g(s, m, S, i), T > o) {
                                    var x = m.numberOfChildrenWithoutContent < w;
                                    if (x || O.hasAvailableRequests())for (f(b, i), b.sort(_), E = 0; w > E; ++E)C = b[E], C.parentPlaneMask = y, p(m.geometricError, C, t, i) > o && (C.isContentUnloaded() && C.visibility(a) !== h.MASK_OUTSIDE && r ? v(e, C) : d.push(C))
                                }
                            } else if (o >= T || 0 === w)g(s, m, S, i); else {
                                var A = 0 === m.numberOfChildrenWithoutContent;
                                if ((A || O.hasAvailableRequests()) && (f(b, i), b.sort(_)), A)for (E = 0; w > E; ++E)C = b[E], C.parentPlaneMask = y, d.push(C); else if (g(s, m, S, i), r)for (E = 0; w > E && O.hasAvailableRequests(); ++E)C = b[E], C.isContentUnloaded() && v(e, C)
                            }
                        }
                    }
                }
            }
        }

        function C(e, t) {
            return function () {
                e._processingQueue.push(t);
                var i = e._statistics;
                --i.numberOfPendingRequests, ++i.numberProcessing, A(e)
            }
        }

        function E(e, t) {
            return function () {
                var i = e._processingQueue.indexOf(t);
                e._processingQueue.splice(i, 1), --O.numberOfPendingRequests, --e._statistics.numberProcessing, A(e)
            }
        }

        function S(e, t) {
            return function () {
                --O.numberOfPendingRequests, --e._statistics.numberProcessing, A(e)
            }
        }

        function T(e, t, i) {
            for (var n = e._processingQueue, r = n.length, o = r - 1; o >= 0; --o)n[o].process(e, t, i)
        }

        function b(e) {
            var t = e._statistics;
            t.visited = 0, t.numberOfCommands = 0
        }

        function w(e, t) {
            var i = e._statistics;
            if (e.debugShowStatistics && (i.lastVisited !== i.visited || i.lastNumberOfCommands !== i.numberOfCommands || i.lastSelected !== e._selectedTiles.length || i.lastNumberOfPendingRequests !== i.numberOfPendingRequests || i.lastNumberProcessing !== i.numberProcessing)) {
                i.lastVisited = i.visited, i.lastNumberOfCommands = i.numberOfCommands, i.lastSelected = e._selectedTiles.length, i.lastNumberOfPendingRequests = i.numberOfPendingRequests, i.lastNumberProcessing = i.numberProcessing;
                var n = t ? "[Pick ]: " : "[Color]: ";
                n += "Visited: " + i.visited + ", Selected: " + e._selectedTiles.length + ", Commands: " + i.numberOfCommands + ", Requests: " + i.numberOfPendingRequests + ", Processing: " + i.numberProcessing, console.log(n)
            }
        }

        function x(e, t, i, n) {
            for (var r = n.length, o = e._selectedTiles, a = o.length, s = e.tileVisible, u = 0; a > u; ++u) {
                var l = o[u];
                s.raiseEvent(l), l.update(e, t, i, n)
            }
            e._statistics.numberOfCommands = n.length - r
        }

        function A(e) {
            if (e.loadProgress.numberOfListeners > 0) {
                var t = e._statistics;
                e._loadProgressEventsToRaise.push({
                    numberOfPendingRequests: t.numberOfPendingRequests,
                    numberProcessing: t.numberProcessing
                })
            }
        }

        function P(e, t, i) {
            return function () {
                e.loadProgress.raiseEvent(t, i)
            }
        }

        function I(e, t) {
            for (var i = e._loadProgressEventsToRaise, n = i.length, r = 0; n > r; ++r) {
                var o = i[r].numberOfPendingRequests, a = i[r].numberProcessing;
                t.afterRender.push(P(e, o, a))
            }
            i.length = 0
        }

        var D = function (n) {
            n = t(n, t.EMPTY_OBJECT);
            var r = n.url, o = e(r);
            this._url = r, this._root = void 0, this._properties = void 0, this._geometricError = void 0, this._processingQueue = [], this._selectedTiles = [], this.show = t(n.show, !0), this.maximumScreenSpaceError = t(n.maximumScreenSpaceError, 16), this.debugShowStatistics = t(n.debugShowStatistics, !1), this._statistics = {
                visited: 0,
                numberOfCommands: 0,
                numberOfPendingRequests: 0,
                numberProcessing: 0,
                lastSelected: -1,
                lastVisited: -1,
                lastNumberOfCommands: -1,
                lastNumberOfPendingRequests: -1,
                lastNumberProcessing: -1
            }, this.debugFreezeFrame = t(n.debugFreezeFrame, !1), this.debugColorizeTiles = t(n.debugColorizeTiles, !1), this.debugShowBox = t(n.debugShowBox, !1), this.debugShowcontentBox = t(n.debugShowcontentBox, !1), this.debugShowBoundingVolume = t(n.debugShowBoundingVolume, !1), this.debugShowContentsBoundingVolume = t(n.debugShowContentsBoundingVolume, !1), this.loadProgress = new a, this._loadProgressEventsToRaise = [], this.tileVisible = new a, this._readyPromise = m.defer();
            var u = this;
            s(o + "tiles.json").then(function (e) {
                u._properties = e.properties, u._geometricError = e.geometricError, u._root = new l(u, o, e.root, void 0);
                var t = [];
                for (t.push({header: e.root, cesium3DTile: u._root}); t.length > 0;) {
                    var n = t.pop(), r = n.header.children;
                    if (i(r))for (var a = r.length, s = 0; a > s; ++s) {
                        var c = r[s], h = new l(u, o, c, n.cesium3DTile);
                        n.cesium3DTile.children.push(h), t.push({header: c, cesium3DTile: h})
                    }
                }
                u._readyPromise.resolve(u)
            }).otherwise(function (e) {
                u._readyPromise.reject(e)
            })
        };
        n(D.prototype, {
            properties: {
                get: function () {
                    return this._properties
                }
            }, ready: {
                get: function () {
                    return i(this._root)
                }
            }, readyPromise: {
                get: function () {
                    return this._readyPromise
                }
            }, url: {
                get: function () {
                    return this._url
                }
            }
        });
        var M = function () {
            this.numberOfPendingRequests = 0, this.maximumNumberOfPendingRequests = 6
        };
        M.prototype.hasAvailableRequests = function () {
            return this.numberOfPendingRequests < this.maximumNumberOfPendingRequests
        };
        var O = new M, R = [];
        return D.prototype.update = function (e, t, n) {
            if (this.show && i(this._root) && t.mode === d.SCENE3D) {
                var r = t.passes, o = r.pick && !r.render, a = !o;
                b(this), a && T(this, e, t), y(this, e, t, n, a), x(this, e, t, n), I(this, t), w(this, o)
            }
        }, D.prototype.isDestroyed = function () {
            return !1
        }, D.prototype.destroy = function () {
            return r(this)
        }, D
    }),function (e, t) {
        "function" == typeof define && define.amd ? define("Cesium/ThirdParty/Autolinker", [], function () {
            return e.Autolinker = t()
        }) : "object" == typeof exports ? module.exports = t() : e.Autolinker = t()
    }(this, function () {
        var e = function (t) {
            e.Util.assign(this, t);
            var i = this.hashtag;
            if (i !== !1 && "twitter" !== i && "facebook" !== i)throw new Error("invalid `hashtag` cfg - see docs")
        };
        return e.prototype = {
            constructor: e,
            urls: !0,
            email: !0,
            twitter: !0,
            phone: !0,
            hashtag: !1,
            newWindow: !0,
            stripPrefix: !0,
            truncate: void 0,
            className: "",
            htmlParser: void 0,
            matchParser: void 0,
            tagBuilder: void 0,
            link: function (e) {
                for (var t = this.getHtmlParser(), i = t.parse(e), n = 0, r = [], o = 0, a = i.length; a > o; o++) {
                    var s = i[o], u = s.getType(), l = s.getText();
                    if ("element" === u)"a" === s.getTagName() && (s.isClosing() ? n = Math.max(n - 1, 0) : n++), r.push(l); else if ("entity" === u || "comment" === u)r.push(l); else if (0 === n) {
                        var c = this.linkifyStr(l);
                        r.push(c)
                    } else r.push(l)
                }
                return r.join("")
            },
            linkifyStr: function (e) {
                return this.getMatchParser().replace(e, this.createMatchReturnVal, this)
            },
            createMatchReturnVal: function (t) {
                var i;
                if (this.replaceFn && (i = this.replaceFn.call(this, this, t)), "string" == typeof i)return i;
                if (i === !1)return t.getMatchedText();
                if (i instanceof e.HtmlTag)return i.toAnchorString();
                var n = this.getTagBuilder(), r = n.build(t);
                return r.toAnchorString()
            },
            getHtmlParser: function () {
                var t = this.htmlParser;
                return t || (t = this.htmlParser = new e.htmlParser.HtmlParser), t
            },
            getMatchParser: function () {
                var t = this.matchParser;
                return t || (t = this.matchParser = new e.matchParser.MatchParser({
                    urls: this.urls,
                    email: this.email,
                    twitter: this.twitter,
                    phone: this.phone,
                    hashtag: this.hashtag,
                    stripPrefix: this.stripPrefix
                })), t
            },
            getTagBuilder: function () {
                var t = this.tagBuilder;
                return t || (t = this.tagBuilder = new e.AnchorTagBuilder({
                    newWindow: this.newWindow,
                    truncate: this.truncate,
                    className: this.className
                })), t
            }
        }, e.link = function (t, i) {
            var n = new e(i);
            return n.link(t)
        }, e.match = {}, e.htmlParser = {}, e.matchParser = {}, e.Util = {
            abstractMethod: function () {
                throw"abstract"
            }, trimRegex: /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, assign: function (e, t) {
                for (var i in t)t.hasOwnProperty(i) && (e[i] = t[i]);
                return e
            }, extend: function (t, i) {
                var n = t.prototype, r = function () {
                };
                r.prototype = n;
                var o;
                o = i.hasOwnProperty("constructor") ? i.constructor : function () {
                    n.constructor.apply(this, arguments)
                };
                var a = o.prototype = new r;
                return a.constructor = o, a.superclass = n, delete i.constructor, e.Util.assign(a, i), o
            }, ellipsis: function (e, t, i) {
                return e.length > t && (i = null == i ? ".." : i, e = e.substring(0, t - i.length) + i), e
            }, indexOf: function (e, t) {
                if (Array.prototype.indexOf)return e.indexOf(t);
                for (var i = 0, n = e.length; n > i; i++)if (e[i] === t)return i;
                return -1
            }, splitAndCapture: function (e, t) {
                if (!t.global)throw new Error("`splitRegex` must have the 'g' flag set");
                for (var i, n = [], r = 0; i = t.exec(e);)n.push(e.substring(r, i.index)), n.push(i[0]), r = i.index + i[0].length;
                return n.push(e.substring(r)), n
            }, trim: function (e) {
                return e.replace(this.trimRegex, "")
            }
        }, e.HtmlTag = e.Util.extend(Object, {
            whitespaceRegex: /\s+/, constructor: function (t) {
                e.Util.assign(this, t), this.innerHtml = this.innerHtml || this.innerHTML
            }, setTagName: function (e) {
                return this.tagName = e, this
            }, getTagName: function () {
                return this.tagName || ""
            }, setAttr: function (e, t) {
                var i = this.getAttrs();
                return i[e] = t, this
            }, getAttr: function (e) {
                return this.getAttrs()[e]
            }, setAttrs: function (t) {
                var i = this.getAttrs();
                return e.Util.assign(i, t), this
            }, getAttrs: function () {
                return this.attrs || (this.attrs = {})
            }, setClass: function (e) {
                return this.setAttr("class", e)
            }, addClass: function (t) {
                for (var i, n = this.getClass(), r = this.whitespaceRegex, o = e.Util.indexOf, a = n ? n.split(r) : [], s = t.split(r); i = s.shift();)-1 === o(a, i) && a.push(i);
                return this.getAttrs()["class"] = a.join(" "), this
            }, removeClass: function (t) {
                for (var i, n = this.getClass(), r = this.whitespaceRegex, o = e.Util.indexOf, a = n ? n.split(r) : [], s = t.split(r); a.length && (i = s.shift());) {
                    var u = o(a, i);
                    -1 !== u && a.splice(u, 1)
                }
                return this.getAttrs()["class"] = a.join(" "), this
            }, getClass: function () {
                return this.getAttrs()["class"] || ""
            }, hasClass: function (e) {
                return -1 !== (" " + this.getClass() + " ").indexOf(" " + e + " ")
            }, setInnerHtml: function (e) {
                return this.innerHtml = e, this
            }, getInnerHtml: function () {
                return this.innerHtml || ""
            }, toAnchorString: function () {
                var e = this.getTagName(), t = this.buildAttrsStr();
                return t = t ? " " + t : "", ["<", e, t, ">", this.getInnerHtml(), "</", e, ">"].join("")
            }, buildAttrsStr: function () {
                if (!this.attrs)return "";
                var e = this.getAttrs(), t = [];
                for (var i in e)e.hasOwnProperty(i) && t.push(i + '="' + e[i] + '"');
                return t.join(" ")
            }
        }), e.AnchorTagBuilder = e.Util.extend(Object, {
            constructor: function (t) {
                e.Util.assign(this, t)
            }, build: function (t) {
                var i = new e.HtmlTag({
                    tagName: "a",
                    attrs: this.createAttrs(t.getType(), t.getAnchorHref()),
                    innerHtml: this.processAnchorText(t.getAnchorText())
                });
                return i
            }, createAttrs: function (e, t) {
                var i = {href: t}, n = this.createCssClass(e);
                return n && (i["class"] = n), this.newWindow && (i.target = "_blank"), i
            }, createCssClass: function (e) {
                var t = this.className;
                return t ? t + " " + t + "-" + e : ""
            }, processAnchorText: function (e) {
                return e = this.doTruncate(e)
            }, doTruncate: function (t) {
                return e.Util.ellipsis(t, this.truncate || Number.POSITIVE_INFINITY)
            }
        }), e.htmlParser.HtmlParser = e.Util.extend(Object, {
            htmlRegex: function () {
                var e = /!--([\s\S]+?)--/, t = /[0-9a-zA-Z][0-9a-zA-Z:]*/, i = /[^\s\0"'>\/=\x01-\x1F\x7F]+/, n = /(?:"[^"]*?"|'[^']*?'|[^'"=<>`\s]+)/, r = i.source + "(?:\\s*=\\s*" + n.source + ")?";
                return new RegExp(["(?:", "<(!DOCTYPE)", "(?:", "\\s+", "(?:", r, "|", n.source + ")", ")*", ">", ")", "|", "(?:", "<(/)?", "(?:", e.source, "|", "(?:", "(" + t.source + ")", "(?:", "\\s+", r, ")*", "\\s*/?", ")", ")", ">", ")"].join(""), "gi")
            }(),
            htmlCharacterEntitiesRegex: /(&nbsp;|&#160;|&lt;|&#60;|&gt;|&#62;|&quot;|&#34;|&#39;)/gi,
            parse: function (e) {
                for (var t, i, n = this.htmlRegex, r = 0, o = []; null !== (t = n.exec(e));) {
                    var a = t[0], s = t[3], u = t[1] || t[4], l = !!t[2], c = e.substring(r, t.index);
                    c && (i = this.parseTextAndEntityNodes(c), o.push.apply(o, i)), s ? o.push(this.createCommentNode(a, s)) : o.push(this.createElementNode(a, u, l)), r = t.index + a.length
                }
                if (r < e.length) {
                    var h = e.substring(r);
                    h && (i = this.parseTextAndEntityNodes(h), o.push.apply(o, i))
                }
                return o
            },
            parseTextAndEntityNodes: function (t) {
                for (var i = [], n = e.Util.splitAndCapture(t, this.htmlCharacterEntitiesRegex), r = 0, o = n.length; o > r; r += 2) {
                    var a = n[r], s = n[r + 1];
                    a && i.push(this.createTextNode(a)), s && i.push(this.createEntityNode(s))
                }
                return i
            },
            createCommentNode: function (t, i) {
                return new e.htmlParser.CommentNode({text: t, comment: e.Util.trim(i)})
            },
            createElementNode: function (t, i, n) {
                return new e.htmlParser.ElementNode({text: t, tagName: i.toLowerCase(), closing: n})
            },
            createEntityNode: function (t) {
                return new e.htmlParser.EntityNode({text: t})
            },
            createTextNode: function (t) {
                return new e.htmlParser.TextNode({text: t})
            }
        }), e.htmlParser.HtmlNode = e.Util.extend(Object, {
            text: "", constructor: function (t) {
                e.Util.assign(this, t)
            }, getType: e.Util.abstractMethod, getText: function () {
                return this.text
            }
        }), e.htmlParser.CommentNode = e.Util.extend(e.htmlParser.HtmlNode, {
            comment: "", getType: function () {
                return "comment"
            }, getComment: function () {
                return this.comment
            }
        }), e.htmlParser.ElementNode = e.Util.extend(e.htmlParser.HtmlNode, {
            tagName: "",
            closing: !1,
            getType: function () {
                return "element"
            },
            getTagName: function () {
                return this.tagName
            },
            isClosing: function () {
                return this.closing
            }
        }), e.htmlParser.EntityNode = e.Util.extend(e.htmlParser.HtmlNode, {
            getType: function () {
                return "entity"
            }
        }), e.htmlParser.TextNode = e.Util.extend(e.htmlParser.HtmlNode, {
            getType: function () {
                return "text"
            }
        }), e.matchParser.MatchParser = e.Util.extend(Object, {
            urls: !0,
            email: !0,
            twitter: !0,
            phone: !0,
            hashtag: !1,
            stripPrefix: !0,
            matcherRegex: function () {
                var e = /(^|[^\w])@(\w{1,15})/, t = /(^|[^\w])#(\w{1,15})/, i = /(?:[\-;:&=\+\$,\w\.]+@)/, n = /(?:\+?\d{1,3}[-\s.])?\(?\d{3}\)?[-\s.]?\d{3}[-\s.]\d{4}/, r = /(?:[A-Za-z][-.+A-Za-z0-9]+:(?![A-Za-z][-.+A-Za-z0-9]+:\/\/)(?!\d+\/?)(?:\/\/)?)/, o = /(?:www\.)/, a = /[A-Za-z0-9\.\-]*[A-Za-z0-9\-]/, s = /\.(?:international|construction|contractors|enterprises|photography|productions|foundation|immobilien|industries|management|properties|technology|christmas|community|directory|education|equipment|institute|marketing|solutions|vacations|bargains|boutique|builders|catering|cleaning|clothing|computer|democrat|diamonds|graphics|holdings|lighting|partners|plumbing|supplies|training|ventures|academy|careers|company|cruises|domains|exposed|flights|florist|gallery|guitars|holiday|kitchen|neustar|okinawa|recipes|rentals|reviews|shiksha|singles|support|systems|agency|berlin|camera|center|coffee|condos|dating|estate|events|expert|futbol|kaufen|luxury|maison|monash|museum|nagoya|photos|repair|report|social|supply|tattoo|tienda|travel|viajes|villas|vision|voting|voyage|actor|build|cards|cheap|codes|dance|email|glass|house|mango|ninja|parts|photo|shoes|solar|today|tokyo|tools|watch|works|aero|arpa|asia|best|bike|blue|buzz|camp|club|cool|coop|farm|fish|gift|guru|info|jobs|kiwi|kred|land|limo|link|menu|mobi|moda|name|pics|pink|post|qpon|rich|ruhr|sexy|tips|vote|voto|wang|wien|wiki|zone|bar|bid|biz|cab|cat|ceo|com|edu|gov|int|kim|mil|net|onl|org|pro|pub|red|tel|uno|wed|xxx|xyz|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|za|zm|zw)\b/, u = /[\-A-Za-z0-9+&@#\/%=~_()|'$*\[\]?!:,.;]*[\-A-Za-z0-9+&@#\/%=~_()|'$*\[\]]/;
                return new RegExp(["(", e.source, ")", "|", "(", i.source, a.source, s.source, ")", "|", "(", "(?:", "(", r.source, a.source, ")", "|", "(?:", "(.?//)?", o.source, a.source, ")", "|", "(?:", "(.?//)?", a.source, s.source, ")", ")", "(?:" + u.source + ")?", ")", "|", "(", n.source, ")", "|", "(", t.source, ")"].join(""), "gi")
            }(),
            charBeforeProtocolRelMatchRegex: /^(.)?\/\//,
            constructor: function (t) {
                e.Util.assign(this, t), this.matchValidator = new e.MatchValidator
            },
            replace: function (e, t, i) {
                var n = this;
                return e.replace(this.matcherRegex, function (e, r, o, a, s, u, l, c, h, d, m, p, f) {
                    var _ = n.processCandidateMatch(e, r, o, a, s, u, l, c, h, d, m, p, f);
                    if (_) {
                        var v = t.call(i, _.match);
                        return _.prefixStr + v + _.suffixStr
                    }
                    return e
                })
            },
            processCandidateMatch: function (t, i, n, r, o, a, s, u, l, c, h, d, m) {
                var p, f = u || l, _ = "", v = "";
                if (a && !this.urls || o && !this.email || c && !this.phone || i && !this.twitter || h && !this.hashtag || !this.matchValidator.isValidMatch(a, s, f))return null;
                if (this.matchHasUnbalancedClosingParen(t) && (t = t.substr(0, t.length - 1), v = ")"), o)p = new e.match.Email({
                    matchedText: t,
                    email: o
                }); else if (i)n && (_ = n, t = t.slice(1)), p = new e.match.Twitter({
                    matchedText: t,
                    twitterHandle: r
                }); else if (c) {
                    var g = t.replace(/\D/g, "");
                    p = new e.match.Phone({matchedText: t, number: g})
                } else if (h)d && (_ = d, t = t.slice(1)), p = new e.match.Hashtag({
                    matchedText: t,
                    serviceName: this.hashtag,
                    hashtag: m
                }); else {
                    if (f) {
                        var y = f.match(this.charBeforeProtocolRelMatchRegex)[1] || "";
                        y && (_ = y, t = t.slice(1))
                    }
                    p = new e.match.Url({
                        matchedText: t,
                        url: t,
                        protocolUrlMatch: !!s,
                        protocolRelativeMatch: !!f,
                        stripPrefix: this.stripPrefix
                    })
                }
                return {prefixStr: _, suffixStr: v, match: p}
            },
            matchHasUnbalancedClosingParen: function (e) {
                var t = e.charAt(e.length - 1);
                if (")" === t) {
                    var i = e.match(/\(/g), n = e.match(/\)/g), r = i && i.length || 0, o = n && n.length || 0;
                    if (o > r)return !0
                }
                return !1
            }
        }), e.MatchValidator = e.Util.extend(Object, {
            invalidProtocolRelMatchRegex: /^[\w]\/\//,
            hasFullProtocolRegex: /^[A-Za-z][-.+A-Za-z0-9]+:\/\//,
            uriSchemeRegex: /^[A-Za-z][-.+A-Za-z0-9]+:/,
            hasWordCharAfterProtocolRegex: /:[^\s]*?[A-Za-z]/,
            isValidMatch: function (e, t, i) {
                return t && !this.isValidUriScheme(t) || this.urlMatchDoesNotHaveProtocolOrDot(e, t) || this.urlMatchDoesNotHaveAtLeastOneWordChar(e, t) || this.isInvalidProtocolRelativeMatch(i) ? !1 : !0
            },
            isValidUriScheme: function (e) {
                var t = e.match(this.uriSchemeRegex)[0].toLowerCase();
                return "javascript:" !== t && "vbscript:" !== t
            },
            urlMatchDoesNotHaveProtocolOrDot: function (e, t) {
                return !(!e || t && this.hasFullProtocolRegex.test(t) || -1 !== e.indexOf("."))
            },
            urlMatchDoesNotHaveAtLeastOneWordChar: function (e, t) {
                return e && t ? !this.hasWordCharAfterProtocolRegex.test(e) : !1
            },
            isInvalidProtocolRelativeMatch: function (e) {
                return !!e && this.invalidProtocolRelMatchRegex.test(e)
            }
        }), e.match.Match = e.Util.extend(Object, {
            constructor: function (t) {
                e.Util.assign(this, t)
            }, getType: e.Util.abstractMethod, getMatchedText: function () {
                return this.matchedText
            }, getAnchorHref: e.Util.abstractMethod, getAnchorText: e.Util.abstractMethod
        }), e.match.Email = e.Util.extend(e.match.Match, {
            getType: function () {
                return "email"
            }, getEmail: function () {
                return this.email
            }, getAnchorHref: function () {
                return "mailto:" + this.email
            }, getAnchorText: function () {
                return this.email
            }
        }), e.match.Hashtag = e.Util.extend(e.match.Match, {
            getType: function () {
                return "hashtag"
            }, getHashtag: function () {
                return this.hashtag
            }, getAnchorHref: function () {
                var e = this.serviceName, t = this.hashtag;
                switch (e) {
                    case"twitter":
                        return "https://twitter.com/hashtag/" + t;
                    case"facebook":
                        return "https://www.facebook.com/hashtag/" + t;
                    default:
                        throw new Error("Unknown service name to point hashtag to: ", e)
                }
            }, getAnchorText: function () {
                return "#" + this.hashtag
            }
        }), e.match.Phone = e.Util.extend(e.match.Match, {
            getType: function () {
                return "phone"
            }, getNumber: function () {
                return this.number
            }, getAnchorHref: function () {
                return "tel:" + this.number
            }, getAnchorText: function () {
                return this.matchedText
            }
        }), e.match.Twitter = e.Util.extend(e.match.Match, {
            getType: function () {
                return "twitter"
            }, getTwitterHandle: function () {
                return this.twitterHandle
            }, getAnchorHref: function () {
                return "https://twitter.com/" + this.twitterHandle
            }, getAnchorText: function () {
                return "@" + this.twitterHandle
            }
        }), e.match.Url = e.Util.extend(e.match.Match, {
            urlPrefixRegex: /^(https?:\/\/)?(www\.)?/i,
            protocolRelativeRegex: /^\/\//,
            protocolPrepended: !1,
            getType: function () {
                return "url"
            },
            getUrl: function () {
                var e = this.url;
                return this.protocolRelativeMatch || this.protocolUrlMatch || this.protocolPrepended || (e = this.url = "http://" + e, this.protocolPrepended = !0), e
            },
            getAnchorHref: function () {
                var e = this.getUrl();
                return e.replace(/&amp;/g, "&")
            },
            getAnchorText: function () {
                var e = this.getUrl();
                return this.protocolRelativeMatch && (e = this.stripProtocolRelativePrefix(e)), this.stripPrefix && (e = this.stripUrlPrefix(e)), e = this.removeTrailingSlash(e)
            },
            stripUrlPrefix: function (e) {
                return e.replace(this.urlPrefixRegex, "")
            },
            stripProtocolRelativePrefix: function (e) {
                return e.replace(this.protocolRelativeRegex, "")
            },
            removeTrailingSlash: function (e) {
                return "/" === e.charAt(e.length - 1) && (e = e.slice(0, -1)), e
            }
        }), e
    }),define("Cesium/Core/EventHelper", ["./defined", "./DeveloperError"], function (e, t) {
        "use strict";
        var i = function () {
            this._removalFunctions = []
        };
        return i.prototype.add = function (e, t, i) {
            var n = e.addEventListener(t, i);
            this._removalFunctions.push(n);
            var r = this;
            return function () {
                n();
                var e = r._removalFunctions;
                e.splice(e.indexOf(n), 1)
            }
        }, i.prototype.removeAll = function () {
            for (var e = this._removalFunctions, t = 0, i = e.length; i > t; ++t)e[t]();
            e.length = 0
        }, i
    }),define("Cesium/DataSources/BoundingSphereState", ["../Core/freezeObject"], function (e) {
        "use strict";
        var t = {DONE: 0, PENDING: 1, FAILED: 2};
        return e(t)
    }),define("Cesium/DataSources/DataSourceCollection", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Event", "../ThirdParty/when"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = function () {
            this._dataSources = [], this._dataSourceAdded = new o, this._dataSourceRemoved = new o
        };
        return i(s.prototype, {
            length: {
                get: function () {
                    return this._dataSources.length
                }
            }, dataSourceAdded: {
                get: function () {
                    return this._dataSourceAdded
                }
            }, dataSourceRemoved: {
                get: function () {
                    return this._dataSourceRemoved
                }
            }
        }), s.prototype.add = function (e) {
            var t = this, i = this._dataSources;
            return a(e, function (e) {
                return i === t._dataSources && (t._dataSources.push(e), t._dataSourceAdded.raiseEvent(t, e)), e
            })
        }, s.prototype.remove = function (t, i) {
            i = e(i, !1);
            var n = this._dataSources.indexOf(t);
            return -1 !== n ? (this._dataSources.splice(n, 1), this._dataSourceRemoved.raiseEvent(this, t), i && "function" == typeof t.destroy && t.destroy(), !0) : !1
        }, s.prototype.removeAll = function (t) {
            t = e(t, !1);
            for (var i = this._dataSources, n = 0, r = i.length; r > n; ++n) {
                var o = i[n];
                this._dataSourceRemoved.raiseEvent(this, o), t && "function" == typeof o.destroy && o.destroy()
            }
            this._dataSources = []
        }, s.prototype.contains = function (e) {
            return -1 !== this.indexOf(e)
        }, s.prototype.indexOf = function (e) {
            return this._dataSources.indexOf(e)
        }, s.prototype.get = function (e) {
            return this._dataSources[e]
        }, s.prototype.isDestroyed = function () {
            return !1
        }, s.prototype.destroy = function () {
            return this.removeAll(!0), n(this)
        }, s
    }),define("Cesium/Core/AssociativeArray", ["./defined", "./defineProperties", "./DeveloperError"], function (e, t, i) {
        "use strict";
        var n = function () {
            this._array = [], this._hash = {}
        };
        return t(n.prototype, {
            length: {
                get: function () {
                    return this._array.length
                }
            }, values: {
                get: function () {
                    return this._array
                }
            }
        }), n.prototype.contains = function (t) {
            return e(this._hash[t])
        }, n.prototype.set = function (e, t) {
            var i = this._hash[e];
            t !== i && (this.remove(e), this._hash[e] = t, this._array.push(t))
        }, n.prototype.get = function (e) {
            return this._hash[e]
        }, n.prototype.remove = function (t) {
            var i = this._hash[t], n = e(i);
            if (n) {
                var r = this._array;
                r.splice(r.indexOf(i), 1), delete this._hash[t]
            }
            return n
        }, n.prototype.removeAll = function () {
            var e = this._array;
            e.length > 0 && (this._hash = {}, e.length = 0)
        }, n
    }),define("Cesium/Core/NearFarScalar", ["./defaultValue", "./defined", "./DeveloperError"], function (e, t, i) {
        "use strict";
        var n = function (t, i, n, r) {
            this.near = e(t, 0), this.nearValue = e(i, 0), this.far = e(n, 1), this.farValue = e(r, 0)
        };
        return n.clone = function (e, i) {
            return t(e) ? t(i) ? (i.near = e.near, i.nearValue = e.nearValue, i.far = e.far, i.farValue = e.farValue, i) : new n(e.near, e.nearValue, e.far, e.farValue) : void 0
        }, n.packedLength = 4, n.pack = function (t, i, n) {
            n = e(n, 0), i[n++] = t.near, i[n++] = t.nearValue, i[n++] = t.far, i[n] = t.farValue
        }, n.unpack = function (i, r, o) {
            return r = e(r, 0), t(o) || (o = new n), o.near = i[r++], o.nearValue = i[r++], o.far = i[r++], o.farValue = i[r], o
        }, n.equals = function (e, i) {
            return e === i || t(e) && t(i) && e.near === i.near && e.nearValue === i.nearValue && e.far === i.far && e.farValue === i.farValue
        }, n.prototype.clone = function (e) {
            return n.clone(this, e)
        }, n.prototype.equals = function (e) {
            return n.equals(this, e)
        }, n
    }),define("Cesium/Renderer/VertexArrayFacade", ["../Core/ComponentDatatype", "../Core/defaultValue", "../Core/defined", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Math", "./Buffer", "./BufferUsage", "./VertexArray"], function (e, t, i, n, r, o, a, s, u) {
        "use strict";
        function l(e, t) {
            if (t.needsCommit && t.vertexSizeInBytes > 0) {
                t.needsCommit = !1;
                var n = t.vertexBuffer, r = e._size * t.vertexSizeInBytes, o = i(n);
                if (!o || n.sizeInBytes < r)return o && n.destroy(), t.vertexBuffer = a.createVertexBuffer({
                    context: e._context,
                    typedArray: t.arrayBuffer,
                    usage: t.usage
                }), t.vertexBuffer.vertexArrayDestroyable = !1, !0;
                t.vertexBuffer.copyFromArrayView(t.arrayBuffer)
            }
            return !1
        }

        function c(e, t, i) {
            if (e.needsCommit && e.vertexSizeInBytes > 0) {
                var n = e.vertexSizeInBytes * t, r = e.vertexSizeInBytes * i;
                e.vertexBuffer.copyFromArrayView(new Uint8Array(e.arrayBuffer, n, r), n)
            }
        }

        function h(e) {
            var t = e.va;
            if (i(t)) {
                for (var n = t.length, r = 0; n > r; ++r)t[r].va.destroy();
                e.va = void 0
            }
        }

        var d = function (t, n, r) {
            function o(t, i) {
                return e.getSizeInBytes(i.componentDatatype) - e.getSizeInBytes(t.componentDatatype)
            }

            var a = d._verifyAttributes(n);
            r = r || 0;
            for (var u, l, c = [], h = {}, m = a.length, p = 0; m > p; ++p) {
                var f = a[p];
                f.vertexBuffer ? c.push(f) : (l = f.usage, u = h[l], i(u) || (u = h[l] = []), u.push(f))
            }
            this._buffersByUsage = {}, this._allBuffers = [];
            for (l in h)if (h.hasOwnProperty(l)) {
                u = h[l], u.sort(o);
                var _, v = d._vertexSizeInBytes(u);
                switch (Number(l)) {
                    case s.STATIC_DRAW:
                        _ = s.STATIC_DRAW;
                        break;
                    case s.STREAM_DRAW:
                        _ = s.STREAM_DRAW;
                        break;
                    case s.DYNAMIC_DRAW:
                        _ = s.DYNAMIC_DRAW
                }
                var g = {
                    vertexSizeInBytes: v,
                    vertexBuffer: void 0,
                    usage: _,
                    needsCommit: !1,
                    arrayBuffer: void 0,
                    arrayViews: d._createArrayViews(u, v)
                };
                this._buffersByUsage[l] = g, this._allBuffers.push(g)
            }
            this._size = 0, this._precreated = c, this._context = t, this.writers = void 0, this.va = void 0, this.resize(r)
        };
        d._verifyAttributes = function (i) {
            for (var n = [], o = 0; o < i.length; ++o) {
                var a = i[o], u = {
                    index: t(a.index, o),
                    enabled: t(a.enabled, !0),
                    componentsPerAttribute: a.componentsPerAttribute,
                    componentDatatype: a.componentDatatype || e.FLOAT,
                    normalize: a.normalize || !1,
                    vertexBuffer: a.vertexBuffer,
                    usage: a.usage || s.STATIC_DRAW
                };
                if (n.push(u), 1 !== u.componentsPerAttribute && 2 !== u.componentsPerAttribute && 3 !== u.componentsPerAttribute && 4 !== u.componentsPerAttribute)throw new r("attribute.componentsPerAttribute must be in the range [1, 4].");
                var l = u.componentDatatype;
                if (!e.validate(l))throw new r("Attribute must have a valid componentDatatype or not specify it.");
                if (!s.validate(u.usage))throw new r("Attribute must have a valid usage or not specify it.")
            }
            for (var c = new Array(n.length), h = 0; h < n.length; ++h) {
                var d = n[h], m = d.index;
                if (c[m])throw new r("Index " + m + " is used by more than one attribute.");
                c[m] = !0
            }
            return n
        }, d._vertexSizeInBytes = function (t) {
            for (var i = 0, n = t.length, r = 0; n > r; ++r) {
                var o = t[r];
                i += o.componentsPerAttribute * e.getSizeInBytes(o.componentDatatype)
            }
            var a = n > 0 ? e.getSizeInBytes(t[0].componentDatatype) : 0, s = a > 0 ? i % a : 0, u = 0 === s ? 0 : a - s;
            return i += u
        }, d._createArrayViews = function (t, i) {
            for (var n = [], r = 0, o = t.length, a = 0; o > a; ++a) {
                var s = t[a], u = s.componentDatatype;
                n.push({
                    index: s.index,
                    enabled: s.enabled,
                    componentsPerAttribute: s.componentsPerAttribute,
                    componentDatatype: u,
                    normalize: s.normalize,
                    offsetInBytes: r,
                    vertexSizeInComponentType: i / e.getSizeInBytes(u),
                    view: void 0
                }), r += s.componentsPerAttribute * e.getSizeInBytes(u)
            }
            return n
        }, d.prototype.resize = function (e) {
            this._size = e;
            var t = this._allBuffers;
            this.writers = [];
            for (var i = 0, n = t.length; n > i; ++i) {
                var r = t[i];
                d._resize(r, this._size), d._appendWriters(this.writers, r)
            }
            h(this)
        }, d._resize = function (t, n) {
            if (t.vertexSizeInBytes > 0) {
                var r = new ArrayBuffer(n * t.vertexSizeInBytes);
                if (i(t.arrayBuffer))for (var o = new Uint8Array(r), a = new Uint8Array(t.arrayBuffer), s = a.length, u = 0; s > u; ++u)o[u] = a[u];
                for (var l = t.arrayViews, c = l.length, h = 0; c > h; ++h) {
                    var d = l[h];
                    d.view = e.createArrayBufferView(d.componentDatatype, r, d.offsetInBytes)
                }
                t.arrayBuffer = r
            }
        };
        var m = [function (e, t, i) {
            return function (n, r) {
                t[n * i] = r, e.needsCommit = !0
            }
        }, function (e, t, i) {
            return function (n, r, o) {
                var a = n * i;
                t[a] = r, t[a + 1] = o, e.needsCommit = !0
            }
        }, function (e, t, i) {
            return function (n, r, o, a) {
                var s = n * i;
                t[s] = r, t[s + 1] = o, t[s + 2] = a, e.needsCommit = !0
            }
        }, function (e, t, i) {
            return function (n, r, o, a, s) {
                var u = n * i;
                t[u] = r, t[u + 1] = o, t[u + 2] = a, t[u + 3] = s, e.needsCommit = !0
            }
        }];
        return d._appendWriters = function (e, t) {
            for (var i = t.arrayViews, n = i.length, r = 0; n > r; ++r) {
                var o = i[r];
                e[o.index] = m[o.componentsPerAttribute - 1](t, o.view, o.vertexSizeInComponentType)
            }
        }, d.prototype.commit = function (e) {
            for (var t, n = !1, r = this._allBuffers, a = 0, s = r.length; s > a; ++a)t = r[a], n = l(this, t) || n;
            if (n || !i(this.va)) {
                var c = this._buffersByUsage;
                h(this);
                for (var m = this.va = [], p = i(e) ? Math.ceil(this._size / o.SIXTY_FOUR_KILOBYTES) : 1, f = 0; p > f; ++f) {
                    var _ = [];
                    for (var v in c)c.hasOwnProperty(v) && (t = c[v], d._appendAttributes(_, t, f * t.vertexSizeInBytes * o.SIXTY_FOUR_KILOBYTES));
                    _ = _.concat(this._precreated), m.push({
                        va: new u({
                            context: this._context,
                            attributes: _,
                            indexBuffer: e
                        }),
                        indicesCount: 1.5 * (f !== p - 1 ? o.SIXTY_FOUR_KILOBYTES : this._size % o.SIXTY_FOUR_KILOBYTES)
                    })
                }
            }
        }, d._appendAttributes = function (e, t, i) {
            for (var n = t.arrayViews, r = n.length, o = 0; r > o; ++o) {
                var a = n[o];
                e.push({
                    index: a.index,
                    enabled: a.enabled,
                    componentsPerAttribute: a.componentsPerAttribute,
                    componentDatatype: a.componentDatatype,
                    normalize: a.normalize,
                    vertexBuffer: t.vertexBuffer,
                    offsetInBytes: i + a.offsetInBytes,
                    strideInBytes: t.vertexSizeInBytes
                })
            }
        }, d.prototype.subCommit = function (e, t) {
            for (var i = this._allBuffers, n = 0, r = i.length; r > n; ++n)c(i[n], e, t)
        }, d.prototype.endSubCommits = function () {
            for (var e = this._allBuffers, t = 0, i = e.length; i > t; ++t)e[t].needsCommit = !1
        }, d.prototype.isDestroyed = function () {
            return !1
        }, d.prototype.destroy = function () {
            for (var e = this._allBuffers, t = 0, i = e.length; i > t; ++t) {
                var r = e[t];
                r.vertexBuffer = r.vertexBuffer && r.vertexBuffer.destroy()
            }
            return h(this), n(this)
        }, d
    }),define("Cesium/Shaders/BillboardCollectionFS", [], function () {
        "use strict";
        return "uniform sampler2D u_atlas;\n\nvarying vec2 v_textureCoordinates;\n\n#ifdef RENDER_FOR_PICK\nvarying vec4 v_pickColor;\n#else\nvarying vec4 v_color;\n#endif\n\nvoid main()\n{\n#ifdef RENDER_FOR_PICK\n    vec4 vertexColor = vec4(1.0, 1.0, 1.0, 1.0);\n#else\n    vec4 vertexColor = v_color;\n#endif\n    \n    vec4 color = texture2D(u_atlas, v_textureCoordinates) * vertexColor;\n    if (color.a == 0.0)\n    {\n        discard;\n    }\n    \n#ifdef RENDER_FOR_PICK\n    gl_FragColor = v_pickColor;\n#else\n    gl_FragColor = color;\n#endif\n}"
    }),define("Cesium/Shaders/BillboardCollectionVS", [], function () {
        "use strict";
        return "attribute vec4 positionHighAndScale;\nattribute vec4 positionLowAndRotation;   \nattribute vec4 compressedAttribute0;        // pixel offset, translate, horizontal origin, vertical origin, show, texture coordinates, direction\nattribute vec4 compressedAttribute1;        // aligned axis, translucency by distance, image width\nattribute vec4 compressedAttribute2;        // image height, color, pick color, 15 bits free\nattribute vec3 eyeOffset;                   // eye offset in meters\nattribute vec4 scaleByDistance;             // near, nearScale, far, farScale\nattribute vec4 pixelOffsetScaleByDistance;  // near, nearScale, far, farScale\n\nvarying vec2 v_textureCoordinates;\n\n#ifdef RENDER_FOR_PICK\nvarying vec4 v_pickColor;\n#else\nvarying vec4 v_color;\n#endif\n\nconst float UPPER_BOUND = 32768.0;\n\nconst float SHIFT_LEFT16 = 65536.0;\nconst float SHIFT_LEFT8 = 256.0;\nconst float SHIFT_LEFT7 = 128.0;\nconst float SHIFT_LEFT5 = 32.0;\nconst float SHIFT_LEFT3 = 8.0;\nconst float SHIFT_LEFT2 = 4.0;\nconst float SHIFT_LEFT1 = 2.0;\n\nconst float SHIFT_RIGHT8 = 1.0 / 256.0;\nconst float SHIFT_RIGHT7 = 1.0 / 128.0;\nconst float SHIFT_RIGHT5 = 1.0 / 32.0;\nconst float SHIFT_RIGHT3 = 1.0 / 8.0;\nconst float SHIFT_RIGHT2 = 1.0 / 4.0;\nconst float SHIFT_RIGHT1 = 1.0 / 2.0;\n\nvec4 computePositionWindowCoordinates(vec4 positionEC, vec2 imageSize, float scale, vec2 direction, vec2 origin, vec2 translate, vec2 pixelOffset, vec3 alignedAxis, float rotation, bool sizeInMeters)\n{\n    vec2 halfSize = imageSize * scale * czm_resolutionScale;\n    halfSize *= ((direction * 2.0) - 1.0);\n    \n    if (sizeInMeters)\n    {\n        positionEC.xy += halfSize;\n    }\n    \n    vec4 positionWC = czm_eyeToWindowCoordinates(positionEC);\n    \n    if (sizeInMeters)\n    {\n        positionWC.xy += (origin * abs(halfSize)) / czm_metersPerPixel(positionEC);\n    }\n    else\n    {\n        positionWC.xy += (origin * abs(halfSize));\n    }\n    \n#if defined(ROTATION) || defined(ALIGNED_AXIS)\n    if (!all(equal(alignedAxis, vec3(0.0))) || rotation != 0.0)\n    {\n        float angle = rotation;\n        if (!all(equal(alignedAxis, vec3(0.0))))\n        {\n            vec3 pos = positionEC.xyz + czm_encodedCameraPositionMCHigh + czm_encodedCameraPositionMCLow;\n            vec3 normal = normalize(cross(alignedAxis, pos));\n            vec4 tangent = vec4(normalize(cross(pos, normal)), 0.0);\n            tangent = czm_modelViewProjection * tangent;\n            angle += sign(-tangent.x) * acos(tangent.y / length(tangent.xy));\n        }\n        \n        float cosTheta = cos(angle);\n        float sinTheta = sin(angle);\n        mat2 rotationMatrix = mat2(cosTheta, sinTheta, -sinTheta, cosTheta);\n        halfSize = rotationMatrix * halfSize;\n    }\n#endif\n    \n    if (!sizeInMeters)\n    {\n        positionWC.xy += halfSize;\n    }\n    \n    positionWC.xy += translate;\n    positionWC.xy += (pixelOffset * czm_resolutionScale);\n    \n    return positionWC;\n}\n\nvoid main() \n{\n    // Modifying this shader may also require modifications to Billboard._computeScreenSpacePosition\n    \n    // unpack attributes\n    vec3 positionHigh = positionHighAndScale.xyz;\n    vec3 positionLow = positionLowAndRotation.xyz;\n    float scale = positionHighAndScale.w;\n    \n#if defined(ROTATION) || defined(ALIGNED_AXIS)\n    float rotation = positionLowAndRotation.w;\n#else\n    float rotation = 0.0;\n#endif\n\n    float compressed = compressedAttribute0.x;\n    \n    vec2 pixelOffset;\n    pixelOffset.x = floor(compressed * SHIFT_RIGHT7);\n    compressed -= pixelOffset.x * SHIFT_LEFT7;\n    pixelOffset.x -= UPPER_BOUND;\n    \n    vec2 origin;\n    origin.x = floor(compressed * SHIFT_RIGHT5);\n    compressed -= origin.x * SHIFT_LEFT5;\n    \n    origin.y = floor(compressed * SHIFT_RIGHT3);\n    compressed -= origin.y * SHIFT_LEFT3;\n    \n    origin -= vec2(1.0);\n    \n    float show = floor(compressed * SHIFT_RIGHT2);\n    compressed -= show * SHIFT_LEFT2;\n    \n    vec2 direction;\n    direction.x = floor(compressed * SHIFT_RIGHT1);\n    direction.y = compressed - direction.x * SHIFT_LEFT1;\n    \n    float temp = compressedAttribute0.y  * SHIFT_RIGHT8;\n    pixelOffset.y = -(floor(temp) - UPPER_BOUND);\n    \n    vec2 translate;\n    translate.y = (temp - floor(temp)) * SHIFT_LEFT16;\n    \n    temp = compressedAttribute0.z * SHIFT_RIGHT8;\n    translate.x = floor(temp) - UPPER_BOUND;\n    \n    translate.y += (temp - floor(temp)) * SHIFT_LEFT8;\n    translate.y -= UPPER_BOUND;\n    \n    vec2 textureCoordinates = czm_decompressTextureCoordinates(compressedAttribute0.w);\n    \n    temp = compressedAttribute1.x * SHIFT_RIGHT8;\n    \n    vec2 imageSize = vec2(floor(temp), compressedAttribute2.w);\n    \n#ifdef EYE_DISTANCE_TRANSLUCENCY\n    vec4 translucencyByDistance;\n    translucencyByDistance.x = compressedAttribute1.z;\n    translucencyByDistance.z = compressedAttribute1.w;\n    \n    translucencyByDistance.y = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;\n    \n    temp = compressedAttribute1.y * SHIFT_RIGHT8;\n    translucencyByDistance.w = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;\n#endif\n\n#ifdef ALIGNED_AXIS\n    vec3 alignedAxis = czm_octDecode(floor(compressedAttribute1.y * SHIFT_RIGHT8));\n#else\n    vec3 alignedAxis = vec3(0.0);\n#endif\n    \n#ifdef RENDER_FOR_PICK\n    temp = compressedAttribute2.y;\n#else\n    temp = compressedAttribute2.x;\n#endif\n\n    vec4 color;\n    temp = temp * SHIFT_RIGHT8;\n    color.b = (temp - floor(temp)) * SHIFT_LEFT8;\n    temp = floor(temp) * SHIFT_RIGHT8;\n    color.g = (temp - floor(temp)) * SHIFT_LEFT8;\n    color.r = floor(temp);\n    \n    temp = compressedAttribute2.z * SHIFT_RIGHT8;\n    bool sizeInMeters = (temp - floor(temp)) * SHIFT_LEFT8 > 0.0;\n    temp = floor(temp) * SHIFT_RIGHT8;\n    \n#ifdef RENDER_FOR_PICK\n    color.a = (temp - floor(temp)) * SHIFT_LEFT8;\n    vec4 pickColor = color / 255.0;\n#else\n    color.a = floor(temp);\n    color /= 255.0;\n#endif\n    \n    ///////////////////////////////////////////////////////////////////////////\n    \n    vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n    vec4 positionEC = czm_modelViewRelativeToEye * p;\n    positionEC = czm_eyeOffset(positionEC, eyeOffset);\n    positionEC.xyz *= show;\n    \n    ///////////////////////////////////////////////////////////////////////////     \n\n#if defined(EYE_DISTANCE_SCALING) || defined(EYE_DISTANCE_TRANSLUCENCY) || defined(EYE_DISTANCE_PIXEL_OFFSET)\n    float lengthSq;\n    if (czm_sceneMode == czm_sceneMode2D)\n    {\n        // 2D camera distance is a special case\n        // treat all billboards as flattened to the z=0.0 plane\n        lengthSq = czm_eyeHeight2D.y;\n    }\n    else\n    {\n        lengthSq = dot(positionEC.xyz, positionEC.xyz);\n    }\n#endif\n\n#ifdef EYE_DISTANCE_SCALING\n    scale *= czm_nearFarScalar(scaleByDistance, lengthSq);\n    // push vertex behind near plane for clipping\n    if (scale == 0.0)\n    {\n        positionEC.xyz = vec3(0.0);\n    }\n#endif\n\n    float translucency = 1.0;\n#ifdef EYE_DISTANCE_TRANSLUCENCY\n    translucency = czm_nearFarScalar(translucencyByDistance, lengthSq);\n    // push vertex behind near plane for clipping\n    if (translucency == 0.0)\n    {\n        positionEC.xyz = vec3(0.0);\n    }\n#endif\n\n#ifdef EYE_DISTANCE_PIXEL_OFFSET\n    float pixelOffsetScale = czm_nearFarScalar(pixelOffsetScaleByDistance, lengthSq);\n    pixelOffset *= pixelOffsetScale;\n#endif\n    \n#ifdef CLAMPED_TO_GROUND\n    // move slightly closer to camera to avoid depth issues.\n    positionEC.z *= 0.995;\n    \n    // Force bottom vertical origin\n    origin.y = 1.0;\n#endif\n\n    vec4 positionWC = computePositionWindowCoordinates(positionEC, imageSize, scale, direction, origin, translate, pixelOffset, alignedAxis, rotation, sizeInMeters);\n    gl_Position = czm_viewportOrthographic * vec4(positionWC.xy, -positionWC.z, 1.0);\n    v_textureCoordinates = textureCoordinates;\n\n#ifdef RENDER_FOR_PICK\n    v_pickColor = pickColor;\n#else\n    v_color = color;\n    v_color.a *= translucency;\n#endif\n}\n"
    }),define("Cesium/Scene/HeightReference", ["../Core/freezeObject"], function (e) {
        "use strict";
        var t = {NONE: 0, CLAMP_TO_GROUND: 1, RELATIVE_TO_GROUND: 2};
        return e(t)
    }),define("Cesium/Scene/HorizontalOrigin", ["../Core/freezeObject"], function (e) {
        "use strict";
        var t = {CENTER: 0, LEFT: 1, RIGHT: -1};
        return e(t)
    }),define("Cesium/Scene/SceneTransforms", ["../Core/BoundingRectangle", "../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/Cartographic", "../Core/defined", "../Core/DeveloperError", "../Core/Math", "../Core/Matrix4", "./SceneMode"], function (e, t, i, n, r, o, a, s, u, l) {
        "use strict";
        var c = {}, h = new n(0, 0, 0, 1), d = new n, m = new u;
        c.wgs84ToWindowCoordinates = function (e, t, i) {
            var r = c.computeActualWgs84Position(e.frameState, t, h);
            if (!o(r))return void 0;
            var a = e.camera, s = u.multiply(a.frustum.projectionMatrix, a.viewMatrix, m);
            return u.multiplyByVector(s, n.fromElements(r.x, r.y, r.z, 1, d), d), d.z < 0 && e.mode !== l.SCENE2D ? void 0 : (i = c.clipToGLWindowCoordinates(e, d, i), i.y = e.canvas.clientHeight - i.y, i)
        }, c.wgs84ToDrawingBufferCoordinates = function (e, t, i) {
            var r = c.computeActualWgs84Position(e.frameState, t, h);
            if (!o(r))return void 0;
            var a = e.camera, s = u.multiply(a.frustum.projectionMatrix, a.viewMatrix, m);
            return u.multiplyByVector(s, n.fromElements(r.x, r.y, r.z, 1, d), d), d.z < 0 && e.mode !== l.SCENE2D ? void 0 : c.clipToDrawingBufferCoordinates(e, d, i)
        };
        var p = new i, f = new r;
        c.computeActualWgs84Position = function (e, t, n) {
            var r = e.mode;
            if (r === l.SCENE3D)return i.clone(t, n);
            var a = e.mapProjection, u = a.ellipsoid.cartesianToCartographic(t, f);
            if (!o(u))return void 0;
            if (a.project(u, p), r === l.COLUMBUS_VIEW)return i.fromElements(p.z, p.x, p.y, n);
            if (r === l.SCENE2D)return i.fromElements(0, p.x, p.y, n);
            var c = e.morphTime;
            return i.fromElements(s.lerp(p.z, t.x, c), s.lerp(p.x, t.y, c), s.lerp(p.y, t.z, c), n)
        };
        var _ = new i, v = new i, g = new e, y = new u;
        c.clipToGLWindowCoordinates = function (e, n, r) {
            var o = e.canvas;
            return i.divideByScalar(n, n.w, _), g.width = o.clientWidth, g.height = o.clientHeight, u.computeViewportTransformation(g, 0, 1, y), u.multiplyByPoint(y, _, v), t.fromCartesian3(v, r)
        }, c.clipToDrawingBufferCoordinates = function (e, n, r) {
            return i.divideByScalar(n, n.w, _), g.width = e.drawingBufferWidth, g.height = e.drawingBufferHeight, u.computeViewportTransformation(g, 0, 1, y), u.multiplyByPoint(y, _, v), t.fromCartesian3(v, r)
        }, c.transformWindowToDrawingBuffer = function (e, i, n) {
            var r = e.canvas, o = e.drawingBufferWidth / r.clientWidth, a = e.drawingBufferHeight / r.clientHeight;
            return t.fromElements(i.x * o, i.y * a, n)
        };
        var C = new n, E = new n;
        return c.drawingBufferToWgs84Coordinates = function (e, t, r, o) {
            var a = e.context, s = a.uniformState, l = s.viewport, c = (s.viewportTransformation, n.clone(n.UNIT_W, C));
            c.x = (t.x - l.x) / l.width * 2 - 1, c.y = (t.y - l.y) / l.height * 2 - 1, c.z = 2 * r - 1, c.w = 1;
            var h = u.multiplyByVector(s.inverseViewProjection, c, E), d = 1 / h.w;
            return i.multiplyByScalar(h, d, h), i.fromCartesian4(h, o)
        }, c
    }),define("Cesium/Scene/VerticalOrigin", ["../Core/freezeObject"], function (e) {
        "use strict";
        var t = {CENTER: 0, BOTTOM: 1, TOP: -1};
        return e(t)
    }),define("Cesium/Scene/Billboard", ["../Core/BoundingRectangle", "../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/Cartographic", "../Core/Color", "../Core/createGuid", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Matrix4", "../Core/NearFarScalar", "./HeightReference", "./HorizontalOrigin", "./SceneMode", "./SceneTransforms", "./VerticalOrigin"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v) {
        "use strict";
        function g(e, t) {
            var i = e._billboardCollection;
            u(i) && (i._updateBillboard(e, t), e._dirty = !0)
        }

        var y = function (e, n) {
            e = s(e, s.EMPTY_OBJECT), this._show = s(e.show, !0), this._position = i.clone(s(e.position, i.ZERO)), this._actualPosition = i.clone(this._position), this._pixelOffset = t.clone(s(e.pixelOffset, t.ZERO)), this._translate = new t(0, 0), this._eyeOffset = i.clone(s(e.eyeOffset, i.ZERO)), this._verticalOrigin = s(e.verticalOrigin, v.CENTER), this._horizontalOrigin = s(e.horizontalOrigin, p.CENTER), this._scale = s(e.scale, 1), this._color = o.clone(s(e.color, o.WHITE)), this._rotation = s(e.rotation, 0), this._alignedAxis = i.clone(s(e.alignedAxis, i.ZERO)), this._width = e.width, this._height = e.height, this._scaleByDistance = e.scaleByDistance, this._translucencyByDistance = e.translucencyByDistance, this._pixelOffsetScaleByDistance = e.pixelOffsetScaleByDistance, this._heightReference = s(e.heightReference, m.NONE), this._sizeInMeters = s(e.sizeInMeters, !1), this._id = e.id, this._collection = s(e.collection, n), this._pickId = void 0, this._pickPrimitive = s(e._pickPrimitive, this), this._billboardCollection = n, this._dirty = !1, this._index = -1, this._imageIndex = -1, this._imageIndexPromise = void 0, this._imageId = void 0, this._image = void 0, this._imageSubRegion = void 0, this._imageWidth = void 0, this._imageHeight = void 0;
            var r = e.image, l = e.imageId;
            u(r) && (u(l) || (l = "string" == typeof r ? r : u(r.src) ? r.src : a()), this._imageId = l, this._image = r), u(e.imageSubRegion) && (this._imageId = l, this._imageSubRegion = e.imageSubRegion), u(this._billboardCollection._textureAtlas) && this._loadImage(), this._actualClampedPosition = void 0, this._removeCallbackFunc = void 0, this._mode = f.SCENE3D, this._updateClamping()
        }, C = y.SHOW_INDEX = 0, E = y.POSITION_INDEX = 1, S = y.PIXEL_OFFSET_INDEX = 2, T = y.EYE_OFFSET_INDEX = 3, b = y.HORIZONTAL_ORIGIN_INDEX = 4, w = y.VERTICAL_ORIGIN_INDEX = 5, x = y.SCALE_INDEX = 6, A = y.IMAGE_INDEX_INDEX = 7, P = y.COLOR_INDEX = 8, I = y.ROTATION_INDEX = 9, D = y.ALIGNED_AXIS_INDEX = 10, M = y.SCALE_BY_DISTANCE_INDEX = 11, O = y.TRANSLUCENCY_BY_DISTANCE_INDEX = 12, R = y.PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX = 13;
        y.NUMBER_OF_PROPERTIES = 14, l(y.prototype, {
            show: {
                get: function () {
                    return this._show
                }, set: function (e) {
                    this._show !== e && (this._show = e, g(this, C))
                }
            }, position: {
                get: function () {
                    return this._position
                }, set: function (e) {
                    var t = this._position;
                    i.equals(t, e) || (i.clone(e, t), i.clone(e, this._actualPosition), this._updateClamping(), g(this, E))
                }
            }, heightReference: {
                get: function () {
                    return this._heightReference
                }, set: function (e) {
                    var t = this._heightReference;
                    e !== t && (this._heightReference = e, this._updateClamping(), g(this, E))
                }
            }, pixelOffset: {
                get: function () {
                    return this._pixelOffset
                }, set: function (e) {
                    var i = this._pixelOffset;
                    t.equals(i, e) || (t.clone(e, i), g(this, S))
                }
            }, scaleByDistance: {
                get: function () {
                    return this._scaleByDistance
                }, set: function (e) {
                    var t = this._scaleByDistance;
                    d.equals(t, e) || (this._scaleByDistance = d.clone(e, t), g(this, M))
                }
            }, translucencyByDistance: {
                get: function () {
                    return this._translucencyByDistance
                }, set: function (e) {
                    var t = this._translucencyByDistance;
                    d.equals(t, e) || (this._translucencyByDistance = d.clone(e, t), g(this, O))
                }
            }, pixelOffsetScaleByDistance: {
                get: function () {
                    return this._pixelOffsetScaleByDistance
                }, set: function (e) {
                    var t = this._pixelOffsetScaleByDistance;
                    d.equals(t, e) || (this._pixelOffsetScaleByDistance = d.clone(e, t), g(this, R))
                }
            }, eyeOffset: {
                get: function () {
                    return this._eyeOffset
                }, set: function (e) {
                    var t = this._eyeOffset;
                    i.equals(t, e) || (i.clone(e, t), g(this, T))
                }
            }, horizontalOrigin: {
                get: function () {
                    return this._horizontalOrigin
                }, set: function (e) {
                    this._horizontalOrigin !== e && (this._horizontalOrigin = e, g(this, b))
                }
            }, verticalOrigin: {
                get: function () {
                    return this._verticalOrigin
                }, set: function (e) {
                    this._verticalOrigin !== e && (this._verticalOrigin = e, g(this, w))
                }
            }, scale: {
                get: function () {
                    return this._scale
                }, set: function (e) {
                    this._scale !== e && (this._scale = e, g(this, x))
                }
            }, color: {
                get: function () {
                    return this._color
                }, set: function (e) {
                    var t = this._color;
                    o.equals(t, e) || (o.clone(e, t), g(this, P))
                }
            }, rotation: {
                get: function () {
                    return this._rotation
                }, set: function (e) {
                    this._rotation !== e && (this._rotation = e, g(this, I))
                }
            }, alignedAxis: {
                get: function () {
                    return this._alignedAxis
                }, set: function (e) {
                    var t = this._alignedAxis;
                    i.equals(t, e) || (i.clone(e, t), g(this, D))
                }
            }, width: {
                get: function () {
                    return s(this._width, this._imageWidth)
                }, set: function (e) {
                    this._width !== e && (this._width = e, g(this, A))
                }
            }, height: {
                get: function () {
                    return s(this._height, this._imageHeight)
                }, set: function (e) {
                    this._height !== e && (this._height = e, g(this, A))
                }
            }, sizeInMeters: {
                get: function () {
                    return this._sizeInMeters
                }, set: function (e) {
                    this._sizeInMeters !== e && (this._sizeInMeters = e, g(this, P))
                }
            }, id: {
                get: function () {
                    return this._id
                }, set: function (e) {
                    this._id = e, u(this._pickId) && (this._pickId.object.id = e)
                }
            }, pickPrimitive: {
                get: function () {
                    return this._pickPrimitive
                }, set: function (e) {
                    this._pickPrimitive = e, u(this._pickId) && (this._pickId.object.primitive = e)
                }
            }, image: {
                get: function () {
                    return this._imageId
                }, set: function (e) {
                    u(e) ? "string" == typeof e ? this.setImage(e, e) : u(e.src) ? this.setImage(e.src, e) : this.setImage(a(), e) : (this._imageIndex = -1, this._imageSubRegion = void 0, this._imageId = void 0, this._image = void 0, this._imageIndexPromise = void 0, g(this, A))
                }
            }, ready: {
                get: function () {
                    return -1 !== this._imageIndex
                }
            }, _clampedPosition: {
                get: function () {
                    return this._actualClampedPosition
                }, set: function (e) {
                    this._actualClampedPosition = i.clone(e, this._actualClampedPosition), g(this, E)
                }
            }
        }), y.prototype.getPickId = function (e) {
            return u(this._pickId) || (this._pickId = e.createPickId({
                primitive: this._pickPrimitive,
                collection: this._collection,
                id: this._id
            })), this._pickId
        }, y.prototype._updateClamping = function () {
            y._updateClamping(this._billboardCollection, this)
        };
        var N = new r, L = new i;
        y._updateClamping = function (e, t) {
            var n = e._scene;
            if (u(n)) {
                var o = n.globe, a = o.ellipsoid, s = o._surface, l = n.frameState.mode, h = n.frameState.mapProjection, d = l !== t._mode;
                if (t._mode = l, (t._heightReference === m.NONE || d) && u(t._removeCallbackFunc) && (t._removeCallbackFunc(), t._removeCallbackFunc = void 0, t._clampedPosition = void 0), t._heightReference !== m.NONE && u(t._position)) {
                    var p = a.cartesianToCartographic(t._position);
                    if (u(p)) {
                        u(t._removeCallbackFunc) && t._removeCallbackFunc();
                        var _ = function (e) {
                            if (t._heightReference === m.RELATIVE_TO_GROUND)if (t._mode === f.SCENE3D) {
                                var n = a.cartesianToCartographic(e, N);
                                n.height += p.height, a.cartographicToCartesian(n, e)
                            } else e.x += p.height;
                            t._clampedPosition = i.clone(e, t._clampedPosition)
                        };
                        t._removeCallbackFunc = s.updateHeight(p, _);
                        var v = o.getHeight(p);
                        u(v) && (r.clone(p, N), N.height = v, t._mode === f.SCENE3D ? a.cartographicToCartesian(N, L) : (h.project(N, L), i.fromElements(L.z, L.x, L.y, L)), _(L))
                    }
                }
            } else if (t._heightReference !== m.NONE)throw new c("Height reference is not supported.")
        }, y.prototype._loadImage = function () {
            var t, i = this._billboardCollection._textureAtlas, n = this._imageId, r = this._image, o = this._imageSubRegion;
            if (u(r) && (t = i.addImage(n, r)), u(o) && (t = i.addSubRegion(n, o)), this._imageIndexPromise = t, u(t)) {
                var a = this;
                t.then(function (t) {
                    if (a._imageId === n && a._image === r && e.equals(a._imageSubRegion, o)) {
                        var s = i.textureCoordinates[t];
                        a._imageWidth = i.texture.width * s.width, a._imageHeight = i.texture.height * s.height, a._imageIndex = t, a._ready = !0, a._image = void 0, a._imageIndexPromise = void 0, g(a, A)
                    }
                }).otherwise(function (e) {
                    console.error("Error loading image for billboard: " + e), a._imageIndexPromise = void 0
                })
            }
        }, y.prototype.setImage = function (e, t) {
            this._imageId !== e && (this._imageIndex = -1, this._imageSubRegion = void 0, this._imageId = e, this._image = t, u(this._billboardCollection._textureAtlas) && this._loadImage())
        }, y.prototype.setImageSubRegion = function (t, i) {
            this._imageId === t && e.equals(this._imageSubRegion, i) || (this._imageIndex = -1, this._imageId = t, this._imageSubRegion = e.clone(i), u(this._billboardCollection._textureAtlas) && this._loadImage())
        }, y.prototype._setTranslate = function (e) {
            var i = this._translate;
            t.equals(i, e) || (t.clone(e, i), g(this, S))
        }, y.prototype._getActualPosition = function () {
            return u(this._clampedPosition) ? this._clampedPosition : this._actualPosition
        }, y.prototype._setActualPosition = function (e) {
            u(this._clampedPosition) || i.clone(e, this._actualPosition), g(this, E)
        };
        var F = new n;
        y._computeActualPosition = function (e, t, i, n) {
            return u(e._clampedPosition) ? (i.mode !== e._mode && e._updateClamping(), e._clampedPosition) : i.mode === f.SCENE3D ? t : (h.multiplyByPoint(n, t, F), _.computeActualWgs84Position(i, F))
        };
        var B = new h, z = new n, V = new i, U = new t, k = new t;
        y._computeScreenSpacePosition = function (e, r, o, a, s, u) {
            var l = s.camera, c = l.viewMatrix, d = l.frustum.projectionMatrix, m = h.multiplyTransformation(c, e, B), p = h.multiplyByVector(m, n.fromElements(r.x, r.y, r.z, 1, z), z), f = i.multiplyComponents(o, i.normalize(p, V), V);
            p.x += o.x + f.x, p.y += o.y + f.y, p.z += f.z;
            var v = h.multiplyByVector(d, p, z), g = _.clipToGLWindowCoordinates(s, v, u);
            a = t.clone(a, k), a.y = -a.y;
            var y = t.multiplyByScalar(a, s.context.uniformState.resolutionScale, U);
            return g.x += y.x, g.y += y.y, g
        };
        var G = new t(0, 0);
        return y.prototype.computeScreenSpacePosition = function (e, i) {
            var n = this._billboardCollection;
            u(i) || (i = new t), t.clone(this._pixelOffset, G), t.add(G, this._translate, G);
            var r = n.modelMatrix, o = this._getActualPosition(), a = y._computeScreenSpacePosition(r, o, this._eyeOffset, G, e, i);
            return a.y = e.canvas.clientHeight - a.y, a
        }, y.prototype.equals = function (n) {
            return this === n || u(n) && this._id === n._id && i.equals(this._position, n._position) && this._imageId === n._imageId && this._show === n._show && this._scale === n._scale && this._verticalOrigin === n._verticalOrigin && this._horizontalOrigin === n._horizontalOrigin && e.equals(this._imageSubRegion, n._imageSubRegion) && o.equals(this._color, n._color) && t.equals(this._pixelOffset, n._pixelOffset) && t.equals(this._translate, n._translate) && i.equals(this._eyeOffset, n._eyeOffset) && d.equals(this._scaleByDistance, n._scaleByDistance) && d.equals(this._translucencyByDistance, n._translucencyByDistance) && d.equals(this._pixelOffsetScaleByDistance, n._pixelOffsetScaleByDistance)
        }, y.prototype._destroy = function () {
            u(this._customData) && (this._billboardCollection._scene.globe._surface.removeTileCustomData(this._customData), this._customData = void 0), this.image = void 0, this._pickId = this._pickId && this._pickId.destroy(), this._billboardCollection = void 0
        }, y
    }),define("Cesium/Scene/TextureAtlas", ["../Core/BoundingRectangle", "../Core/Cartesian2", "../Core/createGuid", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/loadImage", "../Core/PixelFormat", "../Core/RuntimeError", "../Renderer/Framebuffer", "../Renderer/RenderState", "../Renderer/Texture", "../ThirdParty/when"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p) {
        "use strict";
        function f(e, i, r, o, a) {
            this.bottomLeft = n(e, t.ZERO), this.topRight = n(i, t.ZERO), this.childNode1 = r, this.childNode2 = o, this.imageIndex = a
        }

        function _(i, n) {
            var o = i._context, a = i.numberOfImages, s = 2;
            if (a > 0) {
                var u = i._texture.width, l = i._texture.height, c = s * (u + n.width + i._borderWidthInPixels), p = s * (l + n.height + i._borderWidthInPixels), _ = u / c, v = l / p, g = new f(new t(u + i._borderWidthInPixels, 0), new t(c, l)), y = new f(new t, new t(c, l), i._root, g), C = new f(new t(0, l + i._borderWidthInPixels), new t(c, p)), E = new f(new t, new t(c, p), y, C);
                i._root = E;
                for (var S = 0; S < i._textureCoordinates.length; S++) {
                    var T = i._textureCoordinates[S];
                    r(T) && (T.x *= _, T.y *= v, T.width *= _, T.height *= v)
                }
                var b = new m({
                    context: i._context,
                    width: c,
                    height: p,
                    pixelFormat: i._pixelFormat
                }), w = new h({
                    context: o,
                    colorTextures: [b],
                    destroyAttachments: !1
                }), x = i._copyCommand, A = {viewport: new e(0, 0, u, l)};
                x.renderState = d.fromCache(A), w._bind(), x.execute(i._context), w._unBind(), w.destroy(), i._texture = b, d.removeFromCache(A), x.renderState = void 0
            } else {
                var P = s * (n.width + i._borderWidthInPixels), I = s * (n.height + i._borderWidthInPixels);
                i._texture = i._texture && i._texture.destroy(), i._texture = new m({
                    context: i._context,
                    width: P,
                    height: I,
                    pixelFormat: i._pixelFormat
                }), i._root = new f(new t, new t(P, I))
            }
        }

        function v(e, i, n) {
            if (!r(i))return void 0;
            if (!r(i.childNode1) && !r(i.childNode2)) {
                if (r(i.imageIndex))return void 0;
                var o = i.topRight.x - i.bottomLeft.x, a = i.topRight.y - i.bottomLeft.y, s = o - n.width, u = a - n.height;
                if (0 > s || 0 > u)return void 0;
                if (0 === s && 0 === u)return i;
                if (s > u) {
                    i.childNode1 = new f(new t(i.bottomLeft.x, i.bottomLeft.y), new t(i.bottomLeft.x + n.width, i.topRight.y));
                    var l = i.bottomLeft.x + n.width + e._borderWidthInPixels;
                    l < i.topRight.x && (i.childNode2 = new f(new t(l, i.bottomLeft.y), new t(i.topRight.x, i.topRight.y)))
                } else {
                    i.childNode1 = new f(new t(i.bottomLeft.x, i.bottomLeft.y), new t(i.topRight.x, i.bottomLeft.y + n.height));
                    var c = i.bottomLeft.y + n.height + e._borderWidthInPixels;
                    c < i.topRight.y && (i.childNode2 = new f(new t(i.bottomLeft.x, c), new t(i.topRight.x, i.topRight.y)))
                }
                return v(e, i.childNode1, n)
            }
            return v(e, i.childNode1, n) || v(e, i.childNode2, n)
        }

        function g(t, n, o) {
            var a = v(t, t._root, n);
            if (r(a)) {
                a.imageIndex = o;
                var s = t._texture.width, u = t._texture.height, l = a.topRight.x - a.bottomLeft.x, c = a.topRight.y - a.bottomLeft.y, h = a.bottomLeft.x / s, d = a.bottomLeft.y / u, m = l / s, p = c / u;
                t._textureCoordinates[o] = new e(h, d, m, p), t._texture.copyFrom(n, a.bottomLeft.x, a.bottomLeft.y)
            } else _(t, n), g(t, n, o);
            t._guid = i()
        }

        var y = new t(16, 16), C = function (e) {
            e = n(e, n.EMPTY_OBJECT);
            var r = n(e.borderWidthInPixels, 1), o = n(e.initialSize, y);
            this._context = e.context, this._pixelFormat = n(e.pixelFormat, l.RGBA), this._borderWidthInPixels = r, this._textureCoordinates = [], this._guid = i(), this._idHash = {}, this._texture = new m({
                context: this._context,
                width: o.x,
                height: o.y,
                pixelFormat: this._pixelFormat
            }), this._root = new f(new t, new t(o.x, o.y));
            var a = this, s = {
                u_texture: function () {
                    return a._texture
                }
            }, u = "uniform sampler2D u_texture;\nvarying vec2 v_textureCoordinates;\nvoid main()\n{\n    gl_FragColor = texture2D(u_texture, v_textureCoordinates);\n}\n";
            this._copyCommand = this._context.createViewportQuadCommand(u, {uniformMap: s})
        };
        return o(C.prototype, {
            borderWidthInPixels: {
                get: function () {
                    return this._borderWidthInPixels
                }
            }, textureCoordinates: {
                get: function () {
                    return this._textureCoordinates
                }
            }, texture: {
                get: function () {
                    return this._texture
                }
            }, numberOfImages: {
                get: function () {
                    return this._textureCoordinates.length
                }
            }, guid: {
                get: function () {
                    return this._guid
                }
            }
        }), C.prototype.addImage = function (e, t) {
            var i = this._idHash[e];
            if (r(i))return i;
            "function" == typeof t ? t = t(e) : "string" == typeof t && (t = u(t));
            var n = this;
            return i = p(t, function (e) {
                if (n.isDestroyed())return -1;
                var t = n.numberOfImages;
                return g(n, e, t), t
            }), this._idHash[e] = i, i
        }, C.prototype.addSubRegion = function (t, n) {
            var o = this._idHash[t];
            if (!r(o))throw new c('image with id "' + t + '" not found in the atlas.');
            var a = this;
            return p(o, function (t) {
                if (-1 === t)return -1;
                var r = a._texture.width, o = a._texture.height, s = a.numberOfImages, u = a._textureCoordinates[t], l = u.x + n.x / r, c = u.y + n.y / o, h = n.width / r, d = n.height / o;
                return a._textureCoordinates.push(new e(l, c, h, d)), a._guid = i(), s
            })
        }, C.prototype.isDestroyed = function () {
            return !1
        }, C.prototype.destroy = function () {
            return this._texture = this._texture && this._texture.destroy(), a(this)
        }, C
    }),define("Cesium/Scene/BillboardCollection", ["../Core/AttributeCompression", "../Core/BoundingSphere", "../Core/Cartesian2", "../Core/Cartesian3", "../Core/Color", "../Core/ComponentDatatype", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/EncodedCartesian3", "../Core/IndexDatatype", "../Core/Math", "../Core/Matrix4", "../Renderer/Buffer", "../Renderer/BufferUsage", "../Renderer/DrawCommand", "../Renderer/RenderState", "../Renderer/ShaderProgram", "../Renderer/ShaderSource", "../Renderer/VertexArrayFacade", "../Shaders/BillboardCollectionFS", "../Shaders/BillboardCollectionVS", "./Billboard", "./BlendingState", "./HorizontalOrigin", "./Pass", "./SceneMode", "./TextureAtlas"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S, T, b, w, x, A, P, I) {
        "use strict";
        function D(e) {
            for (var t = e.length, i = 0; t > i; ++i)e[i] && e[i]._destroy()
        }

        function M(e) {
            if (e._billboardsRemoved) {
                e._billboardsRemoved = !1;
                for (var t = [], i = e._billboards, n = i.length, r = 0, o = 0; n > r; ++r) {
                    var a = i[r];
                    a && (a._index = o++, t.push(a))
                }
                e._billboards = t
            }
        }

        function O(e) {
            var t = 16384, i = e.cache.billboardCollection_indexBuffer;
            if (s(i))return i;
            for (var n = 6 * t, r = new Uint16Array(n), o = 0, a = 0; n > o; o += 6, a += 4)r[o] = a, r[o + 1] = a + 1, r[o + 2] = a + 2, r[o + 3] = a + 0, r[o + 4] = a + 2, r[o + 5] = a + 3;
            return i = f.createIndexBuffer({
                context: e,
                typedArray: r,
                usage: _.STATIC_DRAW,
                indexDatatype: d.UNSIGNED_SHORT
            }), i.vertexArrayDestroyable = !1, e.cache.billboardCollection_indexBuffer = i, i
        }

        function R(e, t, i) {
            return new E(e, [{
                index: ae.positionHighAndScale,
                componentsPerAttribute: 4,
                componentDatatype: o.FLOAT,
                usage: i[j]
            }, {
                index: ae.positionLowAndRotation,
                componentsPerAttribute: 4,
                componentDatatype: o.FLOAT,
                usage: i[j]
            }, {
                index: ae.compressedAttribute0,
                componentsPerAttribute: 4,
                componentDatatype: o.FLOAT,
                usage: i[Y]
            }, {
                index: ae.compressedAttribute1,
                componentsPerAttribute: 4,
                componentDatatype: o.FLOAT,
                usage: i[ne]
            }, {
                index: ae.compressedAttribute2,
                componentsPerAttribute: 4,
                componentDatatype: o.FLOAT,
                usage: i[$]
            }, {index: ae.eyeOffset, componentsPerAttribute: 3, componentDatatype: o.FLOAT, usage: i[X]}, {
                index: ae.scaleByDistance, componentsPerAttribute: 4, componentDatatype: o.FLOAT,
                usage: i[ie]
            }, {
                index: ae.pixelOffsetScaleByDistance,
                componentsPerAttribute: 4,
                componentDatatype: o.FLOAT,
                usage: i[re]
            }], 4 * t)
        }

        function N(e, i, n, r, o) {
            var a = 4 * o._index, s = o._getActualPosition();
            e._mode === P.SCENE3D && (t.expand(e._baseVolume, s, e._baseVolume), e._boundingVolumeDirty = !0), h.fromCartesian(s, ue);
            var u = o.scale, l = o.rotation;
            0 !== l && (e._shaderRotation = !0), e._maxScale = Math.max(e._maxScale, u);
            var c = r[ae.positionHighAndScale], d = ue.high;
            c(a + 0, d.x, d.y, d.z, u), c(a + 1, d.x, d.y, d.z, u), c(a + 2, d.x, d.y, d.z, u), c(a + 3, d.x, d.y, d.z, u);
            var m = r[ae.positionLowAndRotation], p = ue.low;
            m(a + 0, p.x, p.y, p.z, l), m(a + 1, p.x, p.y, p.z, l), m(a + 2, p.x, p.y, p.z, l), m(a + 3, p.x, p.y, p.z, l)
        }

        function L(t, i, n, r, o) {
            var a = 4 * o._index, s = o.pixelOffset, u = s.x, l = s.y, c = o._translate, h = c.x, d = c.y;
            t._maxPixelOffset = Math.max(t._maxPixelOffset, Math.abs(u + h), Math.abs(-l + d));
            var p = o.horizontalOrigin, f = o.verticalOrigin, _ = o.show;
            0 === o.color.alpha && (_ = !1), t._allHorizontalCenter = t._allHorizontalCenter && p === x.CENTER, t._allVerticalCenter = t._allVerticalCenter && f === x.CENTER;
            var v = 0, g = 0, y = 0, C = 0, E = o._imageIndex;
            if (-1 !== E) {
                var S = n[E];
                v = S.x, g = S.y, y = S.width, C = S.height
            }
            var T = v + y, b = g + C, w = Math.floor(m.clamp(u, -ce, ce) + ce) * me;
            w += (p + 1) * pe, w += (f + 1) * fe, w += (_ ? 1 : 0) * _e;
            var A = Math.floor(m.clamp(l, -ce, ce) + ce) * de, P = Math.floor(m.clamp(h, -ce, ce) + ce) * de, I = (m.clamp(d, -ce, ce) + ce) * ve, D = Math.floor(I), M = Math.floor((I - D) * de);
            A += D, P += M, le.x = v, le.y = g;
            var O = e.compressTextureCoordinates(le);
            le.x = T;
            var R = e.compressTextureCoordinates(le);
            le.y = b;
            var N = e.compressTextureCoordinates(le);
            le.x = v;
            var L = e.compressTextureCoordinates(le), F = r[ae.compressedAttribute0];
            F(a + 0, w + ge, A, P, O), F(a + 1, w + ye, A, P, R), F(a + 2, w + Ce, A, P, N), F(a + 3, w + Ee, A, P, L)
        }

        function F(t, i, r, o, u) {
            var l = 4 * u._index, c = u.alignedAxis;
            n.equals(c, n.ZERO) || (t._shaderAlignedAxis = !0);
            var h = 0, d = 1, p = 1, f = 1, _ = u.translucencyByDistance;
            s(_) && (h = _.near, d = _.nearValue, p = _.far, f = _.farValue, (1 !== d || 1 !== f) && (t._shaderTranslucencyByDistance = !0));
            var v = 0, g = u._imageIndex;
            if (-1 !== g) {
                var y = r[g];
                v = y.width
            }
            var C = t._textureAtlas.texture.width, E = Math.ceil(.5 * a(u.width, C * v));
            t._maxSize = Math.max(t._maxSize, E);
            var S = m.clamp(E, 0, he), T = 0;
            Math.abs(n.magnitudeSquared(c) - 1) < m.EPSILON6 && (T = e.octEncodeFloat(c)), d = m.clamp(d, 0, 1), d = 1 === d ? 255 : 255 * d | 0, S = S * de + d, f = m.clamp(f, 0, 1), f = 1 === f ? 255 : 255 * f | 0, T = T * de + f;
            var b = o[ae.compressedAttribute1];
            b(l + 0, S, T, h, p), b(l + 1, S, T, h, p), b(l + 2, S, T, h, p), b(l + 3, S, T, h, p)
        }

        function B(e, t, i, n, o) {
            var s = 4 * o._index, u = o.color, l = o.getPickId(t).color, c = o.sizeInMeters ? 1 : 0;
            e._allSizedInMeters = e._allSizedInMeters && 1 === c;
            var h = 0, d = o._imageIndex;
            if (-1 !== d) {
                var m = i[d];
                h = m.height
            }
            var p = e._textureAtlas.texture.dimensions, f = Math.ceil(.5 * a(o.height, p.y * h));
            e._maxSize = Math.max(e._maxSize, f);
            var _ = r.floatToByte(u.red), v = r.floatToByte(u.green), g = r.floatToByte(u.blue), y = _ * he + v * de + g;
            _ = r.floatToByte(l.red), v = r.floatToByte(l.green), g = r.floatToByte(l.blue);
            var C = _ * he + v * de + g, E = r.floatToByte(u.alpha) * he + r.floatToByte(l.alpha) * de + c, S = n[ae.compressedAttribute2];
            S(s + 0, y, C, E, f), S(s + 1, y, C, E, f), S(s + 2, y, C, E, f), S(s + 3, y, C, E, f)
        }

        function z(e, t, i, n, r) {
            var o = 4 * r._index, a = r.eyeOffset;
            e._maxEyeOffset = Math.max(e._maxEyeOffset, Math.abs(a.x), Math.abs(a.y), Math.abs(a.z));
            var s = n[ae.eyeOffset];
            s(o + 0, a.x, a.y, a.z), s(o + 1, a.x, a.y, a.z), s(o + 2, a.x, a.y, a.z), s(o + 3, a.x, a.y, a.z)
        }

        function V(e, t, i, n, r) {
            var o = 4 * r._index, a = n[ae.scaleByDistance], u = 0, l = 1, c = 1, h = 1, d = r.scaleByDistance;
            s(d) && (u = d.near, l = d.nearValue, c = d.far, h = d.farValue, (1 !== l || 1 !== h) && (e._shaderScaleByDistance = !0)), a(o + 0, u, l, c, h), a(o + 1, u, l, c, h), a(o + 2, u, l, c, h), a(o + 3, u, l, c, h)
        }

        function U(e, t, i, n, r) {
            var o = 4 * r._index, a = n[ae.pixelOffsetScaleByDistance], u = 0, l = 1, c = 1, h = 1, d = r.pixelOffsetScaleByDistance;
            s(d) && (u = d.near, l = d.nearValue, c = d.far, h = d.farValue, (1 !== l || 1 !== h) && (e._shaderPixelOffsetScaleByDistance = !0)), a(o + 0, u, l, c, h), a(o + 1, u, l, c, h), a(o + 2, u, l, c, h), a(o + 3, u, l, c, h)
        }

        function k(e, t, i, n, r) {
            N(e, t, i, n, r), L(e, t, i, n, r), F(e, t, i, n, r), B(e, t, i, n, r), z(e, t, i, n, r), V(e, t, i, n, r), U(e, t, i, n, r)
        }

        function G(e, i, n, r, o, a) {
            var u;
            r.mode === P.SCENE3D ? (u = e._baseVolume, e._boundingVolumeDirty = !0) : u = e._baseVolume2D;
            for (var l = [], c = 0; n > c; ++c) {
                var h = i[c], d = h.position, m = b._computeActualPosition(h, d, r, o);
                s(m) && (h._setActualPosition(m), a ? l.push(m) : t.expand(u, m, u))
            }
            a && t.fromPoints(l, u)
        }

        function H(e, t) {
            var i = t.mode, n = e._billboards, r = e._billboardsToUpdate, o = e._modelMatrix;
            e._createVertexArray || e._mode !== i || i !== P.SCENE3D && !p.equals(o, e.modelMatrix) ? (e._mode = i, p.clone(e.modelMatrix, o), e._createVertexArray = !0, (i === P.SCENE3D || i === P.SCENE2D || i === P.COLUMBUS_VIEW) && G(e, n, n.length, t, o, !0)) : i === P.MORPHING ? G(e, n, n.length, t, o, !0) : (i === P.SCENE2D || i === P.COLUMBUS_VIEW) && G(e, r, e._billboardsToUpdateIndex, t, o, !1)
        }

        function W(e, t, i, n) {
            var r = 1;
            if (!e._allSizedInMeters || 0 !== e._maxPixelOffset) {
                var o = i.camera, a = o.distanceToBoundingSphere(n);
                Se.x = t.drawingBufferWidth, Se.y = t.drawingBufferHeight;
                var s = o.frustum.getPixelSize(Se, a, Te);
                r = Math.max(s.x, s.y)
            }
            var u = r * e._maxScale * e._maxSize * 2;
            e._allHorizontalCenter && e._allVerticalCenter && (u *= .5);
            var l = r * e._maxPixelOffset + e._maxEyeOffset;
            n.radius += u + l
        }

        var q = b.SHOW_INDEX, j = b.POSITION_INDEX, Y = b.PIXEL_OFFSET_INDEX, X = b.EYE_OFFSET_INDEX, Z = b.HORIZONTAL_ORIGIN_INDEX, K = b.VERTICAL_ORIGIN_INDEX, J = b.SCALE_INDEX, Q = b.IMAGE_INDEX_INDEX, $ = b.COLOR_INDEX, ee = b.ROTATION_INDEX, te = b.ALIGNED_AXIS_INDEX, ie = b.SCALE_BY_DISTANCE_INDEX, ne = b.TRANSLUCENCY_BY_DISTANCE_INDEX, re = b.PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX, oe = b.NUMBER_OF_PROPERTIES, ae = {
            positionHighAndScale: 0,
            positionLowAndRotation: 1,
            compressedAttribute0: 2,
            compressedAttribute1: 3,
            compressedAttribute2: 4,
            eyeOffset: 5,
            scaleByDistance: 6,
            pixelOffsetScaleByDistance: 7
        }, se = function (e) {
            e = a(e, a.EMPTY_OBJECT), this._scene = e.scene, this._textureAtlas = void 0, this._textureAtlasGUID = void 0, this._destroyTextureAtlas = !0, this._sp = void 0, this._rs = void 0, this._vaf = void 0, this._spPick = void 0, this._billboards = [], this._billboardsToUpdate = [], this._billboardsToUpdateIndex = 0, this._billboardsRemoved = !1, this._createVertexArray = !1, this._shaderRotation = !1, this._compiledShaderRotation = !1, this._compiledShaderRotationPick = !1, this._shaderAlignedAxis = !1, this._compiledShaderAlignedAxis = !1, this._compiledShaderAlignedAxisPick = !1, this._shaderScaleByDistance = !1, this._compiledShaderScaleByDistance = !1, this._compiledShaderScaleByDistancePick = !1, this._shaderTranslucencyByDistance = !1, this._compiledShaderTranslucencyByDistance = !1, this._compiledShaderTranslucencyByDistancePick = !1, this._shaderPixelOffsetScaleByDistance = !1, this._compiledShaderPixelOffsetScaleByDistance = !1, this._compiledShaderPixelOffsetScaleByDistancePick = !1, this._propertiesChanged = new Uint32Array(oe), this._maxSize = 0, this._maxEyeOffset = 0, this._maxScale = 1, this._maxPixelOffset = 0, this._allHorizontalCenter = !0, this._allVerticalCenter = !0, this._allSizedInMeters = !0, this._baseVolume = new t, this._baseVolumeWC = new t, this._baseVolume2D = new t, this._boundingVolume = new t, this._boundingVolumeDirty = !1, this._colorCommands = [], this._pickCommands = [], this.modelMatrix = p.clone(a(e.modelMatrix, p.IDENTITY)), this._modelMatrix = p.clone(p.IDENTITY), this.debugShowBoundingVolume = a(e.debugShowBoundingVolume, !1), this._mode = P.SCENE3D, this._buffersUsage = [_.STATIC_DRAW, _.STATIC_DRAW, _.STATIC_DRAW, _.STATIC_DRAW, _.STATIC_DRAW, _.STATIC_DRAW, _.STATIC_DRAW, _.STATIC_DRAW, _.STATIC_DRAW, _.STATIC_DRAW, _.STATIC_DRAW, _.STATIC_DRAW, _.STATIC_DRAW, _.STATIC_DRAW];
            var i = this;
            this._uniforms = {
                u_atlas: function () {
                    return i._textureAtlas.texture
                }
            }
        };
        u(se.prototype, {
            length: {
                get: function () {
                    return M(this), this._billboards.length
                }
            }, textureAtlas: {
                get: function () {
                    return this._textureAtlas
                }, set: function (e) {
                    this._textureAtlas !== e && (this._textureAtlas = this._destroyTextureAtlas && this._textureAtlas && this._textureAtlas.destroy(), this._textureAtlas = e, this._createVertexArray = !0)
                }
            }, destroyTextureAtlas: {
                get: function () {
                    return this._destroyTextureAtlas
                }, set: function (e) {
                    this._destroyTextureAtlas = e
                }
            }
        }), se.prototype.add = function (e) {
            var t = new b(e, this);
            return t._index = this._billboards.length, this._billboards.push(t), this._createVertexArray = !0, t
        }, se.prototype.remove = function (e) {
            return this.contains(e) ? (this._billboards[e._index] = null, this._billboardsRemoved = !0, this._createVertexArray = !0, e._destroy(), !0) : !1
        }, se.prototype.removeAll = function () {
            D(this._billboards), this._billboards = [], this._billboardsToUpdate = [], this._billboardsToUpdateIndex = 0, this._billboardsRemoved = !1, this._createVertexArray = !0
        }, se.prototype._updateBillboard = function (e, t) {
            e._dirty || (this._billboardsToUpdate[this._billboardsToUpdateIndex++] = e), ++this._propertiesChanged[t]
        }, se.prototype.contains = function (e) {
            return s(e) && e._billboardCollection === this
        }, se.prototype.get = function (e) {
            return M(this), this._billboards[e]
        }, se.prototype.computeNewBuffersUsage = function () {
            for (var e = this._buffersUsage, t = !1, i = this._propertiesChanged, n = 0; oe > n; ++n) {
                var r = 0 === i[n] ? _.STATIC_DRAW : _.STREAM_DRAW;
                t = t || e[n] !== r, e[n] = r
            }
            return t
        };
        var ue = new h, le = new i, ce = 32768, he = 65536, de = 256, me = 128, pe = 32, fe = 8, _e = 4, ve = 1 / 256, ge = 0, ye = 2, Ce = 3, Ee = 1, Se = new i, Te = new i, be = [];
        return se.prototype.update = function (e, i, n) {
            M(this);
            var r = this._billboards, o = r.length, a = this._textureAtlas;
            if (!s(a)) {
                a = this._textureAtlas = new I({context: e});
                for (var u = 0; o > u; ++u)r[u]._loadImage()
            }
            var l = a.textureCoordinates;
            if (0 !== l.length) {
                H(this, i), r = this._billboards, o = r.length;
                var c = this._billboardsToUpdate, h = this._billboardsToUpdateIndex, d = this._propertiesChanged, m = a.guid, f = this._createVertexArray || this._textureAtlasGUID !== m;
                this._textureAtlasGUID = m;
                var _, E = i.passes, b = E.pick;
                if (f || !b && this.computeNewBuffersUsage()) {
                    this._createVertexArray = !1;
                    for (var x = 0; oe > x; ++x)d[x] = 0;
                    if (this._vaf = this._vaf && this._vaf.destroy(), o > 0) {
                        this._vaf = R(e, o, this._buffersUsage), _ = this._vaf.writers;
                        for (var D = 0; o > D; ++D) {
                            var G = this._billboards[D];
                            G._dirty = !1, k(this, e, l, _, G)
                        }
                        this._vaf.commit(O(e))
                    }
                    this._billboardsToUpdateIndex = 0
                } else if (h > 0) {
                    var se = be;
                    se.length = 0, (d[j] || d[ee] || d[J]) && se.push(N), (d[Q] || d[Y] || d[Z] || d[K] || d[q]) && se.push(L), (d[Q] || d[te] || d[ne]) && se.push(F), (d[Q] || d[$]) && se.push(B), d[X] && se.push(z), d[ie] && se.push(V), d[re] && se.push(U);
                    var ue = se.length;
                    if (_ = this._vaf.writers, h / o > .1) {
                        for (var le = 0; h > le; ++le) {
                            var ce = c[le];
                            ce._dirty = !1;
                            for (var he = 0; ue > he; ++he)se[he](this, e, l, _, ce)
                        }
                        this._vaf.commit(O(e))
                    } else {
                        for (var de = 0; h > de; ++de) {
                            var me = c[de];
                            me._dirty = !1;
                            for (var pe = 0; ue > pe; ++pe)se[pe](this, e, l, _, me);
                            this._vaf.subCommit(4 * me._index, 4)
                        }
                        this._vaf.endSubCommits()
                    }
                    this._billboardsToUpdateIndex = 0
                }
                if (h > 1.5 * o && (c.length = o), s(this._vaf) && s(this._vaf.va)) {
                    this._boundingVolumeDirty && (this._boundingVolumeDirty = !1, t.transform(this._baseVolume, this.modelMatrix, this._baseVolumeWC));
                    var fe, _e = p.IDENTITY;
                    i.mode === P.SCENE3D ? (_e = this.modelMatrix, fe = t.clone(this._baseVolumeWC, this._boundingVolume)) : fe = t.clone(this._baseVolume2D, this._boundingVolume), W(this, e, i, fe);
                    var ve, ge, ye, Ce, Ee, Se;
                    if (E.render) {
                        var Te = this._colorCommands;
                        for (s(this._rs) || (this._rs = g.fromCache({
                            depthTest: {enabled: !0},
                            blending: w.ALPHA_BLEND
                        })), (!s(this._sp) || this._shaderRotation && !this._compiledShaderRotation || this._shaderAlignedAxis && !this._compiledShaderAlignedAxis || this._shaderScaleByDistance && !this._compiledShaderScaleByDistance || this._shaderTranslucencyByDistance && !this._compiledShaderTranslucencyByDistance || this._shaderPixelOffsetScaleByDistance && !this._compiledShaderPixelOffsetScaleByDistance) && (Ce = new C({sources: [T]}), this._shaderRotation && Ce.defines.push("ROTATION"), this._shaderAlignedAxis && Ce.defines.push("ALIGNED_AXIS"), this._shaderScaleByDistance && Ce.defines.push("EYE_DISTANCE_SCALING"), this._shaderTranslucencyByDistance && Ce.defines.push("EYE_DISTANCE_TRANSLUCENCY"), this._shaderPixelOffsetScaleByDistance && Ce.defines.push("EYE_DISTANCE_PIXEL_OFFSET"), s(this._scene) && Ce.defines.push("CLAMPED_TO_GROUND"), this._sp = y.replaceCache({
                            context: e,
                            shaderProgram: this._sp,
                            vertexShaderSource: Ce,
                            fragmentShaderSource: S,
                            attributeLocations: ae
                        }), this._compiledShaderRotation = this._shaderRotation, this._compiledShaderAlignedAxis = this._shaderAlignedAxis, this._compiledShaderScaleByDistance = this._shaderScaleByDistance, this._compiledShaderTranslucencyByDistance = this._shaderTranslucencyByDistance, this._compiledShaderPixelOffsetScaleByDistance = this._shaderPixelOffsetScaleByDistance), ve = this._vaf.va, ge = ve.length, Te.length = ge, Se = 0; ge > Se; ++Se)ye = Te[Se], s(ye) || (ye = Te[Se] = new v({
                            pass: A.OPAQUE,
                            owner: this
                        })), ye.boundingVolume = fe, ye.modelMatrix = _e, ye.count = ve[Se].indicesCount, ye.shaderProgram = this._sp, ye.uniformMap = this._uniforms, ye.vertexArray = ve[Se].va, ye.renderState = this._rs, ye.debugShowBoundingVolume = this.debugShowBoundingVolume, n.push(ye)
                    }
                    if (b) {
                        var we = this._pickCommands;
                        for ((!s(this._spPick) || this._shaderRotation && !this._compiledShaderRotationPick || this._shaderAlignedAxis && !this._compiledShaderAlignedAxisPick || this._shaderScaleByDistance && !this._compiledShaderScaleByDistancePick || this._shaderTranslucencyByDistance && !this._compiledShaderTranslucencyByDistancePick || this._shaderPixelOffsetScaleByDistance && !this._compiledShaderPixelOffsetScaleByDistancePick) && (Ce = new C({
                            defines: ["RENDER_FOR_PICK"],
                            sources: [T]
                        }), this._shaderRotation && Ce.defines.push("ROTATION"), this._shaderAlignedAxis && Ce.defines.push("ALIGNED_AXIS"), this._shaderScaleByDistance && Ce.defines.push("EYE_DISTANCE_SCALING"), this._shaderTranslucencyByDistance && Ce.defines.push("EYE_DISTANCE_TRANSLUCENCY"), this._shaderPixelOffsetScaleByDistance && Ce.defines.push("EYE_DISTANCE_PIXEL_OFFSET"), s(this._scene) && Ce.defines.push("CLAMPED_TO_GROUND"), Ee = new C({
                            defines: ["RENDER_FOR_PICK"],
                            sources: [S]
                        }), this._spPick = y.replaceCache({
                            context: e,
                            shaderProgram: this._spPick,
                            vertexShaderSource: Ce,
                            fragmentShaderSource: Ee,
                            attributeLocations: ae
                        }), this._compiledShaderRotationPick = this._shaderRotation, this._compiledShaderAlignedAxisPick = this._shaderAlignedAxis, this._compiledShaderScaleByDistancePick = this._shaderScaleByDistance, this._compiledShaderTranslucencyByDistancePick = this._shaderTranslucencyByDistance, this._compiledShaderPixelOffsetScaleByDistancePick = this._shaderPixelOffsetScaleByDistance), ve = this._vaf.va, ge = ve.length, we.length = ge, Se = 0; ge > Se; ++Se)ye = we[Se], s(ye) || (ye = we[Se] = new v({
                            pass: A.OPAQUE,
                            owner: this
                        })), ye.boundingVolume = fe, ye.modelMatrix = _e, ye.count = ve[Se].indicesCount, ye.shaderProgram = this._spPick, ye.uniformMap = this._uniforms, ye.vertexArray = ve[Se].va, ye.renderState = this._rs, n.push(ye)
                    }
                }
            }
        }, se.prototype.isDestroyed = function () {
            return !1
        }, se.prototype.destroy = function () {
            return this._textureAtlas = this._destroyTextureAtlas && this._textureAtlas && this._textureAtlas.destroy(), this._sp = this._sp && this._sp.destroy(), this._spPick = this._spPick && this._spPick.destroy(), this._vaf = this._vaf && this._vaf.destroy(), D(this._billboards), l(this)
        }, se
    }),define("Cesium/DataSources/BillboardVisualizer", ["../Core/AssociativeArray", "../Core/BoundingRectangle", "../Core/Cartesian2", "../Core/Cartesian3", "../Core/Color", "../Core/defined", "../Core/destroyObject", "../Core/DeveloperError", "../Core/NearFarScalar", "../Scene/BillboardCollection", "../Scene/HorizontalOrigin", "../Scene/VerticalOrigin", "./BoundingSphereState", "./Property"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m) {
        "use strict";
        function p(e, t) {
            if (o(e)) {
                var i = e.billboard;
                o(i) && (e.textureValue = void 0, e.billboard = void 0, i.show = !1, i.image = void 0, t.push(i._index))
            }
        }

        var f = r.WHITE, _ = n.ZERO, v = i.ZERO, g = 1, y = 0, C = n.ZERO, E = c.CENTER, S = h.CENTER, T = !1, b = new n, w = new r, x = new n, A = new i, P = new u, I = new u, D = new u, M = new t, O = function (e) {
            this.entity = e, this.billboard = void 0, this.textureValue = void 0
        }, R = function (t, i) {
            i.collectionChanged.addEventListener(R.prototype._onCollectionChanged, this), this._scene = t, this._unusedIndexes = [], this._billboardCollection = void 0, this._entityCollection = i, this._items = new e, this._onCollectionChanged(i, i.values, [], [])
        };
        return R.prototype.update = function (e) {
            for (var t = this._items.values, i = this._unusedIndexes, n = 0, r = t.length; r > n; n++) {
                var a, s = t[n], u = s.entity, c = u._billboard, h = s.billboard, d = u.isShowing && u.isAvailable(e) && m.getValueOrDefault(c._show, e, !0);
                if (d && (b = m.getValueOrUndefined(u._position, e, b), a = m.getValueOrUndefined(c._image, e), d = o(b) && o(a)), d) {
                    if (!o(h)) {
                        var O = this._billboardCollection;
                        o(O) || (O = new l, this._billboardCollection = O, this._scene.primitives.add(O));
                        var R = i.length;
                        h = R > 0 ? O.get(i.pop()) : O.add(), h.id = u, h.image = void 0, s.billboard = h
                    }
                    h.show = d, s.textureValue !== a && (h.image = a, s.textureValue = a), h.position = b, h.color = m.getValueOrDefault(c._color, e, f, w), h.eyeOffset = m.getValueOrDefault(c._eyeOffset, e, _, x), h.pixelOffset = m.getValueOrDefault(c._pixelOffset, e, v, A), h.scale = m.getValueOrDefault(c._scale, e, g), h.rotation = m.getValueOrDefault(c._rotation, e, y), h.alignedAxis = m.getValueOrDefault(c._alignedAxis, e, C), h.horizontalOrigin = m.getValueOrDefault(c._horizontalOrigin, e, E), h.verticalOrigin = m.getValueOrDefault(c._verticalOrigin, e, S), h.width = m.getValueOrUndefined(c._width, e), h.height = m.getValueOrUndefined(c._height, e), h.scaleByDistance = m.getValueOrUndefined(c._scaleByDistance, e, P), h.translucencyByDistance = m.getValueOrUndefined(c._translucencyByDistance, e, I), h.pixelOffsetScaleByDistance = m.getValueOrUndefined(c._pixelOffsetScaleByDistance, e, D), h.sizeInMeters = m.getValueOrDefault(c._sizeInMeters, T);
                    var N = m.getValueOrUndefined(c._imageSubRegion, e, M);
                    o(N) && h.setImageSubRegion(h._imageId, N)
                } else p(s, i)
            }
            return !0
        }, R.prototype.getBoundingSphere = function (e, t) {
            var i = this._items.get(e.id);
            return o(i) && o(i.billboard) ? (t.center = n.clone(i.billboard.position, t.center), t.radius = 0, d.DONE) : d.FAILED
        }, R.prototype.isDestroyed = function () {
            return !1
        }, R.prototype.destroy = function () {
            return this._entityCollection.collectionChanged.removeEventListener(R.prototype._onCollectionChanged, this), o(this._billboardCollection) && this._scene.primitives.remove(this._billboardCollection), a(this)
        }, R.prototype._onCollectionChanged = function (e, t, i, n) {
            var r, a, s = this._unusedIndexes, u = this._items;
            for (r = t.length - 1; r > -1; r--)a = t[r], o(a._billboard) && o(a._position) && u.set(a.id, new O(a));
            for (r = n.length - 1; r > -1; r--)a = n[r], o(a._billboard) && o(a._position) ? u.contains(a.id) || u.set(a.id, new O(a)) : (p(u.get(a.id), s), u.remove(a.id));
            for (r = i.length - 1; r > -1; r--)a = i[r], p(u.get(a.id), s), u.remove(a.id)
        }, R
    }),define("Cesium/Core/BoxGeometry", ["./BoundingSphere", "./Cartesian3", "./ComponentDatatype", "./defaultValue", "./defined", "./DeveloperError", "./Geometry", "./GeometryAttribute", "./GeometryAttributes", "./PrimitiveType", "./VertexFormat"], function (e, t, i, n, r, o, a, s, u, l, c) {
        "use strict";
        var h = new t, d = function (e) {
            e = n(e, n.EMPTY_OBJECT);
            var i = e.minimumCorner, r = e.maximumCorner, o = n(e.vertexFormat, c.DEFAULT);
            this._minimumCorner = t.clone(i), this._maximumCorner = t.clone(r), this._vertexFormat = o, this._workerName = "createBoxGeometry"
        };
        d.fromDimensions = function (e) {
            e = n(e, n.EMPTY_OBJECT);
            var i = e.dimensions, r = t.multiplyByScalar(i, .5, new t), o = t.negate(r, new t), a = r, s = {
                minimumCorner: o,
                maximumCorner: a,
                vertexFormat: e.vertexFormat
            };
            return new d(s)
        }, d.packedLength = 2 * t.packedLength + c.packedLength, d.pack = function (e, i, r) {
            r = n(r, 0), t.pack(e._minimumCorner, i, r), t.pack(e._maximumCorner, i, r + t.packedLength), c.pack(e._vertexFormat, i, r + 2 * t.packedLength)
        };
        var m = new t, p = new t, f = new c, _ = {minimumCorner: m, maximumCorner: p, vertexFormat: f};
        return d.unpack = function (e, i, o) {
            i = n(i, 0);
            var a = t.unpack(e, i, m), s = t.unpack(e, i + t.packedLength, p), u = c.unpack(e, i + 2 * t.packedLength, f);
            return r(o) ? (o._minimumCorner = t.clone(a, o._minimumCorner), o._maximumCorner = t.clone(s, o._maximumCorner), o._vertexFormat = c.clone(u, o._vertexFormat), o) : new d(_)
        }, d.createGeometry = function (n) {
            var r, o, c = n._minimumCorner, d = n._maximumCorner, m = n._vertexFormat, p = new u;
            if (m.position && (m.st || m.normal || m.binormal || m.tangent)) {
                if (m.position && (o = new Float64Array(72), o[0] = c.x, o[1] = c.y, o[2] = d.z, o[3] = d.x, o[4] = c.y, o[5] = d.z, o[6] = d.x, o[7] = d.y, o[8] = d.z, o[9] = c.x, o[10] = d.y, o[11] = d.z, o[12] = c.x, o[13] = c.y, o[14] = c.z, o[15] = d.x, o[16] = c.y, o[17] = c.z, o[18] = d.x, o[19] = d.y, o[20] = c.z, o[21] = c.x, o[22] = d.y, o[23] = c.z, o[24] = d.x, o[25] = c.y, o[26] = c.z, o[27] = d.x, o[28] = d.y, o[29] = c.z, o[30] = d.x, o[31] = d.y, o[32] = d.z, o[33] = d.x, o[34] = c.y, o[35] = d.z, o[36] = c.x, o[37] = c.y, o[38] = c.z, o[39] = c.x, o[40] = d.y, o[41] = c.z, o[42] = c.x, o[43] = d.y, o[44] = d.z, o[45] = c.x, o[46] = c.y, o[47] = d.z, o[48] = c.x, o[49] = d.y, o[50] = c.z, o[51] = d.x, o[52] = d.y, o[53] = c.z, o[54] = d.x, o[55] = d.y, o[56] = d.z, o[57] = c.x, o[58] = d.y, o[59] = d.z, o[60] = c.x, o[61] = c.y, o[62] = c.z, o[63] = d.x, o[64] = c.y, o[65] = c.z, o[66] = d.x, o[67] = c.y, o[68] = d.z, o[69] = c.x, o[70] = c.y, o[71] = d.z, p.position = new s({
                        componentDatatype: i.DOUBLE,
                        componentsPerAttribute: 3,
                        values: o
                    })), m.normal) {
                    var f = new Float32Array(72);
                    f[0] = 0, f[1] = 0, f[2] = 1, f[3] = 0, f[4] = 0, f[5] = 1, f[6] = 0, f[7] = 0, f[8] = 1, f[9] = 0, f[10] = 0, f[11] = 1, f[12] = 0, f[13] = 0, f[14] = -1, f[15] = 0, f[16] = 0, f[17] = -1, f[18] = 0, f[19] = 0, f[20] = -1, f[21] = 0, f[22] = 0, f[23] = -1, f[24] = 1, f[25] = 0, f[26] = 0, f[27] = 1, f[28] = 0, f[29] = 0, f[30] = 1, f[31] = 0, f[32] = 0, f[33] = 1, f[34] = 0, f[35] = 0, f[36] = -1, f[37] = 0, f[38] = 0, f[39] = -1, f[40] = 0, f[41] = 0, f[42] = -1, f[43] = 0, f[44] = 0, f[45] = -1, f[46] = 0, f[47] = 0, f[48] = 0, f[49] = 1, f[50] = 0, f[51] = 0, f[52] = 1, f[53] = 0, f[54] = 0, f[55] = 1, f[56] = 0, f[57] = 0, f[58] = 1, f[59] = 0, f[60] = 0, f[61] = -1, f[62] = 0, f[63] = 0, f[64] = -1, f[65] = 0, f[66] = 0, f[67] = -1, f[68] = 0, f[69] = 0, f[70] = -1, f[71] = 0, p.normal = new s({
                        componentDatatype: i.FLOAT,
                        componentsPerAttribute: 3,
                        values: f
                    })
                }
                if (m.st) {
                    var _ = new Float32Array(48);
                    _[0] = 0, _[1] = 0, _[2] = 1, _[3] = 0, _[4] = 1, _[5] = 1, _[6] = 0, _[7] = 1, _[8] = 1, _[9] = 0, _[10] = 0, _[11] = 0, _[12] = 0, _[13] = 1, _[14] = 1, _[15] = 1, _[16] = 0, _[17] = 0, _[18] = 1, _[19] = 0, _[20] = 1, _[21] = 1, _[22] = 0, _[23] = 1, _[24] = 1, _[25] = 0, _[26] = 0, _[27] = 0, _[28] = 0, _[29] = 1, _[30] = 1, _[31] = 1, _[32] = 1, _[33] = 0, _[34] = 0, _[35] = 0, _[36] = 0, _[37] = 1, _[38] = 1, _[39] = 1, _[40] = 0, _[41] = 0, _[42] = 1, _[43] = 0, _[44] = 1, _[45] = 1, _[46] = 0, _[47] = 1, p.st = new s({
                        componentDatatype: i.FLOAT,
                        componentsPerAttribute: 2,
                        values: _
                    })
                }
                if (m.tangent) {
                    var v = new Float32Array(72);
                    v[0] = 1, v[1] = 0, v[2] = 0, v[3] = 1, v[4] = 0, v[5] = 0, v[6] = 1, v[7] = 0, v[8] = 0, v[9] = 1, v[10] = 0, v[11] = 0, v[12] = -1, v[13] = 0, v[14] = 0, v[15] = -1, v[16] = 0, v[17] = 0, v[18] = -1, v[19] = 0, v[20] = 0, v[21] = -1, v[22] = 0, v[23] = 0, v[24] = 0, v[25] = 1, v[26] = 0, v[27] = 0, v[28] = 1, v[29] = 0, v[30] = 0, v[31] = 1, v[32] = 0, v[33] = 0, v[34] = 1, v[35] = 0, v[36] = 0, v[37] = -1, v[38] = 0, v[39] = 0, v[40] = -1, v[41] = 0, v[42] = 0, v[43] = -1, v[44] = 0, v[45] = 0, v[46] = -1, v[47] = 0, v[48] = -1, v[49] = 0, v[50] = 0, v[51] = -1, v[52] = 0, v[53] = 0, v[54] = -1, v[55] = 0, v[56] = 0, v[57] = -1, v[58] = 0, v[59] = 0, v[60] = 1, v[61] = 0, v[62] = 0, v[63] = 1, v[64] = 0, v[65] = 0, v[66] = 1, v[67] = 0, v[68] = 0, v[69] = 1, v[70] = 0, v[71] = 0, p.tangent = new s({
                        componentDatatype: i.FLOAT,
                        componentsPerAttribute: 3,
                        values: v
                    })
                }
                if (m.binormal) {
                    var g = new Float32Array(72);
                    g[0] = 0, g[1] = 1, g[2] = 0, g[3] = 0, g[4] = 1, g[5] = 0, g[6] = 0, g[7] = 1, g[8] = 0, g[9] = 0, g[10] = 1, g[11] = 0, g[12] = 0, g[13] = 1, g[14] = 0, g[15] = 0, g[16] = 1, g[17] = 0, g[18] = 0, g[19] = 1, g[20] = 0, g[21] = 0, g[22] = 1, g[23] = 0, g[24] = 0, g[25] = 0, g[26] = 1, g[27] = 0, g[28] = 0, g[29] = 1, g[30] = 0, g[31] = 0, g[32] = 1, g[33] = 0, g[34] = 0, g[35] = 1, g[36] = 0, g[37] = 0, g[38] = 1, g[39] = 0, g[40] = 0, g[41] = 1, g[42] = 0, g[43] = 0, g[44] = 1, g[45] = 0, g[46] = 0, g[47] = 1, g[48] = 0, g[49] = 0, g[50] = 1, g[51] = 0, g[52] = 0, g[53] = 1, g[54] = 0, g[55] = 0, g[56] = 1, g[57] = 0, g[58] = 0, g[59] = 1, g[60] = 0, g[61] = 0, g[62] = 1, g[63] = 0, g[64] = 0, g[65] = 1, g[66] = 0, g[67] = 0, g[68] = 1, g[69] = 0, g[70] = 0, g[71] = 1, p.binormal = new s({
                        componentDatatype: i.FLOAT,
                        componentsPerAttribute: 3,
                        values: g
                    })
                }
                r = new Uint16Array(36), r[0] = 0, r[1] = 1, r[2] = 2, r[3] = 0, r[4] = 2, r[5] = 3, r[6] = 6, r[7] = 5, r[8] = 4, r[9] = 7, r[10] = 6, r[11] = 4, r[12] = 8, r[13] = 9, r[14] = 10, r[15] = 8, r[16] = 10, r[17] = 11, r[18] = 14, r[19] = 13, r[20] = 12, r[21] = 15, r[22] = 14, r[23] = 12, r[24] = 18, r[25] = 17, r[26] = 16, r[27] = 19, r[28] = 18, r[29] = 16, r[30] = 20, r[31] = 21, r[32] = 22, r[33] = 20, r[34] = 22, r[35] = 23
            } else o = new Float64Array(24), o[0] = c.x, o[1] = c.y, o[2] = c.z, o[3] = d.x, o[4] = c.y, o[5] = c.z, o[6] = d.x, o[7] = d.y, o[8] = c.z, o[9] = c.x, o[10] = d.y, o[11] = c.z, o[12] = c.x, o[13] = c.y, o[14] = d.z, o[15] = d.x, o[16] = c.y, o[17] = d.z, o[18] = d.x, o[19] = d.y, o[20] = d.z, o[21] = c.x, o[22] = d.y, o[23] = d.z, p.position = new s({
                componentDatatype: i.DOUBLE,
                componentsPerAttribute: 3,
                values: o
            }), r = new Uint16Array(36), r[0] = 4, r[1] = 5, r[2] = 6, r[3] = 4, r[4] = 6, r[5] = 7, r[6] = 1, r[7] = 0, r[8] = 3, r[9] = 1, r[10] = 3, r[11] = 2, r[12] = 1, r[13] = 6, r[14] = 5, r[15] = 1, r[16] = 2, r[17] = 6, r[18] = 2, r[19] = 3, r[20] = 7, r[21] = 2, r[22] = 7, r[23] = 6, r[24] = 3, r[25] = 0, r[26] = 4, r[27] = 3, r[28] = 4, r[29] = 7, r[30] = 0, r[31] = 1, r[32] = 5, r[33] = 0, r[34] = 5, r[35] = 4;
            var y = t.subtract(d, c, h), C = .5 * t.magnitude(y);
            return new a({attributes: p, indices: r, primitiveType: l.TRIANGLES, boundingSphere: new e(t.ZERO, C)})
        }, d
    }),define("Cesium/Core/ShowGeometryInstanceAttribute", ["./ComponentDatatype", "./defaultValue", "./defined", "./defineProperties", "./DeveloperError"], function (e, t, i, n, r) {
        "use strict";
        var o = function (e) {
            e = t(e, !0), this.value = o.toValue(e)
        };
        return n(o.prototype, {
            componentDatatype: {
                get: function () {
                    return e.UNSIGNED_BYTE
                }
            }, componentsPerAttribute: {
                get: function () {
                    return 1
                }
            }, normalize: {
                get: function () {
                    return !1
                }
            }
        }), o.toValue = function (e, t) {
            return i(t) ? (t[0] = e, t) : new Uint8Array([e])
        }, o
    }),define("Cesium/Shaders/Appearances/AllMaterialAppearanceFS", [], function () {
        "use strict";
        return "varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec3 v_tangentEC;\nvarying vec3 v_binormalEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC; \n    mat3 tangentToEyeMatrix = czm_tangentToEyeSpaceMatrix(v_normalEC, v_tangentEC, v_binormalEC);\n\n    vec3 normalEC = normalize(v_normalEC);\n#ifdef FACE_FORWARD\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n#endif\n\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.tangentToEyeMatrix = tangentToEyeMatrix;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    materialInput.st = v_st;\n    czm_material material = czm_getMaterial(materialInput);\n    \n#ifdef FLAT    \n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#else\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\n#endif\n}\n"
    }),define("Cesium/Shaders/Appearances/AllMaterialAppearanceVS", [], function () {
        "use strict";
        return "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec3 tangent;\nattribute vec3 binormal;\nattribute vec2 st;\n\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec3 v_tangentEC;\nvarying vec3 v_binormalEC;\nvarying vec2 v_st;\n\nvoid main() \n{\n    vec4 p = czm_computePosition();\n\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n    v_tangentEC = czm_normal * tangent;                       // tangent in eye coordinates\n    v_binormalEC = czm_normal * binormal;                     // binormal in eye coordinates\n    v_st = st;\n    \n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"
    }),define("Cesium/Shaders/Appearances/BasicMaterialAppearanceFS", [], function () {
        "use strict";
        return "varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\n\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC; \n\n    vec3 normalEC = normalize(v_normalEC);\n#ifdef FACE_FORWARD\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n#endif\n\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    czm_material material = czm_getMaterial(materialInput);\n    \n#ifdef FLAT    \n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#else\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\n#endif\n}\n"
    }),define("Cesium/Shaders/Appearances/BasicMaterialAppearanceVS", [], function () {
        "use strict";
        return "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\n\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\n\nvoid main() \n{\n    vec4 p = czm_computePosition();\n\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n    \n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"
    }),define("Cesium/Shaders/Appearances/TexturedMaterialAppearanceFS", [], function () {
        "use strict";
        return "varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC; \n\n    vec3 normalEC = normalize(v_normalEC);;\n#ifdef FACE_FORWARD\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n#endif\n\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    materialInput.st = v_st;\n    czm_material material = czm_getMaterial(materialInput);\n    \n#ifdef FLAT    \n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#else\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\n#endif\n}\n"
    }),define("Cesium/Shaders/Appearances/TexturedMaterialAppearanceVS", [], function () {
        "use strict";
        return "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec2 st;\n\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec2 v_st;\n\nvoid main() \n{\n    vec4 p = czm_computePosition();\n\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n    v_st = st;\n    \n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"
    }),define("Cesium/Shaders/Materials/BumpMapMaterial", [], function () {
        "use strict";
        return "uniform sampler2D image;\nuniform float strength;\nuniform vec2 repeat;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n    \n    vec2 centerPixel = fract(repeat * st);\n    float centerBump = texture2D(image, centerPixel).channel;\n    \n    float imageWidth = float(imageDimensions.x);\n    vec2 rightPixel = fract(repeat * (st + vec2(1.0 / imageWidth, 0.0)));\n    float rightBump = texture2D(image, rightPixel).channel;\n    \n    float imageHeight = float(imageDimensions.y);\n    vec2 leftPixel = fract(repeat * (st + vec2(0.0, 1.0 / imageHeight)));\n    float topBump = texture2D(image, leftPixel).channel;\n    \n    vec3 normalTangentSpace = normalize(vec3(centerBump - rightBump, centerBump - topBump, clamp(1.0 - strength, 0.1, 1.0)));\n    vec3 normalEC = materialInput.tangentToEyeMatrix * normalTangentSpace;\n \n    material.normal = normalEC;\n    material.diffuse = vec3(0.01);\n    \n    return material;\n}"
    }),define("Cesium/Shaders/Materials/CheckerboardMaterial", [], function () {
        "use strict";
        return "uniform vec4 lightColor;\nuniform vec4 darkColor;\nuniform vec2 repeat;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n    \n    // From Stefan Gustavson's Procedural Textures in GLSL in OpenGL Insights\n    float b = mod(floor(repeat.s * st.s) + floor(repeat.t * st.t), 2.0);  // 0.0 or 1.0\n    \n    // Find the distance from the closest separator (region between two colors)\n    float scaledWidth = fract(repeat.s * st.s);\n    scaledWidth = abs(scaledWidth - floor(scaledWidth + 0.5));\n    float scaledHeight = fract(repeat.t * st.t);\n    scaledHeight = abs(scaledHeight - floor(scaledHeight + 0.5));\n    float value = min(scaledWidth, scaledHeight);\n    \n    vec4 currentColor = mix(lightColor, darkColor, b);\n    vec4 color = czm_antialias(lightColor, darkColor, currentColor, value, 0.03);\n    \n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n    \n    return material;\n}\n"
    }),define("Cesium/Shaders/Materials/DotMaterial", [], function () {
        "use strict";
        return "uniform vec4 lightColor;\nuniform vec4 darkColor;\nuniform vec2 repeat;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    // From Stefan Gustavson's Procedural Textures in GLSL in OpenGL Insights\n    float b = smoothstep(0.3, 0.32, length(fract(repeat * materialInput.st) - 0.5));  // 0.0 or 1.0\n\n    vec4 color = mix(lightColor, darkColor, b);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n    \n    return material;\n}\n"
    }),define("Cesium/Shaders/Materials/FadeMaterial", [], function () {
        "use strict";
        return "uniform vec4 fadeInColor;\nuniform vec4 fadeOutColor;\nuniform float maximumDistance;\nuniform bool repeat;\nuniform vec2 fadeDirection;\nuniform vec2 time;\n\nfloat getTime(float t, float coord)\n{\n    float scalar = 1.0 / maximumDistance;\n    float q  = distance(t, coord) * scalar;\n    if (repeat)\n    {\n        float r = distance(t, coord + 1.0) * scalar;\n        float s = distance(t, coord - 1.0) * scalar;\n        q = min(min(r, s), q);\n    }\n    return clamp(q, 0.0, 1.0);\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec2 st = materialInput.st;\n    float s = getTime(time.x, st.s) * fadeDirection.s;\n    float t = getTime(time.y, st.t) * fadeDirection.t;\n    \n    float u = length(vec2(s, t));\n    vec4 color = mix(fadeInColor, fadeOutColor, u);\n    \n    material.emission = color.rgb;\n    material.alpha = color.a;\n    \n    return material;\n}\n";
    }),define("Cesium/Shaders/Materials/GridMaterial", [], function () {
        "use strict";
        return '#ifdef GL_OES_standard_derivatives\n    #extension GL_OES_standard_derivatives : enable\n#endif\n\nuniform vec4 color;\nuniform float cellAlpha;\nuniform vec2 lineCount;\nuniform vec2 lineThickness;\nuniform vec2 lineOffset;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n\n    float scaledWidth = fract(lineCount.s * st.s - lineOffset.s);\n    scaledWidth = abs(scaledWidth - floor(scaledWidth + 0.5));\n    float scaledHeight = fract(lineCount.t * st.t - lineOffset.t);\n    scaledHeight = abs(scaledHeight - floor(scaledHeight + 0.5));\n\n    float value;\n#ifdef GL_OES_standard_derivatives\n    // Fuzz Factor - Controls blurriness of lines\n    const float fuzz = 1.2;\n    vec2 thickness = (lineThickness * czm_resolutionScale) - 1.0;\n\n    // From "3D Engine Design for Virtual Globes" by Cozzi and Ring, Listing 4.13.\n    vec2 dx = abs(dFdx(st));\n    vec2 dy = abs(dFdy(st));\n    vec2 dF = vec2(max(dx.s, dy.s), max(dx.t, dy.t)) * lineCount;\n    value = min(\n        smoothstep(dF.s * thickness.s, dF.s * (fuzz + thickness.s), scaledWidth),\n        smoothstep(dF.t * thickness.t, dF.t * (fuzz + thickness.t), scaledHeight));\n#else\n    // Fuzz Factor - Controls blurriness of lines\n    const float fuzz = 0.05;\n\n    vec2 range = 0.5 - (lineThickness * 0.05);\n    value = min(\n        1.0 - smoothstep(range.s, range.s + fuzz, scaledWidth),\n        1.0 - smoothstep(range.t, range.t + fuzz, scaledHeight));\n#endif\n\n    // Edges taken from RimLightingMaterial.glsl\n    // See http://www.fundza.com/rman_shaders/surface/fake_rim/fake_rim1.html\n    float dRim = 1.0 - abs(dot(materialInput.normalEC, normalize(materialInput.positionToEyeEC)));\n    float sRim = smoothstep(0.8, 1.0, dRim);\n    value *= (1.0 - sRim);\n\n    vec3 halfColor = color.rgb * 0.5;\n    material.diffuse = halfColor;\n    material.emission = halfColor;\n    material.alpha = color.a * (1.0 - ((1.0 - cellAlpha) * value));\n\n    return material;\n}\n'
    }),define("Cesium/Shaders/Materials/NormalMapMaterial", [], function () {
        "use strict";
        return "uniform sampler2D image;\nuniform float strength;\nuniform vec2 repeat;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec4 textureValue = texture2D(image, fract(repeat * materialInput.st));\n    vec3 normalTangentSpace = textureValue.channels;\n    normalTangentSpace.xy = normalTangentSpace.xy * 2.0 - 1.0;\n    normalTangentSpace.z = clamp(1.0 - strength, 0.1, 1.0);\n    normalTangentSpace = normalize(normalTangentSpace);\n    vec3 normalEC = materialInput.tangentToEyeMatrix * normalTangentSpace;\n    \n    material.normal = normalEC;\n    \n    return material;\n}"
    }),define("Cesium/Shaders/Materials/PolylineArrowMaterial", [], function () {
        "use strict";
        return "#extension GL_OES_standard_derivatives : enable\n\nuniform vec4 color;\n\nvarying float v_width;\n\nfloat getPointOnLine(vec2 p0, vec2 p1, float x)\n{\n    float slope = (p0.y - p1.y) / (p0.x - p1.x);\n    return slope * (x - p0.x) + p0.y;\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec2 st = materialInput.st;\n    \n    float base = 1.0 - abs(fwidth(st.s)) * 10.0;\n    vec2 center = vec2(1.0, 0.5);\n    float ptOnUpperLine = getPointOnLine(vec2(base, 1.0), center, st.s);\n    float ptOnLowerLine = getPointOnLine(vec2(base, 0.0), center, st.s);\n    \n    float halfWidth = 0.15;\n    float s = step(0.5 - halfWidth, st.t);\n    s *= 1.0 - step(0.5 + halfWidth, st.t);\n    s *= 1.0 - step(base, st.s);\n    \n    float t = step(base, materialInput.st.s);\n    t *= 1.0 - step(ptOnUpperLine, st.t);\n    t *= step(ptOnLowerLine, st.t);\n    \n    // Find the distance from the closest separator (region between two colors)\n    float dist;\n    if (st.s < base)\n    {\n        float d1 = abs(st.t - (0.5 - halfWidth));\n        float d2 = abs(st.t - (0.5 + halfWidth));\n        dist = min(d1, d2);\n    }\n    else\n    {\n        float d1 = czm_infinity;\n        if (st.t < 0.5 - halfWidth && st.t > 0.5 + halfWidth)\n        {\n            d1 = abs(st.s - base);\n        }\n        float d2 = abs(st.t - ptOnUpperLine);\n        float d3 = abs(st.t - ptOnLowerLine);\n        dist = min(min(d1, d2), d3);\n    }\n    \n    vec4 outsideColor = vec4(0.0);\n    vec4 currentColor = mix(outsideColor, color, clamp(s + t, 0.0, 1.0));\n    vec4 outColor = czm_antialias(outsideColor, color, currentColor, dist);\n    \n    material.diffuse = outColor.rgb;\n    material.alpha = outColor.a;\n    return material;\n}\n"
    }),define("Cesium/Shaders/Materials/PolylineGlowMaterial", [], function () {
        "use strict";
        return "uniform vec4 color;\nuniform float glowPower;\n\nvarying float v_width;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n    float glow = glowPower / abs(st.t - 0.5) - (glowPower / 0.5);\n\n    material.emission = max(vec3(glow - 1.0 + color.rgb), color.rgb);\n    material.alpha = clamp(0.0, 1.0, glow) * color.a;\n\n    return material;\n}\n"
    }),define("Cesium/Shaders/Materials/PolylineOutlineMaterial", [], function () {
        "use strict";
        return "uniform vec4 color;\nuniform vec4 outlineColor;\nuniform float outlineWidth;\n\nvarying float v_width;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec2 st = materialInput.st;\n    float halfInteriorWidth =  0.5 * (v_width - outlineWidth) / v_width;\n    float b = step(0.5 - halfInteriorWidth, st.t);\n    b *= 1.0 - step(0.5 + halfInteriorWidth, st.t);\n    \n    // Find the distance from the closest separator (region between two colors)\n    float d1 = abs(st.t - (0.5 - halfInteriorWidth));\n    float d2 = abs(st.t - (0.5 + halfInteriorWidth));\n    float dist = min(d1, d2);\n    \n    vec4 currentColor = mix(outlineColor, color, b);\n    vec4 outColor = czm_antialias(outlineColor, color, currentColor, dist);\n    \n    material.diffuse = outColor.rgb;\n    material.alpha = outColor.a;\n    \n    return material;\n}\n"
    }),define("Cesium/Shaders/Materials/RimLightingMaterial", [], function () {
        "use strict";
        return "uniform vec4 color;\nuniform vec4 rimColor;\nuniform float width;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    // See http://www.fundza.com/rman_shaders/surface/fake_rim/fake_rim1.html\n    float d = 1.0 - dot(materialInput.normalEC, normalize(materialInput.positionToEyeEC));\n    float s = smoothstep(1.0 - width, 1.0, d);\n\n    material.diffuse = color.rgb;\n    material.emission = rimColor.rgb * s; \n    material.alpha = mix(color.a, rimColor.a, s);\n\n    return material;\n}\n"
    }),define("Cesium/Shaders/Materials/StripeMaterial", [], function () {
        "use strict";
        return "uniform vec4 evenColor;\nuniform vec4 oddColor;\nuniform float offset;\nuniform float repeat;\nuniform bool horizontal;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    // Based on the Stripes Fragment Shader in the Orange Book (11.1.2)\n    float coord = mix(materialInput.st.s, materialInput.st.t, float(horizontal));\n    float value = fract((coord - offset) * (repeat * 0.5));\n    float dist = min(value, min(abs(value - 0.5), 1.0 - value));\n    \n    vec4 currentColor = mix(evenColor, oddColor, step(0.5, value));\n    vec4 color = czm_antialias(evenColor, oddColor, currentColor, dist);\n    \n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n    \n    return material;\n}\n"
    }),define("Cesium/Shaders/Materials/Water", [], function () {
        "use strict";
        return "// Thanks for the contribution Jonas\n// http://29a.ch/2012/7/19/webgl-terrain-rendering-water-fog\n\nuniform sampler2D specularMap;\nuniform sampler2D normalMap;\nuniform vec4 baseWaterColor;\nuniform vec4 blendColor;\nuniform float frequency;\nuniform float animationSpeed;\nuniform float amplitude;\nuniform float specularIntensity;\nuniform float fadeFactor;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    float time = czm_frameNumber * animationSpeed;\n    \n    // fade is a function of the distance from the fragment and the frequency of the waves\n    float fade = max(1.0, (length(materialInput.positionToEyeEC) / 10000000000.0) * frequency * fadeFactor);\n            \n    float specularMapValue = texture2D(specularMap, materialInput.st).r;\n    \n    // note: not using directional motion at this time, just set the angle to 0.0;\n    vec4 noise = czm_getWaterNoise(normalMap, materialInput.st * frequency, time, 0.0);\n    vec3 normalTangentSpace = noise.xyz * vec3(1.0, 1.0, (1.0 / amplitude));\n    \n    // fade out the normal perturbation as we move further from the water surface\n    normalTangentSpace.xy /= fade;\n        \n    // attempt to fade out the normal perturbation as we approach non water areas (low specular map value)\n    normalTangentSpace = mix(vec3(0.0, 0.0, 50.0), normalTangentSpace, specularMapValue);\n    \n    normalTangentSpace = normalize(normalTangentSpace);\n    \n    // get ratios for alignment of the new normal vector with a vector perpendicular to the tangent plane\n    float tsPerturbationRatio = clamp(dot(normalTangentSpace, vec3(0.0, 0.0, 1.0)), 0.0, 1.0);\n    \n    // fade out water effect as specular map value decreases\n    material.alpha = specularMapValue;\n    \n    // base color is a blend of the water and non-water color based on the value from the specular map\n    // may need a uniform blend factor to better control this\n    material.diffuse = mix(blendColor.rgb, baseWaterColor.rgb, specularMapValue);\n    \n    // diffuse highlights are based on how perturbed the normal is\n    material.diffuse += (0.1 * tsPerturbationRatio);\n    \n    material.normal = normalize(materialInput.tangentToEyeMatrix * normalTangentSpace);\n    \n    material.specular = specularIntensity;\n    material.shininess = 10.0;\n    \n    return material;\n}"
    }),define("Cesium/Scene/Material", ["../Core/Cartesian2", "../Core/clone", "../Core/Color", "../Core/combine", "../Core/createGuid", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/isArray", "../Core/loadImage", "../Core/Matrix2", "../Core/Matrix3", "../Core/Matrix4", "../Renderer/CubeMap", "../Renderer/Texture", "../Shaders/Materials/BumpMapMaterial", "../Shaders/Materials/CheckerboardMaterial", "../Shaders/Materials/DotMaterial", "../Shaders/Materials/FadeMaterial", "../Shaders/Materials/GridMaterial", "../Shaders/Materials/NormalMapMaterial", "../Shaders/Materials/PolylineArrowMaterial", "../Shaders/Materials/PolylineGlowMaterial", "../Shaders/Materials/PolylineOutlineMaterial", "../Shaders/Materials/RimLightingMaterial", "../Shaders/Materials/StripeMaterial", "../Shaders/Materials/Water", "../ThirdParty/when"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S, T, b, w, x, A, P, I) {
        "use strict";
        function D(e, i) {
            e = o(e, o.EMPTY_OBJECT), i._strict = o(e.strict, !1), i._count = o(e.count, 0), i._template = t(o(e.fabric, o.EMPTY_OBJECT)), i._template.uniforms = t(o(i._template.uniforms, o.EMPTY_OBJECT)), i._template.materials = t(o(i._template.materials, o.EMPTY_OBJECT)), i.type = a(i._template.type) ? i._template.type : r(), i.shaderSource = "", i.materials = {}, i.uniforms = {}, i._uniforms = {}, i._translucentFunctions = [];
            var s, u = W._materialCache.getMaterial(i.type);
            if (a(u)) {
                var l = t(u.fabric, !0);
                i._template = n(i._template, l, !0), s = u.translucent
            }
            N(i), a(u) || W._materialCache.addMaterial(i.type, i), L(i), z(i), k(i);
            var c = 0 === i._translucentFunctions.length ? !0 : void 0;
            if (s = o(s, c), s = o(e.translucent, s), a(s))if ("function" == typeof s) {
                var h = function () {
                    return s(i)
                };
                i._translucentFunctions.push(h)
            } else i._translucentFunctions.push(s)
        }

        function M(e, t, i, n) {
            if (a(e))for (var r in e)if (e.hasOwnProperty(r)) {
                var o = -1 !== t.indexOf(r);
                (n && !o || !n && o) && i(r, t)
            }
        }

        function O(e, t) {
            for (var i = "fabric: property name '" + e + "' is not valid. It should be ", n = 0; n < t.length; n++) {
                var r = "'" + t[n] + "'";
                i += n === t.length - 1 ? "or " + r + "." : r + ", "
            }
            throw new l(i)
        }

        function R(e, t) {
            var i = "fabric: uniforms and materials cannot share the same property '" + e + "'";
            throw new l(i)
        }

        function N(e) {
            var t = e._template, i = t.uniforms, n = t.materials, r = t.components;
            if (a(r) && a(t.source))throw new l("fabric: cannot have source and components in the same template.");
            M(t, q, O, !0), M(r, j, O, !0);
            var o = [];
            for (var s in n)n.hasOwnProperty(s) && o.push(s);
            M(i, o, R, !1)
        }

        function L(e) {
            var t = e._template.components, i = e._template.source;
            if (a(i))e.shaderSource += i + "\n"; else {
                if (e.shaderSource += "czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n", e.shaderSource += "czm_material material = czm_getDefaultMaterial(materialInput);\n", a(t))for (var n in t)t.hasOwnProperty(n) && (e.shaderSource += "material." + n + " = " + t[n] + ";\n");
                e.shaderSource += "return material;\n}\n"
            }
        }

        function F(e) {
            return function (t, i) {
                var n, r, o = t.uniforms, s = o[e], u = t._textures[e];
                if (s instanceof _ && s !== u) {
                    t._texturePaths[e] = void 0;
                    var l = t._textures[e];
                    return l !== t._defaultTexture && l.destroy(), t._textures[e] = s, n = e + "Dimensions", void(o.hasOwnProperty(n) && (r = o[n], r.x = s._width, r.y = s._height))
                }
                a(u) || (t._texturePaths[e] = void 0, a(t._defaultTexture) || (t._defaultTexture = i.defaultTexture), u = t._textures[e] = t._defaultTexture, n = e + "Dimensions", o.hasOwnProperty(n) && (r = o[n], r.x = u._width, r.y = u._height)), s !== W.DefaultImageId && s !== t._texturePaths[e] && ("string" == typeof s ? I(h(s), function (i) {
                    t._loadedImages.push({id: e, image: i})
                }) : s instanceof HTMLCanvasElement && t._loadedImages.push({id: e, image: s}), t._texturePaths[e] = s)
            }
        }

        function B(e) {
            return function (t, i) {
                var n = t.uniforms[e];
                if (n instanceof f) {
                    var r = t._textures[e];
                    return r !== t._defaultTexture && r.destroy(), t._texturePaths[e] = void 0, void(t._textures[e] = n)
                }
                if (a(t._textures[e]) || (t._texturePaths[e] = void 0, t._textures[e] = i.defaultCubeMap), n !== W.DefaultCubeMapId) {
                    var o = n.positiveX + n.negativeX + n.positiveY + n.negativeY + n.positiveZ + n.negativeZ;
                    if (o !== t._texturePaths[e]) {
                        var s = [h(n.positiveX), h(n.negativeX), h(n.positiveY), h(n.negativeY), h(n.positiveZ), h(n.negativeZ)];
                        I.all(s).then(function (i) {
                            t._loadedCubeMaps.push({id: e, images: i})
                        }), t._texturePaths[e] = o
                    }
                }
            }
        }

        function z(e) {
            var t = e._template.uniforms;
            for (var i in t)t.hasOwnProperty(i) && V(e, i)
        }

        function V(e, t) {
            var i = e._strict, n = e._template.uniforms, r = n[t], o = U(r);
            if (!a(o))throw new l("fabric: uniform '" + t + "' has invalid type.");
            if ("channels" === o) {
                if (0 === G(e, t, r, !1) && i)throw new l("strict: shader source does not use channels '" + t + "'.")
            } else {
                if ("sampler2D" === o) {
                    var s = t + "Dimensions";
                    H(e, s) > 0 && (n[s] = {type: "ivec3", x: 1, y: 1}, V(e, s))
                }
                var u = new RegExp("uniform\\s+" + o + "\\s+" + t + "\\s*;");
                if (!u.test(e.shaderSource)) {
                    var c = "uniform " + o + " " + t + ";";
                    e.shaderSource = c + e.shaderSource
                }
                var h = t + "_" + e._count++;
                if (1 === G(e, t, h) && i)throw new l("strict: shader source does not use uniform '" + t + "'.");
                if (e.uniforms[t] = r, "sampler2D" === o)e._uniforms[h] = function () {
                    return e._textures[t]
                }, e._updateFunctions.push(F(t)); else if ("samplerCube" === o)e._uniforms[h] = function () {
                    return e._textures[t]
                }, e._updateFunctions.push(B(t)); else if (-1 !== o.indexOf("mat")) {
                    var d = new Y[o];
                    e._uniforms[h] = function () {
                        return Y[o].fromColumnMajorArray(e.uniforms[t], d)
                    }
                } else e._uniforms[h] = function () {
                    return e.uniforms[t]
                }
            }
        }

        function U(e) {
            var t = e.type;
            if (!a(t)) {
                var i = typeof e;
                if ("number" === i)t = "float"; else if ("boolean" === i)t = "bool"; else if ("string" === i || e instanceof HTMLCanvasElement)t = /^([rgba]){1,4}$/i.test(e) ? "channels" : e === W.DefaultCubeMapId ? "samplerCube" : "sampler2D"; else if ("object" === i)if (c(e))(4 === e.length || 9 === e.length || 16 === e.length) && (t = "mat" + Math.sqrt(e.length)); else {
                    var n = 0;
                    for (var r in e)e.hasOwnProperty(r) && (n += 1);
                    n >= 2 && 4 >= n ? t = "vec" + n : 6 === n && (t = "samplerCube")
                }
            }
            return t
        }

        function k(e) {
            var t = e._strict, i = e._template.materials;
            for (var r in i)if (i.hasOwnProperty(r)) {
                var o = new W({strict: t, fabric: i[r], count: e._count});
                e._count = o._count, e._uniforms = n(e._uniforms, o._uniforms, !0), e.materials[r] = o, e._translucentFunctions = e._translucentFunctions.concat(o._translucentFunctions);
                var a = "czm_getMaterial", s = a + "_" + e._count++;
                G(o, a, s), e.shaderSource = o.shaderSource + e.shaderSource;
                var u = s + "(materialInput)";
                if (0 === G(e, r, u) && t)throw new l("strict: shader source does not use material '" + r + "'.")
            }
        }

        function G(e, t, i, n) {
            n = o(n, !0);
            var r = 0, a = "([\\w])?", s = "([\\w" + (n ? "." : "") + "])?", u = new RegExp(s + t + a, "g");
            return e.shaderSource = e.shaderSource.replace(u, function (e, t, n) {
                return t || n ? e : (r += 1, i)
            }), r
        }

        function H(e, t, i) {
            return G(e, t, t, i)
        }

        var W = function (e) {
            this.type = void 0, this.shaderSource = void 0, this.materials = void 0, this.uniforms = void 0, this._uniforms = void 0, this.translucent = void 0, this._strict = void 0, this._template = void 0, this._count = void 0, this._texturePaths = {}, this._loadedImages = [], this._loadedCubeMaps = [], this._textures = {}, this._updateFunctions = [], this._defaultTexture = void 0, D(e, this), s(this, {
                type: {
                    value: this.type,
                    writable: !1
                }
            }), a(W._uniformList[this.type]) || (W._uniformList[this.type] = Object.keys(this._uniforms))
        };
        W._uniformList = {}, W.fromType = function (e, t) {
            var i = new W({fabric: {type: e}});
            if (a(t))for (var n in t)t.hasOwnProperty(n) && (i.uniforms[n] = t[n]);
            return i
        }, W.prototype.isTranslucent = function () {
            if (a(this.translucent))return "function" == typeof this.translucent ? this.translucent() : this.translucent;
            for (var e = !0, t = this._translucentFunctions, i = t.length, n = 0; i > n; ++n) {
                var r = t[n];
                if (e = "function" == typeof r ? e && r() : e && r, !e)break
            }
            return e
        }, W.prototype.update = function (e) {
            var t, i, n = this._loadedImages, r = n.length;
            for (t = 0; r > t; ++t) {
                var o = n[t];
                i = o.id;
                var a = o.image, s = new _({context: e, source: a});
                this._textures[i] = s;
                var u = i + "Dimensions";
                if (this.uniforms.hasOwnProperty(u)) {
                    var l = this.uniforms[u];
                    l.x = s._width, l.y = s._height
                }
            }
            n.length = 0;
            var c = this._loadedCubeMaps;
            for (r = c.length, t = 0; r > t; ++t) {
                var h = c[t];
                i = h.id;
                var d = h.images, m = new f({
                    context: e,
                    source: {
                        positiveX: d[0],
                        negativeX: d[1],
                        positiveY: d[2],
                        negativeY: d[3],
                        positiveZ: d[4],
                        negativeZ: d[5]
                    }
                });
                this._textures[i] = m
            }
            c.length = 0;
            var p = this._updateFunctions;
            for (r = p.length, t = 0; r > t; ++t)p[t](this, e);
            var v = this.materials;
            for (var g in v)v.hasOwnProperty(g) && v[g].update(e)
        }, W.prototype.isDestroyed = function () {
            return !1
        }, W.prototype.destroy = function () {
            var e = this._textures;
            for (var t in e)if (e.hasOwnProperty(t)) {
                var i = e[t];
                i !== this._defaultTexture && i.destroy()
            }
            var n = this.materials;
            for (var r in n)n.hasOwnProperty(r) && n[r].destroy();
            return u(this)
        };
        var q = ["type", "materials", "uniforms", "components", "source"], j = ["diffuse", "specular", "shininess", "normal", "emission", "alpha"], Y = {
            mat2: d,
            mat3: m,
            mat4: p
        };
        return W._materialCache = {
            _materials: {}, addMaterial: function (e, t) {
                this._materials[e] = t
            }, getMaterial: function (e) {
                return this._materials[e]
            }
        }, W.DefaultImageId = "czm_defaultImage", W.DefaultCubeMapId = "czm_defaultCubeMap", W.ColorType = "Color", W._materialCache.addMaterial(W.ColorType, {
            fabric: {
                type: W.ColorType,
                uniforms: {color: new i(1, 0, 0, .5)},
                components: {diffuse: "color.rgb", alpha: "color.a"}
            }, translucent: function (e) {
                return e.uniforms.color.alpha < 1
            }
        }), W.ImageType = "Image", W._materialCache.addMaterial(W.ImageType, {
            fabric: {
                type: W.ImageType,
                uniforms: {image: W.DefaultImageId, repeat: new e(1, 1)},
                components: {
                    diffuse: "texture2D(image, fract(repeat * materialInput.st)).rgb",
                    alpha: "texture2D(image, fract(repeat * materialInput.st)).a"
                }
            }, translucent: !0
        }), W.DiffuseMapType = "DiffuseMap", W._materialCache.addMaterial(W.DiffuseMapType, {
            fabric: {
                type: W.DiffuseMapType,
                uniforms: {image: W.DefaultImageId, channels: "rgb", repeat: new e(1, 1)},
                components: {diffuse: "texture2D(image, fract(repeat * materialInput.st)).channels"}
            }, translucent: !1
        }), W.AlphaMapType = "AlphaMap", W._materialCache.addMaterial(W.AlphaMapType, {
            fabric: {
                type: W.AlphaMapType,
                uniforms: {image: W.DefaultImageId, channel: "a", repeat: new e(1, 1)},
                components: {alpha: "texture2D(image, fract(repeat * materialInput.st)).channel"}
            }, translucent: !0
        }), W.SpecularMapType = "SpecularMap", W._materialCache.addMaterial(W.SpecularMapType, {
            fabric: {
                type: W.SpecularMapType,
                uniforms: {image: W.DefaultImageId, channel: "r", repeat: new e(1, 1)},
                components: {specular: "texture2D(image, fract(repeat * materialInput.st)).channel"}
            }, translucent: !1
        }), W.EmissionMapType = "EmissionMap", W._materialCache.addMaterial(W.EmissionMapType, {
            fabric: {
                type: W.EmissionMapType,
                uniforms: {image: W.DefaultImageId, channels: "rgb", repeat: new e(1, 1)},
                components: {emission: "texture2D(image, fract(repeat * materialInput.st)).channels"}
            }, translucent: !1
        }), W.BumpMapType = "BumpMap", W._materialCache.addMaterial(W.BumpMapType, {
            fabric: {
                type: W.BumpMapType,
                uniforms: {image: W.DefaultImageId, channel: "r", strength: .8, repeat: new e(1, 1)},
                source: v
            }, translucent: !1
        }), W.NormalMapType = "NormalMap", W._materialCache.addMaterial(W.NormalMapType, {
            fabric: {
                type: W.NormalMapType,
                uniforms: {image: W.DefaultImageId, channels: "rgb", strength: .8, repeat: new e(1, 1)},
                source: S
            }, translucent: !1
        }), W.GridType = "Grid", W._materialCache.addMaterial(W.GridType, {
            fabric: {
                type: W.GridType,
                uniforms: {
                    color: new i(0, 1, 0, 1),
                    cellAlpha: .1,
                    lineCount: new e(8, 8),
                    lineThickness: new e(1, 1),
                    lineOffset: new e(0, 0)
                },
                source: E
            }, translucent: function (e) {
                var t = e.uniforms;
                return t.color.alpha < 1 || t.cellAlpha < 1
            }
        }), W.StripeType = "Stripe", W._materialCache.addMaterial(W.StripeType, {
            fabric: {
                type: W.StripeType,
                uniforms: {
                    horizontal: !0,
                    evenColor: new i(1, 1, 1, .5),
                    oddColor: new i(0, 0, 1, .5),
                    offset: 0,
                    repeat: 5
                },
                source: A
            }, translucent: function (e) {
                var t = e.uniforms;
                return t.evenColor.alpha < 1 || t.oddColor.alpha < 0
            }
        }), W.CheckerboardType = "Checkerboard", W._materialCache.addMaterial(W.CheckerboardType, {
            fabric: {
                type: W.CheckerboardType,
                uniforms: {lightColor: new i(1, 1, 1, .5), darkColor: new i(0, 0, 0, .5), repeat: new e(5, 5)},
                source: g
            }, translucent: function (e) {
                var t = e.uniforms;
                return t.lightColor.alpha < 1 || t.darkColor.alpha < 0
            }
        }), W.DotType = "Dot", W._materialCache.addMaterial(W.DotType, {
            fabric: {
                type: W.DotType,
                uniforms: {lightColor: new i(1, 1, 0, .75), darkColor: new i(0, 1, 1, .75), repeat: new e(5, 5)},
                source: y
            }, translucent: function (e) {
                var t = e.uniforms;
                return t.lightColor.alpha < 1 || t.darkColor.alpha < 0
            }
        }), W.WaterType = "Water", W._materialCache.addMaterial(W.WaterType, {
            fabric: {
                type: W.WaterType,
                uniforms: {
                    baseWaterColor: new i(.2, .3, .6, 1),
                    blendColor: new i(0, 1, .699, 1),
                    specularMap: W.DefaultImageId,
                    normalMap: W.DefaultImageId,
                    frequency: 10,
                    animationSpeed: .01,
                    amplitude: 1,
                    specularIntensity: .5,
                    fadeFactor: 1
                },
                source: P
            }, translucent: function (e) {
                var t = e.uniforms;
                return t.baseWaterColor.alpha < 1 || t.blendColor.alpha < 0
            }
        }), W.RimLightingType = "RimLighting", W._materialCache.addMaterial(W.RimLightingType, {
            fabric: {
                type: W.RimLightingType,
                uniforms: {color: new i(1, 0, 0, .7), rimColor: new i(1, 1, 1, .4), width: .3},
                source: x
            }, translucent: function (e) {
                var t = e.uniforms;
                return t.color.alpha < 1 || t.rimColor.alpha < 0
            }
        }), W.FadeType = "Fade", W._materialCache.addMaterial(W.FadeType, {
            fabric: {
                type: W.FadeType,
                uniforms: {
                    fadeInColor: new i(1, 0, 0, 1),
                    fadeOutColor: new i(0, 0, 0, 0),
                    maximumDistance: .5,
                    repeat: !0,
                    fadeDirection: {x: !0, y: !0},
                    time: new e(.5, .5)
                },
                source: C
            }, translucent: function (e) {
                var t = e.uniforms;
                return t.fadeInColor.alpha < 1 || t.fadeOutColor.alpha < 0
            }
        }), W.PolylineArrowType = "PolylineArrow", W._materialCache.addMaterial(W.PolylineArrowType, {
            fabric: {
                type: W.PolylineArrowType,
                uniforms: {color: new i(1, 1, 1, 1)},
                source: T
            }, translucent: !0
        }), W.PolylineGlowType = "PolylineGlow", W._materialCache.addMaterial(W.PolylineGlowType, {
            fabric: {
                type: W.PolylineGlowType,
                uniforms: {color: new i(0, .5, 1, 1), glowPower: .25},
                source: b
            }, translucent: !0
        }), W.PolylineOutlineType = "PolylineOutline", W._materialCache.addMaterial(W.PolylineOutlineType, {
            fabric: {
                type: W.PolylineOutlineType,
                uniforms: {color: new i(1, 1, 1, 1), outlineColor: new i(1, 0, 0, 1), outlineWidth: 1},
                source: w
            }, translucent: function (e) {
                var t = e.uniforms;
                return t.color.alpha < 1 || t.outlineColor.alpha < 1
            }
        }), W
    }),define("Cesium/Scene/MaterialAppearance", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/freezeObject", "../Core/VertexFormat", "../Shaders/Appearances/AllMaterialAppearanceFS", "../Shaders/Appearances/AllMaterialAppearanceVS", "../Shaders/Appearances/BasicMaterialAppearanceFS", "../Shaders/Appearances/BasicMaterialAppearanceVS", "../Shaders/Appearances/TexturedMaterialAppearanceFS", "../Shaders/Appearances/TexturedMaterialAppearanceVS", "./Appearance", "./Material"], function (e, t, i, n, r, o, a, s, u, l, c, h, d) {
        "use strict";
        var m = function (i) {
            i = e(i, e.EMPTY_OBJECT);
            var n = e(i.translucent, !0), r = e(i.closed, !1), o = e(i.materialSupport, m.MaterialSupport.TEXTURED);
            this.material = t(i.material) ? i.material : d.fromType(d.ColorType), this.translucent = n, this._vertexShaderSource = e(i.vertexShaderSource, o.vertexShaderSource), this._fragmentShaderSource = e(i.fragmentShaderSource, o.fragmentShaderSource), this._renderState = h.getDefaultRenderState(n, r, i.renderState), this._closed = r, this._materialSupport = o, this._vertexFormat = o.vertexFormat, this._flat = e(i.flat, !1), this._faceForward = e(i.faceForward, !r)
        };
        return i(m.prototype, {
            vertexShaderSource: {
                get: function () {
                    return this._vertexShaderSource
                }
            }, fragmentShaderSource: {
                get: function () {
                    return this._fragmentShaderSource
                }
            }, renderState: {
                get: function () {
                    return this._renderState
                }
            }, closed: {
                get: function () {
                    return this._closed
                }
            }, materialSupport: {
                get: function () {
                    return this._materialSupport
                }
            }, vertexFormat: {
                get: function () {
                    return this._vertexFormat
                }
            }, flat: {
                get: function () {
                    return this._flat
                }
            }, faceForward: {
                get: function () {
                    return this._faceForward
                }
            }
        }), m.prototype.getFragmentShaderSource = h.prototype.getFragmentShaderSource, m.prototype.isTranslucent = h.prototype.isTranslucent, m.prototype.getRenderState = h.prototype.getRenderState, m.MaterialSupport = {
            BASIC: n({
                vertexFormat: r.POSITION_AND_NORMAL,
                vertexShaderSource: u,
                fragmentShaderSource: s
            }),
            TEXTURED: n({vertexFormat: r.POSITION_NORMAL_AND_ST, vertexShaderSource: c, fragmentShaderSource: l}),
            ALL: n({vertexFormat: r.ALL, vertexShaderSource: a, fragmentShaderSource: o})
        }, m
    }),define("Cesium/DataSources/dynamicGeometryGetBoundingSphere", ["../Core/BoundingSphere", "../Core/defined", "../Core/DeveloperError", "./BoundingSphereState"], function (e, t, i, n) {
        "use strict";
        var r = function (i, r, o, a) {
            var s;
            return t(r) && r.show && r.ready && (s = r.getGeometryInstanceAttributes(i), t(s) && t(s.boundingSphere)) ? (e.transform(s.boundingSphere, r.modelMatrix, a), n.DONE) : t(o) && o.show && o.ready && (s = o.getGeometryInstanceAttributes(i), t(s) && t(s.boundingSphere)) ? (e.transform(s.boundingSphere, o.modelMatrix, a), n.DONE) : t(r) && !r.ready || t(o) && !o.ready ? n.PENDING : n.FAILED
        };
        return r
    }),define("Cesium/DataSources/MaterialProperty", ["../Core/Color", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Scene/Material"], function (e, t, i, n, r) {
        "use strict";
        var o = function () {
            n.throwInstantiationError()
        };
        return i(o.prototype, {
            isConstant: {get: n.throwInstantiationError},
            definitionChanged: {get: n.throwInstantiationError}
        }), o.prototype.getType = n.throwInstantiationError, o.prototype.getValue = n.throwInstantiationError, o.prototype.equals = n.throwInstantiationError, o.getValue = function (i, n, o) {
            var a;
            return t(n) && (a = n.getType(i), t(a)) ? (t(o) && o.type === a || (o = r.fromType(a)), n.getValue(i, o.uniforms), o) : (t(o) && o.type === r.ColorType || (o = r.fromType(r.ColorType)), e.clone(e.WHITE, o.uniforms.color), o)
        }, o
    }),define("Cesium/DataSources/BoxGeometryUpdater", ["../Core/BoxGeometry", "../Core/BoxOutlineGeometry", "../Core/Color", "../Core/ColorGeometryInstanceAttribute", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Event", "../Core/GeometryInstance", "../Core/Iso8601", "../Core/ShowGeometryInstanceAttribute", "../Scene/MaterialAppearance", "../Scene/PerInstanceColorAppearance", "../Scene/Primitive", "./ColorMaterialProperty", "./ConstantProperty", "./dynamicGeometryGetBoundingSphere", "./MaterialProperty", "./Property"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C) {
        "use strict";
        var E = new _(i.WHITE), S = new v(!0), T = new v(!0), b = new v(!1), w = new v(i.BLACK), x = new i, A = function (e) {
            this.id = e, this.vertexFormat = void 0, this.dimensions = void 0
        }, P = function (e, t) {
            this._entity = e, this._scene = t, this._entitySubscription = e.definitionChanged.addEventListener(P.prototype._onEntityPropertyChanged, this), this._fillEnabled = !1, this._dynamic = !1, this._outlineEnabled = !1, this._geometryChanged = new l, this._showProperty = void 0, this._materialProperty = void 0, this._hasConstantOutline = !0, this._showOutlineProperty = void 0, this._outlineColorProperty = void 0, this._outlineWidth = 1, this._options = new A(e), this._onEntityPropertyChanged(e, "box", e.box, void 0)
        };
        a(P, {
            perInstanceColorAppearanceType: {value: p},
            materialAppearanceType: {value: m}
        }), a(P.prototype, {
            entity: {
                get: function () {
                    return this._entity
                }
            }, fillEnabled: {
                get: function () {
                    return this._fillEnabled
                }
            }, hasConstantFill: {
                get: function () {
                    return !this._fillEnabled || !o(this._entity.availability) && C.isConstant(this._showProperty) && C.isConstant(this._fillProperty)
                }
            }, fillMaterialProperty: {
                get: function () {
                    return this._materialProperty
                }
            }, outlineEnabled: {
                get: function () {
                    return this._outlineEnabled
                }
            }, hasConstantOutline: {
                get: function () {
                    return !this._outlineEnabled || !o(this._entity.availability) && C.isConstant(this._showProperty) && C.isConstant(this._showOutlineProperty)
                }
            }, outlineColorProperty: {
                get: function () {
                    return this._outlineColorProperty
                }
            }, outlineWidth: {
                get: function () {
                    return this._outlineWidth
                }
            }, isDynamic: {
                get: function () {
                    return this._dynamic
                }
            }, isClosed: {value: !0}, geometryChanged: {
                get: function () {
                    return this._geometryChanged
                }
            }
        }), P.prototype.isOutlineVisible = function (e) {
            var t = this._entity;
            return this._outlineEnabled && t.isAvailable(e) && this._showProperty.getValue(e) && this._showOutlineProperty.getValue(e)
        }, P.prototype.isFilled = function (e) {
            var t = this._entity;
            return this._fillEnabled && t.isAvailable(e) && this._showProperty.getValue(e) && this._fillProperty.getValue(e)
        }, P.prototype.createFillGeometryInstance = function (t) {
            var r, a, s = this._entity, u = s.isAvailable(t), l = new d(u && s.isShowing && this._showProperty.getValue(t) && this._fillProperty.getValue(t));
            if (this._materialProperty instanceof _) {
                var m = i.WHITE;
                o(this._materialProperty.color) && (this._materialProperty.color.isConstant || u) && (m = this._materialProperty.color.getValue(t)), a = n.fromColor(m), r = {
                    show: l,
                    color: a
                }
            } else r = {show: l};
            return new c({
                id: s,
                geometry: e.fromDimensions(this._options),
                modelMatrix: s._getModelMatrix(h.MINIMUM_VALUE),
                attributes: r
            })
        }, P.prototype.createOutlineGeometryInstance = function (e) {
            var r = this._entity, o = r.isAvailable(e), a = C.getValueOrDefault(this._outlineColorProperty, e, i.BLACK);
            return new c({
                id: r,
                geometry: t.fromDimensions(this._options),
                modelMatrix: r._getModelMatrix(h.MINIMUM_VALUE),
                attributes: {
                    show: new d(o && r.isShowing && this._showProperty.getValue(e) && this._showOutlineProperty.getValue(e)),
                    color: n.fromColor(a)
                }
            })
        }, P.prototype.isDestroyed = function () {
            return !1
        }, P.prototype.destroy = function () {
            this._entitySubscription(), s(this)
        }, P.prototype._onEntityPropertyChanged = function (e, t, i, n) {
            if ("availability" === t || "position" === t || "orientation" === t || "box" === t) {
                var a = this._entity.box;
                if (!o(a))return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var s = a.fill, u = o(s) && s.isConstant ? s.getValue(h.MINIMUM_VALUE) : !0, l = a.outline, c = o(l);
                if (c && l.isConstant && (c = l.getValue(h.MINIMUM_VALUE)), !u && !c)return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var d = a.dimensions, f = e.position, v = a.show;
                if (!o(d) || !o(f) || o(v) && v.isConstant && !v.getValue(h.MINIMUM_VALUE))return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var g = r(a.material, E), y = g instanceof _;
                this._materialProperty = g, this._fillProperty = r(s, T), this._showProperty = r(v, S), this._showOutlineProperty = r(a.outline, b), this._outlineColorProperty = c ? r(a.outlineColor, w) : void 0;
                var x = a.outlineWidth;
                if (this._fillEnabled = u, this._outlineEnabled = c, f.isConstant && C.isConstant(e.orientation) && d.isConstant && C.isConstant(x)) {
                    var A = this._options;
                    A.vertexFormat = y ? p.VERTEX_FORMAT : m.MaterialSupport.TEXTURED.vertexFormat, A.dimensions = d.getValue(h.MINIMUM_VALUE, A.dimensions), this._outlineWidth = o(x) ? x.getValue(h.MINIMUM_VALUE) : 1, this._dynamic = !1, this._geometryChanged.raiseEvent(this)
                } else this._dynamic || (this._dynamic = !0, this._geometryChanged.raiseEvent(this))
            }
        }, P.prototype.createDynamicUpdater = function (e) {
            return new I(e, this)
        };
        var I = function (e, t) {
            this._primitives = e, this._primitive = void 0, this._outlinePrimitive = void 0, this._geometryUpdater = t, this._options = new A(t._entity)
        };
        return I.prototype.update = function (r) {
            var a = this._primitives;
            a.removeAndDestroy(this._primitive), a.removeAndDestroy(this._outlinePrimitive), this._primitive = void 0, this._outlinePrimitive = void 0;
            var s = this._geometryUpdater, u = s._entity, l = u.box;
            if (u.isShowing && u.isAvailable(r) && C.getValueOrDefault(l.show, r, !0)) {
                var h = this._options, d = u._getModelMatrix(r), _ = C.getValueOrUndefined(l.dimensions, r, h.dimensions);
                if (o(d) && o(_)) {
                    if (h.dimensions = _, C.getValueOrDefault(l.fill, r, !0)) {
                        var v = y.getValue(r, s.fillMaterialProperty, this._material);
                        this._material = v;
                        var g = new m({material: v, translucent: v.isTranslucent(), closed: !0});
                        h.vertexFormat = g.vertexFormat, this._primitive = a.add(new f({
                            geometryInstances: new c({
                                id: u,
                                geometry: e.fromDimensions(h),
                                modelMatrix: d
                            }), appearance: g, asynchronous: !1
                        }))
                    }
                    if (C.getValueOrDefault(l.outline, r, !1)) {
                        h.vertexFormat = p.VERTEX_FORMAT;
                        var E = C.getValueOrClonedDefault(l.outlineColor, r, i.BLACK, x), S = C.getValueOrDefault(l.outlineWidth, r, 1), T = 1 !== E.alpha;
                        this._outlinePrimitive = a.add(new f({
                            geometryInstances: new c({
                                id: u,
                                geometry: t.fromDimensions(h),
                                modelMatrix: d,
                                attributes: {color: n.fromColor(E)}
                            }),
                            appearance: new p({
                                flat: !0,
                                translucent: T,
                                renderState: {lineWidth: s._scene.clampLineWidth(S)}
                            }),
                            asynchronous: !1
                        }))
                    }
                }
            }
        }, I.prototype.getBoundingSphere = function (e, t) {
            return g(e, this._primitive, this._outlinePrimitive, t)
        }, I.prototype.isDestroyed = function () {
            return !1
        }, I.prototype.destroy = function () {
            var e = this._primitives;
            e.removeAndDestroy(this._primitive), e.removeAndDestroy(this._outlinePrimitive), s(this)
        }, P
    }),define("Cesium/Core/CornerType", ["./freezeObject"], function (e) {
        "use strict";
        var t = {ROUNDED: 0, MITERED: 1, BEVELED: 2};
        return e(t)
    }),define("Cesium/Core/PolylineVolumeGeometryLibrary", ["./Cartesian2", "./Cartesian3", "./Cartesian4", "./Cartographic", "./CornerType", "./EllipsoidTangentPlane", "./Math", "./Matrix3", "./Matrix4", "./PolylinePipeline", "./Quaternion", "./Transforms"], function (e, t, i, n, r, o, a, s, u, l, c, h) {
        "use strict";
        function d(e, t) {
            for (var i = new Array(e.length), n = 0; n < e.length; n++) {
                var r = e[n];
                N = t.cartesianToCartographic(r, N), i[n] = N.height, e[n] = t.scaleToGeodeticSurface(r, r)
            }
            return i
        }

        function m(e, i, n, r) {
            var o, a = e[0], s = e[1], u = t.angleBetween(a, s), l = Math.ceil(u / r), c = new Array(l);
            if (i === n) {
                for (o = 0; l > o; o++)c[o] = i;
                return c.push(n), c
            }
            var h = n - i, d = h / l;
            for (o = 1; l > o; o++) {
                var m = i + o * d;
                c[o] = m
            }
            return c[0] = i, c.push(n), c
        }

        function p(i, n, r, a) {
            var s = new o(r, a), u = s.projectPointOntoPlane(t.add(r, i, Y), Y), l = s.projectPointOntoPlane(t.add(r, n, X), X), c = e.angleBetween(u, l);
            return l.x * u.y - l.y * u.x >= 0 ? -c : c
        }

        function f(e, i, n, r, o, a, l, c) {
            var d = U, m = k;
            F = h.eastNorthUpToFixedFrame(e, o, F), d = u.multiplyByPointAsVector(F, L, d), d = t.normalize(d, d);
            var f = p(d, i, e, o);
            z = s.fromRotationZ(f, z), G.z = a, F = u.multiplyTransformation(F, u.fromRotationTranslation(z, G, B), F);
            var _ = V;
            _[0] = l;
            for (var v = 0; c > v; v++)for (var g = 0; g < n.length; g += 3)m = t.fromArray(n, g, m), m = s.multiplyByVector(_, m, m), m = u.multiplyByPoint(F, m, m), r.push(m.x, m.y, m.z);
            return r
        }

        function _(e, i, n, r, o, a, s) {
            for (var u = 0; u < e.length; u += 3) {
                var l = t.fromArray(e, u, H);
                r = f(l, i, n, r, o, a[u / 3], s, 1)
            }
            return r
        }

        function v(e, t) {
            var i = e.length, n = new Array(6 * i), r = 0, o = t.x + t.width / 2, a = t.y + t.height / 2, s = e[0];
            n[r++] = s.x - o, n[r++] = 0, n[r++] = s.y - a;
            for (var u = 1; i > u; u++) {
                s = e[u];
                var l = s.x - o, c = s.y - a;
                n[r++] = l, n[r++] = 0, n[r++] = c, n[r++] = l, n[r++] = 0, n[r++] = c
            }
            return s = e[0], n[r++] = s.x - o, n[r++] = 0, n[r++] = s.y - a, n
        }

        function g(e, t) {
            for (var i = e.length, n = new Array(3 * i), r = 0, o = t.x + t.width / 2, a = t.y + t.height / 2, s = 0; i > s; s++)n[r++] = e[s].x - o, n[r++] = 0, n[r++] = e[s].y - a;
            return n
        }

        function y(e, i, n, o, u, l, h, d, m, p) {
            var _, v = t.angleBetween(t.subtract(i, e, M), t.subtract(n, e, O)), g = o === r.BEVELED ? 0 : Math.ceil(v / a.toRadians(5));
            _ = u ? s.fromQuaternion(c.fromAxisAngle(t.negate(e, M), v / (g + 1), W), j) : s.fromQuaternion(c.fromAxisAngle(e, v / (g + 1), W), j);
            var y, C;
            if (i = t.clone(i, q), g > 0)for (var E = p ? 2 : 1, S = 0; g > S; S++)i = s.multiplyByVector(_, i, i), y = t.subtract(i, e, M), y = t.normalize(y, y), u || (y = t.negate(y, y)), C = l.scaleToGeodeticSurface(i, O), h = f(C, y, d, h, l, m, 1, E); else y = t.subtract(i, e, M), y = t.normalize(y, y), u || (y = t.negate(y, y)), C = l.scaleToGeodeticSurface(i, O), h = f(C, y, d, h, l, m, 1, 1), n = t.clone(n, q), y = t.subtract(n, e, M), y = t.normalize(y, y), u || (y = t.negate(y, y)), C = l.scaleToGeodeticSurface(n, O), h = f(C, y, d, h, l, m, 1, 1);
            return h
        }

        function C(e, t) {
            return a.equalsEpsilon(e.latitude, t.latitude, a.EPSILON6) && a.equalsEpsilon(e.longitude, t.longitude, a.EPSILON6)
        }

        var E = [new t, new t], S = new t, T = new t, b = new t, w = new t, x = new t, A = new t, P = new t, I = new t, D = new t, M = new t, O = new t, R = {}, N = new n, L = new t(-1, 0, 0), F = new u, B = new u, z = new s, V = s.IDENTITY.clone(), U = new t, k = new i, G = new t, H = new t, W = new c, q = new t, j = new s;
        R.removeDuplicatesFromShape = function (t) {
            for (var i = t.length, n = [], r = i - 1, o = 0; i > o; r = o++) {
                var a = t[r], s = t[o];
                e.equals(a, s) || n.push(s)
            }
            return n
        };
        var Y = new t, X = new t;
        R.angleIsGreaterThanPi = function (e, i, n, r) {
            var a = new o(n, r), s = a.projectPointOntoPlane(t.add(n, e, Y), Y), u = a.projectPointOntoPlane(t.add(n, i, X), X);
            return u.x * s.y - u.y * s.x >= 0
        };
        var Z = new n, K = new n;
        R.removeDuplicatesFromPositions = function (e, t) {
            var i = e.length;
            if (2 > i)return e.slice(0);
            var n = [];
            n.push(e[0]);
            for (var r = 1; i > r; ++r) {
                var o = e[r - 1], a = e[r], s = t.cartesianToCartographic(o, Z), u = t.cartesianToCartographic(a, K);
                C(s, u) || n.push(a)
            }
            return n
        };
        var J = new t, Q = new t;
        return R.computePositions = function (e, i, n, o, s) {
            var u = o._ellipsoid, c = d(e, u), h = o._granularity, p = o._cornerType, C = s ? v(i, n) : g(i, n), O = s ? g(i, n) : void 0, N = n.height / 2, L = n.width / 2, F = e.length, B = [], z = s ? [] : void 0, V = S, U = T, k = b, G = w, H = x, W = A, q = P, j = I, Y = D, X = e[0], Z = e[1];
            G = u.geodeticSurfaceNormal(X, G), V = t.subtract(Z, X, V), V = t.normalize(V, V), j = t.cross(G, V, j), j = t.normalize(j, j);
            var K = c[0], $ = c[1];
            s && (z = f(X, j, O, z, u, K + N, 1, 1)), Y = t.clone(X, Y), X = Z, U = t.negate(V, U);
            for (var ee, te, ie = 1; F - 1 > ie; ie++) {
                var ne = s ? 2 : 1;
                Z = e[ie + 1], V = t.subtract(Z, X, V), V = t.normalize(V, V), k = t.add(V, U, k), k = t.normalize(k, k), G = u.geodeticSurfaceNormal(X, G);
                var re = t.multiplyByScalar(G, t.dot(V, G), J);
                t.subtract(V, re, re), t.normalize(re, re);
                var oe = t.multiplyByScalar(G, t.dot(U, G), Q);
                t.subtract(U, oe, oe), t.normalize(oe, oe);
                var ae = !a.equalsEpsilon(Math.abs(t.dot(re, oe)), 1, a.EPSILON7);
                if (ae) {
                    k = t.cross(k, G, k), k = t.cross(G, k, k), k = t.normalize(k, k);
                    var se = 1 / Math.max(.25, t.magnitude(t.cross(k, U, M))), ue = R.angleIsGreaterThanPi(V, U, X, u);
                    ue ? (H = t.add(X, t.multiplyByScalar(k, se * L, k), H), W = t.add(H, t.multiplyByScalar(j, L, W), W), E[0] = t.clone(Y, E[0]), E[1] = t.clone(W, E[1]), ee = m(E, K + N, $ + N, h), te = l.generateArc({
                        positions: E,
                        granularity: h,
                        ellipsoid: u
                    }), B = _(te, j, C, B, u, ee, 1), j = t.cross(G, V, j), j = t.normalize(j, j), q = t.add(H, t.multiplyByScalar(j, L, q), q), p === r.ROUNDED || p === r.BEVELED ? y(H, W, q, p, ue, u, B, C, $ + N, s) : (k = t.negate(k, k), B = f(X, k, C, B, u, $ + N, se, ne)), Y = t.clone(q, Y)) : (H = t.add(X, t.multiplyByScalar(k, se * L, k), H), W = t.add(H, t.multiplyByScalar(j, -L, W), W), E[0] = t.clone(Y, E[0]), E[1] = t.clone(W, E[1]), ee = m(E, K + N, $ + N, h), te = l.generateArc({
                        positions: E,
                        granularity: h,
                        ellipsoid: u
                    }), B = _(te, j, C, B, u, ee, 1), j = t.cross(G, V, j), j = t.normalize(j, j), q = t.add(H, t.multiplyByScalar(j, -L, q), q), p === r.ROUNDED || p === r.BEVELED ? y(H, W, q, p, ue, u, B, C, $ + N, s) : B = f(X, k, C, B, u, $ + N, se, ne), Y = t.clone(q, Y)), U = t.negate(V, U)
                } else B = f(Y, j, C, B, u, K + N, 1, 1), Y = X;
                K = $, $ = c[ie + 1], X = Z
            }
            E[0] = t.clone(Y, E[0]), E[1] = t.clone(X, E[1]), ee = m(E, K + N, $ + N, h), te = l.generateArc({
                positions: E,
                granularity: h,
                ellipsoid: u
            }), B = _(te, j, C, B, u, ee, 1), s && (z = f(X, j, O, z, u, $ + N, 1, 1)), F = B.length;
            var le = s ? F + z.length : F, ce = new Float64Array(le);
            return ce.set(B), s && ce.set(z, F), ce
        }, R
    }),define("Cesium/Core/CorridorGeometryLibrary", ["./Cartesian3", "./CornerType", "./defined", "./isArray", "./Math", "./Matrix3", "./PolylinePipeline", "./PolylineVolumeGeometryLibrary", "./Quaternion"], function (e, t, i, n, r, o, a, s, u) {
        "use strict";
        function l(i, n, a, s, l) {
            var c = e.angleBetween(e.subtract(n, i, f), e.subtract(a, i, _)), h = s === t.BEVELED ? 1 : Math.ceil(c / r.toRadians(5)) + 1, d = 3 * h, m = new Array(d);
            m[d - 3] = a.x, m[d - 2] = a.y, m[d - 1] = a.z;
            var p;
            p = l ? o.fromQuaternion(u.fromAxisAngle(e.negate(i, f), c / h, D), M) : o.fromQuaternion(u.fromAxisAngle(i, c / h, D), M);
            var v = 0;
            n = e.clone(n, f);
            for (var g = 0; h > g; g++)n = o.multiplyByVector(p, n, n), m[v++] = n.x, m[v++] = n.y, m[v++] = n.z;
            return m
        }

        function c(i) {
            var n = C, r = E, o = S, a = i[1];
            r = e.fromArray(i[1], a.length - 3, r), o = e.fromArray(i[0], 0, o), n = e.multiplyByScalar(e.add(r, o, n), .5, n);
            var s = l(n, r, o, t.ROUNDED, !1), u = i.length - 1, c = i[u - 1];
            a = i[u], r = e.fromArray(c, c.length - 3, r), o = e.fromArray(a, 0, o), n = e.multiplyByScalar(e.add(r, o, n), .5, n);
            var h = l(n, r, o, t.ROUNDED, !1);
            return [s, h]
        }

        function h(t, i, n, r) {
            var o = f;
            return r ? o = e.add(t, i, o) : (i = e.negate(i, i), o = e.add(t, i, o)), [o.x, o.y, o.z, n.x, n.y, n.z]
        }

        function d(t, i, n, r) {
            for (var o = new Array(t.length), a = new Array(t.length), s = e.multiplyByScalar(i, n, f), u = e.negate(s, _), l = 0, c = t.length - 1, h = 0; h < t.length; h += 3) {
                var d = e.fromArray(t, h, v), m = e.add(d, u, g);
                o[l++] = m.x, o[l++] = m.y, o[l++] = m.z;
                var p = e.add(d, s, g);
                a[c--] = p.z, a[c--] = p.y, a[c--] = p.x
            }
            return r.push(o, a), r
        }

        function m(e, t) {
            for (var i = 0; i < e.length; i++)e[i] = t.scaleToGeodeticSurface(e[i], e[i]);
            return e
        }

        var p = {}, f = new e, _ = new e, v = new e, g = new e, y = [new e, new e], C = new e, E = new e, S = new e, T = new e, b = new e, w = new e, x = new e, A = new e, P = new e, I = new e, D = new u, M = new o;
        p.addAttribute = function (e, t, n, r) {
            var o = t.x, a = t.y, s = t.z;
            i(n) && (e[n] = o, e[n + 1] = a, e[n + 2] = s), i(r) && (e[r] = s, e[r - 1] = a, e[r - 2] = o)
        };
        var O = new e, R = new e;
        p.computePositions = function (i) {
            var n = i.granularity, o = i.positions, u = i.ellipsoid;
            o = m(o, u);
            var p = i.width / 2, _ = i.cornerType, v = i.saveAttributes, g = C, D = E, M = S, N = T, L = b, F = w, B = x, z = A, V = P, U = I, k = [], G = v ? [] : void 0, H = v ? [] : void 0, W = o[0], q = o[1];
            D = e.normalize(e.subtract(q, W, D), D), g = u.geodeticSurfaceNormal(W, g), N = e.normalize(e.cross(g, D, N), N), v && (G.push(N.x, N.y, N.z), H.push(g.x, g.y, g.z)), B = e.clone(W, B), W = q, M = e.negate(D, M);
            var j, Y, X = [], Z = o.length;
            for (Y = 1; Z - 1 > Y; Y++) {
                g = u.geodeticSurfaceNormal(W, g), q = o[Y + 1], D = e.normalize(e.subtract(q, W, D), D), L = e.normalize(e.add(D, M, L), L);
                var K = e.multiplyByScalar(g, e.dot(D, g), O);
                e.subtract(D, K, K), e.normalize(K, K);
                var J = e.multiplyByScalar(g, e.dot(M, g), R);
                e.subtract(M, J, J), e.normalize(J, J);
                var Q = !r.equalsEpsilon(Math.abs(e.dot(K, J)), 1, r.EPSILON7);
                if (Q) {
                    L = e.cross(L, g, L), L = e.cross(g, L, L);
                    var $ = p / Math.max(.25, e.magnitude(e.cross(L, M, f))), ee = s.angleIsGreaterThanPi(D, M, W, u);
                    L = e.multiplyByScalar(L, $, L), ee ? (z = e.add(W, L, z), U = e.add(z, e.multiplyByScalar(N, p, U), U), V = e.add(z, e.multiplyByScalar(N, 2 * p, V), V), y[0] = e.clone(B, y[0]), y[1] = e.clone(U, y[1]), j = a.generateArc({
                        positions: y,
                        granularity: n,
                        ellipsoid: u
                    }), k = d(j, N, p, k), v && (G.push(N.x, N.y, N.z), H.push(g.x, g.y, g.z)), F = e.clone(V, F), N = e.normalize(e.cross(g, D, N), N), V = e.add(z, e.multiplyByScalar(N, 2 * p, V), V), B = e.add(z, e.multiplyByScalar(N, p, B), B), _ === t.ROUNDED || _ === t.BEVELED ? X.push({leftPositions: l(z, F, V, _, ee)}) : X.push({leftPositions: h(W, e.negate(L, L), V, ee)})) : (V = e.add(W, L, V), U = e.add(V, e.negate(e.multiplyByScalar(N, p, U), U), U), z = e.add(V, e.negate(e.multiplyByScalar(N, 2 * p, z), z), z), y[0] = e.clone(B, y[0]), y[1] = e.clone(U, y[1]), j = a.generateArc({
                        positions: y,
                        granularity: n,
                        ellipsoid: u
                    }), k = d(j, N, p, k), v && (G.push(N.x, N.y, N.z), H.push(g.x, g.y, g.z)), F = e.clone(z, F), N = e.normalize(e.cross(g, D, N), N), z = e.add(V, e.negate(e.multiplyByScalar(N, 2 * p, z), z), z), B = e.add(V, e.negate(e.multiplyByScalar(N, p, B), B), B), _ === t.ROUNDED || _ === t.BEVELED ? X.push({rightPositions: l(V, F, z, _, ee)}) : X.push({rightPositions: h(W, L, z, ee)})), M = e.negate(D, M)
                }
                W = q
            }
            g = u.geodeticSurfaceNormal(W, g), y[0] = e.clone(B, y[0]), y[1] = e.clone(W, y[1]), j = a.generateArc({
                positions: y,
                granularity: n,
                ellipsoid: u
            }), k = d(j, N, p, k), v && (G.push(N.x, N.y, N.z), H.push(g.x, g.y, g.z));
            var te;
            return _ === t.ROUNDED && (te = c(k)), {positions: k, corners: X, lefts: G, normals: H, endPositions: te}
        };
        var N = new e, L = new e;
        return p.scaleToGeodeticHeight = function (t, i, r, o) {
            var a = t.length, s = n(o) ? o : new Array(t.length);
            s.length = t.length;
            for (var u = i, l = 0; a > l; l += 3) {
                var c = r.scaleToGeodeticSurface(e.fromArray(t, l, L), L), h = N;
                0 !== i && (h = r.geodeticSurfaceNormal(c, h), h = e.multiplyByScalar(h, u, h), c = e.add(c, h, c)), s[l] = c.x, s[l + 1] = c.y, s[l + 2] = c.z
            }
            return s
        }, p
    }),define("Cesium/Core/CorridorGeometry", ["./BoundingSphere", "./Cartesian3", "./ComponentDatatype", "./CornerType", "./CorridorGeometryLibrary", "./defaultValue", "./defined", "./DeveloperError", "./Ellipsoid", "./Geometry", "./GeometryAttribute", "./GeometryAttributes", "./IndexDatatype", "./Math", "./PolylinePipeline", "./PrimitiveType", "./VertexFormat"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _) {
        "use strict";
        function v(e, i, n, o, a, s) {
            var u = e.normals, l = e.tangents, c = e.binormals, h = t.normalize(t.cross(n, i, P), P);
            s.normal && r.addAttribute(u, i, o, a), s.binormal && r.addAttribute(c, n, o, a), s.tangent && r.addAttribute(l, h, o, a)
        }

        function g(e, n, o) {
            var s, u, l, p = e.positions, f = e.corners, _ = e.endPositions, g = e.lefts, y = e.normals, C = new h, E = 0, x = 0, D = 0;
            for (u = 0; u < p.length; u += 2)l = p[u].length - 3, E += l, D += 2 * l, x += p[u + 1].length - 3;
            for (E += 3, x += 3, u = 0; u < f.length; u++) {
                s = f[u];
                var M = f[u].leftPositions;
                a(M) ? (l = M.length, E += l, D += l) : (l = f[u].rightPositions.length, x += l, D += l)
            }
            var O, R = a(_);
            R && (O = _[0].length - 3, E += O, x += O, O /= 3, D += 6 * O);
            var N, L, F, B, z, V, U = E + x, k = new Float64Array(U), G = n.normal ? new Float32Array(U) : void 0, H = n.tangent ? new Float32Array(U) : void 0, W = n.binormal ? new Float32Array(U) : void 0, q = {
                normals: G,
                tangents: H,
                binormals: W
            }, j = 0, Y = U - 1, X = S, Z = T, K = O / 2, J = d.createTypedArray(U / 3, D), Q = 0;
            if (R) {
                V = b, z = w;
                var $ = _[0];
                for (X = t.fromArray(y, 0, X), Z = t.fromArray(g, 0, Z), u = 0; K > u; u++)V = t.fromArray($, 3 * (K - 1 - u), V), z = t.fromArray($, 3 * (K + u), z), r.addAttribute(k, z, j), r.addAttribute(k, V, void 0, Y), v(q, X, Z, j, Y, n), L = j / 3, B = L + 1, N = (Y - 2) / 3, F = N - 1, J[Q++] = N, J[Q++] = L, J[Q++] = F, J[Q++] = F, J[Q++] = L, J[Q++] = B, j += 3, Y -= 3
            }
            var ee = 0, te = 0, ie = p[ee++], ne = p[ee++];
            k.set(ie, j), k.set(ne, Y - ne.length + 1), Z = t.fromArray(g, te, Z);
            var re, oe;
            for (l = ne.length - 3, u = 0; l > u; u += 3)re = o.geodeticSurfaceNormal(t.fromArray(ie, u, P), P), oe = o.geodeticSurfaceNormal(t.fromArray(ne, l - u, I), I), X = t.normalize(t.add(re, oe, X), X), v(q, X, Z, j, Y, n), L = j / 3, B = L + 1, N = (Y - 2) / 3, F = N - 1, J[Q++] = N, J[Q++] = L, J[Q++] = F, J[Q++] = F, J[Q++] = L, J[Q++] = B, j += 3, Y -= 3;
            for (re = o.geodeticSurfaceNormal(t.fromArray(ie, l, P), P), oe = o.geodeticSurfaceNormal(t.fromArray(ne, l, I), I), X = t.normalize(t.add(re, oe, X), X), te += 3, u = 0; u < f.length; u++) {
                var ae;
                s = f[u];
                var se, ue, le = s.leftPositions, ce = s.rightPositions, he = A, de = b, me = w;
                if (X = t.fromArray(y, te, X), a(le)) {
                    for (v(q, X, Z, void 0, Y, n), Y -= 3, se = B, ue = F, ae = 0; ae < le.length / 3; ae++)he = t.fromArray(le, 3 * ae, he), J[Q++] = se, J[Q++] = ue - ae - 1, J[Q++] = ue - ae, r.addAttribute(k, he, void 0, Y), de = t.fromArray(k, 3 * (ue - ae - 1), de), me = t.fromArray(k, 3 * se, me), Z = t.normalize(t.subtract(de, me, Z), Z), v(q, X, Z, void 0, Y, n), Y -= 3;
                    he = t.fromArray(k, 3 * se, he), de = t.subtract(t.fromArray(k, 3 * ue, de), he, de), me = t.subtract(t.fromArray(k, 3 * (ue - ae), me), he, me), Z = t.normalize(t.add(de, me, Z), Z), v(q, X, Z, j, void 0, n), j += 3
                } else {
                    for (v(q, X, Z, j, void 0, n), j += 3, se = F, ue = B, ae = 0; ae < ce.length / 3; ae++)he = t.fromArray(ce, 3 * ae, he), J[Q++] = se, J[Q++] = ue + ae, J[Q++] = ue + ae + 1, r.addAttribute(k, he, j), de = t.fromArray(k, 3 * se, de), me = t.fromArray(k, 3 * (ue + ae), me), Z = t.normalize(t.subtract(de, me, Z), Z), v(q, X, Z, j, void 0, n), j += 3;
                    he = t.fromArray(k, 3 * se, he), de = t.subtract(t.fromArray(k, 3 * (ue + ae), de), he, de), me = t.subtract(t.fromArray(k, 3 * ue, me), he, me), Z = t.normalize(t.negate(t.add(me, de, Z), Z), Z), v(q, X, Z, void 0, Y, n), Y -= 3
                }
                for (ie = p[ee++], ne = p[ee++], ie.splice(0, 3), ne.splice(ne.length - 3, 3), k.set(ie, j), k.set(ne, Y - ne.length + 1), l = ne.length - 3, te += 3, Z = t.fromArray(g, te, Z), ae = 0; ae < ne.length; ae += 3)re = o.geodeticSurfaceNormal(t.fromArray(ie, ae, P), P), oe = o.geodeticSurfaceNormal(t.fromArray(ne, l - ae, I), I), X = t.normalize(t.add(re, oe, X), X), v(q, X, Z, j, Y, n), B = j / 3, L = B - 1, F = (Y - 2) / 3, N = F + 1, J[Q++] = N, J[Q++] = L, J[Q++] = F, J[Q++] = F, J[Q++] = L, J[Q++] = B, j += 3, Y -= 3;
                j -= 3, Y += 3
            }
            if (X = t.fromArray(y, y.length - 3, X), v(q, X, Z, j, Y, n), R) {
                j += 3, Y -= 3, V = b, z = w;
                var pe = _[1];
                for (u = 0; K > u; u++)V = t.fromArray(pe, 3 * (O - u - 1), V), z = t.fromArray(pe, 3 * u, z), r.addAttribute(k, V, void 0, Y), r.addAttribute(k, z, j), v(q, X, Z, j, Y, n), B = j / 3, L = B - 1, F = (Y - 2) / 3, N = F + 1, J[Q++] = N, J[Q++] = L, J[Q++] = F, J[Q++] = F, J[Q++] = L, J[Q++] = B, j += 3, Y -= 3
            }
            if (C.position = new c({componentDatatype: i.DOUBLE, componentsPerAttribute: 3, values: k}), n.st) {
                var fe, _e, ve = new Float32Array(U / 3 * 2), ge = 0;
                if (R) {
                    E /= 3, x /= 3;
                    var ye = Math.PI / (O + 1);
                    _e = 1 / (E - O + 1), fe = 1 / (x - O + 1);
                    var Ce, Ee = O / 2;
                    for (u = Ee + 1; O + 1 > u; u++)Ce = m.PI_OVER_TWO + ye * u, ve[ge++] = fe * (1 + Math.cos(Ce)), ve[ge++] = .5 * (1 + Math.sin(Ce));
                    for (u = 1; x - O + 1 > u; u++)ve[ge++] = u * fe, ve[ge++] = 0;
                    for (u = O; u > Ee; u--)Ce = m.PI_OVER_TWO - u * ye, ve[ge++] = 1 - fe * (1 + Math.cos(Ce)), ve[ge++] = .5 * (1 + Math.sin(Ce));
                    for (u = Ee; u > 0; u--)Ce = m.PI_OVER_TWO - ye * u, ve[ge++] = 1 - _e * (1 + Math.cos(Ce)), ve[ge++] = .5 * (1 + Math.sin(Ce));
                    for (u = E - O; u > 0; u--)ve[ge++] = u * _e, ve[ge++] = 1;
                    for (u = 1; Ee + 1 > u; u++)Ce = m.PI_OVER_TWO + ye * u, ve[ge++] = _e * (1 + Math.cos(Ce)), ve[ge++] = .5 * (1 + Math.sin(Ce))
                } else {
                    for (E /= 3, x /= 3, _e = 1 / (E - 1), fe = 1 / (x - 1), u = 0; x > u; u++)ve[ge++] = u * fe, ve[ge++] = 0;
                    for (u = E; u > 0; u--)ve[ge++] = (u - 1) * _e, ve[ge++] = 1
                }
                C.st = new c({componentDatatype: i.FLOAT, componentsPerAttribute: 2, values: ve})
            }
            return n.normal && (C.normal = new c({
                componentDatatype: i.FLOAT,
                componentsPerAttribute: 3,
                values: q.normals
            })), n.tangent && (C.tangent = new c({
                componentDatatype: i.FLOAT,
                componentsPerAttribute: 3,
                values: q.tangents
            })), n.binormal && (C.binormal = new c({
                componentDatatype: i.FLOAT,
                componentsPerAttribute: 3,
                values: q.binormals
            })), {attributes: C, indices: J}
        }

        function y(e, i) {
            if (!(i.normal || i.binormal || i.tangent || i.st))return e;
            var n, o, a = e.position.values;
            (i.normal || i.binormal) && (n = e.normal.values, o = e.binormal.values);
            var s, u = e.position.values.length / 18, l = 3 * u, c = 2 * u, h = 2 * l;
            if (i.normal || i.binormal || i.tangent) {
                var d = i.normal ? new Float32Array(6 * l) : void 0, m = i.binormal ? new Float32Array(6 * l) : void 0, p = i.tangent ? new Float32Array(6 * l) : void 0, f = S, _ = T, v = b, g = w, y = x, C = A, E = h;
                for (s = 0; l > s; s += 3) {
                    var P = E + h;
                    f = t.fromArray(a, s, f), _ = t.fromArray(a, s + l, _), v = t.fromArray(a, (s + 3) % l, v), _ = t.subtract(_, f, _), v = t.subtract(v, f, v), g = t.normalize(t.cross(_, v, g), g), i.normal && (r.addAttribute(d, g, P), r.addAttribute(d, g, P + 3), r.addAttribute(d, g, E), r.addAttribute(d, g, E + 3)), (i.tangent || i.binormal) && (C = t.fromArray(n, s, C), i.binormal && (r.addAttribute(m, C, P), r.addAttribute(m, C, P + 3), r.addAttribute(m, C, E), r.addAttribute(m, C, E + 3)), i.tangent && (y = t.normalize(t.cross(C, g, y), y), r.addAttribute(p, y, P), r.addAttribute(p, y, P + 3), r.addAttribute(p, y, E), r.addAttribute(p, y, E + 3))), E += 6
                }
                if (i.normal) {
                    for (d.set(n), s = 0; l > s; s += 3)d[s + l] = -n[s], d[s + l + 1] = -n[s + 1], d[s + l + 2] = -n[s + 2];
                    e.normal.values = d
                } else e.normal = void 0;
                if (i.binormal ? (m.set(o), m.set(o, l), e.binormal.values = m) : e.binormal = void 0, i.tangent) {
                    var I = e.tangent.values;
                    p.set(I), p.set(I, l), e.tangent.values = p
                }
            }
            if (i.st) {
                var D = e.st.values, M = new Float32Array(6 * c);
                M.set(D), M.set(D, c);
                for (var O = 2 * c, R = 0; 2 > R; R++) {
                    for (M[O++] = D[0], M[O++] = D[1], s = 2; c > s; s += 2) {
                        var N = D[s], L = D[s + 1];
                        M[O++] = N, M[O++] = L, M[O++] = N, M[O++] = L
                    }
                    M[O++] = D[0], M[O++] = D[1]
                }
                e.st.values = M
            }
            return e
        }

        function C(e, t, i) {
            i[t++] = e[0], i[t++] = e[1], i[t++] = e[2];
            for (var n = 3; n < e.length; n += 3) {
                var r = e[n], o = e[n + 1], a = e[n + 2];
                i[t++] = r, i[t++] = o, i[t++] = a, i[t++] = r, i[t++] = o, i[t++] = a
            }
            return i[t++] = e[0], i[t++] = e[1], i[t++] = e[2], i
        }

        function E(e, t) {
            var i = new _({
                position: t.positon,
                normal: t.normal || t.binormal,
                tangent: t.tangent,
                binormal: t.normal || t.binormal,
                st: t.st
            }), n = e.ellipsoid, o = r.computePositions(e), a = g(o, i, n), s = e.height, u = e.extrudedHeight, l = a.attributes, c = a.indices, h = l.position.values, m = h.length, p = new Float64Array(6 * m), f = new Float64Array(m);
            f.set(h);
            var v = new Float64Array(4 * m);
            h = r.scaleToGeodeticHeight(h, s, n, h), v = C(h, 0, v), f = r.scaleToGeodeticHeight(f, u, n, f), v = C(f, 2 * m, v), p.set(h), p.set(f, m), p.set(v, 2 * m), l.position.values = p, m /= 3;
            var E, S = c.length, T = m + m, b = d.createTypedArray(p.length / 3, 2 * S + 3 * T);
            b.set(c);
            var w = S;
            for (E = 0; S > E; E += 3) {
                var x = c[E], A = c[E + 1], P = c[E + 2];
                b[w++] = P + m, b[w++] = A + m, b[w++] = x + m
            }
            l = y(l, t);
            var I, D, M, O;
            for (E = 0; T > E; E += 2)I = E + T, D = I + T, M = I + 1, O = D + 1, b[w++] = I, b[w++] = D, b[w++] = M, b[w++] = M, b[w++] = D, b[w++] = O;
            return {attributes: l, indices: b}
        }

        var S = new t, T = new t, b = new t, w = new t, x = new t, A = new t, P = new t, I = new t, D = function (e) {
            e = o(e, o.EMPTY_OBJECT);
            var i = e.positions, r = e.width;
            this._positions = i, this._ellipsoid = u.clone(o(e.ellipsoid, u.WGS84)), this._vertexFormat = _.clone(o(e.vertexFormat, _.DEFAULT)), this._width = r, this._height = o(e.height, 0), this._extrudedHeight = o(e.extrudedHeight, this._height), this._cornerType = o(e.cornerType, n.ROUNDED), this._granularity = o(e.granularity, m.RADIANS_PER_DEGREE), this._workerName = "createCorridorGeometry", this.packedLength = 1 + i.length * t.packedLength + u.packedLength + _.packedLength + 5
        };
        D.pack = function (e, i, n) {
            n = o(n, 0);
            var r = e._positions, a = r.length;
            i[n++] = a;
            for (var s = 0; a > s; ++s, n += t.packedLength)t.pack(r[s], i, n);
            u.pack(e._ellipsoid, i, n), n += u.packedLength, _.pack(e._vertexFormat, i, n), n += _.packedLength, i[n++] = e._width, i[n++] = e._height, i[n++] = e._extrudedHeight, i[n++] = e._cornerType, i[n] = e._granularity
        };
        var M = u.clone(u.UNIT_SPHERE), O = new _, R = {
            positions: void 0,
            ellipsoid: M,
            vertexFormat: O,
            width: void 0,
            height: void 0,
            extrudedHeight: void 0,
            cornerType: void 0,
            granularity: void 0
        };
        return D.unpack = function (e, i, n) {
            i = o(i, 0);
            for (var r = e[i++], s = new Array(r), l = 0; r > l; ++l, i += t.packedLength)s[l] = t.unpack(e, i);
            var c = u.unpack(e, i, M);
            i += u.packedLength;
            var h = _.unpack(e, i, O);
            i += _.packedLength;
            var d = e[i++], m = e[i++], p = e[i++], f = e[i++], v = e[i];
            return a(n) ? (n._positions = s, n._ellipsoid = u.clone(c, n._ellipsoid), n._vertexFormat = _.clone(h, n._vertexFormat), n._width = d, n._height = m, n._extrudedHeight = p, n._cornerType = f, n._granularity = v, n) : (R.positions = s, R.width = d, R.height = m, R.extrudedHeight = p, R.cornerType = f, R.granularity = v, new D(R))
        }, D.createGeometry = function (t) {
            var i = t._positions, n = t._height, o = t._extrudedHeight, a = n !== o, s = p.removeDuplicates(i);
            if (s.length < 2)return void 0;
            var u, c = t._ellipsoid, h = t._vertexFormat, d = {
                ellipsoid: c,
                positions: s,
                width: t._width,
                cornerType: t._cornerType,
                granularity: t._granularity,
                saveAttributes: !0
            };
            if (a) {
                var m = Math.max(n, o);
                o = Math.min(n, o), n = m, d.height = n, d.extrudedHeight = o, u = E(d, h)
            } else {
                var _ = r.computePositions(d);
                u = g(_, h, c), u.attributes.position.values = r.scaleToGeodeticHeight(u.attributes.position.values, n, c, u.attributes.position.values)
            }
            var v = u.attributes, y = e.fromVertices(v.position.values, void 0, 3);
            return h.position || (u.attributes.position.values = void 0), new l({
                attributes: v,
                indices: u.indices,
                primitiveType: f.TRIANGLES,
                boundingSphere: y
            })
        }, D.createShadowVolume = function (e, t, i) {
            var n = e._granularity, r = e._ellipsoid, o = t(n, r), a = i(n, r);
            return new D({
                positions: e._positions,
                width: e._width,
                cornerType: e._cornerType,
                ellipsoid: r,
                granularity: n,
                extrudedHeight: o,
                height: a,
                vertexFormat: _.POSITION_ONLY
            })
        }, D
    }),define("Cesium/Core/CorridorOutlineGeometry", ["./BoundingSphere", "./Cartesian3", "./ComponentDatatype", "./CornerType", "./CorridorGeometryLibrary", "./defaultValue", "./defined", "./DeveloperError", "./Ellipsoid", "./Geometry", "./GeometryAttribute", "./GeometryAttributes", "./IndexDatatype", "./Math", "./PolylinePipeline", "./PrimitiveType"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f) {
        "use strict";
        function _(e, o) {
            var s, u, l, m = [], p = e.positions, f = e.corners, _ = e.endPositions, v = new h, E = 0, S = 0, T = 0;
            for (u = 0; u < p.length; u += 2)l = p[u].length - 3, E += l, T += l / 3 * 4, S += p[u + 1].length - 3;
            for (E += 3, S += 3, u = 0; u < f.length; u++) {
                s = f[u];
                var b = f[u].leftPositions;
                a(b) ? (l = b.length, E += l, T += l / 3 * 2) : (l = f[u].rightPositions.length, S += l, T += l / 3 * 2)
            }
            var w, x = a(_);
            x && (w = _[0].length - 3, E += w, S += w, w /= 3, T += 4 * w);
            var A, P, I, D, M, O, R = E + S, N = new Float64Array(R), L = 0, F = R - 1, B = w / 2, z = d.createTypedArray(R / 3, T + 4), V = 0;
            if (z[V++] = L / 3, z[V++] = (F - 2) / 3, x) {
                m.push(L / 3), O = g, M = y;
                var U = _[0];
                for (u = 0; B > u; u++)O = t.fromArray(U, 3 * (B - 1 - u), O), M = t.fromArray(U, 3 * (B + u), M), r.addAttribute(N, M, L), r.addAttribute(N, O, void 0, F), P = L / 3, D = P + 1, A = (F - 2) / 3, I = A - 1, z[V++] = A, z[V++] = I, z[V++] = P, z[V++] = D, L += 3, F -= 3
            }
            var k = 0, G = p[k++], H = p[k++];
            for (N.set(G, L), N.set(H, F - H.length + 1), l = H.length - 3, m.push(L / 3, (F - 2) / 3), u = 0; l > u; u += 3)P = L / 3, D = P + 1, A = (F - 2) / 3, I = A - 1, z[V++] = A, z[V++] = I, z[V++] = P, z[V++] = D, L += 3, F -= 3;
            for (u = 0; u < f.length; u++) {
                var W;
                s = f[u];
                var q, j = s.leftPositions, Y = s.rightPositions, X = C;
                if (a(j)) {
                    for (F -= 3, q = I, m.push(D), W = 0; W < j.length / 3; W++)X = t.fromArray(j, 3 * W, X), z[V++] = q - W - 1, z[V++] = q - W, r.addAttribute(N, X, void 0, F), F -= 3;
                    m.push(q - Math.floor(j.length / 6)), o === n.BEVELED && m.push((F - 2) / 3 + 1), L += 3
                } else {
                    for (L += 3, q = D, m.push(I), W = 0; W < Y.length / 3; W++)X = t.fromArray(Y, 3 * W, X), z[V++] = q + W, z[V++] = q + W + 1, r.addAttribute(N, X, L), L += 3;
                    m.push(q + Math.floor(Y.length / 6)), o === n.BEVELED && m.push(L / 3 - 1), F -= 3
                }
                for (G = p[k++], H = p[k++], G.splice(0, 3), H.splice(H.length - 3, 3), N.set(G, L), N.set(H, F - H.length + 1), l = H.length - 3, W = 0; W < H.length; W += 3)D = L / 3, P = D - 1, I = (F - 2) / 3, A = I + 1, z[V++] = A, z[V++] = I, z[V++] = P, z[V++] = D, L += 3, F -= 3;
                L -= 3, F += 3, m.push(L / 3, (F - 2) / 3)
            }
            if (x) {
                L += 3, F -= 3, O = g, M = y;
                var Z = _[1];
                for (u = 0; B > u; u++)O = t.fromArray(Z, 3 * (w - u - 1), O), M = t.fromArray(Z, 3 * u, M), r.addAttribute(N, O, void 0, F), r.addAttribute(N, M, L), D = L / 3, P = D - 1, I = (F - 2) / 3, A = I + 1, z[V++] = A, z[V++] = I, z[V++] = P, z[V++] = D, L += 3, F -= 3;
                m.push(L / 3)
            } else m.push(L / 3, (F - 2) / 3);
            return z[V++] = L / 3, z[V++] = (F - 2) / 3, v.position = new c({
                componentDatatype: i.DOUBLE,
                componentsPerAttribute: 3,
                values: N
            }), {attributes: v, indices: z, wallIndices: m}
        }

        function v(e) {
            var t = e.ellipsoid, i = r.computePositions(e), n = _(i, e.cornerType), o = n.wallIndices, a = e.height, s = e.extrudedHeight, u = n.attributes, l = n.indices, c = u.position.values, h = c.length, m = new Float64Array(h);
            m.set(c);
            var p = new Float64Array(2 * h);
            c = r.scaleToGeodeticHeight(c, a, t, c), m = r.scaleToGeodeticHeight(m, s, t, m), p.set(c), p.set(m, h), u.position.values = p, h /= 3;
            var f, v = l.length, g = d.createTypedArray(p.length / 3, 2 * (v + o.length));
            g.set(l);
            var y = v;
            for (f = 0; v > f; f += 2) {
                var C = l[f], E = l[f + 1];
                g[y++] = C + h, g[y++] = E + h
            }
            var S, T;
            for (f = 0; f < o.length; f++)S = o[f], T = S + h, g[y++] = S, g[y++] = T;
            return {attributes: u, indices: g}
        }

        var g = new t, y = new t, C = new t, E = function (e) {
            e = o(e, o.EMPTY_OBJECT);
            var i = e.positions, r = e.width;
            this._positions = i, this._ellipsoid = u.clone(o(e.ellipsoid, u.WGS84)), this._width = r, this._height = o(e.height, 0), this._extrudedHeight = o(e.extrudedHeight, this._height), this._cornerType = o(e.cornerType, n.ROUNDED), this._granularity = o(e.granularity, m.RADIANS_PER_DEGREE), this._workerName = "createCorridorOutlineGeometry", this.packedLength = 1 + i.length * t.packedLength + u.packedLength + 5
        };
        E.pack = function (e, i, n) {
            n = o(n, 0);
            var r = e._positions, a = r.length;
            i[n++] = a;
            for (var s = 0; a > s; ++s, n += t.packedLength)t.pack(r[s], i, n);
            u.pack(e._ellipsoid, i, n), n += u.packedLength, i[n++] = e._width, i[n++] = e._height, i[n++] = e._extrudedHeight, i[n++] = e._cornerType, i[n] = e._granularity
        };
        var S = u.clone(u.UNIT_SPHERE), T = {
            positions: void 0,
            ellipsoid: S,
            width: void 0,
            height: void 0,
            extrudedHeight: void 0,
            cornerType: void 0,
            granularity: void 0
        };
        return E.unpack = function (e, i, n) {
            i = o(i, 0);
            for (var r = e[i++], s = new Array(r), l = 0; r > l; ++l, i += t.packedLength)s[l] = t.unpack(e, i);
            var c = u.unpack(e, i, S);
            i += u.packedLength;
            var h = e[i++], d = e[i++], m = e[i++], p = e[i++], f = e[i];
            return a(n) ? (n._positions = s, n._ellipsoid = u.clone(c, n._ellipsoid), n._width = h, n._height = d, n._extrudedHeight = m, n._cornerType = p, n._granularity = f, n) : (T.positions = s, T.width = h, T.height = d, T.extrudedHeight = m, T.cornerType = p, T.granularity = f, new E(T))
        }, E.createGeometry = function (t) {
            var i = t._positions, n = t._height, o = t._extrudedHeight, a = n !== o, s = p.removeDuplicates(i);
            if (s.length < 2)return void 0;
            var u, c = t._ellipsoid, h = {
                ellipsoid: c,
                positions: s,
                width: t._width,
                cornerType: t._cornerType,
                granularity: t._granularity,
                saveAttributes: !1
            };
            if (a) {
                var d = Math.max(n, o);
                o = Math.min(n, o), n = d, h.height = n, h.extrudedHeight = o, u = v(h)
            } else {
                var m = r.computePositions(h);
                u = _(m, h.cornerType), u.attributes.position.values = r.scaleToGeodeticHeight(u.attributes.position.values, n, c, u.attributes.position.values)
            }
            var g = u.attributes, y = e.fromVertices(g.position.values, void 0, 3);
            return new l({attributes: g, indices: u.indices, primitiveType: f.LINES, boundingSphere: y})
        }, E
    }),define("Cesium/DataSources/CorridorGeometryUpdater", ["../Core/Color", "../Core/ColorGeometryInstanceAttribute", "../Core/CorridorGeometry", "../Core/CorridorOutlineGeometry", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Event", "../Core/GeometryInstance", "../Core/Iso8601", "../Core/ShowGeometryInstanceAttribute", "../Scene/MaterialAppearance", "../Scene/PerInstanceColorAppearance", "../Scene/Primitive", "./ColorMaterialProperty", "./ConstantProperty", "./dynamicGeometryGetBoundingSphere", "./MaterialProperty", "./Property"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C) {
        "use strict";
        var E = new _(e.WHITE), S = new v(!0), T = new v(!0), b = new v(!1), w = new v(e.BLACK), x = new e, A = function (e) {
            this.id = e, this.vertexFormat = void 0, this.positions = void 0, this.width = void 0, this.cornerType = void 0, this.height = void 0, this.extrudedHeight = void 0, this.granularity = void 0
        }, P = function (e, t) {
            this._entity = e, this._scene = t, this._entitySubscription = e.definitionChanged.addEventListener(P.prototype._onEntityPropertyChanged, this), this._fillEnabled = !1, this._isClosed = !1, this._dynamic = !1, this._outlineEnabled = !1, this._geometryChanged = new l, this._showProperty = void 0, this._materialProperty = void 0, this._hasConstantOutline = !0, this._showOutlineProperty = void 0, this._outlineColorProperty = void 0, this._outlineWidth = 1, this._options = new A(e), this._onEntityPropertyChanged(e, "corridor", e.corridor, void 0)
        };
        a(P, {
            perInstanceColorAppearanceType: {value: p},
            materialAppearanceType: {value: m}
        }), a(P.prototype, {
            entity: {
                get: function () {
                    return this._entity
                }
            }, fillEnabled: {
                get: function () {
                    return this._fillEnabled
                }
            }, hasConstantFill: {
                get: function () {
                    return !this._fillEnabled || !o(this._entity.availability) && C.isConstant(this._showProperty) && C.isConstant(this._fillProperty)
                }
            }, fillMaterialProperty: {
                get: function () {
                    return this._materialProperty
                }
            }, outlineEnabled: {
                get: function () {
                    return this._outlineEnabled
                }
            }, hasConstantOutline: {
                get: function () {
                    return !this._outlineEnabled || !o(this._entity.availability) && C.isConstant(this._showProperty) && C.isConstant(this._showOutlineProperty)
                }
            }, outlineColorProperty: {
                get: function () {
                    return this._outlineColorProperty
                }
            }, outlineWidth: {
                get: function () {
                    return this._outlineWidth
                }
            }, isDynamic: {
                get: function () {
                    return this._dynamic
                }
            }, isClosed: {
                get: function () {
                    return this._isClosed
                }
            }, geometryChanged: {
                get: function () {
                    return this._geometryChanged
                }
            }
        }), P.prototype.isOutlineVisible = function (e) {
            var t = this._entity;
            return this._outlineEnabled && t.isAvailable(e) && this._showProperty.getValue(e) && this._showOutlineProperty.getValue(e)
        }, P.prototype.isFilled = function (e) {
            var t = this._entity;
            return this._fillEnabled && t.isAvailable(e) && this._showProperty.getValue(e) && this._fillProperty.getValue(e)
        }, P.prototype.createFillGeometryInstance = function (n) {
            var r, a, s = this._entity, u = s.isAvailable(n), l = new d(u && s.isShowing && this._showProperty.getValue(n) && this._fillProperty.getValue(n));
            if (this._materialProperty instanceof _) {
                var h = e.WHITE;
                o(this._materialProperty.color) && (this._materialProperty.color.isConstant || u) && (h = this._materialProperty.color.getValue(n)), a = t.fromColor(h), r = {
                    show: l,
                    color: a
                }
            } else r = {show: l};
            return new c({id: s, geometry: new i(this._options), attributes: r})
        }, P.prototype.createOutlineGeometryInstance = function (i) {
            var r = this._entity, o = r.isAvailable(i), a = C.getValueOrDefault(this._outlineColorProperty, i, e.BLACK);
            return new c({
                id: r,
                geometry: new n(this._options),
                attributes: {
                    show: new d(o && r.isShowing && this._showProperty.getValue(i) && this._showOutlineProperty.getValue(i)),
                    color: t.fromColor(a)
                }
            })
        }, P.prototype.isDestroyed = function () {
            return !1
        }, P.prototype.destroy = function () {
            this._entitySubscription(), s(this)
        }, P.prototype._onEntityPropertyChanged = function (e, t, i, n) {
            if ("availability" === t || "corridor" === t) {
                var a = this._entity.corridor;
                if (!o(a))return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var s = a.fill, u = o(s) && s.isConstant ? s.getValue(h.MINIMUM_VALUE) : !0, l = a.outline, c = o(l);
                if (c && l.isConstant && (c = l.getValue(h.MINIMUM_VALUE)), !u && !c)return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var d = a.positions, f = a.show;
                if (o(f) && f.isConstant && !f.getValue(h.MINIMUM_VALUE) || !o(d))return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var v = r(a.material, E), g = v instanceof _;
                this._materialProperty = v, this._fillProperty = r(s, T), this._showProperty = r(f, S), this._showOutlineProperty = r(a.outline, b), this._outlineColorProperty = c ? r(a.outlineColor, w) : void 0;
                var y = a.height, x = a.extrudedHeight, A = a.granularity, P = a.width, I = a.outlineWidth, D = a.cornerType;
                if (this._isClosed = o(x), this._fillEnabled = u, this._outlineEnabled = c, d.isConstant && C.isConstant(y) && C.isConstant(x) && C.isConstant(A) && C.isConstant(P) && C.isConstant(I) && C.isConstant(D)) {
                    var M = this._options;
                    M.vertexFormat = g ? p.VERTEX_FORMAT : m.MaterialSupport.TEXTURED.vertexFormat, M.positions = d.getValue(h.MINIMUM_VALUE, M.positions), M.height = o(y) ? y.getValue(h.MINIMUM_VALUE) : void 0, M.extrudedHeight = o(x) ? x.getValue(h.MINIMUM_VALUE) : void 0, M.granularity = o(A) ? A.getValue(h.MINIMUM_VALUE) : void 0, M.width = o(P) ? P.getValue(h.MINIMUM_VALUE) : void 0, M.cornerType = o(D) ? D.getValue(h.MINIMUM_VALUE) : void 0, this._outlineWidth = o(I) ? I.getValue(h.MINIMUM_VALUE) : 1, this._dynamic = !1, this._geometryChanged.raiseEvent(this)
                } else this._dynamic || (this._dynamic = !0, this._geometryChanged.raiseEvent(this))
            }
        }, P.prototype.createDynamicUpdater = function (e) {
            return new I(e, this)
        };
        var I = function (e, t) {
            this._primitives = e, this._primitive = void 0, this._outlinePrimitive = void 0, this._geometryUpdater = t, this._options = new A(t._entity)
        };
        return I.prototype.update = function (r) {
            var a = this._primitives;
            a.removeAndDestroy(this._primitive), a.removeAndDestroy(this._outlinePrimitive), this._primitive = void 0, this._outlinePrimitive = void 0;
            var s = this._geometryUpdater, u = s._entity, l = u.corridor;
            if (u.isShowing && u.isAvailable(r) && C.getValueOrDefault(l.show, r, !0)) {
                var h = this._options, d = C.getValueOrUndefined(l.positions, r, h.positions), _ = C.getValueOrUndefined(l.width, r);
                if (o(d) && o(_)) {
                    if (h.positions = d, h.width = _, h.height = C.getValueOrUndefined(l.height, r), h.extrudedHeight = C.getValueOrUndefined(l.extrudedHeight, r), h.granularity = C.getValueOrUndefined(l.granularity, r), h.cornerType = C.getValueOrUndefined(l.cornerType, r), !o(l.fill) || l.fill.getValue(r)) {
                        var v = y.getValue(r, s.fillMaterialProperty, this._material);
                        this._material = v;
                        var g = new m({material: v, translucent: v.isTranslucent(), closed: o(h.extrudedHeight)});
                        h.vertexFormat = g.vertexFormat, this._primitive = a.add(new f({
                            geometryInstances: new c({
                                id: u,
                                geometry: new i(h)
                            }), appearance: g, asynchronous: !1
                        }))
                    }
                    if (o(l.outline) && l.outline.getValue(r)) {
                        h.vertexFormat = p.VERTEX_FORMAT;
                        var E = C.getValueOrClonedDefault(l.outlineColor, r, e.BLACK, x), S = C.getValueOrDefault(l.outlineWidth, r, 1), T = 1 !== E.alpha;
                        this._outlinePrimitive = a.add(new f({
                            geometryInstances: new c({
                                id: u,
                                geometry: new n(h),
                                attributes: {color: t.fromColor(E)}
                            }),
                            appearance: new p({
                                flat: !0,
                                translucent: T,
                                renderState: {lineWidth: s._scene.clampLineWidth(S)}
                            }),
                            asynchronous: !1
                        }))
                    }
                }
            }
        }, I.prototype.getBoundingSphere = function (e, t) {
            return g(e, this._primitive, this._outlinePrimitive, t)
        }, I.prototype.isDestroyed = function () {
            return !1
        }, I.prototype.destroy = function () {
            var e = this._primitives;
            e.removeAndDestroy(this._primitive), e.removeAndDestroy(this._outlinePrimitive), s(this)
        }, P
    }),define("Cesium/DataSources/DataSource", ["../Core/defineProperties", "../Core/DeveloperError"], function (e, t) {
        "use strict";
        var i = function () {
            t.throwInstantiationError()
        };
        return e(i.prototype, {
            name: {get: t.throwInstantiationError},
            clock: {get: t.throwInstantiationError},
            entities: {get: t.throwInstantiationError},
            isLoading: {get: t.throwInstantiationError},
            changedEvent: {get: t.throwInstantiationError},
            errorEvent: {get: t.throwInstantiationError},
            loadingEvent: {get: t.throwInstantiationError}
        }), i.prototype.update = t.throwInstantiationError, i.setLoading = function (e, t) {
            e._isLoading !== t && (t ? e._entityCollection.suspendEvents() : e._entityCollection.resumeEvents(), e._isLoading = t, e._loading.raiseEvent(e, t))
        }, i
    }),define("Cesium/DataSources/EntityCollection", ["../Core/AssociativeArray", "../Core/createGuid", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "../Core/Iso8601", "../Core/JulianDate", "../Core/RuntimeError", "../Core/TimeInterval", "./Entity"], function (e, t, i, n, r, o, a, s, u, l, c) {
        "use strict";
        function h(e) {
            if (0 === e._suspendCount) {
                var t = e._addedEntities, i = e._removedEntities, n = e._changedEntities;
                (0 !== n.length || 0 !== t.length || 0 !== i.length) && (e._collectionChanged.raiseEvent(e, t.values, i.values, n.values), t.removeAll(), i.removeAll(), n.removeAll())
            }
        }

        var d = {id: void 0}, m = function () {
            this._entities = new e, this._addedEntities = new e, this._removedEntities = new e, this._changedEntities = new e, this._suspendCount = 0, this._collectionChanged = new o, this._id = t()
        };
        return m.prototype.suspendEvents = function () {
            this._suspendCount++
        }, m.prototype.resumeEvents = function () {
            this._suspendCount--, h(this)
        }, m.collectionChangedEventCallback = void 0, n(m.prototype, {
            collectionChanged: {
                get: function () {
                    return this._collectionChanged
                }
            }, id: {
                get: function () {
                    return this._id
                }
            }, values: {
                get: function () {
                    return this._entities.values
                }
            }
        }), m.prototype.computeAvailability = function () {
            for (var e = a.MAXIMUM_VALUE, t = a.MINIMUM_VALUE, n = this._entities.values, r = 0, o = n.length; o > r; r++) {
                var u = n[r], c = u.availability;
                if (i(c)) {
                    var h = c.start, d = c.stop;
                    s.lessThan(h, e) && !h.equals(a.MINIMUM_VALUE) && (e = h), s.greaterThan(d, t) && !d.equals(a.MAXIMUM_VALUE) && (t = d)
                }
            }
            return a.MAXIMUM_VALUE.equals(e) && (e = a.MINIMUM_VALUE), a.MINIMUM_VALUE.equals(t) && (t = a.MAXIMUM_VALUE), new l({
                start: e,
                stop: t
            })
        }, m.prototype.add = function (e) {
            e instanceof c || (e = new c(e));
            var t = e.id, i = this._entities;
            if (i.contains(t))throw new u("An entity with id " + t + " already exists in this collection.");
            i.set(t, e);
            this._removedEntities;
            return this._removedEntities.remove(t) || this._addedEntities.set(t, e), e.definitionChanged.addEventListener(m.prototype._onEntityDefinitionChanged, this), h(this), e
        }, m.prototype.remove = function (e) {
            return i(e) ? this.removeById(e.id) : !1
        }, m.prototype.contains = function (e) {
            return this._entities.get(e.id) === e
        }, m.prototype.removeById = function (e) {
            if (!i(e))return !1;
            var t = this._entities, n = t.get(e);
            return this._entities.remove(e) ? (this._addedEntities.remove(e) || (this._removedEntities.set(e, n), this._changedEntities.remove(e)), this._entities.remove(e), n.definitionChanged.removeEventListener(m.prototype._onEntityDefinitionChanged, this), h(this), !0) : !1
        }, m.prototype.removeAll = function () {
            for (var e = this._entities, t = e.length, n = e.values, r = this._addedEntities, o = this._removedEntities, a = 0; t > a; a++) {
                var s = n[a], u = s.id, l = r.get(u);
                i(l) || (s.definitionChanged.removeEventListener(m.prototype._onEntityDefinitionChanged, this), o.set(u, s))
            }
            e.removeAll(), r.removeAll(), this._changedEntities.removeAll(), h(this)
        }, m.prototype.getById = function (e) {
            return this._entities.get(e)
        }, m.prototype.getOrCreateEntity = function (e) {
            var t = this._entities.get(e);
            return i(t) || (d.id = e, t = new c(d), this.add(t)), t
        }, m.prototype._onEntityDefinitionChanged = function (e) {
            var t = e.id;
            this._addedEntities.contains(t) || this._changedEntities.set(t, e), h(this)
        }, m
    }),define("Cesium/DataSources/CustomDataSource", ["../Core/defineProperties", "../Core/Event", "./DataSource", "./EntityCollection"], function (e, t, i, n) {
        "use strict";
        var r = function (e) {
            this._name = e, this._clock = void 0, this._changed = new t, this._error = new t, this._isLoading = !1, this._loading = new t, this._entityCollection = new n
        };
        return e(r.prototype, {
            name: {
                get: function () {
                    return this._name
                }, set: function (e) {
                    this._name !== e && (this._name = e, this._changed.raiseEvent(this))
                }
            }, clock: {
                get: function () {
                    return this._clock
                }, set: function (e) {
                    this._clock !== e && (this._clock = e, this._changed.raiseEvent(this))
                }
            }, entities: {
                get: function () {
                    return this._entityCollection
                }
            }, isLoading: {
                get: function () {
                    return this._isLoading
                }, set: function (e) {
                    i.setLoading(this, e)
                }
            }, changedEvent: {
                get: function () {
                    return this._changed
                }
            }, errorEvent: {
                get: function () {
                    return this._error
                }
            }, loadingEvent: {
                get: function () {
                    return this._loading
                }
            }
        }), r
    }),define("Cesium/Core/CylinderGeometryLibrary", ["./Math"], function (e) {
        "use strict";
        var t = {};
        return t.computePositions = function (t, i, n, r, o) {
            var a, s = .5 * t, u = -s, l = r + r, c = o ? 2 * l : l, h = new Float64Array(3 * c), d = 0, m = 0, p = o ? 3 * l : 0, f = o ? 3 * (l + r) : 3 * r;
            for (a = 0; r > a; a++) {
                var _ = a / r * e.TWO_PI, v = Math.cos(_), g = Math.sin(_), y = v * n, C = g * n, E = v * i, S = g * i;
                h[m + p] = y, h[m + p + 1] = C, h[m + p + 2] = u, h[m + f] = E, h[m + f + 1] = S, h[m + f + 2] = s, m += 3, o && (h[d++] = y, h[d++] = C, h[d++] = u, h[d++] = E, h[d++] = S, h[d++] = s)
            }
            return h
        }, t
    }),define("Cesium/Core/CylinderGeometry", ["./BoundingSphere", "./Cartesian2", "./Cartesian3", "./ComponentDatatype", "./CylinderGeometryLibrary", "./defaultValue", "./defined", "./DeveloperError", "./Geometry", "./GeometryAttribute", "./GeometryAttributes", "./IndexDatatype", "./Math", "./PrimitiveType", "./VertexFormat"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p) {
        "use strict";
        var f = new t, _ = new i, v = new i, g = new i, y = new i, C = function (e) {
            e = o(e, o.EMPTY_OBJECT);
            var t = e.length, i = e.topRadius, n = e.bottomRadius, r = o(e.vertexFormat, p.DEFAULT), a = o(e.slices, 128);
            this._length = t, this._topRadius = i, this._bottomRadius = n, this._vertexFormat = p.clone(r), this._slices = a, this._workerName = "createCylinderGeometry"
        };
        C.packedLength = p.packedLength + 4, C.pack = function (e, t, i) {
            i = o(i, 0), p.pack(e._vertexFormat, t, i), i += p.packedLength, t[i++] = e._length, t[i++] = e._topRadius, t[i++] = e._bottomRadius, t[i] = e._slices
        };
        var E = new p, S = {vertexFormat: E, length: void 0, topRadius: void 0, bottomRadius: void 0, slices: void 0};
        return C.unpack = function (e, t, i) {
            t = o(t, 0);
            var n = p.unpack(e, t, E);
            t += p.packedLength;
            var r = e[t++], s = e[t++], u = e[t++], l = e[t];
            return a(i) ? (i._vertexFormat = p.clone(n, i._vertexFormat), i._length = r, i._topRadius = s, i._bottomRadius = u, i._slices = l, i) : (S.length = r, S.topRadius = s, S.bottomRadius = u, S.slices = l, new C(S))
        }, C.createGeometry = function (o) {
            var a, s = o._length, p = o._topRadius, C = o._bottomRadius, E = o._vertexFormat, S = o._slices, T = S + S, b = S + T, w = T + T, x = r.computePositions(s, p, C, S, !0), A = E.st ? new Float32Array(2 * w) : void 0, P = E.normal ? new Float32Array(3 * w) : void 0, I = E.tangent ? new Float32Array(3 * w) : void 0, D = E.binormal ? new Float32Array(3 * w) : void 0, M = E.normal || E.tangent || E.binormal;
            if (M) {
                var O = E.tangent || E.binormal, R = 0, N = 0, L = 0, F = _;
                F.z = 0;
                var B = g, z = v;
                for (a = 0; S > a; a++) {
                    var V = a / S * d.TWO_PI, U = Math.cos(V), k = Math.sin(V);
                    M && (F.x = U, F.y = k, O && (B = i.normalize(i.cross(i.UNIT_Z, F, B), B)), E.normal && (P[R++] = U, P[R++] = k, P[R++] = 0, P[R++] = U, P[R++] = k, P[R++] = 0), E.tangent && (I[N++] = B.x, I[N++] = B.y, I[N++] = B.z, I[N++] = B.x, I[N++] = B.y, I[N++] = B.z), E.binormal && (z = i.normalize(i.cross(F, B, z), z), D[L++] = z.x, D[L++] = z.y, D[L++] = z.z, D[L++] = z.x, D[L++] = z.y, D[L++] = z.z))
                }
                for (a = 0; S > a; a++)E.normal && (P[R++] = 0, P[R++] = 0, P[R++] = -1), E.tangent && (I[N++] = 1, I[N++] = 0, I[N++] = 0), E.binormal && (D[L++] = 0, D[L++] = -1, D[L++] = 0);
                for (a = 0; S > a; a++)E.normal && (P[R++] = 0, P[R++] = 0, P[R++] = 1), E.tangent && (I[N++] = 1, I[N++] = 0, I[N++] = 0), E.binormal && (D[L++] = 0, D[L++] = 1, D[L++] = 0)
            }
            var G = 12 * S - 12, H = h.createTypedArray(w, G), W = 0, q = 0;
            for (a = 0; S - 1 > a; a++)H[W++] = q, H[W++] = q + 2, H[W++] = q + 3, H[W++] = q, H[W++] = q + 3, H[W++] = q + 1, q += 2;
            for (H[W++] = T - 2, H[W++] = 0, H[W++] = 1, H[W++] = T - 2, H[W++] = 1, H[W++] = T - 1, a = 1; S - 1 > a; a++)H[W++] = T + a + 1, H[W++] = T + a, H[W++] = T;
            for (a = 1; S - 1 > a; a++)H[W++] = b, H[W++] = b + a, H[W++] = b + a + 1;
            var j = 0;
            if (E.st) {
                var Y = Math.max(p, C);
                for (a = 0; w > a; a++) {
                    var X = i.fromArray(x, 3 * a, y);
                    A[j++] = (X.x + Y) / (2 * Y), A[j++] = (X.y + Y) / (2 * Y)
                }
            }
            var Z = new c;
            E.position && (Z.position = new l({
                componentDatatype: n.DOUBLE,
                componentsPerAttribute: 3,
                values: x
            })), E.normal && (Z.normal = new l({
                componentDatatype: n.FLOAT,
                componentsPerAttribute: 3,
                values: P
            })), E.tangent && (Z.tangent = new l({
                componentDatatype: n.FLOAT,
                componentsPerAttribute: 3,
                values: I
            })), E.binormal && (Z.binormal = new l({
                componentDatatype: n.FLOAT,
                componentsPerAttribute: 3,
                values: D
            })), E.st && (Z.st = new l({
                componentDatatype: n.FLOAT,
                componentsPerAttribute: 2,
                values: A
            })), f.x = .5 * s, f.y = Math.max(C, p);
            var K = new e(i.ZERO, t.magnitude(f));
            return new u({attributes: Z, indices: H, primitiveType: m.TRIANGLES, boundingSphere: K})
        }, C
    }),define("Cesium/Core/CylinderOutlineGeometry", ["./BoundingSphere", "./Cartesian2", "./Cartesian3", "./ComponentDatatype", "./CylinderGeometryLibrary", "./defaultValue", "./defined", "./DeveloperError", "./Geometry", "./GeometryAttribute", "./GeometryAttributes", "./IndexDatatype", "./PrimitiveType"], function (e, t, i, n, r, o, a, s, u, l, c, h, d) {
        "use strict";
        var m = new t, p = function (e) {
            e = o(e, o.EMPTY_OBJECT);
            var t = e.length, i = e.topRadius, n = e.bottomRadius, r = o(e.slices, 128), a = Math.max(o(e.numberOfVerticalLines, 16), 0);
            this._length = t, this._topRadius = i, this._bottomRadius = n, this._slices = r, this._numberOfVerticalLines = a, this._workerName = "createCylinderOutlineGeometry"
        };
        p.packedLength = 5, p.pack = function (e, t, i) {
            i = o(i, 0), t[i++] = e._length, t[i++] = e._topRadius, t[i++] = e._bottomRadius, t[i++] = e._slices, t[i] = e._numberOfVerticalLines
        };
        var f = {
            length: void 0,
            topRadius: void 0,
            bottomRadius: void 0,
            slices: void 0,
            numberOfVerticalLines: void 0
        };
        return p.unpack = function (e, t, i) {
            t = o(t, 0);
            var n = e[t++], r = e[t++], s = e[t++], u = e[t++], l = e[t];
            return a(i) ? (i._length = n, i._topRadius = r, i._bottomRadius = s, i._slices = u, i._numberOfVerticalLines = l, i) : (f.length = n, f.topRadius = r, f.bottomRadius = s, f.slices = u, f.numberOfVerticalLines = l, new p(f))
        }, p.createGeometry = function (o) {
            var a, s = o._length, p = o._topRadius, f = o._bottomRadius, _ = o._slices, v = o._numberOfVerticalLines, g = 2 * _, y = r.computePositions(s, p, f, _, !1), C = 2 * _;
            if (v > 0) {
                var E = Math.min(v, _);
                a = Math.round(_ / E), C += E
            }
            for (var S = h.createTypedArray(g, 2 * C), T = 0, b = 0; _ - 1 > b; b++)S[T++] = b, S[T++] = b + 1, S[T++] = b + _, S[T++] = b + 1 + _;
            if (S[T++] = _ - 1, S[T++] = 0, S[T++] = _ + _ - 1, S[T++] = _, v > 0)for (b = 0; _ > b; b += a)S[T++] = b, S[T++] = b + _;
            var w = new c;
            w.position = new l({
                componentDatatype: n.DOUBLE,
                componentsPerAttribute: 3,
                values: y
            }), m.x = .5 * s, m.y = Math.max(f, p);
            var x = new e(i.ZERO, t.magnitude(m));
            return new u({attributes: w, indices: S, primitiveType: d.LINES, boundingSphere: x})
        }, p
    }),define("Cesium/DataSources/CylinderGeometryUpdater", ["../Core/Cartesian3", "../Core/Color", "../Core/ColorGeometryInstanceAttribute", "../Core/CylinderGeometry", "../Core/CylinderOutlineGeometry", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Event", "../Core/GeometryInstance", "../Core/Iso8601", "../Core/ShowGeometryInstanceAttribute", "../Scene/MaterialAppearance", "../Scene/PerInstanceColorAppearance", "../Scene/Primitive", "./ColorMaterialProperty", "./ConstantProperty", "./dynamicGeometryGetBoundingSphere", "./MaterialProperty", "./Property"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E) {
        "use strict";
        var S = new v(t.WHITE), T = new g(!0), b = new g(!0), w = new g(!1), x = new g(t.BLACK), A = new t, P = function (e) {
            this.id = e, this.vertexFormat = void 0, this.length = void 0, this.topRadius = void 0, this.bottomRadius = void 0, this.slices = void 0, this.numberOfVerticalLines = void 0
        }, I = function (e, t) {
            this._entity = e, this._scene = t, this._entitySubscription = e.definitionChanged.addEventListener(I.prototype._onEntityPropertyChanged, this), this._fillEnabled = !1, this._dynamic = !1, this._outlineEnabled = !1, this._geometryChanged = new c, this._showProperty = void 0, this._materialProperty = void 0, this._hasConstantOutline = !0, this._showOutlineProperty = void 0, this._outlineColorProperty = void 0, this._outlineWidth = 1, this._options = new P(e), this._onEntityPropertyChanged(e, "cylinder", e.cylinder, void 0)
        };
        s(I, {
            perInstanceColorAppearanceType: {value: f},
            materialAppearanceType: {value: p}
        }), s(I.prototype, {
            entity: {
                get: function () {
                    return this._entity
                }
            }, fillEnabled: {
                get: function () {
                    return this._fillEnabled
                }
            }, hasConstantFill: {
                get: function () {
                    return !this._fillEnabled || !a(this._entity.availability) && E.isConstant(this._showProperty) && E.isConstant(this._fillProperty)
                }
            }, fillMaterialProperty: {
                get: function () {
                    return this._materialProperty
                }
            }, outlineEnabled: {
                get: function () {
                    return this._outlineEnabled
                }
            }, hasConstantOutline: {
                get: function () {
                    return !this._outlineEnabled || !a(this._entity.availability) && E.isConstant(this._showProperty) && E.isConstant(this._showOutlineProperty)
                }
            }, outlineColorProperty: {
                get: function () {
                    return this._outlineColorProperty
                }
            }, outlineWidth: {
                get: function () {
                    return this._outlineWidth
                }
            }, isDynamic: {
                get: function () {
                    return this._dynamic
                }
            }, isClosed: {value: !0}, geometryChanged: {
                get: function () {
                    return this._geometryChanged
                }
            }
        }), I.prototype.isOutlineVisible = function (e) {
            var t = this._entity;
            return this._outlineEnabled && t.isAvailable(e) && this._showProperty.getValue(e) && this._showOutlineProperty.getValue(e)
        }, I.prototype.isFilled = function (e) {
            var t = this._entity;
            return this._fillEnabled && t.isAvailable(e) && this._showProperty.getValue(e) && this._fillProperty.getValue(e)
        }, I.prototype.createFillGeometryInstance = function (e) {
            var r, o, s = this._entity, u = s.isAvailable(e), l = new m(u && s.isShowing && this._showProperty.getValue(e) && this._fillProperty.getValue(e));
            if (this._materialProperty instanceof v) {
                var c = t.WHITE;
                a(this._materialProperty.color) && (this._materialProperty.color.isConstant || u) && (c = this._materialProperty.color.getValue(e)), o = i.fromColor(c), r = {
                    show: l,
                    color: o
                }
            } else r = {show: l};
            return new h({
                id: s,
                geometry: new n(this._options),
                modelMatrix: s._getModelMatrix(d.MINIMUM_VALUE),
                attributes: r
            })
        }, I.prototype.createOutlineGeometryInstance = function (e) {
            var n = this._entity, o = n.isAvailable(e), a = E.getValueOrDefault(this._outlineColorProperty, e, t.BLACK);
            return new h({
                id: n,
                geometry: new r(this._options),
                modelMatrix: n._getModelMatrix(d.MINIMUM_VALUE),
                attributes: {
                    show: new m(o && n.isShowing && this._showProperty.getValue(e) && this._showOutlineProperty.getValue(e)),
                    color: i.fromColor(a)
                }
            })
        }, I.prototype.isDestroyed = function () {
            return !1
        }, I.prototype.destroy = function () {
            this._entitySubscription(), u(this)
        }, I.prototype._onEntityPropertyChanged = function (e, t, i, n) {
            if ("availability" === t || "position" === t || "orientation" === t || "cylinder" === t) {
                var r = e.cylinder;
                if (!a(r))return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var s = r.fill, u = a(s) && s.isConstant ? s.getValue(d.MINIMUM_VALUE) : !0, l = r.outline, c = a(l);
                if (c && l.isConstant && (c = l.getValue(d.MINIMUM_VALUE)), !u && !c)return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var h = e.position, m = r.length, _ = r.topRadius, g = r.bottomRadius, y = r.show;
                if (a(y) && y.isConstant && !y.getValue(d.MINIMUM_VALUE) || !a(h) || !a(m) || !a(_) || !a(g))return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var C = o(r.material, S), A = C instanceof v;
                this._materialProperty = C, this._fillProperty = o(s, b), this._showProperty = o(y, T), this._showOutlineProperty = o(r.outline, w), this._outlineColorProperty = c ? o(r.outlineColor, x) : void 0;
                var P = r.slices, I = r.outlineWidth, D = r.numberOfVerticalLines;
                if (this._fillEnabled = u, this._outlineEnabled = c, h.isConstant && E.isConstant(e.orientation) && m.isConstant && _.isConstant && g.isConstant && E.isConstant(P) && E.isConstant(I) && E.isConstant(D)) {
                    var M = this._options;
                    M.vertexFormat = A ? f.VERTEX_FORMAT : p.MaterialSupport.TEXTURED.vertexFormat, M.length = m.getValue(d.MINIMUM_VALUE), M.topRadius = _.getValue(d.MINIMUM_VALUE), M.bottomRadius = g.getValue(d.MINIMUM_VALUE), M.slices = a(P) ? P.getValue(d.MINIMUM_VALUE) : void 0, M.numberOfVerticalLines = a(D) ? D.getValue(d.MINIMUM_VALUE) : void 0, this._outlineWidth = a(I) ? I.getValue(d.MINIMUM_VALUE) : 1, this._dynamic = !1, this._geometryChanged.raiseEvent(this)
                } else this._dynamic || (this._dynamic = !0, this._geometryChanged.raiseEvent(this))
            }
        }, I.prototype.createDynamicUpdater = function (e) {
            return new D(e, this)
        };
        var D = function (e, t) {
            this._primitives = e, this._primitive = void 0, this._outlinePrimitive = void 0, this._geometryUpdater = t, this._options = new P(t._entity)
        };
        return D.prototype.update = function (e) {
            var o = this._primitives;
            o.removeAndDestroy(this._primitive), o.removeAndDestroy(this._outlinePrimitive), this._primitive = void 0, this._outlinePrimitive = void 0;
            var s = this._geometryUpdater, u = s._entity, l = u.cylinder;
            if (u.isShowing && u.isAvailable(e) && E.getValueOrDefault(l.show, e, !0)) {
                var c = this._options, d = u._getModelMatrix(e), m = E.getValueOrUndefined(l.length, e), v = E.getValueOrUndefined(l.topRadius, e), g = E.getValueOrUndefined(l.bottomRadius, e);
                if (a(d) && a(m) && a(v) && a(g)) {
                    if (c.length = m, c.topRadius = v, c.bottomRadius = g, c.slices = E.getValueOrUndefined(l.slices, e), c.numberOfVerticalLines = E.getValueOrUndefined(l.numberOfVerticalLines, e), E.getValueOrDefault(l.fill, e, !0)) {
                        var y = C.getValue(e, s.fillMaterialProperty, this._material);
                        this._material = y;
                        var S = new p({material: y, translucent: y.isTranslucent(), closed: !0});
                        c.vertexFormat = S.vertexFormat, this._primitive = o.add(new _({
                            geometryInstances: new h({
                                id: u,
                                geometry: new n(c),
                                modelMatrix: d
                            }), appearance: S, asynchronous: !1
                        }))
                    }
                    if (E.getValueOrDefault(l.outline, e, !1)) {
                        c.vertexFormat = f.VERTEX_FORMAT;
                        var T = E.getValueOrClonedDefault(l.outlineColor, e, t.BLACK, A), b = E.getValueOrDefault(l.outlineWidth, e, 1), w = 1 !== T.alpha;
                        this._outlinePrimitive = o.add(new _({
                            geometryInstances: new h({
                                id: u,
                                geometry: new r(c),
                                modelMatrix: d,
                                attributes: {color: i.fromColor(T)}
                            }),
                            appearance: new f({
                                flat: !0,
                                translucent: w,
                                renderState: {lineWidth: s._scene.clampLineWidth(b)}
                            }),
                            asynchronous: !1
                        }))
                    }
                }
            }
        }, D.prototype.getBoundingSphere = function (e, t) {
            return y(e, this._primitive, this._outlinePrimitive, t)
        }, D.prototype.isDestroyed = function () {
            return !1
        }, D.prototype.destroy = function () {
            var e = this._primitives;
            e.removeAndDestroy(this._primitive), e.removeAndDestroy(this._outlinePrimitive), u(this)
        }, I
    }),define("Cesium/Core/EllipseGeometryLibrary", ["./Cartesian3", "./Math", "./Matrix3", "./Quaternion"], function (e, t, i, n) {
        "use strict";
        function r(t, r, o, c, h, d, m, p, f, _) {
            var v = t + r;
            e.multiplyByScalar(c, Math.cos(v), a), e.multiplyByScalar(o, Math.sin(v), s), e.add(a, s, a);
            var g = Math.cos(t);
            g *= g;
            var y = Math.sin(t);
            y *= y;
            var C = d / Math.sqrt(m * g + h * y), E = C / p;
            return n.fromAxisAngle(a, E, u), i.fromQuaternion(u, l), i.multiplyByVector(l, f, _), e.normalize(_, _), e.multiplyByScalar(_, p, _), _
        }

        var o = {}, a = new e, s = new e, u = new n, l = new i, c = new e, h = new e, d = new e, m = new e;
        o.raisePositionsToHeight = function (t, i, n) {
            for (var r = i.ellipsoid, o = i.height, a = i.extrudedHeight, s = n ? t.length / 3 * 2 : t.length / 3, u = new Float64Array(3 * s), l = t.length, p = n ? l : 0, f = 0; l > f; f += 3) {
                var _ = f + 1, v = f + 2, g = e.fromArray(t, f, c);
                r.scaleToGeodeticSurface(g, g);
                var y = e.clone(g, h), C = r.geodeticSurfaceNormal(g, m), E = e.multiplyByScalar(C, o, d);
                e.add(g, E, g), n && (e.multiplyByScalar(C, a, E), e.add(y, E, y), u[f + p] = y.x, u[_ + p] = y.y, u[v + p] = y.z), u[f] = g.x, u[_] = g.y, u[v] = g.z
            }
            return u
        };
        var p = new e, f = new e, _ = new e;
        return o.computeEllipsePositions = function (i, n, o) {
            var a = i.semiMinorAxis, s = i.semiMajorAxis, u = i.rotation, l = i.center, m = 8 * i.granularity, v = a * a, g = s * s, y = s * a, C = e.magnitude(l), E = e.normalize(l, p), S = e.cross(e.UNIT_Z, l, f);
            S = e.normalize(S, S);
            var T = e.cross(E, S, _), b = 1 + Math.ceil(t.PI_OVER_TWO / m), w = t.PI_OVER_TWO / (b - 1), x = t.PI_OVER_TWO - b * w;
            0 > x && (b -= Math.ceil(Math.abs(x) / w));
            var A, P, I, D, M, O = 2 * b * (b + 1), R = n ? new Array(3 * O) : void 0, N = 0, L = c, F = h, B = 3 * (2 * b + 2 * (b - 1)), z = B - 1, V = 0, U = o ? new Array(B) : void 0;
            for (x = t.PI_OVER_TWO, A = 0; b > A; ++A) {
                if (L = r(x, u, T, S, v, y, g, C, E, L), F = r(Math.PI - x, u, T, S, v, y, g, C, E, F), n) {
                    for (R[N++] = L.x, R[N++] = L.y, R[N++] = L.z, I = 2 * A + 2, P = 1; I - 1 > P; ++P)D = P / (I - 1), M = e.lerp(L, F, D, d), R[N++] = M.x, R[N++] = M.y, R[N++] = M.z;
                    R[N++] = F.x, R[N++] = F.y, R[N++] = F.z
                }
                o && (U[z--] = L.z, U[z--] = L.y, U[z--] = L.x, 0 !== A && (U[V++] = F.x, U[V++] = F.y, U[V++] = F.z)), x = t.PI_OVER_TWO - (A + 1) * w
            }
            for (A = b; A > 0; --A) {
                if (x = t.PI_OVER_TWO - (A - 1) * w, L = r(-x, u, T, S, v, y, g, C, E, L), F = r(x + Math.PI, u, T, S, v, y, g, C, E, F), n) {
                    for (R[N++] = L.x, R[N++] = L.y, R[N++] = L.z, I = 2 * (A - 1) + 2, P = 1; I - 1 > P; ++P)D = P / (I - 1), M = e.lerp(L, F, D, d), R[N++] = M.x, R[N++] = M.y, R[N++] = M.z;
                    R[N++] = F.x, R[N++] = F.y, R[N++] = F.z
                }
                o && (U[z--] = L.z, U[z--] = L.y, U[z--] = L.x, 1 !== A && (U[V++] = F.x, U[V++] = F.y, U[V++] = F.z))
            }
            var k = {};
            return n && (k.positions = R, k.numPts = b), o && (k.outerPositions = U), k
        }, o
    }),define("Cesium/Core/EllipseGeometry", ["./BoundingSphere", "./Cartesian2", "./Cartesian3", "./Cartographic", "./ComponentDatatype", "./defaultValue", "./defined", "./DeveloperError", "./EllipseGeometryLibrary", "./Ellipsoid", "./GeographicProjection", "./Geometry", "./GeometryAttribute", "./GeometryAttributes", "./GeometryInstance", "./GeometryPipeline", "./IndexDatatype", "./Math", "./Matrix3", "./PrimitiveType", "./Quaternion", "./VertexFormat"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E) {
        "use strict";
        function S(e, n, o) {
            var a = n.vertexFormat, s = n.center, l = n.semiMajorAxis, h = n.semiMinorAxis, p = n.ellipsoid, f = n.stRotation, _ = o ? e.length / 3 * 2 : e.length / 3, v = a.st ? new Float32Array(2 * _) : void 0, y = a.normal ? new Float32Array(3 * _) : void 0, E = a.tangent ? new Float32Array(3 * _) : void 0, S = a.binormal ? new Float32Array(3 * _) : void 0, T = 0, b = L, w = F, x = B, A = new c(p), M = A.project(p.cartesianToCartographic(s, z), V), G = p.scaleToGeodeticSurface(s, P);
            p.geodeticSurfaceNormal(G, G);
            for (var H = C.fromAxisAngle(G, f, N), W = g.fromQuaternion(H, R), q = t.fromElements(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, U), j = t.fromElements(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, k), Y = e.length, X = o ? Y : 0, Z = X / 3 * 2, K = 0; Y > K; K += 3) {
                var J = K + 1, Q = K + 2, $ = i.fromArray(e, K, P);
                if (a.st) {
                    var ee = g.multiplyByVector(W, $, I), te = A.project(p.cartesianToCartographic(ee, z), D);
                    i.subtract(te, M, te), O.x = (te.x + l) / (2 * l), O.y = (te.y + h) / (2 * h), q.x = Math.min(O.x, q.x), q.y = Math.min(O.y, q.y), j.x = Math.max(O.x, j.x), j.y = Math.max(O.y, j.y), o && (v[T + Z] = O.x, v[T + 1 + Z] = O.y), v[T++] = O.x, v[T++] = O.y
                }
                b = p.geodeticSurfaceNormal($, b), (a.normal || a.tangent || a.binormal) && ((a.tangent || a.binormal) && (w = i.cross(i.UNIT_Z, b, w), g.multiplyByVector(W, w, w)), a.normal && (y[K] = b.x, y[J] = b.y, y[Q] = b.z, o && (y[K + X] = -b.x, y[J + X] = -b.y, y[Q + X] = -b.z)), a.tangent && (E[K] = w.x, E[J] = w.y, E[Q] = w.z, o && (E[K + X] = -w.x, E[J + X] = -w.y, E[Q + X] = -w.z)), a.binormal && (x = i.cross(b, w, x), S[K] = x.x, S[J] = x.y, S[Q] = x.z, o && (S[K + X] = x.x, S[J + X] = x.y, S[Q + X] = x.z)))
            }
            if (a.st) {
                Y = v.length;
                for (var ie = 0; Y > ie; ie += 2)v[ie] = (v[ie] - q.x) / (j.x - q.x), v[ie + 1] = (v[ie + 1] - q.y) / (j.y - q.y)
            }
            var ne = new m;
            if (a.position) {
                var re = u.raisePositionsToHeight(e, n, o);
                ne.position = new d({componentDatatype: r.DOUBLE, componentsPerAttribute: 3, values: re})
            }
            return a.st && (ne.st = new d({
                componentDatatype: r.FLOAT,
                componentsPerAttribute: 2,
                values: v
            })), a.normal && (ne.normal = new d({
                componentDatatype: r.FLOAT,
                componentsPerAttribute: 3,
                values: y
            })), a.tangent && (ne.tangent = new d({
                componentDatatype: r.FLOAT,
                componentsPerAttribute: 3,
                values: E
            })), a.binormal && (ne.binormal = new d({
                componentDatatype: r.FLOAT,
                componentsPerAttribute: 3,
                values: S
            })), ne
        }

        function T(e) {
            var t, i, n, r, o, a = new Array(2 * e * (e + 1)), s = 0;
            for (r = 1; e > r; ++r) {
                for (n = r * (r + 1), t = (r - 1) * r, a[s++] = n++, a[s++] = t, a[s++] = n, i = 2 * r, o = 0; i - 1 > o; ++o)a[s++] = n, a[s++] = t++, a[s++] = t, a[s++] = n++, a[s++] = t, a[s++] = n;
                a[s++] = n++, a[s++] = t, a[s++] = n
            }
            for (i = 2 * e, ++n, ++t, r = 0; i - 1 > r; ++r)a[s++] = n, a[s++] = t++, a[s++] = t, a[s++] = n++, a[s++] = t, a[s++] = n;
            for (++t, ++n, r = e - 1; r > 0; --r) {
                for (a[s++] = t++, a[s++] = t, a[s++] = n, i = 2 * r, o = 0; i - 1 > o; ++o)a[s++] = n, a[s++] = t++, a[s++] = t, a[s++] = n++, a[s++] = t, a[s++] = n;
                a[s++] = t++, a[s++] = t++, a[s++] = n++
            }
            return a
        }

        function b(t) {
            var n = t.center;
            G = i.multiplyByScalar(t.ellipsoid.geodeticSurfaceNormal(n, G), t.height, G), G = i.add(n, G, G);
            var r = new e(G, t.semiMajorAxis), o = u.computeEllipsePositions(t, !0, !1), a = o.positions, s = o.numPts, l = S(a, t, !1), c = T(s);
            return c = _.createTypedArray(a.length / 3, c), {boundingSphere: r, attributes: l, indices: c}
        }

        function w(e, n) {
            var o = n.vertexFormat, a = n.center, s = n.semiMajorAxis, u = n.semiMinorAxis, l = n.ellipsoid, h = n.height, p = n.extrudedHeight, f = n.stRotation, _ = e.length / 3 * 2, v = new Float64Array(3 * _), y = o.st ? new Float32Array(2 * _) : void 0, E = o.normal ? new Float32Array(3 * _) : void 0, S = o.tangent ? new Float32Array(3 * _) : void 0, T = o.binormal ? new Float32Array(3 * _) : void 0, b = 0, w = L, x = F, A = B, G = new c(l), H = G.project(l.cartesianToCartographic(a, z), V), W = l.scaleToGeodeticSurface(a, P);
            l.geodeticSurfaceNormal(W, W);
            for (var q = C.fromAxisAngle(W, f, N), j = g.fromQuaternion(q, R), Y = t.fromElements(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, U), X = t.fromElements(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, k), Z = e.length, K = Z / 3 * 2, J = 0; Z > J; J += 3) {
                var Q, $ = J + 1, ee = J + 2, te = i.fromArray(e, J, P);
                if (o.st) {
                    var ie = g.multiplyByVector(j, te, I), ne = G.project(l.cartesianToCartographic(ie, z), D);
                    i.subtract(ne, H, ne), O.x = (ne.x + s) / (2 * s), O.y = (ne.y + u) / (2 * u), Y.x = Math.min(O.x, Y.x), Y.y = Math.min(O.y, Y.y), X.x = Math.max(O.x, X.x), X.y = Math.max(O.y, X.y), y[b + K] = O.x, y[b + 1 + K] = O.y, y[b++] = O.x, y[b++] = O.y
                }
                te = l.scaleToGeodeticSurface(te, te), Q = i.clone(te, I), w = l.geodeticSurfaceNormal(te, w);
                var re = i.multiplyByScalar(w, h, M);
                if (te = i.add(te, re, te), re = i.multiplyByScalar(w, p, re), Q = i.add(Q, re, Q), o.position && (v[J + Z] = Q.x, v[$ + Z] = Q.y, v[ee + Z] = Q.z, v[J] = te.x, v[$] = te.y, v[ee] = te.z), o.normal || o.tangent || o.binormal) {
                    A = i.clone(w, A);
                    var oe = i.fromArray(e, (J + 3) % Z, M);
                    i.subtract(oe, te, oe);
                    var ae = i.subtract(Q, te, D);
                    w = i.normalize(i.cross(ae, oe, w), w), o.normal && (E[J] = w.x, E[$] = w.y, E[ee] = w.z, E[J + Z] = w.x, E[$ + Z] = w.y, E[ee + Z] = w.z), o.tangent && (x = i.normalize(i.cross(A, w, x), x), S[J] = x.x, S[$] = x.y, S[ee] = x.z, S[J + Z] = x.x, S[J + 1 + Z] = x.y, S[J + 2 + Z] = x.z), o.binormal && (T[J] = A.x, T[$] = A.y, T[ee] = A.z, T[J + Z] = A.x, T[$ + Z] = A.y, T[ee + Z] = A.z)
                }
            }
            if (o.st) {
                Z = y.length;
                for (var se = 0; Z > se; se += 2)y[se] = (y[se] - Y.x) / (X.x - Y.x), y[se + 1] = (y[se + 1] - Y.y) / (X.y - Y.y)
            }
            var ue = new m;
            return o.position && (ue.position = new d({
                componentDatatype: r.DOUBLE,
                componentsPerAttribute: 3,
                values: v
            })), o.st && (ue.st = new d({
                componentDatatype: r.FLOAT,
                componentsPerAttribute: 2,
                values: y
            })), o.normal && (ue.normal = new d({
                componentDatatype: r.FLOAT,
                componentsPerAttribute: 3,
                values: E
            })), o.tangent && (ue.tangent = new d({
                componentDatatype: r.FLOAT,
                componentsPerAttribute: 3,
                values: S
            })), o.binormal && (ue.binormal = new d({
                componentDatatype: r.FLOAT,
                componentsPerAttribute: 3,
                values: T
            })), ue
        }

        function x(e) {
            for (var t = e.length / 3, i = _.createTypedArray(t, 6 * t), n = 0, r = 0; t > r; r++) {
                var o = r, a = r + t, s = (o + 1) % t, u = s + t;
                i[n++] = o, i[n++] = a, i[n++] = s, i[n++] = s, i[n++] = a, i[n++] = u
            }
            return i
        }

        function A(t) {
            var n = t.center, r = t.ellipsoid, o = t.semiMajorAxis, a = i.multiplyByScalar(r.geodeticSurfaceNormal(n, P), t.height, P);
            H.center = i.add(n, a, H.center), H.radius = o, a = i.multiplyByScalar(r.geodeticSurfaceNormal(n, a), t.extrudedHeight, a), W.center = i.add(n, a, W.center), W.radius = o;
            var s = u.computeEllipsePositions(t, !0, !0), l = s.positions, c = s.numPts, d = s.outerPositions, m = e.union(H, W), v = S(l, t, !0), g = T(c), C = g.length;
            g.length = 2 * C;
            for (var E = l.length / 3, b = 0; C > b; b += 3)g[b + C] = g[b + 2] + E, g[b + 1 + C] = g[b + 1] + E, g[b + 2 + C] = g[b] + E;
            var A = _.createTypedArray(2 * E / 3, g), I = new h({
                attributes: v,
                indices: A,
                primitiveType: y.TRIANGLES
            }), D = w(d, t);
            g = x(d);
            var M = _.createTypedArray(2 * d.length / 3, g), O = new h({
                attributes: D,
                indices: M,
                primitiveType: y.TRIANGLES
            }), R = f.combineInstances([new p({geometry: I}), new p({geometry: O})]);
            return {boundingSphere: m, attributes: R[0].attributes, indices: R[0].indices}
        }

        var P = new i, I = new i, D = new i, M = new i, O = new t, R = new g, N = new C, L = new i, F = new i, B = new i, z = new n, V = new i, U = new t, k = new t, G = new i, H = new e, W = new e, q = function (e) {
            e = o(e, o.EMPTY_OBJECT);
            var t = e.center, n = o(e.ellipsoid, l.WGS84), r = e.semiMajorAxis, s = e.semiMinorAxis, u = o(e.granularity, v.RADIANS_PER_DEGREE), c = o(e.height, 0), h = e.extrudedHeight, d = a(h) && Math.abs(c - h) > 1, m = o(e.vertexFormat, E.DEFAULT);
            this._center = i.clone(t), this._semiMajorAxis = r, this._semiMinorAxis = s, this._ellipsoid = l.clone(n), this._rotation = o(e.rotation, 0), this._stRotation = o(e.stRotation, 0), this._height = c, this._granularity = u, this._vertexFormat = E.clone(m), this._extrudedHeight = o(h, c), this._extrude = d, this._workerName = "createEllipseGeometry"
        };
        q.packedLength = i.packedLength + l.packedLength + E.packedLength + 8, q.pack = function (e, t, n) {
            n = o(n, 0), i.pack(e._center, t, n), n += i.packedLength, l.pack(e._ellipsoid, t, n), n += l.packedLength, E.pack(e._vertexFormat, t, n), n += E.packedLength, t[n++] = e._semiMajorAxis, t[n++] = e._semiMinorAxis, t[n++] = e._rotation, t[n++] = e._stRotation, t[n++] = e._height, t[n++] = e._granularity, t[n++] = e._extrudedHeight, t[n] = e._extrude ? 1 : 0
        };
        var j = new i, Y = new l, X = new E, Z = {
            center: j,
            ellipsoid: Y,
            vertexFormat: X,
            semiMajorAxis: void 0,
            semiMinorAxis: void 0,
            rotation: void 0,
            stRotation: void 0,
            height: void 0,
            granularity: void 0,
            extrudedHeight: void 0
        };
        return q.unpack = function (e, t, n) {
            t = o(t, 0);
            var r = i.unpack(e, t, j);
            t += i.packedLength;
            var s = l.unpack(e, t, Y);
            t += l.packedLength;
            var u = E.unpack(e, t, X);
            t += E.packedLength;
            var c = e[t++], h = e[t++], d = e[t++], m = e[t++], p = e[t++], f = e[t++], _ = e[t++], v = 1 === e[t];
            return a(n) ? (n._center = i.clone(r, n._center), n._ellipsoid = l.clone(s, n._ellipsoid), n._vertexFormat = E.clone(u, n._vertexFormat), n._semiMajorAxis = c, n._semiMinorAxis = h, n._rotation = d, n._stRotation = m, n._height = p, n._granularity = f, n._extrudedHeight = _, n._extrude = v, n) : (Z.height = p, Z.extrudedHeight = _, Z.granularity = f, Z.stRotation = m, Z.rotation = d, Z.semiMajorAxis = c, Z.semiMinorAxis = h, new q(Z))
        }, q.createGeometry = function (e) {
            e._center = e._ellipsoid.scaleToGeodeticSurface(e._center, e._center);
            var t, i = {
                center: e._center,
                semiMajorAxis: e._semiMajorAxis,
                semiMinorAxis: e._semiMinorAxis,
                ellipsoid: e._ellipsoid,
                rotation: e._rotation,
                height: e._height,
                extrudedHeight: e._extrudedHeight,
                granularity: e._granularity,
                vertexFormat: e._vertexFormat,
                stRotation: e._stRotation
            };
            return e._extrude ? (i.extrudedHeight = Math.min(e._extrudedHeight, e._height), i.height = Math.max(e._extrudedHeight, e._height), t = A(i)) : t = b(i), new h({
                attributes: t.attributes,
                indices: t.indices,
                primitiveType: y.TRIANGLES,
                boundingSphere: t.boundingSphere
            })
        }, q.createShadowVolume = function (e, t, i) {
            var n = e._granularity, r = e._ellipsoid, o = t(n, r), a = i(n, r);
            return new q({
                center: e._center,
                semiMajorAxis: e._semiMajorAxis,
                semiMinorAxis: e._semiMinorAxis,
                ellipsoid: r,
                stRotation: e._stRotation,
                granularity: n,
                extrudedHeight: o,
                height: a,
                vertexFormat: E.POSITION_ONLY
            })
        }, q
    }),define("Cesium/Core/EllipseOutlineGeometry", ["./BoundingSphere", "./Cartesian3", "./ComponentDatatype", "./defaultValue", "./defined", "./DeveloperError", "./EllipseGeometryLibrary", "./Ellipsoid", "./Geometry", "./GeometryAttribute", "./GeometryAttributes", "./IndexDatatype", "./Math", "./PrimitiveType"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m) {
        "use strict";
        function p(n) {
            var r = n.center;
            v = t.multiplyByScalar(n.ellipsoid.geodeticSurfaceNormal(r, v), n.height, v), v = t.add(r, v, v);
            for (var o = new e(v, n.semiMajorAxis), s = a.computeEllipsePositions(n, !1, !0).outerPositions, u = new c({
                position: new l({
                    componentDatatype: i.DOUBLE,
                    componentsPerAttribute: 3,
                    values: a.raisePositionsToHeight(s, n, !1)
                })
            }), d = s.length / 3, m = h.createTypedArray(d, 2 * d), p = 0, f = 0; d > f; ++f)m[p++] = f, m[p++] = (f + 1) % d;
            return {boundingSphere: o, attributes: u, indices: m}
        }

        function f(r) {
            var o = n(r.numberOfVerticalLines, 16);
            o = Math.max(o, 0);
            var s = r.center, u = r.ellipsoid, d = r.semiMajorAxis, m = t.multiplyByScalar(u.geodeticSurfaceNormal(s, _), r.height, _);
            g.center = t.add(s, m, g.center), g.radius = d, m = t.multiplyByScalar(u.geodeticSurfaceNormal(s, m), r.extrudedHeight, m), y.center = t.add(s, m, y.center), y.radius = d;
            var p = a.computeEllipsePositions(r, !1, !0).outerPositions, f = new c({
                position: new l({
                    componentDatatype: i.DOUBLE,
                    componentsPerAttribute: 3,
                    values: a.raisePositionsToHeight(p, r, !0)
                })
            });
            p = f.position.values;
            var v = e.union(g, y), C = p.length / 3, E = h.createTypedArray(C, 2 * C + 2 * o);
            C /= 2;
            var S, T = 0;
            for (S = 0; C > S; ++S)E[T++] = S, E[T++] = (S + 1) % C, E[T++] = S + C, E[T++] = (S + 1) % C + C;
            var b;
            if (o > 0) {
                var w = Math.min(o, C);
                b = Math.round(C / w)
            }
            var x = Math.min(b * o, C);
            if (o > 0)for (S = 0; x > S; S += b)E[T++] = S, E[T++] = S + C;
            return {boundingSphere: v, attributes: f, indices: E}
        }

        var _ = new t, v = new t, g = new e, y = new e, C = function (e) {
            e = n(e, n.EMPTY_OBJECT);
            var i = e.center, o = n(e.ellipsoid, s.WGS84), a = e.semiMajorAxis, u = e.semiMinorAxis, l = n(e.granularity, d.RADIANS_PER_DEGREE), c = n(e.height, 0), h = e.extrudedHeight, m = r(h) && Math.abs(c - h) > 1;
            this._center = t.clone(i), this._semiMajorAxis = a, this._semiMinorAxis = u, this._ellipsoid = s.clone(o), this._rotation = n(e.rotation, 0), this._height = c, this._granularity = l, this._extrudedHeight = h, this._extrude = m, this._numberOfVerticalLines = Math.max(n(e.numberOfVerticalLines, 16), 0), this._workerName = "createEllipseOutlineGeometry"
        };
        C.packedLength = t.packedLength + s.packedLength + 9, C.pack = function (e, i, o) {
            o = n(o, 0), t.pack(e._center, i, o), o += t.packedLength, s.pack(e._ellipsoid, i, o), o += s.packedLength, i[o++] = e._semiMajorAxis, i[o++] = e._semiMinorAxis, i[o++] = e._rotation, i[o++] = e._height, i[o++] = e._granularity, i[o++] = r(e._extrudedHeight) ? 1 : 0, i[o++] = n(e._extrudedHeight, 0), i[o++] = e._extrude ? 1 : 0, i[o] = e._numberOfVerticalLines
        };
        var E = new t, S = new s, T = {
            center: E,
            ellipsoid: S,
            semiMajorAxis: void 0,
            semiMinorAxis: void 0,
            rotation: void 0,
            height: void 0,
            granularity: void 0,
            extrudedHeight: void 0,
            numberOfVerticalLines: void 0
        };
        return C.unpack = function (e, i, o) {
            i = n(i, 0);
            var a = t.unpack(e, i, E);
            i += t.packedLength;
            var u = s.unpack(e, i, S);
            i += s.packedLength;
            var l = e[i++], c = e[i++], h = e[i++], d = e[i++], m = e[i++], p = e[i++], f = e[i++], _ = 1 === e[i++], v = e[i];
            return r(o) ? (o._center = t.clone(a, o._center), o._ellipsoid = s.clone(u, o._ellipsoid), o._semiMajorAxis = l, o._semiMinorAxis = c, o._rotation = h, o._height = d, o._granularity = m, o._extrudedHeight = p ? f : void 0, o._extrude = _, o._numberOfVerticalLines = v, o) : (T.height = d, T.extrudedHeight = p ? f : void 0, T.granularity = m, T.rotation = h, T.semiMajorAxis = l, T.semiMinorAxis = c, T.numberOfVerticalLines = v, new C(T))
        }, C.createGeometry = function (e) {
            e._center = e._ellipsoid.scaleToGeodeticSurface(e._center, e._center);
            var t, i = {
                center: e._center,
                semiMajorAxis: e._semiMajorAxis,
                semiMinorAxis: e._semiMinorAxis,
                ellipsoid: e._ellipsoid,
                rotation: e._rotation,
                height: e._height,
                extrudedHeight: e._extrudedHeight,
                granularity: e._granularity,
                numberOfVerticalLines: e._numberOfVerticalLines
            };
            return e._extrude ? (i.extrudedHeight = Math.min(e._extrudedHeight, e._height), i.height = Math.max(e._extrudedHeight, e._height), t = f(i)) : t = p(i), new u({
                attributes: t.attributes,
                indices: t.indices,
                primitiveType: m.LINES,
                boundingSphere: t.boundingSphere
            })
        }, C
    }),define("Cesium/DataSources/EllipseGeometryUpdater", ["../Core/Color", "../Core/ColorGeometryInstanceAttribute", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/EllipseGeometry", "../Core/EllipseOutlineGeometry", "../Core/Event", "../Core/GeometryInstance", "../Core/Iso8601", "../Core/ShowGeometryInstanceAttribute", "../Scene/MaterialAppearance", "../Scene/PerInstanceColorAppearance", "../Scene/Primitive", "./ColorMaterialProperty", "./ConstantProperty", "./dynamicGeometryGetBoundingSphere", "./MaterialProperty", "./Property"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C) {
        "use strict";
        var E = new _(e.WHITE), S = new v(!0), T = new v(!0), b = new v(!1), w = new v(e.BLACK), x = new e, A = function (e) {
            this.id = e, this.vertexFormat = void 0, this.center = void 0, this.semiMajorAxis = void 0, this.semiMinorAxis = void 0, this.rotation = void 0, this.height = void 0, this.extrudedHeight = void 0, this.granularity = void 0, this.stRotation = void 0, this.numberOfVerticalLines = void 0
        }, P = function (e, t) {
            this._entity = e, this._scene = t, this._entitySubscription = e.definitionChanged.addEventListener(P.prototype._onEntityPropertyChanged, this), this._fillEnabled = !1, this._isClosed = !1, this._dynamic = !1, this._outlineEnabled = !1, this._geometryChanged = new l, this._showProperty = void 0, this._materialProperty = void 0, this._hasConstantOutline = !0, this._showOutlineProperty = void 0, this._outlineColorProperty = void 0, this._outlineWidth = 1, this._options = new A(e), this._onEntityPropertyChanged(e, "ellipse", e.ellipse, void 0)
        };
        r(P, {
            perInstanceColorAppearanceType: {value: p},
            materialAppearanceType: {value: m}
        }), r(P.prototype, {
            entity: {
                get: function () {
                    return this._entity
                }
            }, fillEnabled: {
                get: function () {
                    return this._fillEnabled
                }
            }, hasConstantFill: {
                get: function () {
                    return !this._fillEnabled || !n(this._entity.availability) && C.isConstant(this._showProperty) && C.isConstant(this._fillProperty)
                }
            }, fillMaterialProperty: {
                get: function () {
                    return this._materialProperty
                }
            }, outlineEnabled: {
                get: function () {
                    return this._outlineEnabled
                }
            }, hasConstantOutline: {
                get: function () {
                    return !this._outlineEnabled || !n(this._entity.availability) && C.isConstant(this._showProperty) && C.isConstant(this._showOutlineProperty)
                }
            }, outlineColorProperty: {
                get: function () {
                    return this._outlineColorProperty
                }
            }, outlineWidth: {
                get: function () {
                    return this._outlineWidth
                }
            }, isDynamic: {
                get: function () {
                    return this._dynamic
                }
            }, isClosed: {
                get: function () {
                    return this._isClosed
                }
            }, geometryChanged: {
                get: function () {
                    return this._geometryChanged
                }
            }
        }), P.prototype.isOutlineVisible = function (e) {
            var t = this._entity;
            return this._outlineEnabled && t.isAvailable(e) && this._showProperty.getValue(e) && this._showOutlineProperty.getValue(e)
        }, P.prototype.isFilled = function (e) {
            var t = this._entity;
            return this._fillEnabled && t.isAvailable(e) && this._showProperty.getValue(e) && this._fillProperty.getValue(e)
        }, P.prototype.createFillGeometryInstance = function (i) {
            var r, o, a = this._entity, u = a.isAvailable(i), l = new d(u && a.isShowing && this._showProperty.getValue(i) && this._fillProperty.getValue(i));
            if (this._materialProperty instanceof _) {
                var h = e.WHITE;
                n(this._materialProperty.color) && (this._materialProperty.color.isConstant || u) && (h = this._materialProperty.color.getValue(i)), o = t.fromColor(h), r = {
                    show: l,
                    color: o
                }
            } else r = {show: l};
            return new c({id: a, geometry: new s(this._options), attributes: r})
        }, P.prototype.createOutlineGeometryInstance = function (i) {
            var n = this._entity, r = n.isAvailable(i), o = C.getValueOrDefault(this._outlineColorProperty, i, e.BLACK);
            return new c({
                id: n,
                geometry: new u(this._options),
                attributes: {
                    show: new d(r && n.isShowing && this._showProperty.getValue(i) && this._showOutlineProperty.getValue(i)),
                    color: t.fromColor(o)
                }
            })
        }, P.prototype.isDestroyed = function () {
            return !1
        }, P.prototype.destroy = function () {
            this._entitySubscription(), o(this)
        }, P.prototype._onEntityPropertyChanged = function (e, t, r, o) {
            if ("availability" === t || "position" === t || "ellipse" === t) {
                var a = this._entity.ellipse;
                if (!n(a))return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var s = a.fill, u = n(s) && s.isConstant ? s.getValue(h.MINIMUM_VALUE) : !0, l = a.outline, c = n(l);
                if (c && l.isConstant && (c = l.getValue(h.MINIMUM_VALUE)), !u && !c)return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var d = this._entity.position, f = a.semiMajorAxis, v = a.semiMinorAxis, g = a.show;
                if (n(g) && g.isConstant && !g.getValue(h.MINIMUM_VALUE) || !n(d) || !n(f) || !n(v))return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var y = i(a.material, E), x = y instanceof _;
                this._materialProperty = y, this._fillProperty = i(s, T), this._showProperty = i(g, S), this._showOutlineProperty = i(a.outline, b), this._outlineColorProperty = c ? i(a.outlineColor, w) : void 0;
                var A = a.rotation, P = a.height, I = a.extrudedHeight, D = a.granularity, M = a.stRotation, O = a.outlineWidth, R = a.numberOfVerticalLines;
                if (this._isClosed = n(I), this._fillEnabled = u, this._outlineEnabled = c, d.isConstant && f.isConstant && v.isConstant && C.isConstant(A) && C.isConstant(P) && C.isConstant(I) && C.isConstant(D) && C.isConstant(M) && C.isConstant(O) && C.isConstant(R)) {
                    var N = this._options;
                    N.vertexFormat = x ? p.VERTEX_FORMAT : m.MaterialSupport.TEXTURED.vertexFormat, N.center = d.getValue(h.MINIMUM_VALUE, N.center), N.semiMajorAxis = f.getValue(h.MINIMUM_VALUE, N.semiMajorAxis), N.semiMinorAxis = v.getValue(h.MINIMUM_VALUE, N.semiMinorAxis), N.rotation = n(A) ? A.getValue(h.MINIMUM_VALUE) : void 0, N.height = n(P) ? P.getValue(h.MINIMUM_VALUE) : void 0, N.extrudedHeight = n(I) ? I.getValue(h.MINIMUM_VALUE) : void 0, N.granularity = n(D) ? D.getValue(h.MINIMUM_VALUE) : void 0, N.stRotation = n(M) ? M.getValue(h.MINIMUM_VALUE) : void 0, N.numberOfVerticalLines = n(R) ? R.getValue(h.MINIMUM_VALUE) : void 0, this._outlineWidth = n(O) ? O.getValue(h.MINIMUM_VALUE) : 1, this._dynamic = !1, this._geometryChanged.raiseEvent(this)
                } else this._dynamic || (this._dynamic = !0, this._geometryChanged.raiseEvent(this))
            }
        }, P.prototype.createDynamicUpdater = function (e) {
            return new I(e, this)
        };
        var I = function (e, t) {
            this._primitives = e, this._primitive = void 0, this._outlinePrimitive = void 0, this._geometryUpdater = t, this._options = new A(t._entity)
        };
        return I.prototype.update = function (i) {
            var r = this._primitives;
            r.removeAndDestroy(this._primitive), r.removeAndDestroy(this._outlinePrimitive), this._primitive = void 0, this._outlinePrimitive = void 0;
            var o = this._geometryUpdater, a = o._entity, l = a.ellipse;
            if (a.isShowing && a.isAvailable(i) && C.getValueOrDefault(l.show, i, !0)) {
                var h = this._options, d = C.getValueOrUndefined(a.position, i, h.center), _ = C.getValueOrUndefined(l.semiMajorAxis, i), v = C.getValueOrUndefined(l.semiMinorAxis, i);
                if (n(d) && n(_) && n(v)) {
                    if (h.center = d, h.semiMajorAxis = _, h.semiMinorAxis = v, h.rotation = C.getValueOrUndefined(l.rotation, i), h.height = C.getValueOrUndefined(l.height, i), h.extrudedHeight = C.getValueOrUndefined(l.extrudedHeight, i), h.granularity = C.getValueOrUndefined(l.granularity, i), h.stRotation = C.getValueOrUndefined(l.stRotation, i), h.numberOfVerticalLines = C.getValueOrUndefined(l.numberOfVerticalLines, i), C.getValueOrDefault(l.fill, i, !0)) {
                        var g = y.getValue(i, o.fillMaterialProperty, this._material);
                        this._material = g;
                        var E = new m({material: g, translucent: g.isTranslucent(), closed: n(h.extrudedHeight)});
                        h.vertexFormat = E.vertexFormat, this._primitive = r.add(new f({
                            geometryInstances: new c({
                                id: a,
                                geometry: new s(h)
                            }), appearance: E, asynchronous: !1
                        }))
                    }
                    if (C.getValueOrDefault(l.outline, i, !1)) {
                        h.vertexFormat = p.VERTEX_FORMAT;
                        var S = C.getValueOrClonedDefault(l.outlineColor, i, e.BLACK, x), T = C.getValueOrDefault(l.outlineWidth, i, 1), b = 1 !== S.alpha;
                        this._outlinePrimitive = r.add(new f({
                            geometryInstances: new c({
                                id: a,
                                geometry: new u(h),
                                attributes: {color: t.fromColor(S)}
                            }),
                            appearance: new p({
                                flat: !0,
                                translucent: b,
                                renderState: {lineWidth: o._scene.clampLineWidth(T)}
                            }),
                            asynchronous: !1
                        }))
                    }
                }
            }
        }, I.prototype.getBoundingSphere = function (e, t) {
            return g(e, this._primitive, this._outlinePrimitive, t)
        }, I.prototype.isDestroyed = function () {
            return !1
        }, I.prototype.destroy = function () {
            var e = this._primitives;
            e.removeAndDestroy(this._primitive), e.removeAndDestroy(this._outlinePrimitive), o(this)
        }, P
    }),define("Cesium/Core/EllipsoidGeometry", ["./BoundingSphere", "./Cartesian2", "./Cartesian3", "./ComponentDatatype", "./defaultValue", "./defined", "./DeveloperError", "./Ellipsoid", "./Geometry", "./GeometryAttribute", "./GeometryAttributes", "./IndexDatatype", "./Math", "./PrimitiveType", "./VertexFormat"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p) {
        "use strict";
        var f = new i, _ = new i, v = new i, g = new i, y = new i, C = new i(1, 1, 1), E = Math.cos, S = Math.sin, T = function (e) {
            e = r(e, r.EMPTY_OBJECT);
            var t = r(e.radii, C), n = r(e.stackPartitions, 64), o = r(e.slicePartitions, 64), a = r(e.vertexFormat, p.DEFAULT);
            this._radii = i.clone(t), this._stackPartitions = n, this._slicePartitions = o, this._vertexFormat = p.clone(a), this._workerName = "createEllipsoidGeometry"
        };
        T.packedLength = i.packedLength + p.packedLength + 2, T.pack = function (e, t, n) {
            n = r(n, 0), i.pack(e._radii, t, n), n += i.packedLength, p.pack(e._vertexFormat, t, n), n += p.packedLength, t[n++] = e._stackPartitions, t[n] = e._slicePartitions
        };
        var b = new i, w = new p, x = {radii: b, vertexFormat: w, stackPartitions: void 0, slicePartitions: void 0};
        return T.unpack = function (e, t, n) {
            t = r(t, 0);
            var a = i.unpack(e, t, b);
            t += i.packedLength;
            var s = p.unpack(e, t, w);
            t += p.packedLength;
            var u = e[t++], l = e[t];
            return o(n) ? (n._radii = i.clone(a, n._radii), n._vertexFormat = p.clone(s, n._vertexFormat), n._stackPartitions = u, n._slicePartitions = l, n) : (x.stackPartitions = u, x.slicePartitions = l, new T(x))
        }, T.createGeometry = function (r) {
            var o, a, p = r._radii, C = s.fromCartesian3(p), T = r._vertexFormat, b = r._slicePartitions + 1, w = r._stackPartitions + 1, x = w * b, A = new Float64Array(3 * x), P = 6 * (b - 1) * (w - 1), I = h.createTypedArray(x, P), D = T.normal ? new Float32Array(3 * x) : void 0, M = T.tangent ? new Float32Array(3 * x) : void 0, O = T.binormal ? new Float32Array(3 * x) : void 0, R = T.st ? new Float32Array(2 * x) : void 0, N = new Array(b), L = new Array(b), F = 0;
            for (o = 0; b > o; o++) {
                var B = d.TWO_PI * o / (b - 1);
                N[o] = E(B), L[o] = S(B), A[F++] = 0, A[F++] = 0, A[F++] = p.z
            }
            for (o = 1; w - 1 > o; o++) {
                var z = Math.PI * o / (w - 1), V = S(z), U = p.x * V, k = p.y * V, G = p.z * E(z);
                for (a = 0; b > a; a++)A[F++] = N[a] * U, A[F++] = L[a] * k, A[F++] = G
            }
            for (o = 0; b > o; o++)A[F++] = 0, A[F++] = 0, A[F++] = -p.z;
            var H = new c;
            T.position && (H.position = new l({componentDatatype: n.DOUBLE, componentsPerAttribute: 3, values: A}));
            var W = 0, q = 0, j = 0, Y = 0;
            if (T.st || T.normal || T.tangent || T.binormal) {
                for (o = 0; x > o; o++) {
                    var X = i.fromArray(A, 3 * o, f), Z = C.geodeticSurfaceNormal(X, _);
                    if (T.st) {
                        var K = t.negate(Z, y);
                        t.magnitude(K) < d.EPSILON6 && (F = 3 * (o + b * Math.floor(.5 * w)), F > A.length && (F = 3 * (o - b * Math.floor(.5 * w))), i.fromArray(A, F, K), C.geodeticSurfaceNormal(K, K), t.negate(K, K)), R[W++] = Math.atan2(K.y, K.x) / d.TWO_PI + .5, R[W++] = Math.asin(Z.z) / Math.PI + .5
                    }
                    if (T.normal && (D[q++] = Z.x, D[q++] = Z.y, D[q++] = Z.z), T.tangent || T.binormal) {
                        var J = v;
                        if (b > o || o > x - b - 1 ? (i.cross(i.UNIT_X, Z, J), i.normalize(J, J)) : (i.cross(i.UNIT_Z, Z, J), i.normalize(J, J)), T.tangent && (M[j++] = J.x, M[j++] = J.y, M[j++] = J.z), T.binormal) {
                            var Q = i.cross(Z, J, g);
                            i.normalize(Q, Q), O[Y++] = Q.x, O[Y++] = Q.y, O[Y++] = Q.z
                        }
                    }
                }
                T.st && (H.st = new l({
                    componentDatatype: n.FLOAT,
                    componentsPerAttribute: 2,
                    values: R
                })), T.normal && (H.normal = new l({
                    componentDatatype: n.FLOAT,
                    componentsPerAttribute: 3,
                    values: D
                })), T.tangent && (H.tangent = new l({
                    componentDatatype: n.FLOAT,
                    componentsPerAttribute: 3,
                    values: M
                })), T.binormal && (H.binormal = new l({
                    componentDatatype: n.FLOAT,
                    componentsPerAttribute: 3,
                    values: O
                }))
            }
            for (F = 0, o = 0; w > o; o++) {
                var $ = o * b, ee = (o + 1) * b;
                for (a = 0; b - 1 > a; a++)I[F++] = ee + a, I[F++] = ee + a + 1, I[F++] = $ + a + 1, I[F++] = ee + a, I[F++] = $ + a + 1, I[F++] = $ + a
            }
            return new u({attributes: H, indices: I, primitiveType: m.TRIANGLES, boundingSphere: e.fromEllipsoid(C)})
        }, T
    }),define("Cesium/Core/EllipsoidOutlineGeometry", ["./BoundingSphere", "./Cartesian3", "./ComponentDatatype", "./defaultValue", "./defined", "./DeveloperError", "./Ellipsoid", "./Geometry", "./GeometryAttribute", "./GeometryAttributes", "./IndexDatatype", "./Math", "./PrimitiveType"], function (e, t, i, n, r, o, a, s, u, l, c, h, d) {
        "use strict";
        var m = new t(1, 1, 1), p = Math.cos, f = Math.sin, _ = function (e) {
            e = n(e, n.EMPTY_OBJECT);
            var i = n(e.radii, m), r = n(e.stackPartitions, 10), o = n(e.slicePartitions, 8), a = n(e.subdivisions, 128);
            this._radii = t.clone(i), this._stackPartitions = r, this._slicePartitions = o, this._subdivisions = a, this._workerName = "createEllipsoidOutlineGeometry"
        };
        _.packedLength = t.packedLength + 3, _.pack = function (e, i, r) {
            r = n(r, 0), t.pack(e._radii, i, r), r += t.packedLength, i[r++] = e._stackPartitions, i[r++] = e._slicePartitions, i[r] = e._subdivisions
        };
        var v = new t, g = {radii: v, stackPartitions: void 0, slicePartitions: void 0, subdivisions: void 0};
        return _.unpack = function (e, i, o) {
            i = n(i, 0);
            var a = t.unpack(e, i, v);
            i += t.packedLength;
            var s = e[i++], u = e[i++], l = e[i++];
            return r(o) ? (o._radii = t.clone(a, o._radii), o._stackPartitions = s, o._slicePartitions = u, o._subdivisions = l, o) : (g.stackPartitions = s, g.slicePartitions = u, g.subdivisions = l, new _(g))
        }, _.createGeometry = function (t) {
            var n, r, o, m, _, v, g = t._radii, y = a.fromCartesian3(g), C = t._stackPartitions, E = t._slicePartitions, S = t._subdivisions, T = S * (C + E - 1), b = T - E + 2, w = new Float64Array(3 * b), x = c.createTypedArray(b, 2 * T), A = 0, P = new Array(S), I = new Array(S);
            for (n = 0; S > n; n++)o = h.TWO_PI * n / S, P[n] = p(o), I[n] = f(o);
            for (n = 1; C > n; n++)for (m = Math.PI * n / C, _ = p(m), v = f(m), r = 0; S > r; r++)w[A++] = g.x * P[r] * v, w[A++] = g.y * I[r] * v, w[A++] = g.z * _;
            for (P.length = E, I.length = E, n = 0; E > n; n++)o = h.TWO_PI * n / E, P[n] = p(o), I[n] = f(o);
            for (w[A++] = 0, w[A++] = 0, w[A++] = g.z, n = 1; S > n; n++)for (m = Math.PI * n / S, _ = p(m), v = f(m), r = 0; E > r; r++)w[A++] = g.x * P[r] * v, w[A++] = g.y * I[r] * v, w[A++] = g.z * _;
            for (w[A++] = 0, w[A++] = 0, w[A++] = -g.z, A = 0, n = 0; C - 1 > n; ++n) {
                var D = n * S;
                for (r = 0; S - 1 > r; ++r)x[A++] = D + r, x[A++] = D + r + 1;
                x[A++] = D + S - 1, x[A++] = D
            }
            var M = S * (C - 1);
            for (r = 1; E + 1 > r; ++r)x[A++] = M, x[A++] = M + r;
            for (n = 0; S - 2 > n; ++n) {
                var O = n * E + 1 + M, R = (n + 1) * E + 1 + M;
                for (r = 0; E - 1 > r; ++r)x[A++] = R + r, x[A++] = O + r;
                x[A++] = R + E - 1, x[A++] = O + E - 1
            }
            var N = w.length / 3 - 1;
            for (r = N - 1; r > N - E - 1; --r)x[A++] = N, x[A++] = r;
            var L = new l({position: new u({componentDatatype: i.DOUBLE, componentsPerAttribute: 3, values: w})});
            return new s({attributes: L, indices: x, primitiveType: d.LINES, boundingSphere: e.fromEllipsoid(y)})
        }, _
    }),define("Cesium/DataSources/EllipsoidGeometryUpdater", ["../Core/Cartesian3", "../Core/Color", "../Core/ColorGeometryInstanceAttribute", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/EllipsoidGeometry", "../Core/EllipsoidOutlineGeometry", "../Core/Event", "../Core/GeometryInstance", "../Core/Iso8601", "../Core/Matrix4", "../Core/ShowGeometryInstanceAttribute", "../Scene/MaterialAppearance", "../Scene/PerInstanceColorAppearance", "../Scene/Primitive", "../Scene/SceneMode", "./ColorMaterialProperty", "./ConstantProperty", "./dynamicGeometryGetBoundingSphere", "./MaterialProperty", "./Property"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S, T) {
        "use strict";
        var b = new y(t.WHITE), w = new C(!0), x = new C(!0), A = new C(!1), P = new C(t.BLACK), I = new e, D = new t, M = new e(1, 1, 1), O = function (e) {
            this.id = e, this.vertexFormat = void 0, this.radii = void 0, this.stackPartitions = void 0, this.slicePartitions = void 0, this.subdivisions = void 0
        }, R = function (e, t) {
            this._scene = t, this._entity = e, this._entitySubscription = e.definitionChanged.addEventListener(R.prototype._onEntityPropertyChanged, this), this._fillEnabled = !1, this._dynamic = !1, this._outlineEnabled = !1, this._geometryChanged = new c, this._showProperty = void 0, this._materialProperty = void 0, this._hasConstantOutline = !0, this._showOutlineProperty = void 0, this._outlineColorProperty = void 0, this._outlineWidth = 1, this._options = new O(e), this._onEntityPropertyChanged(e, "ellipsoid", e.ellipsoid, void 0)
        };
        o(R, {
            perInstanceColorAppearanceType: {value: _},
            materialAppearanceType: {value: f}
        }), o(R.prototype, {
            entity: {
                get: function () {
                    return this._entity
                }
            }, fillEnabled: {
                get: function () {
                    return this._fillEnabled
                }
            }, hasConstantFill: {
                get: function () {
                    return !this._fillEnabled || !r(this._entity.availability) && T.isConstant(this._showProperty) && T.isConstant(this._fillProperty)
                }
            }, fillMaterialProperty: {
                get: function () {
                    return this._materialProperty
                }
            }, outlineEnabled: {
                get: function () {
                    return this._outlineEnabled
                }
            }, hasConstantOutline: {
                get: function () {
                    return !this._outlineEnabled || !r(this._entity.availability) && T.isConstant(this._showProperty) && T.isConstant(this._showOutlineProperty)
                }
            }, outlineColorProperty: {
                get: function () {
                    return this._outlineColorProperty
                }
            }, outlineWidth: {
                get: function () {
                    return this._outlineWidth
                }
            }, isDynamic: {
                get: function () {
                    return this._dynamic
                }
            }, isClosed: {value: !0}, geometryChanged: {
                get: function () {
                    return this._geometryChanged
                }
            }
        }), R.prototype.isOutlineVisible = function (e) {
            var t = this._entity;
            return this._outlineEnabled && t.isAvailable(e) && this._showProperty.getValue(e) && this._showOutlineProperty.getValue(e)
        }, R.prototype.isFilled = function (e) {
            var t = this._entity;
            return this._fillEnabled && t.isAvailable(e) && this._showProperty.getValue(e) && this._fillProperty.getValue(e)
        }, R.prototype.createFillGeometryInstance = function (e) {
            var n, o, a = this._entity, s = a.isAvailable(e), l = new p(s && a.isShowing && this._showProperty.getValue(e) && this._fillProperty.getValue(e));
            if (this._materialProperty instanceof y) {
                var c = t.WHITE;
                r(this._materialProperty.color) && (this._materialProperty.color.isConstant || s) && (c = this._materialProperty.color.getValue(e)), o = i.fromColor(c), n = {
                    show: l,
                    color: o
                }
            } else n = {show: l};
            return new h({
                id: a,
                geometry: new u(this._options),
                modelMatrix: a._getModelMatrix(d.MINIMUM_VALUE),
                attributes: n
            })
        }, R.prototype.createOutlineGeometryInstance = function (e) {
            var n = this._entity, r = n.isAvailable(e), o = T.getValueOrDefault(this._outlineColorProperty, e, t.BLACK);
            return new h({
                id: n,
                geometry: new l(this._options),
                modelMatrix: n._getModelMatrix(d.MINIMUM_VALUE),
                attributes: {
                    show: new p(r && n.isShowing && this._showProperty.getValue(e) && this._showOutlineProperty.getValue(e)),
                    color: i.fromColor(o)
                }
            })
        }, R.prototype.isDestroyed = function () {
            return !1
        }, R.prototype.destroy = function () {
            this._entitySubscription(), a(this)
        }, R.prototype._onEntityPropertyChanged = function (e, t, i, o) {
            if ("availability" === t || "position" === t || "orientation" === t || "ellipsoid" === t) {
                var a = e.ellipsoid;
                if (!r(a))return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var s = a.fill, u = r(s) && s.isConstant ? s.getValue(d.MINIMUM_VALUE) : !0, l = a.outline, c = r(l);
                if (c && l.isConstant && (c = l.getValue(d.MINIMUM_VALUE)), !u && !c)return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var h = e.position, m = a.radii, p = a.show;
                if (r(p) && p.isConstant && !p.getValue(d.MINIMUM_VALUE) || !r(h) || !r(m))return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var v = n(a.material, b), g = v instanceof y;
                this._materialProperty = v, this._fillProperty = n(s, x), this._showProperty = n(p, w), this._showOutlineProperty = n(a.outline, A), this._outlineColorProperty = c ? n(a.outlineColor, P) : void 0, this._fillEnabled = u, this._outlineEnabled = c;
                var C = a.stackPartitions, E = a.slicePartitions, S = a.outlineWidth, I = a.subdivisions;
                if (h.isConstant && T.isConstant(e.orientation) && m.isConstant && T.isConstant(C) && T.isConstant(E) && T.isConstant(S) && T.isConstant(I)) {
                    var D = this._options;
                    D.vertexFormat = g ? _.VERTEX_FORMAT : f.MaterialSupport.TEXTURED.vertexFormat, D.radii = m.getValue(d.MINIMUM_VALUE, D.radii), D.stackPartitions = r(C) ? C.getValue(d.MINIMUM_VALUE) : void 0, D.slicePartitions = r(E) ? E.getValue(d.MINIMUM_VALUE) : void 0, D.subdivisions = r(I) ? I.getValue(d.MINIMUM_VALUE) : void 0, this._outlineWidth = r(S) ? S.getValue(d.MINIMUM_VALUE) : 1, this._dynamic = !1, this._geometryChanged.raiseEvent(this)
                } else this._dynamic || (this._dynamic = !0, this._geometryChanged.raiseEvent(this))
            }
        }, R.prototype.createDynamicUpdater = function (e) {
            return new N(e, this)
        };
        var N = function (e, t) {
            this._entity = t._entity, this._scene = t._scene, this._primitives = e, this._primitive = void 0, this._outlinePrimitive = void 0, this._geometryUpdater = t, this._options = new O(t._entity), this._modelMatrix = new m, this._material = void 0, this._attributes = void 0, this._outlineAttributes = void 0, this._lastSceneMode = void 0, this._lastShow = void 0, this._lastOutlineShow = void 0, this._lastOutlineWidth = void 0, this._lastOutlineColor = void 0
        };
        return N.prototype.update = function (e) {
            var o = this._entity, a = o.ellipsoid;
            if (!o.isShowing || !o.isAvailable(e) || !T.getValueOrDefault(a.show, e, !0))return r(this._primitive) && (this._primitive.show = !1), void(r(this._outlinePrimitive) && (this._outlinePrimitive.show = !1));
            var s = T.getValueOrUndefined(a.radii, e, I), c = o._getModelMatrix(e, this._modelMatrix);
            if (!r(c) || !r(s))return r(this._primitive) && (this._primitive.show = !1), void(r(this._outlinePrimitive) && (this._outlinePrimitive.show = !1));
            var d, y = T.getValueOrDefault(a.fill, e, !0), C = T.getValueOrDefault(a.outline, e, !1), E = T.getValueOrClonedDefault(a.outlineColor, e, t.BLACK, D), w = S.getValue(e, n(a.material, b), this._material);
            this._material = w;
            var x = T.getValueOrUndefined(a.stackPartitions, e), A = T.getValueOrUndefined(a.slicePartitions, e), P = T.getValueOrUndefined(a.subdivisions, e), O = T.getValueOrDefault(a.outlineWidth, e, 1), R = this._scene.mode, N = R === g.SCENE3D, L = this._options, F = !N || this._lastSceneMode !== R || !r(this._primitive) || L.stackPartitions !== x || L.slicePartitions !== A || L.subdivisions !== P || this._lastOutlineWidth !== O;
            if (F) {
                var B = this._primitives;
                B.removeAndDestroy(this._primitive), B.removeAndDestroy(this._outlinePrimitive), this._primitive = void 0, this._outlinePrimitive = void 0, this._lastSceneMode = R, this._lastOutlineWidth = O, L.stackPartitions = x, L.slicePartitions = A, L.subdivisions = P, L.radii = N ? M : s, d = new f({
                    material: w,
                    translucent: w.isTranslucent(),
                    closed: !0
                }), L.vertexFormat = d.vertexFormat, this._primitive = B.add(new v({
                    geometryInstances: new h({
                        id: o,
                        geometry: new u(L),
                        modelMatrix: N ? void 0 : c,
                        attributes: {show: new p(y)}
                    }), appearance: d, asynchronous: !1
                })), L.vertexFormat = _.VERTEX_FORMAT, this._outlinePrimitive = B.add(new v({
                    geometryInstances: new h({
                        id: o,
                        geometry: new l(L),
                        modelMatrix: N ? void 0 : c,
                        attributes: {show: new p(C), color: i.fromColor(E)}
                    }),
                    appearance: new _({
                        flat: !0,
                        translucent: 1 !== E.alpha,
                        renderState: {lineWidth: this._geometryUpdater._scene.clampLineWidth(O)}
                    }),
                    asynchronous: !1
                })), this._lastShow = y, this._lastOutlineShow = C, this._lastOutlineColor = t.clone(E, this._lastOutlineColor)
            } else if (this._primitive.ready) {
                var z = this._primitive, V = this._outlinePrimitive;
                z.show = !0, V.show = !0, d = z.appearance, d.material = w;
                var U = this._attributes;
                r(U) || (U = z.getGeometryInstanceAttributes(o), this._attributes = U), y !== this._lastShow && (U.show = p.toValue(y, U.show), this._lastShow = y);
                var k = this._outlineAttributes;
                r(k) || (k = V.getGeometryInstanceAttributes(o), this._outlineAttributes = k), C !== this._lastOutlineShow && (k.show = p.toValue(C, k.show), this._lastOutlineShow = C), t.equals(E, this._lastOutlineColor) || (k.color = i.toValue(E, k.color), t.clone(E, this._lastOutlineColor))
            }
            N && (s.x = Math.max(s.x, .001), s.y = Math.max(s.y, .001), s.z = Math.max(s.z, .001), c = m.multiplyByScale(c, s, c), this._primitive.modelMatrix = c, this._outlinePrimitive.modelMatrix = c)
        }, N.prototype.getBoundingSphere = function (e, t) {
            return E(e, this._primitive, this._outlinePrimitive, t)
        }, N.prototype.isDestroyed = function () {
            return !1
        }, N.prototype.destroy = function () {
            var e = this._primitives;
            e.removeAndDestroy(this._primitive), e.removeAndDestroy(this._outlinePrimitive), a(this)
        }, R
    }),define("Cesium/DataSources/StaticGeometryColorBatch", ["../Core/AssociativeArray", "../Core/Color", "../Core/ColorGeometryInstanceAttribute", "../Core/defined", "../Core/ShowGeometryInstanceAttribute", "../Scene/Primitive", "./BoundingSphereState"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = new t, u = function (t, i, n, r) {
            this.translucent = i, this.appearanceType = n, this.closed = r, this.primitives = t, this.createPrimitive = !1, this.primitive = void 0, this.oldPrimitive = void 0, this.geometry = new e, this.updaters = new e, this.updatersWithAttributes = new e, this.attributes = new e, this.subscriptions = new e, this.showsUpdated = new e, this.itemsToRemove = []
        };
        u.prototype.add = function (e, t) {
            var i = e.entity.id;
            if (this.createPrimitive = !0, this.geometry.set(i, t), this.updaters.set(i, e), e.hasConstantFill && e.fillMaterialProperty.isConstant) {
                var n = this;
                this.subscriptions.set(i, e.entity.definitionChanged.addEventListener(function (t, i, r, o) {
                    "isShowing" === i && n.showsUpdated.set(t.id, e)
                }))
            } else this.updatersWithAttributes.set(i, e)
        }, u.prototype.remove = function (e) {
            var t = e.entity.id;
            if (this.createPrimitive = this.geometry.remove(t) || this.createPrimitive, this.updaters.remove(t)) {
                this.updatersWithAttributes.remove(t);
                var i = this.subscriptions.get(t);
                n(i) && (i(), this.subscriptions.remove(t))
            }
        }, u.prototype.update = function (e) {
            var a, u, l = !0, c = 0, h = this.primitive, d = this.primitives;
            if (this.createPrimitive) {
                var m = this.geometry.values, p = m.length;
                if (p > 0) {
                    for (n(h) && (n(this.oldPrimitive) ? d.remove(h) : this.oldPrimitive = h), u = 0; p > u; u++) {
                        var f = m[u], _ = f.attributes;
                        a = this.attributes.get(f.id.id), n(a) && (n(_.show) && (_.show.value = a.show), n(_.color) && (_.color.value = a.color))
                    }
                    h = new o({
                        asynchronous: !0,
                        geometryInstances: m,
                        appearance: new this.appearanceType({translucent: this.translucent, closed: this.closed})
                    }), d.add(h), l = !1
                } else {
                    n(h) && (d.remove(h), h = void 0);
                    var v = this.oldPrimitive;
                    n(v) && (d.remove(v), this.oldPrimitive = void 0)
                }
                this.attributes.removeAll(), this.primitive = h, this.createPrimitive = !1
            } else if (n(h) && h.ready) {
                n(this.oldPrimitive) && (d.remove(this.oldPrimitive), this.oldPrimitive = void 0);
                var g = this.updatersWithAttributes.values, y = g.length;
                for (u = 0; y > u; u++) {
                    var C = g[u], E = this.geometry.get(C.entity.id);
                    if (a = this.attributes.get(E.id.id), n(a) || (a = h.getGeometryInstanceAttributes(E.id), this.attributes.set(E.id.id, a)), !C.fillMaterialProperty.isConstant) {
                        var S = C.fillMaterialProperty.color;
                        S.getValue(e, s), t.equals(a._lastColor, s) || (a._lastColor = t.clone(s, a._lastColor), a.color = i.toValue(s, a.color), (this.translucent && 255 === a.color[3] || !this.translucent && 255 !== a.color[3]) && (this.itemsToRemove[c++] = C))
                    }
                    var T = C.entity.isShowing && (C.hasConstantFill || C.isFilled(e)), b = 1 === a.show[0];
                    T !== b && (a.show = r.toValue(T, a.show))
                }
                this.updateShows(h)
            } else n(h) && !h.ready && (l = !1);
            return this.itemsToRemove.length = c, l
        }, u.prototype.updateShows = function (e) {
            for (var t = this.showsUpdated.values, i = t.length, o = 0; i > o; o++) {
                var a = t[o], s = this.geometry.get(a.entity.id), u = this.attributes.get(s.id.id);
                n(u) || (u = e.getGeometryInstanceAttributes(s.id), this.attributes.set(s.id.id, u));
                var l = a.entity.isShowing, c = 1 === u.show[0];
                l !== c && (u.show = r.toValue(l, u.show))
            }
            this.showsUpdated.removeAll()
        }, u.prototype.contains = function (e) {
            return this.updaters.contains(e.id)
        }, u.prototype.getBoundingSphere = function (e, t) {
            var i = this.primitive;
            if (!i.ready)return a.PENDING;
            var r = i.getGeometryInstanceAttributes(e);
            return !n(r) || !n(r.boundingSphere) || n(r.show) && 0 === r.show[0] ? a.FAILED : (r.boundingSphere.clone(t), a.DONE)
        }, u.prototype.removeAllPrimitives = function () {
            var e = this.primitives, t = this.primitive;
            n(t) && (e.remove(t), this.primitive = void 0, this.geometry.removeAll(), this.updaters.removeAll());
            var i = this.oldPrimitive;
            n(i) && (e.remove(i), this.oldPrimitive = void 0)
        };
        var l = function (e, t, i) {
            this._solidBatch = new u(e, !1, t, i), this._translucentBatch = new u(e, !0, t, i)
        };
        return l.prototype.add = function (e, t) {
            var i = t.createFillGeometryInstance(e);
            255 === i.attributes.color.value[3] ? this._solidBatch.add(t, i) : this._translucentBatch.add(t, i)
        }, l.prototype.remove = function (e) {
            this._solidBatch.remove(e) || this._translucentBatch.remove(e)
        }, l.prototype.update = function (e) {
            var t, i, n = this._solidBatch.update(e);
            n = this._translucentBatch.update(e) && n;
            var r = this._solidBatch.itemsToRemove, o = r.length;
            if (o > 0)for (t = 0; o > t; t++)i = r[t], this._solidBatch.remove(i), this._translucentBatch.add(i, i.createFillGeometryInstance(e));
            r = this._translucentBatch.itemsToRemove;
            var a = r.length;
            if (a > 0)for (t = 0; a > t; t++)i = r[t], this._translucentBatch.remove(i), this._solidBatch.add(i, i.createFillGeometryInstance(e));
            return (o > 0 || a > 0) && (n = this._solidBatch.update(e) && n, n = this._translucentBatch.update(e) && n), n
        }, l.prototype.getBoundingSphere = function (e, t) {
            return this._solidBatch.contains(e) ? this._solidBatch.getBoundingSphere(e, t) : this._translucentBatch.contains(e) ? this._translucentBatch.getBoundingSphere(e, t) : a.FAILED
        }, l.prototype.removeAllPrimitives = function () {
            this._solidBatch.removeAllPrimitives(), this._translucentBatch.removeAllPrimitives()
        }, l
    }),define("Cesium/DataSources/StaticGeometryPerMaterialBatch", ["../Core/AssociativeArray", "../Core/defined", "../Core/ShowGeometryInstanceAttribute", "../Scene/Primitive", "./BoundingSphereState", "./MaterialProperty"], function (e, t, i, n, r, o) {
        "use strict";
        var a = function (t, i, n, r) {
            this.primitives = t, this.appearanceType = i, this.materialProperty = n, this.closed = r, this.updaters = new e, this.createPrimitive = !0, this.primitive = void 0, this.oldPrimitive = void 0, this.geometry = new e, this.material = void 0, this.updatersWithAttributes = new e, this.attributes = new e, this.invalidated = !1, this.removeMaterialSubscription = n.definitionChanged.addEventListener(a.prototype.onMaterialChanged, this), this.subscriptions = new e, this.showsUpdated = new e
        };
        a.prototype.onMaterialChanged = function () {
            this.invalidated = !0
        }, a.prototype.isMaterial = function (e) {
            var i = this.materialProperty, n = e.fillMaterialProperty;
            return n === i ? !0 : t(i) ? i.equals(n) : !1
        }, a.prototype.add = function (e, t) {
            var i = t.entity.id;
            if (this.updaters.set(i, t), this.geometry.set(i, t.createFillGeometryInstance(e)), t.hasConstantFill && t.fillMaterialProperty.isConstant) {
                var n = this;
                this.subscriptions.set(i, t.entity.definitionChanged.addEventListener(function (e, i, r, o) {
                    "isShowing" === i && n.showsUpdated.set(e.id, t)
                }))
            } else this.updatersWithAttributes.set(i, t);
            this.createPrimitive = !0
        }, a.prototype.remove = function (e) {
            var i = e.entity.id, n = this.updaters.remove(i);
            if (n) {
                this.geometry.remove(i), this.updatersWithAttributes.remove(i);
                var r = this.subscriptions.get(i);
                t(r) && (r(), this.subscriptions.remove(i))
            }
            return this.createPrimitive = n, n
        }, a.prototype.update = function (e) {
            var r, a, s = !0, u = this.primitive, l = this.primitives, c = this.geometry.values;
            if (this.createPrimitive) {
                var h = c.length;
                if (h > 0) {
                    for (t(u) && (t(this.oldPrimitive) ? l.remove(u) : this.oldPrimitive = u), a = 0; h > a; a++) {
                        var d = c[a], m = d.attributes;
                        r = this.attributes.get(d.id.id), t(r) && (t(m.show) && (m.show.value = r.show), t(m.color) && (m.color.value = r.color))
                    }
                    this.material = o.getValue(e, this.materialProperty, this.material), u = new n({
                        asynchronous: !0,
                        geometryInstances: c,
                        appearance: new this.appearanceType({
                            material: this.material,
                            translucent: this.material.isTranslucent(),
                            closed: this.closed
                        })
                    }), l.add(u), s = !1
                } else {
                    t(u) && (l.remove(u), u = void 0);
                    var p = this.oldPrimitive;
                    t(p) && (l.remove(p), this.oldPrimitive = void 0)
                }
                this.attributes.removeAll(), this.primitive = u, this.createPrimitive = !1
            } else if (t(u) && u.ready) {
                t(this.oldPrimitive) && (l.remove(this.oldPrimitive), this.oldPrimitive = void 0), this.material = o.getValue(e, this.materialProperty, this.material), this.primitive.appearance.material = this.material;
                var f = this.updatersWithAttributes.values, _ = f.length;
                for (a = 0; _ > a; a++) {
                    var v = f[a], g = v.entity, y = this.geometry.get(g.id);
                    r = this.attributes.get(y.id.id), t(r) || (r = u.getGeometryInstanceAttributes(y.id), this.attributes.set(y.id.id, r));
                    var C = g.isShowing && (v.hasConstantFill || v.isFilled(e)), E = 1 === r.show[0];
                    C !== E && (r.show = i.toValue(C, r.show))
                }
                this.updateShows(u)
            } else t(u) && !u.ready && (s = !1);
            return s
        }, a.prototype.updateShows = function (e) {
            for (var n = this.showsUpdated.values, r = n.length, o = 0; r > o; o++) {
                var a = n[o], s = a.entity, u = this.geometry.get(s.id), l = this.attributes.get(u.id.id);
                t(l) || (l = e.getGeometryInstanceAttributes(u.id), this.attributes.set(u.id.id, l));
                var c = s.isShowing, h = 1 === l.show[0];
                c !== h && (l.show = i.toValue(c, l.show))
            }
            this.showsUpdated.removeAll()
        }, a.prototype.contains = function (e) {
            return this.updaters.contains(e.id)
        }, a.prototype.getBoundingSphere = function (e, i) {
            var n = this.primitive;
            if (!n.ready)return r.PENDING;
            var o = n.getGeometryInstanceAttributes(e);
            return !t(o) || !t(o.boundingSphere) || t(o.show) && 0 === o.show[0] ? r.FAILED : (o.boundingSphere.clone(i), r.DONE)
        }, a.prototype.destroy = function (e) {
            var i = this.primitive, n = this.primitives;
            t(i) && n.remove(i);
            var r = this.oldPrimitive;
            t(r) && n.remove(r), this.removeMaterialSubscription()
        };
        var s = function (e, t, i) {
            this._items = [], this._primitives = e, this._appearanceType = t, this._closed = i
        };
        return s.prototype.add = function (e, t) {
            for (var i = this._items, n = i.length, r = 0; n > r; r++) {
                var o = i[r];
                if (o.isMaterial(t))return void o.add(e, t)
            }
            var s = new a(this._primitives, this._appearanceType, t.fillMaterialProperty, this._closed);
            s.add(e, t), i.push(s)
        }, s.prototype.remove = function (e) {
            for (var t = this._items, i = t.length, n = i - 1; n >= 0; n--) {
                var r = t[n];
                if (r.remove(e)) {
                    0 === r.updaters.length && (t.splice(n, 1), r.destroy());
                    break
                }
            }
        }, s.prototype.update = function (e) {
            var t, i = this._items, n = i.length;
            for (t = n - 1; t >= 0; t--) {
                var r = i[t];
                if (r.invalidated) {
                    i.splice(t, 1);
                    for (var o = r.updaters.values, a = o.length, s = 0; a > s; s++)this.add(e, o[s]);
                    r.destroy()
                }
            }
            var u = !0;
            for (t = 0; n > t; t++)u = i[t].update(e) && u;
            return u
        }, s.prototype.getBoundingSphere = function (e, t) {
            for (var i = this._items, n = i.length, o = 0; n > o; o++) {
                var a = i[o];
                if (a.contains(e))return a.getBoundingSphere(e, t)
            }
            return r.FAILED
        }, s.prototype.removeAllPrimitives = function () {
            for (var e = this._items, t = e.length, i = 0; t > i; i++)e[i].destroy();
            this._items.length = 0
        }, s
    }),define("Cesium/DataSources/StaticOutlineGeometryBatch", ["../Core/AssociativeArray", "../Core/Color", "../Core/ColorGeometryInstanceAttribute", "../Core/defined", "../Core/ShowGeometryInstanceAttribute", "../Scene/PerInstanceColorAppearance", "../Scene/Primitive", "./BoundingSphereState"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        var u = function (t, i, n) {
            this.translucent = i, this.primitives = t, this.createPrimitive = !1, this.primitive = void 0, this.oldPrimitive = void 0, this.geometry = new e, this.updaters = new e, this.updatersWithAttributes = new e, this.attributes = new e, this.itemsToRemove = [], this.width = n, this.subscriptions = new e, this.showsUpdated = new e
        };
        u.prototype.add = function (e, t) {
            var i = e.entity.id;
            if (this.createPrimitive = !0, this.geometry.set(i, t), this.updaters.set(i, e), e.hasConstantOutline && e.outlineColorProperty.isConstant) {
                var n = this;
                this.subscriptions.set(i, e.entity.definitionChanged.addEventListener(function (t, i, r, o) {
                    "isShowing" === i && n.showsUpdated.set(t.id, e)
                }))
            } else this.updatersWithAttributes.set(i, e)
        }, u.prototype.remove = function (e) {
            var t = e.entity.id;
            if (this.createPrimitive = this.geometry.remove(t) || this.createPrimitive, this.updaters.remove(t)) {
                this.updatersWithAttributes.remove(t);
                var i = this.subscriptions.get(t);
                n(i) && (i(), this.subscriptions.remove(t))
            }
        };
        var l = new t;
        u.prototype.update = function (e) {
            var s, u, c = !0, h = 0, d = this.primitive, m = this.primitives;
            if (this.createPrimitive) {
                var p = this.geometry.values, f = p.length;
                if (f > 0) {
                    for (n(d) && (n(this.oldPrimitive) ? m.remove(d) : this.oldPrimitive = d), u = 0; f > u; u++) {
                        var _ = p[u], v = _.attributes;
                        s = this.attributes.get(_.id.id), n(s) && (n(v.show) && (v.show.value = s.show), n(v.color) && (v.color.value = s.color))
                    }
                    d = new a({
                        asynchronous: !0,
                        geometryInstances: p,
                        appearance: new o({
                            flat: !0,
                            translucent: this.translucent,
                            renderState: {lineWidth: this.width}
                        })
                    }), m.add(d), c = !1
                } else {
                    n(d) && (m.remove(d), d = void 0);
                    var g = this.oldPrimitive;
                    n(g) && (m.remove(g), this.oldPrimitive = void 0)
                }
                this.attributes.removeAll(), this.primitive = d, this.createPrimitive = !1
            } else if (n(d) && d.ready) {
                n(this.oldPrimitive) && (m.remove(this.oldPrimitive), this.oldPrimitive = void 0);
                var y = this.updatersWithAttributes.values, C = y.length;
                for (u = 0; C > u; u++) {
                    var E = y[u], S = this.geometry.get(E.entity.id);
                    if (s = this.attributes.get(S.id.id), n(s) || (s = d.getGeometryInstanceAttributes(S.id), this.attributes.set(S.id.id, s)), !E.outlineColorProperty.isConstant) {
                        var T = E.outlineColorProperty;
                        T.getValue(e, l), t.equals(s._lastColor, l) || (s._lastColor = t.clone(l, s._lastColor), s.color = i.toValue(l, s.color), (this.translucent && 255 === s.color[3] || !this.translucent && 255 !== s.color[3]) && (this.itemsToRemove[h++] = E))
                    }
                    var b = E.entity.isShowing && (E.hasConstantOutline || E.isOutlineVisible(e)), w = 1 === s.show[0];
                    b !== w && (s.show = r.toValue(b, s.show))
                }
                this.updateShows(d)
            } else n(d) && !d.ready && (c = !1);
            return this.itemsToRemove.length = h, c
        }, u.prototype.updateShows = function (e) {
            for (var t = this.showsUpdated.values, i = t.length, o = 0; i > o; o++) {
                var a = t[o], s = this.geometry.get(a.entity.id), u = this.attributes.get(s.id.id);
                n(u) || (u = e.getGeometryInstanceAttributes(s.id), this.attributes.set(s.id.id, u));
                var l = a.entity.isShowing, c = 1 === u.show[0];
                l !== c && (u.show = r.toValue(l, u.show))
            }
            this.showsUpdated.removeAll()
        }, u.prototype.contains = function (e) {
            return this.updaters.contains(e.id)
        }, u.prototype.getBoundingSphere = function (e, t) {
            var i = this.primitive;
            if (!i.ready)return s.PENDING;
            var r = i.getGeometryInstanceAttributes(e);
            return !n(r) || !n(r.boundingSphere) || n(r.show) && 0 === r.show[0] ? s.FAILED : (r.boundingSphere.clone(t), s.DONE)
        }, u.prototype.removeAllPrimitives = function () {
            var e = this.primitives, t = this.primitive;
            n(t) && (e.remove(t), this.primitive = void 0, this.geometry.removeAll(), this.updaters.removeAll());
            var i = this.oldPrimitive;
            n(i) && (e.remove(i), this.oldPrimitive = void 0)
        };
        var c = function (t, i) {
            this._primitives = t, this._scene = i, this._solidBatches = new e, this._translucentBatches = new e
        };
        return c.prototype.add = function (e, t) {
            var i, r, o = t.createOutlineGeometryInstance(e), a = this._scene.clampLineWidth(t.outlineWidth);
            255 === o.attributes.color.value[3] ? (i = this._solidBatches, r = i.get(a), n(r) || (r = new u(this._primitives, !1, a), i.set(a, r)), r.add(t, o)) : (i = this._translucentBatches, r = i.get(a), n(r) || (r = new u(this._primitives, !0, a), i.set(a, r)), r.add(t, o))
        }, c.prototype.remove = function (e) {
            var t, i = this._solidBatches.values, n = i.length;
            for (t = 0; n > t; t++)if (i[t].remove(e))return;
            var r = this._translucentBatches.values, o = r.length;
            for (t = 0; o > t; t++)if (r[t].remove(e))return
        }, c.prototype.update = function (e) {
            var t, i, n, r, o, a = this._solidBatches.values, s = a.length, u = this._translucentBatches.values, l = u.length, c = !0, h = !1;
            do {
                for (h = !1, i = 0; s > i; i++) {
                    r = a[i], c = r.update(e), o = r.itemsToRemove;
                    var d = o.length;
                    if (d > 0)for (h = !0, t = 0; d > t; t++)n = o[t], r.remove(n), this.add(e, n)
                }
                for (i = 0; l > i; i++) {
                    r = u[i], c = r.update(e), o = r.itemsToRemove;
                    var m = o.length;
                    if (m > 0)for (h = !0, t = 0; m > t; t++)n = o[t], r.remove(n), this.add(e, n)
                }
            } while (h);
            return c
        }, c.prototype.getBoundingSphere = function (e, t) {
            var i, n = this._solidBatches.values, r = n.length;
            for (i = 0; r > i; i++) {
                var o = n[i];
                if (o.contains(e))return o.getBoundingSphere(e, t)
            }
            var a = this._translucentBatches.values, u = a.length;
            for (i = 0; u > i; i++) {
                var l = a[i];
                if (l.contains(e))return l.getBoundingSphere(e, t)
            }
            return s.FAILED
        }, c.prototype.removeAllPrimitives = function () {
            var e, t = this._solidBatches.values, i = t.length;
            for (e = 0; i > e; e++)t[e].removeAllPrimitives();
            var n = this._translucentBatches.values, r = n.length;
            for (e = 0; r > e; e++)n[e].removeAllPrimitives()
        }, c
    }),define("Cesium/DataSources/GeometryVisualizer", ["../Core/AssociativeArray", "../Core/BoundingSphere", "../Core/defined", "../Core/destroyObject", "../Core/DeveloperError", "./BoundingSphereState", "./ColorMaterialProperty", "./StaticGeometryColorBatch", "./StaticGeometryPerMaterialBatch", "./StaticOutlineGeometryBatch"], function (e, t, i, n, r, o, a, s, u, l) {
        "use strict";
        function c(e, t) {
            for (var i = e._batches, n = i.length, r = 0; n > r; r++)i[r].remove(t)
        }

        function h(e, t, i) {
            return i.isDynamic ? void e._dynamicBatch.add(t, i) : (i.outlineEnabled && e._outlineBatch.add(t, i), void(i.fillEnabled && (i.isClosed ? i.fillMaterialProperty instanceof a ? e._closedColorBatch.add(t, i) : e._closedMaterialBatch.add(t, i) : i.fillMaterialProperty instanceof a ? e._openColorBatch.add(t, i) : e._openMaterialBatch.add(t, i))))
        }

        var d = [], m = function (t) {
            this._primitives = t, this._dynamicUpdaters = new e
        };
        m.prototype.add = function (e, t) {
            this._dynamicUpdaters.set(t.entity.id, t.createDynamicUpdater(this._primitives))
        }, m.prototype.remove = function (e) {
            var t = e.entity.id, n = this._dynamicUpdaters.get(t);
            i(n) && (this._dynamicUpdaters.remove(t), n.destroy())
        }, m.prototype.update = function (e) {
            for (var t = this._dynamicUpdaters.values, i = 0, n = t.length; n > i; i++)t[i].update(e);
            return !0
        }, m.prototype.removeAllPrimitives = function () {
            for (var e = this._dynamicUpdaters.values, t = 0, i = e.length; i > t; t++)e[t].destroy();
            this._dynamicUpdaters.removeAll()
        }, m.prototype.getBoundingSphere = function (e, t) {
            var n = this._dynamicUpdaters.get(e.id);
            return i(n) && i(n.getBoundingSphere) ? n.getBoundingSphere(e, t) : o.FAILED
        };
        var p = function (t, i, n) {
            this._type = t;
            var r = i.primitives;
            this._scene = i, this._primitives = r, this._entityCollection = void 0, this._addedObjects = new e, this._removedObjects = new e, this._changedObjects = new e, this._outlineBatch = new l(r, i), this._closedColorBatch = new s(r, t.perInstanceColorAppearanceType, !0), this._closedMaterialBatch = new u(r, t.materialAppearanceType, !0), this._openColorBatch = new s(r, t.perInstanceColorAppearanceType, !1), this._openMaterialBatch = new u(r, t.materialAppearanceType, !1), this._dynamicBatch = new m(r), this._batches = [this._closedColorBatch, this._closedMaterialBatch, this._openColorBatch, this._openMaterialBatch, this._dynamicBatch, this._outlineBatch], this._subscriptions = new e, this._updaters = new e, this._entityCollection = n, n.collectionChanged.addEventListener(p.prototype._onCollectionChanged, this), this._onCollectionChanged(n, n.values, d)
        };
        p.prototype.update = function (e) {
            var t, i, n, r, o = this._addedObjects, a = o.values, s = this._removedObjects, u = s.values, l = this._changedObjects, d = l.values;
            for (t = d.length - 1; t > -1; t--)i = d[t], n = i.id, r = this._updaters.get(n), r.entity === i ? (c(this, r), h(this, e, r)) : (u.push(i), a.push(i));
            for (t = u.length - 1; t > -1; t--)i = u[t], n = i.id, r = this._updaters.get(n), c(this, r), r.destroy(), this._updaters.remove(n), this._subscriptions.get(n)(), this._subscriptions.remove(n);
            for (t = a.length - 1; t > -1; t--)i = a[t], n = i.id, r = new this._type(i, this._scene), this._updaters.set(n, r), h(this, e, r), this._subscriptions.set(n, r.geometryChanged.addEventListener(p._onGeometryChanged, this));
            o.removeAll(), s.removeAll(), l.removeAll();
            var m = !0, f = this._batches, _ = f.length;
            for (t = 0; _ > t; t++)m = f[t].update(e) && m;
            return m
        };
        var f = [], _ = new t;
        return p.prototype.getBoundingSphere = function (e, i) {
            for (var n = f, r = _, a = 0, s = o.DONE, u = this._batches, l = u.length, c = 0; l > c; c++) {
                if (s = u[c].getBoundingSphere(e, r), s === o.PENDING)return o.PENDING;
                s === o.DONE && (n[a] = t.clone(r, n[a]), a++)
            }
            return 0 === a ? o.FAILED : (n.length = a, t.fromBoundingSpheres(n, i), o.DONE)
        }, p.prototype.isDestroyed = function () {
            return !1
        }, p.prototype.destroy = function () {
            this._entityCollection.collectionChanged.removeEventListener(p.prototype._onCollectionChanged, this), this._addedObjects.removeAll(), this._removedObjects.removeAll();
            var e, t = this._batches, i = t.length;
            for (e = 0; i > e; e++)t[e].removeAllPrimitives();
            var r = this._subscriptions.values;
            for (i = r.length, e = 0; i > e; e++)r[e]();
            return this._subscriptions.removeAll(), n(this)
        }, p._onGeometryChanged = function (e) {
            var t = this._removedObjects, n = this._changedObjects, r = e.entity, o = r.id;
            i(t.get(o)) || i(n.get(o)) || n.set(o, r)
        }, p.prototype._onCollectionChanged = function (e, t, i) {
            var n, r, o, a = this._addedObjects, s = this._removedObjects, u = this._changedObjects;
            for (n = i.length - 1; n > -1; n--)o = i[n], r = o.id, a.remove(r) || (s.set(r, o), u.remove(r));
            for (n = t.length - 1; n > -1; n--)o = t[n], r = o.id, s.remove(r) ? u.set(r, o) : a.set(r, o)
        }, p
    }),define("Cesium/ThirdParty/measureText", [], function () {
        var e = function (e, t) {
            return document.defaultView.getComputedStyle(e, null).getPropertyValue(t)
        }, t = function (t, i, n, r) {
            var o = t.measureText(i), a = e(t.canvas, "font-family"), s = e(t.canvas, "font-size").replace("px", ""), u = !/\S/.test(i);
            o.fontsize = s;
            var l = document.createElement("div");
            l.style.position = "absolute", l.style.opacity = 0, l.style.font = s + "px " + a, l.innerHTML = i + "<br/>" + i, document.body.appendChild(l), o.leading = 1.2 * s;
            var c = e(l, "height");
            if (c = c.replace("px", ""), c >= 2 * s && (o.leading = c / 2 | 0), document.body.removeChild(l), u)o.ascent = 0, o.descent = 0, o.bounds = {
                minx: 0,
                maxx: o.width,
                miny: 0,
                maxy: 0
            }, o.height = 0; else {
                var h = document.createElement("canvas"), d = 100;
                h.width = o.width + d, h.height = 3 * s, h.style.opacity = 1, h.style.fontFamily = a, h.style.fontSize = s;
                var m = h.getContext("2d");
                m.font = s + "px " + a;
                var p = h.width, f = h.height, _ = f / 2;
                m.fillStyle = "white", m.fillRect(-1, -1, p + 2, f + 2), n && (m.strokeStyle = "black", m.lineWidth = t.lineWidth, m.strokeText(i, d / 2, _)), r && (m.fillStyle = "black", m.fillText(i, d / 2, _));
                for (var v = m.getImageData(0, 0, p, f).data, g = 0, y = 4 * p, C = v.length; ++g < C && 255 === v[g];);
                var E = g / y | 0;
                for (g = C - 1; --g > 0 && 255 === v[g];);
                var S = g / y | 0;
                for (g = 0; C > g && 255 === v[g];)g += y, g >= C && (g = g - C + 4);
                var T = g % y / 4 | 0, b = 1;
                for (g = C - 3; g >= 0 && 255 === v[g];)g -= y, 0 > g && (g = C - 3 - 4 * b++);
                var w = g % y / 4 + 1 | 0;
                o.ascent = _ - E, o.descent = S - _, o.bounds = {
                    minx: T - d / 2,
                    maxx: w - d / 2,
                    miny: 0,
                    maxy: S - E
                }, o.height = 1 + (S - E)
            }
            return o
        };
        return t
    }),define("Cesium/Core/writeTextToCanvas", ["../ThirdParty/measureText", "./Color", "./defaultValue", "./defined", "./DeveloperError"], function (e, t, i, n, r) {
        "use strict";
        var o, a = function (r, a) {
            if ("" === r)return void 0;
            a = i(a, i.EMPTY_OBJECT);
            var s = i(a.font, "10px sans-serif"), u = i(a.stroke, !1), l = i(a.fill, !0), c = i(a.strokeWidth, 1), h = document.createElement("canvas");
            h.width = 1, h.height = 1, h.style.font = s;
            var d = h.getContext("2d");
            n(o) || (n(d.imageSmoothingEnabled) ? o = "imageSmoothingEnabled" : n(d.mozImageSmoothingEnabled) ? o = "mozImageSmoothingEnabled" : n(d.webkitImageSmoothingEnabled) ? o = "webkitImageSmoothingEnabled" : n(d.msImageSmoothingEnabled) && (o = "msImageSmoothingEnabled")), d.font = s, d.lineJoin = "round", d.lineWidth = c, d[o] = !1, d.textBaseline = i(a.textBaseline, "bottom"), h.style.visibility = "hidden", document.body.appendChild(h);
            var m = e(d, r, u, l);
            m.computedWidth = Math.max(m.width, m.bounds.maxx - m.bounds.minx), h.dimensions = m, document.body.removeChild(h), h.style.visibility = "";
            var p = m.height - m.ascent;
            h.width = m.computedWidth, h.height = m.height;
            var f = h.height - p;
            if (d.font = s, d.lineJoin = "round", d.lineWidth = c, d[o] = !1, u) {
                var _ = i(a.strokeColor, t.BLACK);
                d.strokeStyle = _.toCssColorString(), d.strokeText(r, 0, f)
            }
            if (l) {
                var v = i(a.fillColor, t.WHITE);
                d.fillStyle = v.toCssColorString(), d.fillText(r, 0, f)
            }
            return h
        };
        return a
    }),define("Cesium/Scene/LabelStyle", ["../Core/freezeObject"], function (e) {
        "use strict";
        var t = {FILL: 0, OUTLINE: 1, FILL_AND_OUTLINE: 2};
        return e(t)
    }),define("Cesium/Scene/Label", ["../Core/Cartesian2", "../Core/Cartesian3", "../Core/Color", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/NearFarScalar", "./Billboard", "./HeightReference", "./HorizontalOrigin", "./LabelStyle", "./VerticalOrigin"], function (e, t, i, n, r, o, a, s, u, l, c, h, d) {
        "use strict";
        function m(e) {
            e._rebindAllGlyphs || e._repositionAllGlyphs || e._labelCollection._labelsToUpdate.push(e), e._rebindAllGlyphs = !0
        }

        function p(e) {
            e._rebindAllGlyphs || e._repositionAllGlyphs || e._labelCollection._labelsToUpdate.push(e), e._repositionAllGlyphs = !0
        }

        var f = function (r, o) {
            r = n(r, n.EMPTY_OBJECT), this._text = n(r.text, ""), this._show = n(r.show, !0), this._font = n(r.font, "30px sans-serif"), this._fillColor = i.clone(n(r.fillColor, i.WHITE)), this._outlineColor = i.clone(n(r.outlineColor, i.BLACK)), this._outlineWidth = n(r.outlineWidth, 1), this._style = n(r.style, h.FILL), this._verticalOrigin = n(r.verticalOrigin, d.BOTTOM), this._horizontalOrigin = n(r.horizontalOrigin, c.LEFT), this._pixelOffset = e.clone(n(r.pixelOffset, e.ZERO)), this._eyeOffset = t.clone(n(r.eyeOffset, t.ZERO)), this._position = t.clone(n(r.position, t.ZERO)), this._scale = n(r.scale, 1), this._id = r.id, this._translucencyByDistance = r.translucencyByDistance, this._pixelOffsetScaleByDistance = r.pixelOffsetScaleByDistance, this._heightReference = n(r.heightReference, l.NONE), this._labelCollection = o, this._glyphs = [], this._rebindAllGlyphs = !0, this._repositionAllGlyphs = !0, this._actualClampedPosition = void 0, this._removeCallbackFunc = void 0, this._mode = void 0, this._updateClamping()
        };
        return o(f.prototype, {
            show: {
                get: function () {
                    return this._show
                }, set: function (e) {
                    if (this._show !== e) {
                        this._show = e;
                        for (var t = this._glyphs, i = 0, n = t.length; n > i; i++) {
                            var o = t[i];
                            r(o.billboard) && (o.billboard.show = e)
                        }
                    }
                }
            }, position: {
                get: function () {
                    return this._position
                }, set: function (e) {
                    var i = this._position;
                    if (!t.equals(i, e))if (t.clone(e, i), this._heightReference === l.NONE)for (var n = this._glyphs, o = 0, a = n.length; a > o; o++) {
                        var s = n[o];
                        r(s.billboard) && (s.billboard.position = e)
                    } else this._updateClamping()
                }
            }, heightReference: {
                get: function () {
                    return this._heightReference
                }, set: function (e) {
                    e !== this._heightReference && (this._heightReference = e, this._updateClamping())
                }
            }, text: {
                get: function () {
                    return this._text
                }, set: function (e) {
                    this._text !== e && (this._text = e, m(this))
                }
            }, font: {
                get: function () {
                    return this._font
                }, set: function (e) {
                    this._font !== e && (this._font = e, m(this))
                }
            }, fillColor: {
                get: function () {
                    return this._fillColor
                }, set: function (e) {
                    var t = this._fillColor;
                    i.equals(t, e) || (i.clone(e, t), m(this))
                }
            }, outlineColor: {
                get: function () {
                    return this._outlineColor
                }, set: function (e) {
                    var t = this._outlineColor;
                    i.equals(t, e) || (i.clone(e, t), m(this))
                }
            }, outlineWidth: {
                get: function () {
                    return this._outlineWidth
                }, set: function (e) {
                    this._outlineWidth !== e && (this._outlineWidth = e, m(this))
                }
            }, style: {
                get: function () {
                    return this._style
                }, set: function (e) {
                    this._style !== e && (this._style = e, m(this))
                }
            }, pixelOffset: {
                get: function () {
                    return this._pixelOffset
                }, set: function (t) {
                    var i = this._pixelOffset;
                    if (!e.equals(i, t)) {
                        e.clone(t, i);
                        for (var n = this._glyphs, o = 0, a = n.length; a > o; o++) {
                            var s = n[o];
                            r(s.billboard) && (s.billboard.pixelOffset = t)
                        }
                    }
                }
            }, translucencyByDistance: {
                get: function () {
                    return this._translucencyByDistance
                }, set: function (e) {
                    var t = this._translucencyByDistance;
                    if (!s.equals(t, e)) {
                        this._translucencyByDistance = s.clone(e, t);
                        for (var i = this._glyphs, n = 0, o = i.length; o > n; n++) {
                            var a = i[n];
                            r(a.billboard) && (a.billboard.translucencyByDistance = e)
                        }
                    }
                }
            }, pixelOffsetScaleByDistance: {
                get: function () {
                    return this._pixelOffsetScaleByDistance
                }, set: function (e) {
                    var t = this._pixelOffsetScaleByDistance;
                    if (!s.equals(t, e)) {
                        this._pixelOffsetScaleByDistance = s.clone(e, t);
                        for (var i = this._glyphs, n = 0, o = i.length; o > n; n++) {
                            var a = i[n];
                            r(a.billboard) && (a.billboard.pixelOffsetScaleByDistance = e)
                        }
                    }
                }
            }, eyeOffset: {
                get: function () {
                    return this._eyeOffset
                }, set: function (e) {
                    var i = this._eyeOffset;
                    if (!t.equals(i, e)) {
                        t.clone(e, i);
                        for (var n = this._glyphs, o = 0, a = n.length; a > o; o++) {
                            var s = n[o];
                            r(s.billboard) && (s.billboard.eyeOffset = e)
                        }
                    }
                }
            }, horizontalOrigin: {
                get: function () {
                    return this._horizontalOrigin
                }, set: function (e) {
                    this._horizontalOrigin !== e && (this._horizontalOrigin = e, p(this))
                }
            }, verticalOrigin: {
                get: function () {
                    return this._verticalOrigin
                }, set: function (e) {
                    if (this._verticalOrigin !== e) {
                        this._verticalOrigin = e;
                        for (var t = this._glyphs, i = 0, n = t.length; n > i; i++) {
                            var o = t[i];
                            r(o.billboard) && (o.billboard.verticalOrigin = e)
                        }
                        p(this)
                    }
                }
            }, scale: {
                get: function () {
                    return this._scale
                }, set: function (e) {
                    if (this._scale !== e) {
                        this._scale = e;
                        for (var t = this._glyphs, i = 0, n = t.length; n > i; i++) {
                            var o = t[i];
                            r(o.billboard) && (o.billboard.scale = e)
                        }
                        p(this)
                    }
                }
            }, id: {
                get: function () {
                    return this._id
                }, set: function (e) {
                    if (this._id !== e) {
                        this._id = e;
                        for (var t = this._glyphs, i = 0, n = t.length; n > i; i++) {
                            var o = t[i];
                            r(o.billboard) && (o.billboard.id = e)
                        }
                    }
                }
            }, _clampedPosition: {
                get: function () {
                    return this._actualClampedPosition
                }, set: function (e) {
                    this._actualClampedPosition = t.clone(e, this._actualClampedPosition);
                    for (var i = this._glyphs, n = 0, o = i.length; o > n; n++) {
                        var a = i[n];
                        r(a.billboard) && (a.billboard.position = e)
                    }
                }
            }
        }), f.prototype._updateClamping = function () {
            u._updateClamping(this._labelCollection, this)
        }, f.prototype.computeScreenSpacePosition = function (t, i) {
            r(i) || (i = new e);
            var n = this._labelCollection, o = n.modelMatrix, a = u._computeActualPosition(this, this._position, t.frameState, o), s = u._computeScreenSpacePosition(o, a, this._eyeOffset, this._pixelOffset, t, i);
            return s.y = t.canvas.clientHeight - s.y, s
        }, f.prototype.equals = function (n) {
            return this === n || r(n) && this._show === n._show && this._scale === n._scale && this._style === n._style && this._verticalOrigin === n._verticalOrigin && this._horizontalOrigin === n._horizontalOrigin && this._text === n._text && this._font === n._font && t.equals(this._position, n._position) && i.equals(this._fillColor, n._fillColor) && i.equals(this._outlineColor, n._outlineColor) && e.equals(this._pixelOffset, n._pixelOffset) && t.equals(this._eyeOffset, n._eyeOffset) && s.equals(this._translucencyByDistance, n._translucencyByDistance) && s.equals(this._pixelOffsetScaleByDistance, n._pixelOffsetScaleByDistance) && this._id === n._id
        }, f.prototype.isDestroyed = function () {
            return !1
        }, f
    }),define("Cesium/Scene/LabelCollection", ["../Core/Cartesian2", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Matrix4", "../Core/writeTextToCanvas", "./BillboardCollection", "./HorizontalOrigin", "./Label", "./LabelStyle", "./TextureAtlas", "./VerticalOrigin"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m) {
        "use strict";
        function p() {
            this.textureInfo = void 0, this.dimensions = void 0, this.billboard = void 0
        }

        function f(e, t, i) {
            this.labelCollection = e, this.index = t, this.dimensions = i
        }

        function _(e, t, i, n, r, o, a) {
            return S.font = t, S.fillColor = i, S.strokeColor = n, S.strokeWidth = r, a === m.BOTTOM ? S.textBaseline = "bottom" : a === m.TOP ? S.textBaseline = "top" : S.textBaseline = "middle", S.fill = o === h.FILL || o === h.FILL_AND_OUTLINE, S.stroke = o === h.OUTLINE || o === h.FILL_AND_OUTLINE, s(e, S)
        }

        function v(e, t) {
            t.textureInfo = void 0, t.dimensions = void 0;
            var n = t.billboard;
            i(n) && (n.show = !1, n.image = void 0, e._spareBillboards.push(n), t.billboard = void 0)
        }

        function g(e, t, i, n) {
            e.addImage(t, i).then(function (e, t) {
                n.index = e
            })
        }

        function y(e, t) {
            var n, r, o, a = t._text, s = a.length, u = t._glyphs, c = u.length;
            if (c > s)for (r = s; c > r; ++r)v(e, u[r]);
            u.length = s;
            var h = e._glyphTextureCache;
            for (o = 0; s > o; ++o) {
                var d = a.charAt(o), m = t._font, y = t._fillColor, C = t._outlineColor, E = t._outlineWidth, S = t._style, T = t._verticalOrigin, b = JSON.stringify([d, m, y.toRgba(), C.toRgba(), E, +S, +T]), w = h[b];
                if (!i(w)) {
                    var x = _(d, m, y, C, E, S, T);
                    w = new f(e, -1, x.dimensions), h[b] = w, x.width > 0 && x.height > 0 && g(e._textureAtlas, b, x, w)
                }
                if (n = u[o], i(n) ? -1 === w.index ? v(e, n) : i(n.textureInfo) && (n.textureInfo = void 0) : (n = new p, u[o] = n), n.textureInfo = w, n.dimensions = w.dimensions, -1 !== w.index) {
                    var A = n.billboard;
                    i(A) || (A = e._spareBillboards.length > 0 ? e._spareBillboards.pop() : e._billboardCollection.add({collection: e}), n.billboard = A), A.show = t._show, A.position = t._position, A.eyeOffset = t._eyeOffset, A.pixelOffset = t._pixelOffset, A.horizontalOrigin = l.LEFT, A.verticalOrigin = t._verticalOrigin, A.scale = t._scale, A.pickPrimitive = t, A.id = t._id, A.image = b, A.translucencyByDistance = t._translucencyByDistance, A.pixelOffsetScaleByDistance = t._pixelOffsetScaleByDistance
                }
            }
            t._repositionAllGlyphs = !0
        }

        function C(e, t) {
            var n, r, o = e._glyphs, a = 0, s = 0, u = 0, c = o.length;
            for (u = 0; c > u; ++u)n = o[u], r = n.dimensions, a += r.computedWidth, s = Math.max(s, r.height);
            var h = e._scale, d = e._horizontalOrigin, p = 0;
            d === l.CENTER ? p -= a / 2 * h : d === l.RIGHT && (p -= a * h), T.x = p * t, T.y = 0;
            var f = e._verticalOrigin;
            for (u = 0; c > u; ++u)n = o[u], r = n.dimensions, f === m.BOTTOM || r.height === s ? T.y = -r.descent * h : f === m.TOP ? T.y = -(s - r.height) * h - r.descent * h : f === m.CENTER && (T.y = -(s - r.height) / 2 * h - r.descent * h), T.y *= t, i(n.billboard) && n.billboard._setTranslate(T), T.x += r.computedWidth * h * t
        }

        function E(e, t) {
            for (var n = t._glyphs, o = 0, a = n.length; a > o; ++o)v(e, n[o]);
            t._labelCollection = void 0, i(t._removeCallbackFunc) && t._removeCallbackFunc(), r(t)
        }

        var S = {}, T = new e, b = function (e) {
            e = t(e, t.EMPTY_OBJECT), this._scene = e.scene, this._textureAtlas = void 0, this._billboardCollection = new u({scene: this._scene}), this._billboardCollection.destroyTextureAtlas = !1, this._spareBillboards = [], this._glyphTextureCache = {}, this._labels = [], this._labelsToUpdate = [], this._totalGlyphCount = 0, this._resolutionScale = void 0, this.modelMatrix = a.clone(t(e.modelMatrix, a.IDENTITY)), this.debugShowBoundingVolume = t(e.debugShowBoundingVolume, !1)
        };
        return n(b.prototype, {
            length: {
                get: function () {
                    return this._labels.length
                }
            }
        }), b.prototype.add = function (e) {
            var t = new c(e, this);
            return this._labels.push(t), this._labelsToUpdate.push(t), t
        }, b.prototype.remove = function (e) {
            if (i(e) && e._labelCollection === this) {
                var t = this._labels.indexOf(e);
                if (-1 !== t)return this._labels.splice(t, 1), E(this, e), !0
            }
            return !1
        }, b.prototype.removeAll = function () {
            for (var e = this._labels, t = 0, i = e.length; i > t; ++t)E(this, e[t]);
            e.length = 0
        }, b.prototype.contains = function (e) {
            return i(e) && e._labelCollection === this
        }, b.prototype.get = function (e) {
            return this._labels[e]
        }, b.prototype.update = function (e, t, n) {
            var r = this._billboardCollection;
            r.modelMatrix = this.modelMatrix, r.debugShowBoundingVolume = this.debugShowBoundingVolume, i(this._textureAtlas) || (this._textureAtlas = new d({context: e}), r.textureAtlas = this._textureAtlas);
            var o = e.uniformState, a = o.resolutionScale, s = this._resolutionScale !== a;
            this._resolutionScale = a;
            var u;
            u = s ? this._labels : this._labelsToUpdate;
            for (var l = u.length, c = 0; l > c; ++c) {
                var h = u[c];
                if (!h.isDestroyed()) {
                    var m = h._glyphs.length;
                    h._rebindAllGlyphs && (y(this, h), h._rebindAllGlyphs = !1), (s || h._repositionAllGlyphs) && (C(h, a), h._repositionAllGlyphs = !1);
                    var p = h._glyphs.length - m;
                    this._totalGlyphCount += p
                }
            }
            this._labelsToUpdate.length = 0, r.update(e, t, n)
        }, b.prototype.isDestroyed = function () {
            return !1
        }, b.prototype.destroy = function () {
            return this.removeAll(), this._billboardCollection = this._billboardCollection.destroy(), this._textureAtlas = this._textureAtlas && this._textureAtlas.destroy(), r(this)
        }, b
    }),define("Cesium/DataSources/LabelVisualizer", ["../Core/AssociativeArray", "../Core/Cartesian2", "../Core/Cartesian3", "../Core/Color", "../Core/defined", "../Core/destroyObject", "../Core/DeveloperError", "../Core/NearFarScalar", "../Scene/HorizontalOrigin", "../Scene/LabelCollection", "../Scene/LabelStyle", "../Scene/VerticalOrigin", "./BoundingSphereState", "./Property"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m) {
        "use strict";
        function p(e, t) {
            if (r(e)) {
                var i = e.label;
                r(i) && (t.push(e.index), i.show = !1, e.label = void 0, e.index = -1)
            }
        }

        var f = 1, _ = "30px sans-serif", v = c.FILL, g = n.WHITE, y = n.BLACK, C = 1, E = t.ZERO, S = i.ZERO, T = u.CENTER, b = h.CENTER, w = new i, x = new n, A = new n, P = new i, I = new t, D = new s, M = new s, O = function (e) {
            this.entity = e, this.label = void 0, this.index = void 0
        }, R = function (t, i) {
            i.collectionChanged.addEventListener(R.prototype._onCollectionChanged, this), this._scene = t, this._unusedIndexes = [], this._labelCollection = void 0, this._entityCollection = i, this._items = new e, this._onCollectionChanged(i, i.values, [], [])
        };
        return R.prototype.update = function (e) {
            for (var t = this._items.values, i = this._unusedIndexes, n = 0, o = t.length; o > n; n++) {
                var a, s = t[n], u = s.entity, c = u._label, h = s.label, d = u.isShowing && u.isAvailable(e) && m.getValueOrDefault(c._show, e, !0);
                if (d && (w = m.getValueOrUndefined(u._position, e, w), a = m.getValueOrUndefined(c._text, e), d = r(w) && r(a)), d) {
                    if (!r(h)) {
                        var O = this._labelCollection;
                        r(O) || (O = new l, this._labelCollection = O, this._scene.primitives.add(O));
                        var R = i.length;
                        if (R > 0) {
                            var N = i.pop();
                            s.index = N, h = O.get(N)
                        } else h = O.add(), s.index = O.length - 1;
                        h.id = u, s.label = h
                    }
                    h.show = !0, h.position = w, h.text = a, h.scale = m.getValueOrDefault(c._scale, e, f), h.font = m.getValueOrDefault(c._font, e, _), h.style = m.getValueOrDefault(c._style, e, v), h.fillColor = m.getValueOrDefault(c._fillColor, e, g, x), h.outlineColor = m.getValueOrDefault(c._outlineColor, e, y, A), h.outlineWidth = m.getValueOrDefault(c._outlineWidth, e, C), h.pixelOffset = m.getValueOrDefault(c._pixelOffset, e, E, I), h.eyeOffset = m.getValueOrDefault(c._eyeOffset, e, S, P), h.horizontalOrigin = m.getValueOrDefault(c._horizontalOrigin, e, T), h.verticalOrigin = m.getValueOrDefault(c._verticalOrigin, e, b), h.translucencyByDistance = m.getValueOrUndefined(c._translucencyByDistance, e, D), h.pixelOffsetScaleByDistance = m.getValueOrUndefined(c._pixelOffsetScaleByDistance, e, M)
                } else p(s, i)
            }
            return !0
        }, R.prototype.getBoundingSphere = function (e, t) {
            var n = this._items.get(e.id);
            return r(n) && r(n.label) ? (t.center = i.clone(n.label.position, t.center), t.radius = 0, d.DONE) : d.FAILED
        }, R.prototype.isDestroyed = function () {
            return !1
        }, R.prototype.destroy = function () {
            return this._entityCollection.collectionChanged.removeEventListener(R.prototype._onCollectionChanged, this), r(this._labelCollection) && this._scene.primitives.remove(this._labelCollection), o(this)
        }, R.prototype._onCollectionChanged = function (e, t, i, n) {
            var o, a, s = this._unusedIndexes, u = this._items;
            for (o = t.length - 1; o > -1; o--)a = t[o], r(a._label) && r(a._position) && u.set(a.id, new O(a));
            for (o = n.length - 1; o > -1; o--)a = n[o], r(a._label) && r(a._position) ? u.contains(a.id) || u.set(a.id, new O(a)) : (p(u.get(a.id), s), u.remove(a.id));
            for (o = i.length - 1; o > -1; o--)a = i[o], p(u.get(a.id), s), u.remove(a.id)
        }, R
    }),define("Cesium/DataSources/ModelVisualizer", ["../Core/AssociativeArray", "../Core/BoundingSphere", "../Core/Cartesian3", "../Core/defined", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Matrix4", "../Scene/Model", "../Scene/ModelAnimationLoop", "./BoundingSphereState", "./Property"], function (e, t, i, n, r, o, a, s, u, l, c) {
        "use strict";
        function h(e, t, i, r) {
            var o = i[t.id];
            n(o) && (r.removeAndDestroy(o.modelPrimitive), delete i[t.id])
        }

        function d(e) {
            e.activeAnimations.addAll({loop: u.REPEAT})
        }

        function m(e) {
            console.error(e)
        }

        var p = 1, f = 0, _ = function (t, i) {
            i.collectionChanged.addEventListener(_.prototype._onCollectionChanged, this), this._scene = t, this._primitives = t.primitives, this._entityCollection = i, this._modelHash = {}, this._entitiesToVisualize = new e, this._modelMatrixScratch = new a, this._onCollectionChanged(i, i.values, [], [])
        };
        return _.prototype.update = function (e) {
            for (var t = (this._scene.context, this._entitiesToVisualize.values), i = this._modelHash, r = this._primitives, o = (this._scene, 0), u = t.length; u > o; o++) {
                var l, h, _ = t[o], v = _._model, g = i[_.id], y = _.isShowing && _.isAvailable(e) && c.getValueOrDefault(v._show, e, !0);
                if (y && (h = _._getModelMatrix(e, this._modelMatrixScratch),
                        l = c.getValueOrUndefined(v._uri, e), y = n(h) && n(l)), y) {
                    var C = n(g) ? g.modelPrimitive : void 0;
                    n(C) && l === g.uri || (n(C) && (r.removeAndDestroy(C), delete i[_.id]), C = s.fromGltf({url: l}), C.readyPromise.then(d).otherwise(m), C.id = _, r.add(C), g = {
                        modelPrimitive: C,
                        uri: l
                    }, i[_.id] = g), C.show = !0, C.scale = c.getValueOrDefault(v._scale, e, p), C.minimumPixelSize = c.getValueOrDefault(v._minimumPixelSize, e, f), C.modelMatrix = a.clone(h, C.modelMatrix)
                } else n(g) && (g.modelPrimitive.show = !1)
            }
            return !0
        }, _.prototype.isDestroyed = function () {
            return !1
        }, _.prototype.destroy = function () {
            this._entityCollection.collectionChanged.removeEventListener(_.prototype._onCollectionChanged, this);
            for (var e = this._entitiesToVisualize.values, t = this._modelHash, i = this._primitives, n = e.length - 1; n > -1; n--)h(this, e[n], t, i);
            return r(this)
        }, _.prototype.getBoundingSphere = function (e, i) {
            var r = this._modelHash[e.id];
            if (!n(r))return l.FAILED;
            var o = r.modelPrimitive;
            return n(o) && o.show ? o.ready ? (t.transform(o.boundingSphere, o.modelMatrix, i), l.DONE) : l.PENDING : l.FAILED
        }, _.prototype._onCollectionChanged = function (e, t, i, r) {
            var o, a, s = this._entitiesToVisualize, u = this._modelHash, l = this._primitives;
            for (o = t.length - 1; o > -1; o--)a = t[o], n(a._model) && n(a._position) && s.set(a.id, a);
            for (o = r.length - 1; o > -1; o--)a = r[o], n(a._model) && n(a._position) ? s.set(a.id, a) : (h(this, a, u, l), s.remove(a.id));
            for (o = i.length - 1; o > -1; o--)a = i[o], h(this, a, u, l), s.remove(a.id)
        }, _
    }),define("Cesium/Shaders/PolylineCommon", [], function () {
        "use strict";
        return "void clipLineSegmentToNearPlane(\n    vec3 p0,\n    vec3 p1,\n    out vec4 positionWC,\n    out bool clipped,\n    out bool culledByNearPlane)\n{\n    culledByNearPlane = false;\n    clipped = false;\n    \n    vec3 p1ToP0 = p1 - p0;\n    float magnitude = length(p1ToP0);\n    vec3 direction = normalize(p1ToP0);\n    float endPoint0Distance =  -(czm_currentFrustum.x + p0.z);\n    float denominator = -direction.z;\n    \n    if (endPoint0Distance < 0.0 && abs(denominator) < czm_epsilon7)\n    {\n        culledByNearPlane = true;\n    }\n    else if (endPoint0Distance < 0.0 && abs(denominator) > czm_epsilon7)\n    {\n        // t = (-plane distance - dot(plane normal, ray origin)) / dot(plane normal, ray direction)\n        float t = (czm_currentFrustum.x + p0.z) / denominator;\n        if (t < 0.0 || t > magnitude)\n        {\n            culledByNearPlane = true;\n        }\n        else\n        {\n            p0 = p0 + t * direction;\n            clipped = true;\n        }\n    }\n    \n    positionWC = czm_eyeToWindowCoordinates(vec4(p0, 1.0));\n}\n\nvec4 getPolylineWindowCoordinates(vec4 position, vec4 previous, vec4 next, float expandDirection, float width, bool usePrevious) {\n    vec4 endPointWC, p0, p1;\n    bool culledByNearPlane, clipped;\n    \n    vec4 positionEC = czm_modelViewRelativeToEye * position;\n    vec4 prevEC = czm_modelViewRelativeToEye * previous;\n    vec4 nextEC = czm_modelViewRelativeToEye * next;\n    \n    clipLineSegmentToNearPlane(prevEC.xyz, positionEC.xyz, p0, clipped, culledByNearPlane);\n    clipLineSegmentToNearPlane(nextEC.xyz, positionEC.xyz, p1, clipped, culledByNearPlane);\n    clipLineSegmentToNearPlane(positionEC.xyz, usePrevious ? prevEC.xyz : nextEC.xyz, endPointWC, clipped, culledByNearPlane);\n    \n    if (culledByNearPlane)\n    {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    \n    vec2 prevWC = normalize(p0.xy - endPointWC.xy);\n    vec2 nextWC = normalize(p1.xy - endPointWC.xy);\n    \n    float expandWidth = width * 0.5;\n    vec2 direction;\n\n    if (czm_equalsEpsilon(normalize(previous.xyz - position.xyz), vec3(0.0), czm_epsilon1) || czm_equalsEpsilon(prevWC, -nextWC, czm_epsilon1))\n    {\n        direction = vec2(-nextWC.y, nextWC.x);\n    }\n    else if (czm_equalsEpsilon(normalize(next.xyz - position.xyz), vec3(0.0), czm_epsilon1) || clipped)\n    {\n        direction = vec2(prevWC.y, -prevWC.x);\n    }\n    else\n    {\n        vec2 normal = vec2(-nextWC.y, nextWC.x);\n        direction = normalize((nextWC + prevWC) * 0.5);\n        if (dot(direction, normal) < 0.0)\n        {\n            direction = -direction;\n        }\n\n        // The sine of the angle between the two vectors is given by the formula\n        //         |a x b| = |a||b|sin(theta)\n        // which is\n        //     float sinAngle = length(cross(vec3(direction, 0.0), vec3(nextWC, 0.0)));\n        // Because the z components of both vectors are zero, the x and y coordinate will be zero.\n        // Therefore, the sine of the angle is just the z component of the cross product.\n        float sinAngle = abs(direction.x * nextWC.y - direction.y * nextWC.x);\n        expandWidth = clamp(expandWidth / sinAngle, 0.0, width * 2.0);\n    }\n\n    vec2 offset = direction * expandDirection * expandWidth * czm_resolutionScale;\n    return vec4(endPointWC.xy + offset, -endPointWC.z, 1.0);\n}\n"
    }),define("Cesium/Shaders/PolylineFS", [], function () {
        "use strict";
        return "varying vec2 v_st;\n\nvoid main()\n{\n    czm_materialInput materialInput;\n    \n    materialInput.s = v_st.s;\n    materialInput.st = v_st;\n    materialInput.str = vec3(v_st, 0.0);\n    \n    czm_material material = czm_getMaterial(materialInput);\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n}"
    }),define("Cesium/Shaders/PolylineVS", [], function () {
        "use strict";
        return "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 position2DHigh;\nattribute vec3 position2DLow;\nattribute vec3 prevPosition3DHigh;\nattribute vec3 prevPosition3DLow;\nattribute vec3 prevPosition2DHigh;\nattribute vec3 prevPosition2DLow;\nattribute vec3 nextPosition3DHigh;\nattribute vec3 nextPosition3DLow;\nattribute vec3 nextPosition2DHigh;\nattribute vec3 nextPosition2DLow;\nattribute vec4 texCoordExpandWidthAndShow;\nattribute vec4 pickColor;\n\nvarying vec2  v_st;\nvarying float v_width;\nvarying vec4  czm_pickColor;\n\nvoid main() \n{\n    float texCoord = texCoordExpandWidthAndShow.x;\n    float expandDir = texCoordExpandWidthAndShow.y;\n    float width = abs(texCoordExpandWidthAndShow.z) + 0.5;\n    bool usePrev = texCoordExpandWidthAndShow.z < 0.0;\n    float show = texCoordExpandWidthAndShow.w;\n    \n    vec4 p, prev, next;\n    if (czm_morphTime == 1.0)\n    {\n        p = czm_translateRelativeToEye(position3DHigh.xyz, position3DLow.xyz);\n        prev = czm_translateRelativeToEye(prevPosition3DHigh.xyz, prevPosition3DLow.xyz);\n        next = czm_translateRelativeToEye(nextPosition3DHigh.xyz, nextPosition3DLow.xyz);\n    }\n    else if (czm_morphTime == 0.0)\n    {\n        p = czm_translateRelativeToEye(position2DHigh.zxy, position2DLow.zxy);\n        prev = czm_translateRelativeToEye(prevPosition2DHigh.zxy, prevPosition2DLow.zxy);\n        next = czm_translateRelativeToEye(nextPosition2DHigh.zxy, nextPosition2DLow.zxy);\n    }\n    else\n    {\n        p = czm_columbusViewMorph(\n                czm_translateRelativeToEye(position2DHigh.zxy, position2DLow.zxy),\n                czm_translateRelativeToEye(position3DHigh.xyz, position3DLow.xyz),\n                czm_morphTime);\n        prev = czm_columbusViewMorph(\n                czm_translateRelativeToEye(prevPosition2DHigh.zxy, prevPosition2DLow.zxy),\n                czm_translateRelativeToEye(prevPosition3DHigh.xyz, prevPosition3DLow.xyz),\n                czm_morphTime);\n        next = czm_columbusViewMorph(\n                czm_translateRelativeToEye(nextPosition2DHigh.zxy, nextPosition2DLow.zxy),\n                czm_translateRelativeToEye(nextPosition3DHigh.xyz, nextPosition3DLow.xyz),\n                czm_morphTime);\n    }\n    \n    vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev);\n    gl_Position = czm_viewportOrthographic * positionWC * show;\n    \n    v_st = vec2(texCoord, clamp(expandDir, 0.0, 1.0));\n    v_width = width;\n    czm_pickColor = pickColor;\n}\n"
    }),define("Cesium/Scene/Polyline", ["../Core/BoundingSphere", "../Core/Cartesian3", "../Core/Color", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Matrix4", "../Core/PolylinePipeline", "./Material"], function (e, t, i, n, r, o, a, s, u, l) {
        "use strict";
        function c(e, t) {
            ++e._propertiesChanged[t];
            var i = e._polylineCollection;
            r(i) && (i._updatePolyline(e, t), e._dirty = !0)
        }

        var h = function (o, a) {
            o = n(o, n.EMPTY_OBJECT), this._show = n(o.show, !0), this._width = n(o.width, 1), this._loop = n(o.loop, !1), this._material = o.material, r(this._material) || (this._material = l.fromType(l.ColorType, {color: new i(1, 1, 1, 1)}));
            var c = o.positions;
            r(c) || (c = []), this._positions = c, this._actualPositions = u.removeDuplicates(c), this._loop && this._actualPositions.length > 2 && (this._actualPositions === this._positions && (this._actualPositions = c.slice()), this._actualPositions.push(t.clone(this._actualPositions[0]))), this._length = this._actualPositions.length, this._id = o.id;
            var h;
            r(a) && (h = s.clone(a.modelMatrix)), this._modelMatrix = h, this._segments = u.wrapLongitude(this._actualPositions, h), this._actualLength = void 0, this._propertiesChanged = new Uint32Array(v), this._polylineCollection = a, this._dirty = !1, this._pickId = void 0, this._boundingVolume = e.fromPoints(this._actualPositions), this._boundingVolumeWC = e.transform(this._boundingVolume, this._modelMatrix), this._boundingVolume2D = new e
        }, d = h.SHOW_INDEX = 0, m = h.WIDTH_INDEX = 1, p = h.POSITION_INDEX = 2, f = h.MATERIAL_INDEX = 3, _ = h.POSITION_SIZE_INDEX = 4, v = h.NUMBER_OF_PROPERTIES = 5;
        return o(h.prototype, {
            show: {
                get: function () {
                    return this._show
                }, set: function (e) {
                    e !== this._show && (this._show = e, c(this, d))
                }
            }, positions: {
                get: function () {
                    return this._positions
                }, set: function (i) {
                    var n = u.removeDuplicates(i);
                    this._loop && n.length > 2 && (n === i && (n = i.slice()), n.push(t.clone(n[0]))), (this._actualPositions.length !== n.length || this._actualPositions.length !== this._length) && c(this, _), this._positions = i, this._actualPositions = n, this._length = n.length, this._boundingVolume = e.fromPoints(this._actualPositions, this._boundingVolume), this._boundingVolumeWC = e.transform(this._boundingVolume, this._modelMatrix, this._boundingVolumeWC), c(this, p), this.update()
                }
            }, material: {
                get: function () {
                    return this._material
                }, set: function (e) {
                    this._material !== e && (this._material = e, c(this, f))
                }
            }, width: {
                get: function () {
                    return this._width
                }, set: function (e) {
                    var t = this._width;
                    e !== t && (this._width = e, c(this, m))
                }
            }, loop: {
                get: function () {
                    return this._loop
                }, set: function (e) {
                    if (e !== this._loop) {
                        var i = this._actualPositions;
                        e ? i.length > 2 && !t.equals(i[0], i[i.length - 1]) && (i.length === this._positions.length && (this._actualPositions = i = this._positions.slice()), i.push(t.clone(i[0]))) : i.length > 2 && t.equals(i[0], i[i.length - 1]) && (i.length - 1 === this._positions.length ? this._actualPositions = this._positions : i.pop()), this._loop = e, c(this, _)
                    }
                }
            }, id: {
                get: function () {
                    return this._id
                }, set: function (e) {
                    this._id = e, r(this._pickId) && (this._pickId.object.id = e)
                }
            }
        }), h.prototype.update = function () {
            var t = s.IDENTITY;
            r(this._polylineCollection) && (t = this._polylineCollection.modelMatrix);
            var i = this._segments.positions.length, n = this._segments.lengths, o = this._propertiesChanged[p] > 0 || this._propertiesChanged[_] > 0;
            if ((!s.equals(t, this._modelMatrix) || o) && (this._segments = u.wrapLongitude(this._actualPositions, t), this._boundingVolumeWC = e.transform(this._boundingVolume, t, this._boundingVolumeWC)), this._modelMatrix = t, this._segments.positions.length !== i)c(this, _); else for (var a = n.length, l = 0; a > l; ++l)if (n[l] !== this._segments.lengths[l]) {
                c(this, _);
                break
            }
        }, h.prototype.getPickId = function (e) {
            return r(this._pickId) || (this._pickId = e.createPickId({
                primitive: this,
                collection: this._polylineCollection,
                id: this._id
            })), this._pickId
        }, h.prototype._clean = function () {
            this._dirty = !1;
            for (var e = this._propertiesChanged, t = 0; v - 1 > t; ++t)e[t] = 0
        }, h.prototype._destroy = function () {
            this._pickId = this._pickId && this._pickId.destroy(), this._material = this._material && this._material.destroy(), this._polylineCollection = void 0
        }, h
    }),define("Cesium/Scene/PolylineCollection", ["../Core/BoundingSphere", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/Cartographic", "../Core/Color", "../Core/ComponentDatatype", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/EncodedCartesian3", "../Core/IndexDatatype", "../Core/Intersect", "../Core/Math", "../Core/Matrix4", "../Core/Plane", "../Renderer/Buffer", "../Renderer/BufferUsage", "../Renderer/DrawCommand", "../Renderer/RenderState", "../Renderer/ShaderProgram", "../Renderer/ShaderSource", "../Renderer/VertexArray", "../Shaders/PolylineCommon", "../Shaders/PolylineFS", "../Shaders/PolylineVS", "./BlendingState", "./Material", "./Pass", "./Polyline", "./SceneMode"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S, T, b, w, x, A, P, I, D, M) {
        "use strict";
        function O(t, i, n, r, o, a, u) {
            for (var l = r.length, c = 0, h = !0, d = t._vertexArrays, m = t.debugShowBoundingVolume, p = d.length, f = 0; p > f; ++f)for (var _ = d[f], v = _.buckets, g = v.length, C = 0; g > C; ++C) {
                for (var E, S, T, b = v[C], w = b.offset, x = u ? b.bucket.shaderProgram : b.bucket.pickShaderProgram, A = b.bucket.polylines, P = A.length, D = 0, O = 0; P > O; ++O) {
                    var R = A[O], N = L(R._material);
                    if (N !== E) {
                        if (s(E) && D > 0) {
                            var F = S.isTranslucent();
                            c >= l ? (T = new y({owner: t}), r.push(T)) : T = r[c], ++c, T.boundingVolume = e.clone(Q, T.boundingVolume), T.modelMatrix = a, T.shaderProgram = x, T.vertexArray = _.va, T.renderState = F ? t._translucentRS : t._opaqueRS, T.pass = F ? I.TRANSLUCENT : I.OPAQUE, T.debugShowBoundingVolume = u ? m : !1, T.uniformMap = S._uniforms, T.count = D, T.offset = w, w += D, D = 0, h = !0, o.push(T)
                        }
                        S = R._material, S.update(i), E = N
                    }
                    for (var B = R._locatorBuckets, z = B.length, V = 0; z > V; ++V) {
                        var U = B[V];
                        U.locator === b && (D += U.count)
                    }
                    var k;
                    n.mode === M.SCENE3D ? k = R._boundingVolumeWC : n.mode === M.COLUMBUS_VIEW ? k = R._boundingVolume2D : n.mode === M.SCENE2D ? s(R._boundingVolume2D) && (k = e.clone(R._boundingVolume2D, $), k.center.x = 0) : s(R._boundingVolumeWC) && s(R._boundingVolume2D) && (k = e.union(R._boundingVolumeWC, R._boundingVolume2D, $)), h ? (h = !1, e.clone(k, Q)) : e.union(k, Q, Q)
                }
                s(E) && D > 0 && (c >= l ? (T = new y({owner: t}), r.push(T)) : T = r[c], ++c, T.boundingVolume = e.clone(Q, T.boundingVolume), T.modelMatrix = a, T.shaderProgram = x, T.vertexArray = _.va, T.renderState = S.isTranslucent() ? t._translucentRS : t._opaqueRS, T.pass = S.isTranslucent() ? I.TRANSLUCENT : I.OPAQUE, T.debugShowBoundingVolume = u ? m : !1, T.uniformMap = S._uniforms, T.count = D, T.offset = w, h = !0, o.push(T)), E = void 0
            }
            r.length = c
        }

        function R(e) {
            for (var t = e._buffersUsage, i = !1, n = e._propertiesChanged, r = 0; Z - 2 > r; ++r) {
                var o = t[r];
                n[r] ? o.bufferUsage !== g.STREAM_DRAW ? (i = !0, o.bufferUsage = g.STREAM_DRAW, o.frameCount = 100) : o.frameCount = 100 : o.bufferUsage !== g.STATIC_DRAW && (0 === o.frameCount ? (i = !0, o.bufferUsage = g.STATIC_DRAW) : o.frameCount--)
            }
            return i
        }

        function N(e, t, i) {
            e._createVertexArray = !1, V(e), U(e), F(e);
            var n, r, a = [[]], u = a[0], l = [0], c = 0, h = [[]], m = 0, f = e._polylineBuckets;
            for (n in f)f.hasOwnProperty(n) && (r = f[n], r.updateShader(t), m += r.lengthOfPositions);
            if (m > 0) {
                var _, y = e._mode, C = new Float32Array(6 * m * 3), E = new Uint8Array(4 * m), S = new Float32Array(4 * m), b = 0, w = 0, x = 0;
                for (n in f)if (f.hasOwnProperty(n)) {
                    r = f[n], r.write(C, E, S, b, w, x, t, i), y === M.MORPHING && (s(_) || (_ = new Float32Array(6 * m * 3)), r.writeForMorph(_, b));
                    var A = r.lengthOfPositions;
                    b += 6 * A * 3, w += 4 * A, x += 4 * A, c = r.updateIndices(a, l, h, c)
                }
                var P = e._buffersUsage[j].bufferUsage, I = e._buffersUsage[W].bufferUsage, D = e._buffersUsage[q].bufferUsage, O = I === g.STREAM_DRAW || D === g.STREAM_DRAW ? g.STREAM_DRAW : g.STATIC_DRAW;
                e._positionBuffer = v.createVertexBuffer({context: t, typedArray: C, usage: P});
                var R;
                s(_) && (R = v.createVertexBuffer({
                    context: t,
                    typedArray: _,
                    usage: P
                })), e._pickColorBuffer = v.createVertexBuffer({
                    context: t,
                    typedArray: E,
                    usage: g.STATIC_DRAW
                }), e._texCoordExpandWidthAndShowBuffer = v.createVertexBuffer({context: t, typedArray: S, usage: O});
                for (var N = 4 * Uint8Array.BYTES_PER_ELEMENT, L = 3 * Float32Array.BYTES_PER_ELEMENT, B = 4 * Float32Array.BYTES_PER_ELEMENT, z = 0, k = a.length, G = 0; k > G; ++G)if (u = a[G], u.length > 0) {
                    var H = new Uint16Array(u), Y = v.createIndexBuffer({
                        context: t,
                        typedArray: H,
                        usage: g.STATIC_DRAW,
                        indexDatatype: d.UNSIGNED_SHORT
                    });
                    z += l[G];
                    var X, Z, J, Q, $ = 6 * (G * L * p.SIXTY_FOUR_KILOBYTES - z * L), te = L + $, ie = L + te, ne = L + ie, re = L + ne, oe = L + re, ae = G * N * p.SIXTY_FOUR_KILOBYTES - z * N, se = G * B * p.SIXTY_FOUR_KILOBYTES - z * B, ue = [{
                        index: K.position3DHigh,
                        componentsPerAttribute: 3,
                        componentDatatype: o.FLOAT,
                        offsetInBytes: $,
                        strideInBytes: 6 * L
                    }, {
                        index: K.position3DLow,
                        componentsPerAttribute: 3,
                        componentDatatype: o.FLOAT,
                        offsetInBytes: te,
                        strideInBytes: 6 * L
                    }, {
                        index: K.position2DHigh,
                        componentsPerAttribute: 3,
                        componentDatatype: o.FLOAT,
                        offsetInBytes: $,
                        strideInBytes: 6 * L
                    }, {
                        index: K.position2DLow,
                        componentsPerAttribute: 3,
                        componentDatatype: o.FLOAT,
                        offsetInBytes: te,
                        strideInBytes: 6 * L
                    }, {
                        index: K.prevPosition3DHigh,
                        componentsPerAttribute: 3,
                        componentDatatype: o.FLOAT,
                        offsetInBytes: ie,
                        strideInBytes: 6 * L
                    }, {
                        index: K.prevPosition3DLow,
                        componentsPerAttribute: 3,
                        componentDatatype: o.FLOAT,
                        offsetInBytes: ne,
                        strideInBytes: 6 * L
                    }, {
                        index: K.prevPosition2DHigh,
                        componentsPerAttribute: 3,
                        componentDatatype: o.FLOAT,
                        offsetInBytes: ie,
                        strideInBytes: 6 * L
                    }, {
                        index: K.prevPosition2DLow,
                        componentsPerAttribute: 3,
                        componentDatatype: o.FLOAT,
                        offsetInBytes: ne,
                        strideInBytes: 6 * L
                    }, {
                        index: K.nextPosition3DHigh,
                        componentsPerAttribute: 3,
                        componentDatatype: o.FLOAT,
                        offsetInBytes: re,
                        strideInBytes: 6 * L
                    }, {
                        index: K.nextPosition3DLow,
                        componentsPerAttribute: 3,
                        componentDatatype: o.FLOAT,
                        offsetInBytes: oe,
                        strideInBytes: 6 * L
                    }, {
                        index: K.nextPosition2DHigh,
                        componentsPerAttribute: 3,
                        componentDatatype: o.FLOAT,
                        offsetInBytes: re,
                        strideInBytes: 6 * L
                    }, {
                        index: K.nextPosition2DLow,
                        componentsPerAttribute: 3,
                        componentDatatype: o.FLOAT,
                        offsetInBytes: oe,
                        strideInBytes: 6 * L
                    }, {
                        index: K.texCoordExpandWidthAndShow,
                        componentsPerAttribute: 4,
                        componentDatatype: o.FLOAT,
                        vertexBuffer: e._texCoordExpandWidthAndShowBuffer,
                        offsetInBytes: se
                    }, {
                        index: K.pickColor,
                        componentsPerAttribute: 4,
                        componentDatatype: o.UNSIGNED_BYTE,
                        vertexBuffer: e._pickColorBuffer,
                        offsetInBytes: ae,
                        normalize: !0
                    }];
                    y === M.SCENE3D ? (X = e._positionBuffer, Z = "vertexBuffer", J = ee, Q = "value") : y === M.SCENE2D || y === M.COLUMBUS_VIEW ? (X = ee, Z = "value", J = e._positionBuffer, Q = "vertexBuffer") : (X = R, Z = "vertexBuffer", J = e._positionBuffer, Q = "vertexBuffer"), ue[0][Z] = X, ue[1][Z] = X, ue[2][Q] = J, ue[3][Q] = J, ue[4][Z] = X, ue[5][Z] = X, ue[6][Q] = J, ue[7][Q] = J, ue[8][Z] = X, ue[9][Z] = X, ue[10][Q] = J, ue[11][Q] = J;
                    var le = new T({context: t, attributes: ue, indexBuffer: Y});
                    e._vertexArrays.push({va: le, buckets: h[G]})
                }
            }
        }

        function L(e) {
            var t = P._uniformList[e.type], i = t.length;
            te.length = 2 * i;
            for (var n = 0, r = 0; i > r; ++r) {
                var o = t[r];
                te[n] = o, te[n + 1] = e._uniforms[o](), n += 2
            }
            return e.type + ":" + JSON.stringify(te)
        }

        function F(e) {
            for (var t = e._mode, i = e._modelMatrix, n = e._polylineBuckets = {}, r = e._polylines, o = r.length, a = 0; o > a; ++a) {
                var u = r[a];
                if (u._actualPositions.length > 1) {
                    u.update();
                    var l = u.material, c = n[l.type];
                    s(c) || (c = n[l.type] = new ie(l, t, i)), c.addPolyline(u)
                }
            }
        }

        function B(e, t) {
            var i = t.mode;
            e._mode === i && f.equals(e._modelMatrix, e.modelMatrix) || (e._mode = i, e._modelMatrix = f.clone(e.modelMatrix), e._createVertexArray = !0)
        }

        function z(e) {
            if (e._polylinesRemoved) {
                e._polylinesRemoved = !1;
                for (var t = [], i = e._polylines.length, n = 0, r = 0; i > n; ++n) {
                    var o = e._polylines[n];
                    s(o) && (o._index = r++, t.push(o))
                }
                e._polylines = t
            }
        }

        function V(e) {
            for (var t = e._polylines, i = t.length, n = 0; i > n; ++n)if (s(t[n])) {
                var r = t[n]._bucket;
                s(r) && (r.shaderProgram = r.shaderProgram && r.shaderProgram.destroy())
            }
        }

        function U(e) {
            for (var t = e._vertexArrays.length, i = 0; t > i; ++i)e._vertexArrays[i].va.destroy();
            e._vertexArrays.length = 0
        }

        function k(e) {
            for (var t = e._polylines, i = t.length, n = 0; i > n; ++n)s(t[n]) && t[n]._destroy()
        }

        function G(e, t, i) {
            this.count = e, this.offset = t, this.bucket = i
        }

        function H(e) {
            return t.dot(t.UNIT_X, e._boundingVolume.center) < 0 || e._boundingVolume.intersectPlane(_.ORIGIN_ZX_PLANE) === m.INTERSECTING
        }

        var W = D.SHOW_INDEX, q = D.WIDTH_INDEX, j = D.POSITION_INDEX, Y = D.MATERIAL_INDEX, X = D.POSITION_SIZE_INDEX, Z = D.NUMBER_OF_PROPERTIES, K = {
            texCoordExpandWidthAndShow: 0,
            position3DHigh: 1,
            position3DLow: 2,
            position2DHigh: 3,
            position2DLow: 4,
            prevPosition3DHigh: 5,
            prevPosition3DLow: 6,
            prevPosition2DHigh: 7,
            prevPosition2DLow: 8,
            nextPosition3DHigh: 9,
            nextPosition3DLow: 10,
            nextPosition2DHigh: 11,
            nextPosition2DLow: 12,
            pickColor: 13
        }, J = function (e) {
            e = a(e, a.EMPTY_OBJECT), this.modelMatrix = f.clone(a(e.modelMatrix, f.IDENTITY)), this._modelMatrix = f.clone(f.IDENTITY), this.debugShowBoundingVolume = a(e.debugShowBoundingVolume, !1), this._opaqueRS = void 0, this._translucentRS = void 0, this._colorCommands = [], this._pickCommands = [], this._polylinesUpdated = !1, this._polylinesRemoved = !1, this._createVertexArray = !1, this._propertiesChanged = new Uint32Array(Z), this._polylines = [], this._polylineBuckets = {}, this._buffersUsage = [{
                bufferUsage: g.STATIC_DRAW,
                frameCount: 0
            }, {bufferUsage: g.STATIC_DRAW, frameCount: 0}, {
                bufferUsage: g.STATIC_DRAW,
                frameCount: 0
            }], this._mode = void 0, this._polylinesToUpdate = [], this._vertexArrays = [], this._positionBuffer = void 0, this._pickColorBuffer = void 0, this._texCoordExpandWidthAndShowBuffer = void 0
        };
        u(J.prototype, {
            length: {
                get: function () {
                    return z(this), this._polylines.length
                }
            }
        }), J.prototype.add = function (e) {
            var t = new D(e, this);
            return t._index = this._polylines.length, this._polylines.push(t), this._createVertexArray = !0, t
        }, J.prototype.remove = function (e) {
            if (this.contains(e)) {
                if (this._polylines[e._index] = void 0, this._polylinesRemoved = !0, this._createVertexArray = !0, s(e._bucket)) {
                    var t = e._bucket;
                    t.shaderProgram = t.shaderProgram && t.shaderProgram.destroy(), t.pickShaderProgram = t.pickShaderProgram && t.pickShaderProgram.destroy()
                }
                return e._destroy(), !0
            }
            return !1
        }, J.prototype.removeAll = function () {
            V(this), k(this), this._polylineBuckets = {}, this._polylinesRemoved = !1, this._polylines.length = 0, this._polylinesToUpdate.length = 0, this._createVertexArray = !0
        }, J.prototype.contains = function (e) {
            return s(e) && e._polylineCollection === this
        }, J.prototype.get = function (e) {
            return z(this), this._polylines[e]
        }, J.prototype.update = function (e, t, i) {
            if (z(this), 0 !== this._polylines.length) {
                B(this, t);
                var n, r = t.mapProjection, o = this._propertiesChanged;
                if (this._createVertexArray || R(this))N(this, e, r); else if (this._polylinesUpdated) {
                    var a = this._polylinesToUpdate;
                    if (this._mode !== M.SCENE3D)for (var u = a.length, l = 0; u > l; ++l)n = a[l], n.update();
                    if (o[X] || o[Y])N(this, e, r); else for (var c = a.length, h = this._polylineBuckets, d = 0; c > d; ++d) {
                        n = a[d], o = n._propertiesChanged;
                        var m = n._bucket, p = 0;
                        for (var _ in h)if (h.hasOwnProperty(_)) {
                            if (h[_] === m) {
                                (o[j] || o[W] || o[q]) && m.writeUpdate(p, n, this._positionBuffer, this._texCoordExpandWidthAndShowBuffer, r);
                                break
                            }
                            p += h[_].lengthOfPositions
                        }
                        n._clean()
                    }
                    a.length = 0, this._polylinesUpdated = !1
                }
                o = this._propertiesChanged;
                for (var v = 0; Z > v; ++v)o[v] = 0;
                var g = f.IDENTITY;
                t.mode === M.SCENE3D && (g = this.modelMatrix);
                var y = t.passes, E = 0 !== t.morphTime;
                if (s(this._opaqueRS) && this._opaqueRS.depthTest.enabled === E || (this._opaqueRS = C.fromCache({
                        depthMask: E,
                        depthTest: {enabled: E}
                    })), s(this._translucentRS) && this._translucentRS.depthTest.enabled === E || (this._translucentRS = C.fromCache({
                        blending: A.ALPHA_BLEND,
                        depthMask: !E,
                        depthTest: {enabled: E}
                    })), y.render) {
                    var S = this._colorCommands;
                    O(this, e, t, S, i, g, !0)
                }
                if (y.pick) {
                    var T = this._pickCommands;
                    O(this, e, t, T, i, g, !1)
                }
            }
        };
        var Q = new e, $ = new e;
        J.prototype.isDestroyed = function () {
            return !1
        }, J.prototype.destroy = function () {
            return U(this), V(this), k(this), l(this)
        };
        var ee = [0, 0, 0], te = [];
        J.prototype._updatePolyline = function (e, t) {
            this._polylinesUpdated = !0, this._polylinesToUpdate.push(e), ++this._propertiesChanged[t]
        };
        var ie = function (e, t, i) {
            this.polylines = [], this.lengthOfPositions = 0, this.material = e, this.shaderProgram = void 0, this.pickShaderProgram = void 0, this.mode = t, this.modelMatrix = i
        };
        ie.prototype.addPolyline = function (e) {
            var t = this.polylines;
            t.push(e), e._actualLength = this.getPolylinePositionsLength(e), this.lengthOfPositions += e._actualLength, e._bucket = this
        }, ie.prototype.updateShader = function (e) {
            if (!s(this.shaderProgram)) {
                var t = new S({sources: [b, x]}), i = new S({sources: [this.material.shaderSource, w]}), n = new S({
                    sources: i.sources,
                    pickColorQualifier: "varying"
                });
                this.shaderProgram = E.fromCache({
                    context: e,
                    vertexShaderSource: t,
                    fragmentShaderSource: i,
                    attributeLocations: K
                }), this.pickShaderProgram = E.fromCache({
                    context: e,
                    vertexShaderSource: t,
                    fragmentShaderSource: n,
                    attributeLocations: K
                })
            }
        }, ie.prototype.getPolylinePositionsLength = function (e) {
            var t;
            if (this.mode === M.SCENE3D || !H(e))return t = e._actualPositions.length, 4 * t - 4;
            var i = 0, n = e._segments.lengths;
            t = n.length;
            for (var r = 0; t > r; ++r)i += 4 * n[r] - 4;
            return i
        };
        var ne = new t, re = new t, oe = new t, ae = new t;
        ie.prototype.write = function (e, i, n, o, a, s, u, l) {
            for (var c = this.mode, d = this.polylines, m = d.length, p = 0; m > p; ++p)for (var f, _ = d[p], v = _.width, g = _.show && v > 0, y = this.getSegments(_, l), C = y.positions, E = y.lengths, S = C.length, T = _.getPickId(u).color, b = 0, w = 0, x = 0; S > x; ++x) {
                0 === x ? _._loop ? f = C[S - 2] : (f = ae, t.subtract(C[0], C[1], f), t.add(C[0], f, f)) : f = C[x - 1], re.x = f.x, re.y = f.y, re.z = c !== M.SCENE2D ? f.z : 0, f = C[x], ne.x = f.x, ne.y = f.y, ne.z = c !== M.SCENE2D ? f.z : 0, x === S - 1 ? _._loop ? f = C[1] : (f = ae, t.subtract(C[S - 1], C[S - 2], f), t.add(C[S - 1], f, f)) : f = C[x + 1], oe.x = f.x, oe.y = f.y, oe.z = c !== M.SCENE2D ? f.z : 0;
                var A = E[b];
                x === w + A && (w += A, ++b);
                for (var P = x - w === 0, I = x === w + E[b] - 1, D = P ? 2 : 0, O = I ? 2 : 4, R = D; O > R; ++R) {
                    h.writeElements(ne, e, o), h.writeElements(re, e, o + 6), h.writeElements(oe, e, o + 12), i[a] = r.floatToByte(T.red), i[a + 1] = r.floatToByte(T.green), i[a + 2] = r.floatToByte(T.blue), i[a + 3] = r.floatToByte(T.alpha);
                    var N = 0 > R - 2 ? -1 : 1;
                    n[s] = x / (S - 1), n[s + 1] = 2 * (R % 2) - 1, n[s + 2] = N * v, n[s + 3] = g, o += 18, a += 4, s += 4
                }
            }
        };
        var se = new t, ue = new t, le = new t, ce = new t;
        ie.prototype.writeForMorph = function (e, i) {
            for (var n = this.modelMatrix, r = this.polylines, o = r.length, a = 0; o > a; ++a)for (var s = r[a], u = s._segments.positions, l = s._segments.lengths, c = u.length, d = 0, m = 0, p = 0; c > p; ++p) {
                var _;
                0 === p ? s._loop ? _ = u[c - 2] : (_ = ce, t.subtract(u[0], u[1], _), t.add(u[0], _, _)) : _ = u[p - 1], _ = f.multiplyByPoint(n, _, ue);
                var v, g = f.multiplyByPoint(n, u[p], se);
                p === c - 1 ? s._loop ? v = u[1] : (v = ce, t.subtract(u[c - 1], u[c - 2], v), t.add(u[c - 1], v, v)) : v = u[p + 1], v = f.multiplyByPoint(n, v, le);
                var y = l[d];
                p === m + y && (m += y, ++d);
                for (var C = p - m === 0, E = p === m + l[d] - 1, S = C ? 2 : 0, T = E ? 2 : 4, b = S; T > b; ++b)h.writeElements(g, e, i), h.writeElements(_, e, i + 6), h.writeElements(v, e, i + 12), i += 18
            }
        };
        var he = new Array(1);
        ie.prototype.updateIndices = function (e, t, i, n) {
            var r = i.length - 1, o = new G(0, n, this);
            i[r].push(o);
            var a = 0, s = e[e.length - 1], u = 0;
            s.length > 0 && (u = s[s.length - 1] + 1);
            for (var l = this.polylines, c = l.length, h = 0; c > h; ++h) {
                var d = l[h];
                d._locatorBuckets = [];
                var m;
                if (this.mode === M.SCENE3D) {
                    m = he;
                    var f = d._actualPositions.length;
                    if (!(f > 0))continue;
                    m[0] = f
                } else m = d._segments.lengths;
                var _ = m.length;
                if (_ > 0) {
                    for (var v = 0, g = 0; _ > g; ++g)for (var y = m[g] - 1, C = 0; y > C; ++C)u + 4 >= p.SIXTY_FOUR_KILOBYTES - 1 && (d._locatorBuckets.push({
                        locator: o,
                        count: v
                    }), v = 0, t.push(4), s = [], e.push(s), u = 0, o.count = a, a = 0, n = 0, o = new G(0, 0, this), i[++r] = [o]), s.push(u, u + 2, u + 1), s.push(u + 1, u + 2, u + 3), v += 6, a += 6, n += 6, u += 4;
                    d._locatorBuckets.push({
                        locator: o,
                        count: v
                    }), u + 4 >= p.SIXTY_FOUR_KILOBYTES - 1 && (t.push(0), s = [], e.push(s), u = 0, o.count = a, n = 0, a = 0, o = new G(0, 0, this), i[++r] = [o])
                }
                d._clean()
            }
            return o.count = a, n
        }, ie.prototype.getPolylineStartIndex = function (e) {
            for (var t = this.polylines, i = 0, n = t.length, r = 0; n > r; ++r) {
                var o = t[r];
                if (o === e)break;
                i += o._actualLength
            }
            return i
        };
        var de = {positions: void 0, lengths: void 0}, me = new Array(1), pe = new t, fe = new n;
        ie.prototype.getSegments = function (i, n) {
            var r = i._actualPositions;
            if (this.mode === M.SCENE3D)return me[0] = r.length, de.positions = r, de.lengths = me, de;
            H(i) && (r = i._segments.positions);
            for (var o, a = n.ellipsoid, s = [], u = this.modelMatrix, l = r.length, c = pe, h = 0; l > h; ++h)o = r[h], c = f.multiplyByPoint(u, o, c), s.push(n.project(a.cartesianToCartographic(c, fe)));
            if (s.length > 0) {
                i._boundingVolume2D = e.fromPoints(s, i._boundingVolume2D);
                var d = i._boundingVolume2D.center;
                i._boundingVolume2D.center = new t(d.z, d.x, d.y)
            }
            return de.positions = s, de.lengths = i._segments.lengths, de
        };
        var _e, ve;
        return ie.prototype.writeUpdate = function (e, i, n, r, o) {
            var a = this.mode, u = i._actualLength;
            if (u) {
                e += this.getPolylineStartIndex(i);
                var l = _e, c = ve, d = 6 * u * 3;
                !s(l) || l.length < d ? (l = _e = new Float32Array(d), c = ve = new Float32Array(4 * u)) : l.length > d && (l = new Float32Array(l.buffer, 0, d), c = new Float32Array(c.buffer, 0, 4 * u));
                var m, p = 0, f = 0, _ = this.getSegments(i, o), v = _.positions, g = _.lengths, y = 0, C = 0, E = i.width, S = i.show && E > 0;
                u = v.length;
                for (var T = 0; u > T; ++T) {
                    0 === T ? i._loop ? m = v[u - 2] : (m = ae, t.subtract(v[0], v[1], m), t.add(v[0], m, m)) : m = v[T - 1], re.x = m.x, re.y = m.y, re.z = a !== M.SCENE2D ? m.z : 0, m = v[T], ne.x = m.x, ne.y = m.y, ne.z = a !== M.SCENE2D ? m.z : 0, T === u - 1 ? i._loop ? m = v[1] : (m = ae, t.subtract(v[u - 1], v[u - 2], m), t.add(v[u - 1], m, m)) : m = v[T + 1], oe.x = m.x, oe.y = m.y, oe.z = a !== M.SCENE2D ? m.z : 0;
                    var b = g[y];
                    T === C + b && (C += b, ++y);
                    for (var w = T - C === 0, x = T === C + g[y] - 1, A = w ? 2 : 0, P = x ? 2 : 4, I = A; P > I; ++I) {
                        h.writeElements(ne, l, p), h.writeElements(re, l, p + 6), h.writeElements(oe, l, p + 12);
                        var D = 0 > I - 2 ? -1 : 1;
                        c[f] = T / (u - 1), c[f + 1] = 2 * (I % 2) - 1, c[f + 2] = D * E, c[f + 3] = S, p += 18, f += 4
                    }
                }
                n.copyFromArrayView(l, 18 * Float32Array.BYTES_PER_ELEMENT * e), r.copyFromArrayView(c, 4 * Float32Array.BYTES_PER_ELEMENT * e)
            }
        }, J
    }),define("Cesium/Core/TimeIntervalCollection", ["./binarySearch", "./defaultValue", "./defined", "./defineProperties", "./DeveloperError", "./Event", "./JulianDate", "./TimeInterval"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        function u(e, t) {
            return a.compare(e.start, t.start)
        }

        var l = function (e) {
            if (this._intervals = [], this._changedEvent = new o, i(e))for (var t = e.length, n = 0; t > n; n++)this.addInterval(e[n])
        };
        n(l.prototype, {
            changedEvent: {
                get: function () {
                    return this._changedEvent
                }
            }, start: {
                get: function () {
                    var e = this._intervals;
                    return 0 === e.length ? void 0 : e[0].start
                }
            }, isStartIncluded: {
                get: function () {
                    var e = this._intervals;
                    return 0 === e.length ? !1 : e[0].isStartIncluded
                }
            }, stop: {
                get: function () {
                    var e = this._intervals, t = e.length;
                    return 0 === t ? void 0 : e[t - 1].stop
                }
            }, isStopIncluded: {
                get: function () {
                    var e = this._intervals, t = e.length;
                    return 0 === t ? !1 : e[t - 1].isStopIncluded
                }
            }, length: {
                get: function () {
                    return this._intervals.length
                }
            }, isEmpty: {
                get: function () {
                    return 0 === this._intervals.length
                }
            }
        }), l.prototype.equals = function (e, t) {
            if (this === e)return !0;
            if (!(e instanceof l))return !1;
            var i = this._intervals, n = e._intervals, r = i.length;
            if (r !== n.length)return !1;
            for (var o = 0; r > o; o++)if (!s.equals(i[o], n[o], t))return !1;
            return !0
        }, l.prototype.get = function (e) {
            return this._intervals[e]
        }, l.prototype.removeAll = function () {
            this._intervals.length > 0 && (this._intervals.length = 0, this._changedEvent.raiseEvent(this))
        }, l.prototype.findIntervalContainingDate = function (e) {
            var t = this.indexOf(e);
            return t >= 0 ? this._intervals[t] : void 0
        }, l.prototype.findDataForIntervalContainingDate = function (e) {
            var t = this.indexOf(e);
            return t >= 0 ? this._intervals[t].data : void 0
        }, l.prototype.contains = function (e) {
            return this.indexOf(e) >= 0
        };
        var c = new s;
        return l.prototype.indexOf = function (t) {
            var i = this._intervals;
            c.start = t, c.stop = t;
            var n = e(i, c, u);
            return n >= 0 ? i[n].isStartIncluded ? n : n > 0 && i[n - 1].stop.equals(t) && i[n - 1].isStopIncluded ? n - 1 : ~n : (n = ~n, n > 0 && n - 1 < i.length && s.contains(i[n - 1], t) ? n - 1 : ~n)
        }, l.prototype.findInterval = function (e) {
            e = t(e, t.EMPTY_OBJECT);
            for (var n = e.start, r = e.stop, o = e.isStartIncluded, a = e.isStopIncluded, s = this._intervals, u = 0, l = s.length; l > u; u++) {
                var c = s[u];
                if (!(i(n) && !c.start.equals(n) || i(r) && !c.stop.equals(r) || i(o) && c.isStartIncluded !== o || i(a) && c.isStopIncluded !== a))return s[u]
            }
            return void 0
        }, l.prototype.addInterval = function (t, n) {
            if (!t.isEmpty) {
                var r, o, l = this._intervals;
                if (0 === l.length || a.greaterThan(t.start, l[l.length - 1].stop))return l.push(t), void this._changedEvent.raiseEvent(this);
                for (o = e(l, t, u), 0 > o ? o = ~o : o > 0 && t.isStartIncluded && l[o - 1].isStartIncluded && l[o - 1].start.equals(t.start) ? --o : o < l.length && !t.isStartIncluded && l[o].isStartIncluded && l[o].start.equals(t.start) && ++o, o > 0 && (r = a.compare(l[o - 1].stop, t.start), (r > 0 || 0 === r && (l[o - 1].isStopIncluded || t.isStartIncluded)) && ((i(n) ? n(l[o - 1].data, t.data) : l[o - 1].data === t.data) ? (t = new s(a.greaterThan(t.stop, l[o - 1].stop) ? {
                    start: l[o - 1].start,
                    stop: t.stop,
                    isStartIncluded: l[o - 1].isStartIncluded,
                    isStopIncluded: t.isStopIncluded,
                    data: t.data
                } : {
                    start: l[o - 1].start,
                    stop: l[o - 1].stop,
                    isStartIncluded: l[o - 1].isStartIncluded,
                    isStopIncluded: l[o - 1].isStopIncluded || t.stop.equals(l[o - 1].stop) && t.isStopIncluded,
                    data: t.data
                }), l.splice(o - 1, 1), --o) : (r = a.compare(l[o - 1].stop, t.stop), r > 0 || 0 === r && l[o - 1].isStopIncluded && !t.isStopIncluded ? l.splice(o - 1, 1, new s({
                    start: l[o - 1].start,
                    stop: t.start,
                    isStartIncluded: l[o - 1].isStartIncluded,
                    isStopIncluded: !t.isStartIncluded,
                    data: l[o - 1].data
                }), new s({
                    start: t.stop,
                    stop: l[o - 1].stop,
                    isStartIncluded: !t.isStopIncluded,
                    isStopIncluded: l[o - 1].isStopIncluded,
                    data: l[o - 1].data
                })) : l[o - 1] = new s({
                    start: l[o - 1].start,
                    stop: t.start,
                    isStartIncluded: l[o - 1].isStartIncluded,
                    isStopIncluded: !t.isStartIncluded,
                    data: l[o - 1].data
                })))); o < l.length && (r = a.compare(t.stop, l[o].start), r > 0 || 0 === r && (t.isStopIncluded || l[o].isStartIncluded));)if (i(n) ? n(l[o].data, t.data) : l[o].data === t.data)t = new s({
                    start: t.start,
                    stop: a.greaterThan(l[o].stop, t.stop) ? l[o].stop : t.stop,
                    isStartIncluded: t.isStartIncluded,
                    isStopIncluded: a.greaterThan(l[o].stop, t.stop) ? l[o].isStopIncluded : t.isStopIncluded,
                    data: t.data
                }), l.splice(o, 1); else {
                    if (l[o] = new s({
                            start: t.stop,
                            stop: l[o].stop,
                            isStartIncluded: !t.isStopIncluded,
                            isStopIncluded: l[o].isStopIncluded,
                            data: l[o].data
                        }), !l[o].isEmpty)break;
                    l.splice(o, 1)
                }
                l.splice(o, 0, t), this._changedEvent.raiseEvent(this)
            }
        }, l.prototype.removeInterval = function (t) {
            if (t.isEmpty)return !1;
            var i = !1, n = this._intervals, r = e(n, t, u);
            0 > r && (r = ~r);
            var o = t.start, l = t.stop, c = t.isStartIncluded, h = t.isStopIncluded;
            if (r > 0) {
                var d = n[r - 1], m = d.stop;
                (a.greaterThan(m, o) || s.equals(m, o) && d.isStopIncluded && c) && (i = !0, (a.greaterThan(m, l) || d.isStopIncluded && !h && s.equals(m, l)) && n.splice(r, 0, new s({
                    start: l,
                    stop: m,
                    isStartIncluded: !h,
                    isStopIncluded: d.isStopIncluded,
                    data: d.data
                })), n[r - 1] = new s({
                    start: d.start,
                    stop: o,
                    isStartIncluded: d.isStartIncluded,
                    isStopIncluded: !c,
                    data: d.data
                }))
            }
            var p = n[r];
            for (r < n.length && !c && p.isStartIncluded && o.equals(p.start) && (i = !0, n.splice(r, 0, new s({
                start: p.start,
                stop: p.start,
                isStartIncluded: !0,
                isStopIncluded: !0,
                data: p.data
            })), ++r, p = n[r]); r < n.length && a.greaterThan(l, p.stop);)i = !0, n.splice(r, 1);
            return r < n.length && l.equals(p.stop) && (i = !0, !h && p.isStopIncluded ? (r + 1 < n.length && n[r + 1].start.equals(l) && p.data === n[r + 1].data ? (n.splice(r, 1), p = new s({
                start: p.start,
                stop: p.stop,
                isStartIncluded: !0,
                isStopIncluded: p.isStopIncluded,
                data: p.data
            })) : p = new s({
                start: l,
                stop: l,
                isStartIncluded: !0,
                isStopIncluded: !0,
                data: p.data
            }), n[r] = p) : n.splice(r, 1)), r < n.length && (a.greaterThan(l, p.start) || l.equals(p.start) && h && p.isStartIncluded) && (i = !0, n[r] = new s({
                start: l,
                stop: p.stop,
                isStartIncluded: !h,
                isStopIncluded: p.isStopIncluded,
                data: p.data
            })), i && this._changedEvent.raiseEvent(this), i
        }, l.prototype.intersect = function (e, t, n) {
            for (var r = 0, o = 0, u = new l, c = this._intervals, h = e._intervals; r < c.length && o < h.length;) {
                var d = c[r], m = h[o];
                if (a.lessThan(d.stop, m.start))++r; else if (a.lessThan(m.stop, d.start))++o; else {
                    if (i(n) || i(t) && t(d.data, m.data) || !i(t) && m.data === d.data) {
                        var p = s.intersect(d, m, new s, n);
                        p.isEmpty || u.addInterval(p, t)
                    }
                    a.lessThan(d.stop, m.stop) || d.stop.equals(m.stop) && !d.isStopIncluded && m.isStopIncluded ? ++r : ++o
                }
            }
            return u
        }, l
    }),define("Cesium/DataSources/CompositeProperty", ["../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "../Core/EventHelper", "../Core/TimeIntervalCollection", "./Property"], function (e, t, i, n, r, o, a) {
        "use strict";
        function s(t, i, n, r) {
            var o = function () {
                n.raiseEvent(t)
            }, a = [];
            i.removeAll();
            for (var s = r.length, u = 0; s > u; u++) {
                var l = r.get(u);
                e(l.data) && -1 === a.indexOf(l.data) && i.add(l.data.definitionChanged, o)
            }
        }

        var u = function () {
            this._eventHelper = new r, this._definitionChanged = new n, this._intervals = new o, this._intervals.changedEvent.addEventListener(u.prototype._intervalsChanged, this)
        };
        return t(u.prototype, {
            isConstant: {
                get: function () {
                    return this._intervals.isEmpty
                }
            }, definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            }, intervals: {
                get: function () {
                    return this._intervals
                }
            }
        }), u.prototype.getValue = function (t, i) {
            var n = this._intervals.findDataForIntervalContainingDate(t);
            return e(n) ? n.getValue(t, i) : void 0
        }, u.prototype.equals = function (e) {
            return this === e || e instanceof u && this._intervals.equals(e._intervals, a.equals)
        }, u.prototype._intervalsChanged = function () {
            s(this, this._eventHelper, this._definitionChanged, this._intervals), this._definitionChanged.raiseEvent(this)
        }, u
    }),define("Cesium/DataSources/CompositePositionProperty", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "../Core/ReferenceFrame", "./CompositeProperty", "./Property"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        var u = function (t) {
            this._referenceFrame = e(t, o.FIXED), this._definitionChanged = new r, this._composite = new a, this._composite.definitionChanged.addEventListener(u.prototype._raiseDefinitionChanged, this)
        };
        return i(u.prototype, {
            isConstant: {
                get: function () {
                    return this._composite.isConstant
                }
            }, definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            }, intervals: {
                get: function () {
                    return this._composite.intervals
                }
            }, referenceFrame: {
                get: function () {
                    return this._referenceFrame
                }, set: function (e) {
                    this._referenceFrame = e
                }
            }
        }), u.prototype.getValue = function (e, t) {
            return this.getValueInReferenceFrame(e, o.FIXED, t)
        }, u.prototype.getValueInReferenceFrame = function (e, i, n) {
            var r = this._composite._intervals.findDataForIntervalContainingDate(e);
            return t(r) ? r.getValueInReferenceFrame(e, i, n) : void 0
        }, u.prototype.equals = function (e) {
            return this === e || e instanceof u && this._referenceFrame === e._referenceFrame && this._composite.equals(e._composite, s.equals)
        }, u.prototype._raiseDefinitionChanged = function () {
            this._definitionChanged.raiseEvent(this)
        }, u
    }),define("Cesium/DataSources/ReferenceProperty", ["../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "../Core/RuntimeError", "./Property"], function (e, t, i, n, r, o) {
        "use strict";
        function a(t) {
            var i = !0;
            if (t._resolveEntity) {
                var n = t._targetCollection.getById(t._targetId);
                if (e(n) ? (n.definitionChanged.addEventListener(u.prototype._onTargetEntityDefinitionChanged, t), t._targetEntity = n, t._resolveEntity = !1) : (n = t._targetEntity, i = !1), !e(n))throw new r('target entity "' + t._targetId + '" could not be resolved.')
            }
            return i
        }

        function s(t) {
            var i = t._targetProperty;
            if (t._resolveProperty) {
                var n = a(t), o = t._targetPropertyNames;
                i = t._targetEntity;
                for (var s = o.length, u = 0; s > u && e(i); u++)i = i[o[u]];
                if (e(i))t._targetProperty = i, t._resolveProperty = !n; else if (!e(t._targetProperty))throw new r('targetProperty "' + t._targetId + "." + o.join(".") + '" could not be resolved.')
            }
            return i
        }

        var u = function (e, t, i) {
            this._targetCollection = e, this._targetId = t, this._targetPropertyNames = i, this._targetProperty = void 0, this._targetEntity = void 0, this._definitionChanged = new n, this._resolveEntity = !0, this._resolveProperty = !0, e.collectionChanged.addEventListener(u.prototype._onCollectionChanged, this)
        };
        return t(u.prototype, {
            isConstant: {
                get: function () {
                    return o.isConstant(s(this))
                }
            }, definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            }, referenceFrame: {
                get: function () {
                    return s(this).referenceFrame
                }
            }, targetId: {
                get: function () {
                    return this._targetId
                }
            }, targetCollection: {
                get: function () {
                    return this._targetCollection
                }
            }, targetPropertyNames: {
                get: function () {
                    return this._targetPropertyNames
                }
            }, resolvedProperty: {
                get: function () {
                    return s(this)
                }
            }
        }), u.fromString = function (e, t) {
            for (var i, n = [], r = !0, o = !1, a = "", s = 0; s < t.length; ++s) {
                var l = t.charAt(s);
                o ? (a += l, o = !1) : "\\" === l ? o = !0 : r && "#" === l ? (i = a, r = !1, a = "") : r || "." !== l ? a += l : (n.push(a), a = "")
            }
            return n.push(a), new u(e, i, n)
        }, u.prototype.getValue = function (e, t) {
            return s(this).getValue(e, t)
        }, u.prototype.getValueInReferenceFrame = function (e, t, i) {
            return s(this).getValueInReferenceFrame(e, t, i)
        }, u.prototype.getType = function (e) {
            return s(this).getType(e)
        }, u.prototype.equals = function (e) {
            if (this === e)return !0;
            var t = this._targetPropertyNames, i = e._targetPropertyNames;
            if (this._targetCollection !== e._targetCollection || this._targetId !== e._targetId || t.length !== i.length)return !1;
            for (var n = this._targetPropertyNames.length, r = 0; n > r; r++)if (t[r] !== i[r])return !1;
            return !0
        }, u.prototype._onTargetEntityDefinitionChanged = function (e, t, i, n) {
            this._targetPropertyNames[0] === t && (this._resolveProperty = !0, this._definitionChanged.raiseEvent(this))
        }, u.prototype._onCollectionChanged = function (t, i, n) {
            var r = this._targetEntity;
            e(r) && (-1 !== n.indexOf(r) ? (r.definitionChanged.removeEventListener(u.prototype._onTargetEntityDefinitionChanged, this), this._resolveEntity = !0, this._resolveProperty = !0) : this._resolveEntity && (s(this), this._resolveEntity || this._definitionChanged.raiseEvent(this)))
        }, u
    }),define("Cesium/Core/ExtrapolationType", ["./freezeObject"], function (e) {
        "use strict";
        var t = {NONE: 0, HOLD: 1, EXTRAPOLATE: 2};
        return e(t)
    }),define("Cesium/Core/LinearApproximation", ["./defined", "./DeveloperError"], function (e, t) {
        "use strict";
        var i = {type: "Linear"};
        return i.getRequiredDataPoints = function (e) {
            return 2
        }, i.interpolateOrderZero = function (t, i, n, r, o) {
            e(o) || (o = new Array(r));
            var a, s, u, l = i[0], c = i[1];
            for (a = 0; r > a; a++)s = n[a], u = n[a + r], o[a] = ((u - s) * t + c * s - l * u) / (c - l);
            return o
        }, i
    }),define("Cesium/DataSources/SampledProperty", ["../Core/binarySearch", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "../Core/ExtrapolationType", "../Core/JulianDate", "../Core/LinearApproximation"], function (e, t, i, n, r, o, a, s, u) {
        "use strict";
        function l(e, t, i) {
            var n, r = e.length, o = i.length, a = r + o;
            if (e.length = a, r !== t) {
                var s = r - 1;
                for (n = a - 1; n >= t; n--)e[n] = e[s--]
            }
            for (n = 0; o > n; n++)e[t++] = i[n]
        }

        function c(e, t) {
            return e instanceof s ? e : "string" == typeof e ? s.fromIso8601(e) : s.addSeconds(t, e, new s)
        }

        var h = {
            packedLength: 1, pack: function (e, i, n) {
                n = t(n, 0), i[n] = e
            }, unpack: function (e, i, n) {
                return i = t(i, 0), e[i]
            }
        }, d = [], m = [], p = function (t, n, r, o, a) {
            for (var u, h, p, f, _, v, g = 0; g < o.length;) {
                _ = c(o[g], t), p = e(n, _, s.compare);
                var y = 0, C = 0;
                if (0 > p) {
                    for (p = ~p, f = p * a, h = void 0, v = n[p]; g < o.length && (_ = c(o[g], t), !(i(h) && s.compare(h, _) >= 0 || i(v) && s.compare(_, v) >= 0));) {
                        for (d[y++] = _, g += 1, u = 0; a > u; u++)m[C++] = o[g], g += 1;
                        h = _
                    }
                    y > 0 && (m.length = C, l(r, f, m), d.length = y, l(n, p, d))
                } else {
                    for (u = 0; a > u; u++)g++, r[p * a + u] = o[g];
                    g++
                }
            }
        }, f = function (e, n) {
            var r = e;
            r === Number && (r = h);
            var s, l = r.packedLength, c = t(r.packedInterpolationLength, l), d = 0;
            if (i(n)) {
                var m = n.length;
                s = new Array(m);
                for (var p = 0; m > p; p++) {
                    var f = n[p];
                    f === Number && (f = h);
                    var _ = f.packedLength;
                    l += _, c += t(f.packedInterpolationLength, _), s[p] = f
                }
                d = m
            }
            this._type = e, this._innerType = r, this._interpolationDegree = 1, this._interpolationAlgorithm = u, this._numberOfPoints = 0, this._times = [], this._values = [], this._xTable = [], this._yTable = [], this._packedLength = l, this._packedInterpolationLength = c, this._updateTableLength = !0, this._interpolationResult = new Array(c), this._definitionChanged = new o, this._derivativeTypes = n, this._innerDerivativeTypes = s, this._inputOrder = d, this._forwardExtrapolationType = a.NONE, this._forwardExtrapolationDuration = 0, this._backwardExtrapolationType = a.NONE, this._backwardExtrapolationDuration = 0
        };
        return n(f.prototype, {
            isConstant: {
                get: function () {
                    return 0 === this._values.length
                }
            }, definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            }, type: {
                get: function () {
                    return this._type
                }
            }, derivativeTypes: {
                get: function () {
                    return this._derivativeTypes
                }
            }, interpolationDegree: {
                get: function () {
                    return this._interpolationDegree
                }
            }, interpolationAlgorithm: {
                get: function () {
                    return this._interpolationAlgorithm
                }
            }, forwardExtrapolationType: {
                get: function () {
                    return this._forwardExtrapolationType
                }, set: function (e) {
                    this._forwardExtrapolationType !== e && (this._forwardExtrapolationType = e, this._definitionChanged.raiseEvent(this))
                }
            }, forwardExtrapolationDuration: {
                get: function () {
                    return this._forwardExtrapolationDuration
                }, set: function (e) {
                    this._forwardExtrapolationDuration !== e && (this._forwardExtrapolationDuration = e, this._definitionChanged.raiseEvent(this))
                }
            }, backwardExtrapolationType: {
                get: function () {
                    return this._backwardExtrapolationType
                }, set: function (e) {
                    this._backwardExtrapolationType !== e && (this._backwardExtrapolationType = e, this._definitionChanged.raiseEvent(this))
                }
            }, backwardExtrapolationDuration: {
                get: function () {
                    return this._backwardExtrapolationDuration
                }, set: function (e) {
                    this._backwardExtrapolationDuration !== e && (this._backwardExtrapolationDuration = e, this._definitionChanged.raiseEvent(this))
                }
            }
        }), f.prototype.getValue = function (t, n) {
            var r = this._times, o = r.length;
            if (0 === o)return void 0;
            var u, l = this._innerType, c = this._values, h = e(r, t, s.compare);
            if (0 > h) {
                if (h = ~h, 0 === h) {
                    var d = r[h];
                    if (u = this._backwardExtrapolationDuration, this._backwardExtrapolationType === a.NONE || 0 !== u && s.secondsDifference(d, t) > u)return void 0;
                    if (this._backwardExtrapolationType === a.HOLD)return l.unpack(c, 0, n)
                }
                if (h >= o) {
                    h = o - 1;
                    var m = r[h];
                    if (u = this._forwardExtrapolationDuration, this._forwardExtrapolationType === a.NONE || 0 !== u && s.secondsDifference(t, m) > u)return void 0;
                    if (this._forwardExtrapolationType === a.HOLD)return h = o - 1, l.unpack(c, h * l.packedLength, n)
                }
                var p = this._xTable, f = this._yTable, _ = this._interpolationAlgorithm, v = this._packedInterpolationLength, g = this._inputOrder;
                if (this._updateTableLength) {
                    this._updateTableLength = !1;
                    var y = Math.min(_.getRequiredDataPoints(this._interpolationDegree, g), o);
                    y !== this._numberOfPoints && (this._numberOfPoints = y, p.length = y, f.length = y * v)
                }
                var C = this._numberOfPoints - 1;
                if (1 > C)return void 0;
                var E = 0, S = o - 1, T = S - E + 1;
                if (C + 1 > T); else {
                    var b = h - (C / 2 | 0) - 1;
                    E > b && (b = E);
                    var w = b + C;
                    w > S && (w = S, b = w - C, E > b && (b = E)), E = b, S = w
                }
                for (var x = S - E + 1, A = 0; x > A; ++A)p[A] = s.secondsDifference(r[E + A], r[S]);
                if (i(l.convertPackedArrayForInterpolation))l.convertPackedArrayForInterpolation(c, E, S, f); else for (var P = 0, I = this._packedLength, D = E * I, M = (S + 1) * I; M > D;)f[P] = c[D], D++, P++;
                var O, R = s.secondsDifference(t, r[S]);
                if (0 !== g && i(_.interpolate)) {
                    var N = Math.floor(v / (g + 1));
                    O = _.interpolate(R, p, f, N, g, g, this._interpolationResult)
                } else O = _.interpolateOrderZero(R, p, f, v, this._interpolationResult);
                return i(l.unpackInterpolationResult) ? l.unpackInterpolationResult(O, c, E, S, n) : l.unpack(O, 0, n)
            }
            return l.unpack(c, h * this._packedLength, n)
        }, f.prototype.setInterpolationOptions = function (e) {
            var t = !1, i = e.interpolationAlgorithm, n = e.interpolationDegree;
            this._interpolationAlgorithm !== i && (this._interpolationAlgorithm = i, t = !0), this._interpolationDegree !== n && (this._interpolationDegree = n, t = !0), t && (this._updateTableLength = !0, this._definitionChanged.raiseEvent(this))
        }, f.prototype.addSample = function (e, t, n) {
            var r = this._innerDerivativeTypes, o = i(r), a = this._innerType, s = [];
            if (s.push(e), a.pack(t, s, s.length), o)for (var u = r.length, l = 0; u > l; l++)r[l].pack(n[l], s, s.length);
            p(void 0, this._times, this._values, s, this._packedLength), this._updateTableLength = !0, this._definitionChanged.raiseEvent(this)
        }, f.prototype.addSamples = function (e, t, n) {
            for (var r = this._innerDerivativeTypes, o = i(r), a = this._innerType, s = e.length, u = [], l = 0; s > l; l++)if (u.push(e[l]), a.pack(t[l], u, u.length), o)for (var c = n[l], h = r.length, d = 0; h > d; d++)r[d].pack(c[d], u, u.length);
            p(void 0, this._times, this._values, u, this._packedLength), this._updateTableLength = !0, this._definitionChanged.raiseEvent(this)
        }, f.prototype.addSamplesPackedArray = function (e, t) {
            p(t, this._times, this._values, e, this._packedLength), this._updateTableLength = !0, this._definitionChanged.raiseEvent(this)
        }, f.prototype.equals = function (e) {
            if (this === e)return !0;
            if (!i(e))return !1;
            if (this._type !== e._type || this._interpolationDegree !== e._interpolationDegree || this._interpolationAlgorithm !== e._interpolationAlgorithm)return !1;
            var t = this._derivativeTypes, n = i(t), r = e._derivativeTypes, o = i(r);
            if (n !== o)return !1;
            var a, u;
            if (n) {
                if (u = t.length, u !== r.length)return !1;
                for (a = 0; u > a; a++)if (t[a] !== r[a])return !1
            }
            var l = this._times, c = e._times;
            if (u = l.length, u !== c.length)return !1;
            for (a = 0; u > a; a++)if (!s.equals(l[a], c[a]))return !1;
            var h = this._values, d = e._values;
            for (a = 0; u > a; a++)if (h[a] !== d[a])return !1;
            return !0
        }, f._mergeNewSamples = p, f
    }),define("Cesium/DataSources/SampledPositionProperty", ["../Core/Cartesian3", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "../Core/ReferenceFrame", "./PositionProperty", "./Property", "./SampledProperty"], function (e, t, i, n, r, o, a, s, u, l) {
        "use strict";
        var c = function (i, n) {
            n = t(n, 0);
            var r;
            if (n > 0) {
                r = new Array(n);
                for (var s = 0; n > s; s++)r[s] = e
            }
            this._numberOfDerivatives = n, this._property = new l(e, r), this._definitionChanged = new o, this._referenceFrame = t(i, a.FIXED), this._property._definitionChanged.addEventListener(function () {
                this._definitionChanged.raiseEvent(this)
            }, this)
        };
        return n(c.prototype, {
            isConstant: {
                get: function () {
                    return this._property.isConstant
                }
            }, definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            }, referenceFrame: {
                get: function () {
                    return this._referenceFrame
                }
            }, interpolationDegree: {
                get: function () {
                    return this._property.interpolationDegree
                }
            }, interpolationAlgorithm: {
                get: function () {
                    return this._property.interpolationAlgorithm
                }
            }, numberOfDerivatives: {
                get: function () {
                    return this._numberOfDerivatives
                }
            }, forwardExtrapolationType: {
                get: function () {
                    return this._property.forwardExtrapolationType
                }, set: function (e) {
                    this._property.forwardExtrapolationType = e
                }
            }, forwardExtrapolationDuration: {
                get: function () {
                    return this._property.forwardExtrapolationDuration
                }, set: function (e) {
                    this._property.forwardExtrapolationDuration = e
                }
            }, backwardExtrapolationType: {
                get: function () {
                    return this._property.backwardExtrapolationType
                }, set: function (e) {
                    this._property.backwardExtrapolationType = e
                }
            }, backwardExtrapolationDuration: {
                get: function () {
                    return this._property.backwardExtrapolationDuration
                }, set: function (e) {
                    this._property.backwardExtrapolationDuration = e
                }
            }
        }), c.prototype.getValue = function (e, t) {
            return this.getValueInReferenceFrame(e, a.FIXED, t)
        }, c.prototype.getValueInReferenceFrame = function (e, t, n) {
            return n = this._property.getValue(e, n), i(n) ? s.convertToReferenceFrame(e, n, this._referenceFrame, t, n) : void 0
        }, c.prototype.setInterpolationOptions = function (e) {
            this._property.setInterpolationOptions(e)
        }, c.prototype.addSample = function (e, t, i) {
            this._numberOfDerivatives;
            this._property.addSample(e, t, i)
        }, c.prototype.addSamples = function (e, t, i) {
            this._property.addSamples(e, t, i)
        }, c.prototype.addSamplesPackedArray = function (e, t) {
            this._property.addSamplesPackedArray(e, t)
        }, c.prototype.equals = function (e) {
            return this === e || e instanceof c && u.equals(this._property, e._property) && this._referenceFrame === e._referenceFrame
        }, c
    }),define("Cesium/DataSources/ScaledPositionProperty", ["../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Ellipsoid", "../Core/Event", "../Core/ReferenceFrame", "./Property"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = function (e) {
            this._definitionChanged = new r, this._value = void 0, this._removeSubscription = void 0, this.setValue(e)
        };
        return t(s.prototype, {
            isConstant: {
                get: function () {
                    return a.isConstant(this._value)
                }
            }, definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            }, referenceFrame: {
                get: function () {
                    return e(this._value) ? this._value.referenceFrame : o.FIXED
                }
            }
        }), s.prototype.getValue = function (e, t) {
            return this.getValueInReferenceFrame(e, o.FIXED, t)
        }, s.prototype.setValue = function (t) {
            this._value !== t && (this._value = t, e(this._removeSubscription) && (this._removeSubscription(), this._removeSubscription = void 0), e(t) && (this._removeSubscription = t.definitionChanged.addEventListener(this._raiseDefinitionChanged, this)), this._definitionChanged.raiseEvent(this))
        }, s.prototype.getValueInReferenceFrame = function (t, i, r) {
            return e(this._value) ? (r = this._value.getValueInReferenceFrame(t, i, r), e(r) ? n.WGS84.scaleToGeodeticSurface(r, r) : void 0) : void 0
        }, s.prototype.equals = function (e) {
            return this === e || e instanceof s && this._value === e._value
        }, s.prototype._raiseDefinitionChanged = function () {
            this._definitionChanged.raiseEvent(this)
        }, s
    }),define("Cesium/DataSources/TimeIntervalCollectionPositionProperty", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "../Core/ReferenceFrame", "../Core/TimeIntervalCollection", "./PositionProperty", "./Property"], function (e, t, i, n, r, o, a, s, u) {
        "use strict";
        var l = function (t) {
            this._definitionChanged = new r, this._intervals = new a, this._intervals.changedEvent.addEventListener(l.prototype._intervalsChanged, this), this._referenceFrame = e(t, o.FIXED)
        };
        return i(l.prototype, {
            isConstant: {
                get: function () {
                    return this._intervals.isEmpty
                }
            }, definitionChanged: {
                get: function () {
                    return this._definitionChanged
                }
            }, intervals: {
                get: function () {
                    return this._intervals
                }
            }, referenceFrame: {
                get: function () {
                    return this._referenceFrame
                }
            }
        }), l.prototype.getValue = function (e, t) {
            return this.getValueInReferenceFrame(e, o.FIXED, t)
        }, l.prototype.getValueInReferenceFrame = function (e, i, n) {
            var r = this._intervals.findDataForIntervalContainingDate(e);
            return t(r) ? s.convertToReferenceFrame(e, r, this._referenceFrame, i, n) : void 0
        }, l.prototype.equals = function (e) {
            return this === e || e instanceof l && this._intervals.equals(e._intervals, u.equals) && this._referenceFrame === e._referenceFrame
        }, l.prototype._intervalsChanged = function () {
            this._definitionChanged.raiseEvent(this)
        }, l
    }),define("Cesium/DataSources/PathVisualizer", ["../Core/AssociativeArray", "../Core/Cartesian3", "../Core/defined", "../Core/destroyObject", "../Core/DeveloperError", "../Core/JulianDate", "../Core/Matrix3", "../Core/Matrix4", "../Core/ReferenceFrame", "../Core/TimeInterval", "../Core/Transforms", "../Scene/PolylineCollection", "../Scene/SceneMode", "./CompositePositionProperty", "./ConstantPositionProperty", "./MaterialProperty", "./Property", "./ReferenceProperty", "./SampledPositionProperty", "./ScaledPositionProperty", "./TimeIntervalCollectionPositionProperty"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C) {
        "use strict";
        function E(e, t, n, r, a, s, u, l, c) {
            var h, d = l;
            h = e.getValueInReferenceFrame(t, s, c[d]), i(h) && (c[d++] = h);
            for (var m, p, f, _ = !i(a) || o.lessThanOrEquals(a, t) || o.greaterThanOrEquals(a, n), v = 0, g = r.length, y = r[v], C = n, E = !1; g > v;) {
                if (!_ && o.greaterThanOrEquals(y, a) && (h = e.getValueInReferenceFrame(a, s, c[d]), i(h) && (c[d++] = h), _ = !0), o.greaterThan(y, t) && o.lessThan(y, C) && !y.equals(a) && (h = e.getValueInReferenceFrame(y, s, c[d]), i(h) && (c[d++] = h)), g - 1 > v) {
                    if (u > 0 && !E) {
                        var S = r[v + 1], T = o.secondsDifference(S, y);
                        E = T > u, E && (m = Math.ceil(T / u), p = 0, f = T / Math.max(m, 2), m = Math.max(m - 1, 1))
                    }
                    if (E && m > p) {
                        y = o.addSeconds(y, f, new o), p++;
                        continue
                    }
                }
                E = !1, v++, y = r[v]
            }
            return h = e.getValueInReferenceFrame(n, s, c[d]), i(h) && (c[d++] = h), d
        }

        function S(e, t, n, r, a, s, u, l) {
            for (var c, h = 0, d = u, m = t, p = Math.max(s, 60), f = !i(r) || o.lessThanOrEquals(r, t) || o.greaterThanOrEquals(r, n); o.lessThan(m, n);)!f && o.greaterThanOrEquals(m, r) && (f = !0, c = e.getValueInReferenceFrame(r, a, l[d]), i(c) && (l[d] = c, d++)), c = e.getValueInReferenceFrame(m, a, l[d]), i(c) && (l[d] = c, d++), h++, m = o.addSeconds(t, p * h, new o);
            return c = e.getValueInReferenceFrame(n, a, l[d]), i(c) && (l[d] = c, d++), d
        }

        function T(e, t, n, r, a, s, u, c) {
            O.start = t, O.stop = n;
            for (var h = u, d = e.intervals, m = 0; m < d.length; m++) {
                var p = d.get(m);
                if (!l.intersect(p, O, D).isEmpty) {
                    var f = p.start;
                    p.isStartIncluded || (f = p.isStopIncluded ? p.stop : o.addSeconds(p.start, o.secondsDifference(p.stop, p.start) / 2, new o));
                    var _ = e.getValueInReferenceFrame(f, a, c[h]);
                    i(_) && (c[h] = _, h++)
                }
            }
            return h
        }

        function b(e, t, n, r, o, a, s, u) {
            var l = e.getValueInReferenceFrame(t, o, u[s]);
            return i(l) && (u[s++] = l), s
        }

        function w(e, t, i, n, r, a, s, u) {
            M.start = t, M.stop = i;
            for (var c = s, h = e.intervals, d = 0; d < h.length; d++) {
                var m = h.get(d);
                if (!l.intersect(m, M, D).isEmpty) {
                    var p = m.start, f = m.stop, _ = t;
                    o.greaterThan(p, _) && (_ = p);
                    var v = i;
                    o.lessThan(f, v) && (v = f), c = x(m.data, _, v, n, r, a, c, u)
                }
            }
            return c
        }

        function x(e, t, i, n, r, o, a, s) {
            for (var u = e; u instanceof v || u instanceof y;)u instanceof v && (u = u.resolvedProperty), u instanceof y && (u = u._value);
            if (u instanceof g) {
                var l = u._property._times;
                a = E(e, t, i, l, n, r, o, a, s)
            } else a = u instanceof m ? w(e, t, i, n, r, o, a, s) : u instanceof C ? T(e, t, i, n, r, o, a, s) : u instanceof p ? b(e, t, i, n, r, o, a, s) : S(e, t, i, n, r, o, a, s);
            return a
        }

        function A(e, t, n, r, o, a, s) {
            i(s) || (s = []);
            var u = x(e, t, n, r, o, a, 0, s);
            return s.length = u, s
        }

        var P = 60, I = 1, D = new l, M = new l, O = new l, R = function (e) {
            this.entity = e, this.polyline = void 0, this.index = void 0, this.updater = void 0
        }, N = new a, L = function (e, t) {
            this._unusedIndexes = [], this._polylineCollection = new h, this._scene = e, this._referenceFrame = t, e.primitives.add(this._polylineCollection)
        };
        L.prototype.update = function (e) {
            if (this._referenceFrame === u.INERTIAL) {
                var n = c.computeIcrfToFixedMatrix(e, N);
                i(n) || (n = c.computeTemeToPseudoFixedMatrix(e, N)), s.fromRotationTranslation(n, t.ZERO, this._polylineCollection.modelMatrix)
            }
        }, L.prototype.updateObject = function (e, t) {
            var n, r, a = t.entity, s = a._path, u = a._position, l = s._show, c = t.polyline, h = a.isShowing && (!i(l) || l.getValue(e));
            if (h) {
                var d = _.getValueOrUndefined(s._leadTime, e), m = _.getValueOrUndefined(s._trailTime, e), p = a._availability, v = i(p), g = i(d), y = i(m);
                if (h = v || g && y) {
                    if (y && (n = o.addSeconds(e, -m, new o)), g && (r = o.addSeconds(e, d, new o)), v) {
                        var C = p.start, E = p.stop;
                        (!y || o.greaterThan(C, n)) && (n = C), (!g || o.lessThan(E, r)) && (r = E)
                    }
                    h = o.lessThan(n, r)
                }
            }
            if (!h)return void(i(c) && (this._unusedIndexes.push(t.index), t.polyline = void 0, c.show = !1, t.index = void 0));
            if (!i(c)) {
                var S = this._unusedIndexes, T = S.length;
                if (T > 0) {
                    var b = S.pop();
                    c = this._polylineCollection.get(b), t.index = b
                } else t.index = this._polylineCollection.length, c = this._polylineCollection.add();
                c.id = a, t.polyline = c
            }
            var w = _.getValueOrDefault(s._resolution, e, P);
            c.show = !0, c.positions = A(u, n, r, e, this._referenceFrame, w, c.positions), c.material = f.getValue(e, s._material, c.material), c.width = _.getValueOrDefault(s._width, e, I)
        }, L.prototype.removeObject = function (e) {
            var t = e.polyline;
            i(t) && (this._unusedIndexes.push(e.index), e.polyline = void 0, t.show = !1, e.index = void 0)
        }, L.prototype.destroy = function () {
            return this._scene.primitives.remove(this._polylineCollection), n(this)
        };
        var F = function (t, i) {
            i.collectionChanged.addEventListener(F.prototype._onCollectionChanged, this), this._scene = t, this._updaters = {}, this._entityCollection = i, this._items = new e, this._onCollectionChanged(i, i.values, [], [])
        };
        return F.prototype.update = function (e) {
            var t = this._updaters;
            for (var n in t)t.hasOwnProperty(n) && t[n].update(e);
            for (var r = this._items.values, o = 0, a = r.length; a > o; o++) {
                var s = r[o], l = s.entity, c = l._position, h = s.updater, m = u.FIXED;
                this._scene.mode === d.SCENE3D && (m = c.referenceFrame);
                var p = this._updaters[m];
                h === p && i(p) ? p.updateObject(e, s) : (i(h) && h.removeObject(s), i(p) || (p = new L(this._scene, m), p.update(e), this._updaters[m] = p), s.updater = p, i(p) && p.updateObject(e, s))
            }
            return !0
        }, F.prototype.isDestroyed = function () {
            return !1
        }, F.prototype.destroy = function () {
            this._entityCollection.collectionChanged.removeEventListener(F.prototype._onCollectionChanged, this);
            var e = this._updaters;
            for (var t in e)e.hasOwnProperty(t) && e[t].destroy();
            return n(this)
        }, F.prototype._onCollectionChanged = function (e, t, n, r) {
            var o, a, s, u = this._items;
            for (o = t.length - 1; o > -1; o--)a = t[o], i(a._path) && i(a._position) && u.set(a.id, new R(a));
            for (o = r.length - 1; o > -1; o--)a = r[o], i(a._path) && i(a._position) ? u.contains(a.id) || u.set(a.id, new R(a)) : (s = u.get(a.id), i(s) && (s.updater.removeObject(s), u.remove(a.id)));
            for (o = n.length - 1; o > -1; o--)a = n[o], s = u.get(a.id), i(s) && (s.updater.removeObject(s), u.remove(a.id))
        }, F._subSample = A, F
    }),define("Cesium/Shaders/PointPrimitiveCollectionFS", [], function () {
        "use strict";
        return "varying vec4 v_color;\nvarying vec4 v_outlineColor;\nvarying float v_innerPercent;\nvarying float v_pixelDistance;\n\n#ifdef RENDER_FOR_PICK\nvarying vec4 v_pickColor;\n#endif\n\nvoid main()\n{\n    // The distance in UV space from this fragment to the center of the point, at most 0.5.\n    float distanceToCenter = length(gl_PointCoord - vec2(0.5));\n    // The max distance stops one pixel shy of the edge to leave space for anti-aliasing.\n    float maxDistance = max(0.0, 0.5 - v_pixelDistance);\n    float wholeAlpha = 1.0 - smoothstep(maxDistance, 0.5, distanceToCenter);\n    float innerAlpha = 1.0 - smoothstep(maxDistance * v_innerPercent, 0.5 * v_innerPercent, distanceToCenter);\n\n    vec4 color = mix(v_outlineColor, v_color, innerAlpha);\n    color.a *= wholeAlpha;\n    if (color.a < 0.005)\n    {\n        discard;\n    }\n\n#ifdef RENDER_FOR_PICK\n    gl_FragColor = v_pickColor;\n#else\n    gl_FragColor = color;\n#endif\n}"
    }),define("Cesium/Shaders/PointPrimitiveCollectionVS", [], function () {
        "use strict";
        return 'uniform float u_maxTotalPointSize;\n\nattribute vec4 positionHighAndSize;\nattribute vec4 positionLowAndOutline;\nattribute vec4 compressedAttribute0;        // color, outlineColor, pick color\nattribute vec4 compressedAttribute1;        // show, translucency by distance, some free space\nattribute vec4 scaleByDistance;             // near, nearScale, far, farScale\n\nvarying vec4 v_color;\nvarying vec4 v_outlineColor;\nvarying float v_innerPercent;\nvarying float v_pixelDistance;\n\n#ifdef RENDER_FOR_PICK\nvarying vec4 v_pickColor;\n#endif\n\nconst float SHIFT_LEFT8 = 256.0;\nconst float SHIFT_RIGHT8 = 1.0 / 256.0;\n\nvoid main()\n{\n    // Modifying this shader may also require modifications to PointPrimitive._computeScreenSpacePosition\n\n    // unpack attributes\n    vec3 positionHigh = positionHighAndSize.xyz;\n    vec3 positionLow = positionLowAndOutline.xyz;\n    float outlineWidthBothSides = 2.0 * positionLowAndOutline.w;\n    float totalSize = positionHighAndSize.w + outlineWidthBothSides;\n    float outlinePercent = outlineWidthBothSides / totalSize;\n    // Scale in response to browser-zoom.\n    totalSize *= czm_resolutionScale;\n    // Add padding for anti-aliasing on both sides.\n    totalSize += 3.0;\n\n    float temp = compressedAttribute1.x * SHIFT_RIGHT8;\n    float show = floor(temp);\n\n#ifdef EYE_DISTANCE_TRANSLUCENCY\n    vec4 translucencyByDistance;\n    translucencyByDistance.x = compressedAttribute1.z;\n    translucencyByDistance.z = compressedAttribute1.w;\n\n    translucencyByDistance.y = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;\n\n    temp = compressedAttribute1.y * SHIFT_RIGHT8;\n    translucencyByDistance.w = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;\n#endif\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    vec4 color;\n    vec4 outlineColor;\n#ifdef RENDER_FOR_PICK\n    // compressedAttribute0.z => pickColor.rgb\n\n    color = vec4(0.0);\n    outlineColor = vec4(0.0);\n    vec4 pickColor;\n    temp = compressedAttribute0.z * SHIFT_RIGHT8;\n    pickColor.b = (temp - floor(temp)) * SHIFT_LEFT8;\n    temp = floor(temp) * SHIFT_RIGHT8;\n    pickColor.g = (temp - floor(temp)) * SHIFT_LEFT8;\n    pickColor.r = floor(temp);\n#else\n    // compressedAttribute0.x => color.rgb\n\n    temp = compressedAttribute0.x * SHIFT_RIGHT8;\n    color.b = (temp - floor(temp)) * SHIFT_LEFT8;\n    temp = floor(temp) * SHIFT_RIGHT8;\n    color.g = (temp - floor(temp)) * SHIFT_LEFT8;\n    color.r = floor(temp);\n\n    // compressedAttribute0.y => outlineColor.rgb\n\n    temp = compressedAttribute0.y * SHIFT_RIGHT8;\n    outlineColor.b = (temp - floor(temp)) * SHIFT_LEFT8;\n    temp = floor(temp) * SHIFT_RIGHT8;\n    outlineColor.g = (temp - floor(temp)) * SHIFT_LEFT8;\n    outlineColor.r = floor(temp);\n#endif\n\n    // compressedAttribute0.w => color.a, outlineColor.a, pickColor.a\n\n    temp = compressedAttribute0.w * SHIFT_RIGHT8;\n#ifdef RENDER_FOR_PICK\n    pickColor.a = (temp - floor(temp)) * SHIFT_LEFT8;\n    pickColor = pickColor / 255.0;\n#endif\n    temp = floor(temp) * SHIFT_RIGHT8;\n    outlineColor.a = (temp - floor(temp)) * SHIFT_LEFT8;\n    outlineColor /= 255.0;\n    color.a = floor(temp);\n    color /= 255.0;\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n    vec4 positionEC = czm_modelViewRelativeToEye * p;\n    positionEC.xyz *= show;\n\n    ///////////////////////////////////////////////////////////////////////////\n\n#if defined(EYE_DISTANCE_SCALING) || defined(EYE_DISTANCE_TRANSLUCENCY)\n    float lengthSq;\n    if (czm_sceneMode == czm_sceneMode2D)\n    {\n        // 2D camera distance is a special case\n        // treat all billboards as flattened to the z=0.0 plane\n        lengthSq = czm_eyeHeight2D.y;\n    }\n    else\n    {\n        lengthSq = dot(positionEC.xyz, positionEC.xyz);\n    }\n#endif\n\n#ifdef EYE_DISTANCE_SCALING\n    totalSize *= czm_nearFarScalar(scaleByDistance, lengthSq);\n#endif\n    // Clamp to max point size.\n    totalSize = min(totalSize, u_maxTotalPointSize);\n    // If size is too small, push vertex behind near plane for clipping.\n    // Note that context.minimumAliasedPointSize "will be at most 1.0".\n    if (totalSize < 1.0)\n    {\n        positionEC.xyz = vec3(0.0);\n        totalSize = 1.0;\n    }\n\n    float translucency = 1.0;\n#ifdef EYE_DISTANCE_TRANSLUCENCY\n    translucency = czm_nearFarScalar(translucencyByDistance, lengthSq);\n    // push vertex behind near plane for clipping\n    if (translucency < 0.004)\n    {\n        positionEC.xyz = vec3(0.0);\n    }\n#endif\n\n    vec4 positionWC = czm_eyeToWindowCoordinates(positionEC);\n\n    gl_Position = czm_viewportOrthographic * vec4(positionWC.xy, -positionWC.z, 1.0);\n\n    v_color = color;\n    v_color.a *= translucency;\n    v_outlineColor = outlineColor;\n    v_outlineColor.a *= translucency;\n\n    v_innerPercent = 1.0 - outlinePercent;\n    v_pixelDistance = 2.0 / totalSize;\n    gl_PointSize = totalSize;\n\n#ifdef RENDER_FOR_PICK\n    v_pickColor = pickColor;\n#endif\n}\n'
    }),define("Cesium/Scene/PointPrimitive", ["../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/Color", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Matrix4", "../Core/NearFarScalar", "./SceneMode", "./SceneTransforms"], function (e, t, i, n, r, o, a, s, u, l, c, h) {
        "use strict";
        function d(e, t) {
            var i = e._pointPrimitiveCollection;
            o(i) && (i._updatePointPrimitive(e, t), e._dirty = !0)
        }

        var m = function (e, i) {
            e = r(e, r.EMPTY_OBJECT), this._show = r(e.show, !0), this._position = t.clone(r(e.position, t.ZERO)), this._actualPosition = t.clone(this._position), this._color = n.clone(r(e.color, n.WHITE)), this._outlineColor = n.clone(r(e.outlineColor, n.TRANSPARENT)), this._outlineWidth = r(e.outlineWidth, 0), this._pixelSize = r(e.pixelSize, 10), this._scaleByDistance = e.scaleByDistance, this._translucencyByDistance = e.translucencyByDistance, this._id = e.id, this._collection = r(e.collection, i), this._pickId = void 0, this._pointPrimitiveCollection = i, this._dirty = !1, this._index = -1
        }, p = m.SHOW_INDEX = 0, f = m.POSITION_INDEX = 1, _ = m.COLOR_INDEX = 2, v = m.OUTLINE_COLOR_INDEX = 3, g = m.OUTLINE_WIDTH_INDEX = 4, y = m.PIXEL_SIZE_INDEX = 5, C = m.SCALE_BY_DISTANCE_INDEX = 6, E = m.TRANSLUCENCY_BY_DISTANCE_INDEX = 7;
        m.NUMBER_OF_PROPERTIES = 8, a(m.prototype, {
            show: {
                get: function () {
                    return this._show
                }, set: function (e) {
                    this._show !== e && (this._show = e, d(this, p))
                }
            }, position: {
                get: function () {
                    return this._position
                }, set: function (e) {
                    var i = this._position;
                    t.equals(i, e) || (t.clone(e, i), t.clone(e, this._actualPosition), d(this, f))
                }
            }, scaleByDistance: {
                get: function () {
                    return this._scaleByDistance
                }, set: function (e) {
                    var t = this._scaleByDistance;
                    l.equals(t, e) || (this._scaleByDistance = l.clone(e, t), d(this, C))
                }
            }, translucencyByDistance: {
                get: function () {
                    return this._translucencyByDistance
                }, set: function (e) {
                    var t = this._translucencyByDistance;
                    l.equals(t, e) || (this._translucencyByDistance = l.clone(e, t), d(this, E))
                }
            }, pixelSize: {
                get: function () {
                    return this._pixelSize
                }, set: function (e) {
                    this._pixelSize !== e && (this._pixelSize = e, d(this, y))
                }
            }, color: {
                get: function () {
                    return this._color
                }, set: function (e) {
                    var t = this._color;
                    n.equals(t, e) || (n.clone(e, t), d(this, _))
                }
            }, outlineColor: {
                get: function () {
                    return this._outlineColor
                }, set: function (e) {
                    var t = this._outlineColor;
                    n.equals(t, e) || (n.clone(e, t), d(this, v))
                }
            }, outlineWidth: {
                get: function () {
                    return this._outlineWidth
                }, set: function (e) {
                    this._outlineWidth !== e && (this._outlineWidth = e, d(this, g))
                }
            }, id: {
                get: function () {
                    return this._id
                }, set: function (e) {
                    this._id = e, o(this._pickId) && (this._pickId.object.id = e)
                }
            }
        }), m.prototype.getPickId = function (e) {
            return o(this._pickId) || (this._pickId = e.createPickId({
                primitive: this,
                collection: this._collection,
                id: this._id
            })), this._pickId
        }, m.prototype._getActualPosition = function () {
            return this._actualPosition
        }, m.prototype._setActualPosition = function (e) {
            t.clone(e, this._actualPosition), d(this, f)
        };
        var S = new i;
        m._computeActualPosition = function (e, t, i) {
            return t.mode === c.SCENE3D ? e : (u.multiplyByPoint(i, e, S), h.computeActualWgs84Position(t, S))
        };
        var T = new u, b = new i;
        return m._computeScreenSpacePosition = function (e, t, n, r) {
            var o = n.camera, a = o.viewMatrix, s = o.frustum.projectionMatrix, l = u.multiplyTransformation(a, e, T), c = u.multiplyByVector(l, i.fromElements(t.x, t.y, t.z, 1, b), b), d = u.multiplyByVector(s, c, b), m = h.clipToGLWindowCoordinates(n, d, r);
            return m
        }, m.prototype.computeScreenSpacePosition = function (t, i) {
            var n = this._pointPrimitiveCollection;
            o(i) || (i = new e);
            var r = n.modelMatrix, a = m._computeScreenSpacePosition(r, this._actualPosition, t, i);
            return a.y = t.canvas.clientHeight - a.y, a
        }, m.prototype.equals = function (e) {
            return this === e || o(e) && this._id === e._id && t.equals(this._position, e._position) && n.equals(this._color, e._color) && this._pixelSize === e._pixelSize && this._outlineWidth === e._outlineWidth && this._show === e._show && n.equals(this._outlineColor, e._outlineColor) && l.equals(this._scaleByDistance, e._scaleByDistance) && l.equals(this._translucencyByDistance, e._translucencyByDistance)
        }, m.prototype._destroy = function () {
            this._pickId = this._pickId && this._pickId.destroy(), this._pointPrimitiveCollection = void 0
        }, m
    }),define("Cesium/Scene/PointPrimitiveCollection", ["../Core/BoundingSphere", "../Core/Cartesian2", "../Core/Cartesian3", "../Core/Color", "../Core/ComponentDatatype", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/EncodedCartesian3", "../Core/Math", "../Core/Matrix4", "../Core/PrimitiveType", "../Renderer/BufferUsage", "../Renderer/ContextLimits", "../Renderer/DrawCommand", "../Renderer/RenderState", "../Renderer/ShaderProgram", "../Renderer/ShaderSource", "../Renderer/VertexArrayFacade", "../Shaders/PointPrimitiveCollectionFS", "../Shaders/PointPrimitiveCollectionVS", "./PointPrimitive", "./BlendingState", "./Pass", "./SceneMode"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S, T, b, w, x) {
        "use strict";
        function A(e) {
            for (var t = e.length, i = 0; t > i; ++i)e[i] && e[i]._destroy()
        }

        function P(e) {
            if (e._pointPrimitivesRemoved) {
                e._pointPrimitivesRemoved = !1;
                for (var t = [], i = e._pointPrimitives, n = i.length, r = 0, o = 0; n > r; ++r) {
                    var a = i[r];
                    a && (a._index = o++, t.push(a))
                }
                e._pointPrimitives = t
            }
        }

        function I(e, t, i) {
            return new C(e, [{
                index: Y.positionHighAndSize,
                componentsPerAttribute: 4,
                componentDatatype: r.FLOAT,
                usage: i[V]
            }, {
                index: Y.positionLowAndShow,
                componentsPerAttribute: 4,
                componentDatatype: r.FLOAT,
                usage: i[V]
            }, {
                index: Y.compressedAttribute0,
                componentsPerAttribute: 4,
                componentDatatype: r.FLOAT,
                usage: i[U]
            }, {
                index: Y.compressedAttribute1,
                componentsPerAttribute: 4,
                componentDatatype: r.FLOAT,
                usage: i[q]
            }, {index: Y.scaleByDistance, componentsPerAttribute: 4, componentDatatype: r.FLOAT, usage: i[W]}], t)
        }

        function D(t, i, n, r) {
            var o = r._index, a = r._getActualPosition();
            t._mode === x.SCENE3D && (e.expand(t._baseVolume, a, t._baseVolume), t._boundingVolumeDirty = !0), c.fromCartesian(a, Z);
            var s = r.pixelSize, u = r.outlineWidth;
            t._maxPixelSize = Math.max(t._maxPixelSize, s + u);
            var l = n[Y.positionHighAndSize], h = Z.high;
            l(o, h.x, h.y, h.z, s);
            var d = n[Y.positionLowAndOutline], m = Z.low;
            d(o, m.x, m.y, m.z, u)
        }

        function M(e, t, i, r) {
            var o = r._index, a = r.color, s = r.getPickId(t).color, u = r.outlineColor, l = n.floatToByte(a.red), c = n.floatToByte(a.green), h = n.floatToByte(a.blue), d = l * K + c * J + h;
            l = n.floatToByte(u.red), c = n.floatToByte(u.green), h = n.floatToByte(u.blue);
            var m = l * K + c * J + h;
            l = n.floatToByte(s.red), c = n.floatToByte(s.green), h = n.floatToByte(s.blue);
            var p = l * K + c * J + h, f = n.floatToByte(a.alpha) * K + n.floatToByte(u.alpha) * J + n.floatToByte(s.alpha), _ = i[Y.compressedAttribute0];
            _(o, d, m, p, f)
        }

        function O(e, t, i, n) {
            var r = n._index, o = 0, s = 1, u = 1, l = 1, c = n.translucencyByDistance;
            a(c) && (o = c.near, s = c.nearValue, u = c.far, l = c.farValue, (1 !== s || 1 !== l) && (e._shaderTranslucencyByDistance = !0));
            var d = n.show;
            0 === n.color.alpha && 0 === n.outlineColor.alpha && (d = !1), s = h.clamp(s, 0, 1), s = 1 === s ? 255 : 255 * s | 0;
            var m = (d ? 1 : 0) * J + s;
            l = h.clamp(l, 0, 1), l = 1 === l ? 255 : 255 * l | 0;
            var p = l, f = i[Y.compressedAttribute1];
            f(r, m, p, o, u)
        }

        function R(e, t, i, n) {
            var r = n._index, o = i[Y.scaleByDistance], s = 0, u = 1, l = 1, c = 1, h = n.scaleByDistance;
            a(h) && (s = h.near, u = h.nearValue, l = h.far, c = h.farValue, (1 !== u || 1 !== c) && (e._shaderScaleByDistance = !0)), o(r, s, u, l, c)
        }

        function N(e, t, i, n) {
            D(e, t, i, n), M(e, t, i, n), O(e, t, i, n), R(e, t, i, n)
        }

        function L(t, i, n, r, o, s) {
            var u;
            r.mode === x.SCENE3D ? (u = t._baseVolume, t._boundingVolumeDirty = !0) : u = t._baseVolume2D;
            for (var l = [], c = 0; n > c; ++c) {
                var h = i[c], d = h.position, m = T._computeActualPosition(d, r, o);
                a(m) && (h._setActualPosition(m), s ? l.push(m) : e.expand(u, m, u))
            }
            s && e.fromPoints(l, u)
        }

        function F(e, t) {
            var i = t.mode, n = e._pointPrimitives, r = e._pointPrimitivesToUpdate, o = e._modelMatrix;
            e._createVertexArray || e._mode !== i || i !== x.SCENE3D && !d.equals(o, e.modelMatrix) ? (e._mode = i, d.clone(e.modelMatrix, o), e._createVertexArray = !0, (i === x.SCENE3D || i === x.SCENE2D || i === x.COLUMBUS_VIEW) && L(e, n, n.length, t, o, !0)) : i === x.MORPHING ? L(e, n, n.length, t, o, !0) : (i === x.SCENE2D || i === x.COLUMBUS_VIEW) && L(e, r, e._pointPrimitivesToUpdateIndex, t, o, !1)
        }

        function B(e, t, n, r) {
            var o = n.camera, a = o.frustum, s = i.subtract(o.positionWC, r.center, $), u = i.multiplyByScalar(o.directionWC, i.dot(s, o.directionWC), ee), l = Math.max(0, i.magnitude(u) - r.radius);
            Q.x = t.drawingBufferWidth, Q.y = t.drawingBufferHeight;
            var c = a.getPixelSize(Q, l), h = Math.max(c.x, c.y), d = h * e._maxPixelSize;
            r.radius += d
        }

        var z = T.SHOW_INDEX, V = T.POSITION_INDEX, U = T.COLOR_INDEX, k = T.OUTLINE_COLOR_INDEX, G = T.OUTLINE_WIDTH_INDEX, H = T.PIXEL_SIZE_INDEX, W = T.SCALE_BY_DISTANCE_INDEX, q = T.TRANSLUCENCY_BY_DISTANCE_INDEX, j = T.NUMBER_OF_PROPERTIES, Y = {
            positionHighAndSize: 0,
            positionLowAndOutline: 1,
            compressedAttribute0: 2,
            compressedAttribute1: 3,
            scaleByDistance: 4
        }, X = function (t) {
            t = o(t, o.EMPTY_OBJECT), this._sp = void 0, this._rs = void 0, this._vaf = void 0, this._spPick = void 0, this._pointPrimitives = [], this._pointPrimitivesToUpdate = [], this._pointPrimitivesToUpdateIndex = 0, this._pointPrimitivesRemoved = !1, this._createVertexArray = !1, this._shaderScaleByDistance = !1, this._compiledShaderScaleByDistance = !1, this._compiledShaderScaleByDistancePick = !1, this._shaderTranslucencyByDistance = !1, this._compiledShaderTranslucencyByDistance = !1, this._compiledShaderTranslucencyByDistancePick = !1, this._propertiesChanged = new Uint32Array(j), this._maxPixelSize = 1, this._baseVolume = new e, this._baseVolumeWC = new e, this._baseVolume2D = new e, this._boundingVolume = new e, this._boundingVolumeDirty = !1, this._colorCommands = [], this._pickCommands = [], this.modelMatrix = d.clone(o(t.modelMatrix, d.IDENTITY)), this._modelMatrix = d.clone(d.IDENTITY), this.debugShowBoundingVolume = o(t.debugShowBoundingVolume, !1), this._mode = x.SCENE3D, this._maxTotalPointSize = 1, this._buffersUsage = [p.STATIC_DRAW, p.STATIC_DRAW, p.STATIC_DRAW, p.STATIC_DRAW, p.STATIC_DRAW, p.STATIC_DRAW, p.STATIC_DRAW, p.STATIC_DRAW];
            var i = this;
            this._uniforms = {
                u_maxTotalPointSize: function () {
                    return i._maxTotalPointSize
                }
            }
        };
        s(X.prototype, {
            length: {
                get: function () {
                    return P(this), this._pointPrimitives.length
                }
            }
        }), X.prototype.add = function (e) {
            var t = new T(e, this);
            return t._index = this._pointPrimitives.length, this._pointPrimitives.push(t), this._createVertexArray = !0, t
        }, X.prototype.remove = function (e) {
            return this.contains(e) ? (this._pointPrimitives[e._index] = null, this._pointPrimitivesRemoved = !0, this._createVertexArray = !0, e._destroy(), !0) : !1
        }, X.prototype.removeAll = function () {
            A(this._pointPrimitives), this._pointPrimitives = [], this._pointPrimitivesToUpdate = [], this._pointPrimitivesToUpdateIndex = 0, this._pointPrimitivesRemoved = !1, this._createVertexArray = !0
        }, X.prototype._updatePointPrimitive = function (e, t) {
            e._dirty || (this._pointPrimitivesToUpdate[this._pointPrimitivesToUpdateIndex++] = e), ++this._propertiesChanged[t]
        }, X.prototype.contains = function (e) {
            return a(e) && e._pointPrimitiveCollection === this
        }, X.prototype.get = function (e) {
            return P(this), this._pointPrimitives[e]
        }, X.prototype.computeNewBuffersUsage = function () {
            for (var e = this._buffersUsage, t = !1, i = this._propertiesChanged, n = 0; j > n; ++n) {
                var r = 0 === i[n] ? p.STATIC_DRAW : p.STREAM_DRAW;
                t = t || e[n] !== r, e[n] = r
            }
            return t
        };
        var Z = new c, K = 65536, J = 256, Q = new t, $ = new i, ee = new i, te = [];
        return X.prototype.update = function (t, i, n) {
            P(this), this._maxTotalPointSize = f.maximumAliasedPointSize, F(this, i);
            var r, o = this._pointPrimitives, s = o.length, u = this._pointPrimitivesToUpdate, l = this._pointPrimitivesToUpdateIndex, c = this._propertiesChanged, h = this._createVertexArray, p = i.passes, C = p.pick;
            if (h || !C && this.computeNewBuffersUsage()) {
                this._createVertexArray = !1;
                for (var T = 0; j > T; ++T)c[T] = 0;
                if (this._vaf = this._vaf && this._vaf.destroy(), s > 0) {
                    this._vaf = I(t, s, this._buffersUsage), r = this._vaf.writers;
                    for (var A = 0; s > A; ++A) {
                        var L = this._pointPrimitives[A];
                        L._dirty = !1, N(this, t, r, L)
                    }
                    this._vaf.commit()
                }
                this._pointPrimitivesToUpdateIndex = 0
            } else if (l > 0) {
                var X = te;
                X.length = 0, (c[V] || c[G] || c[H]) && X.push(D), (c[U] || c[k]) && X.push(M), (c[z] || c[q]) && X.push(O), c[W] && X.push(R);
                var Z = X.length;
                if (r = this._vaf.writers, l / s > .1) {
                    for (var K = 0; l > K; ++K) {
                        var J = u[K];
                        J._dirty = !1;
                        for (var Q = 0; Z > Q; ++Q)X[Q](this, t, r, J)
                    }
                    this._vaf.commit()
                } else {
                    for (var $ = 0; l > $; ++$) {
                        var ee = u[$];
                        ee._dirty = !1;
                        for (var ie = 0; Z > ie; ++ie)X[ie](this, t, r, ee);
                        this._vaf.subCommit(ee._index, 1)
                    }
                    this._vaf.endSubCommits()
                }
                this._pointPrimitivesToUpdateIndex = 0
            }
            if (l > 1.5 * s && (u.length = s), a(this._vaf) && a(this._vaf.va)) {
                this._boundingVolumeDirty && (this._boundingVolumeDirty = !1, e.transform(this._baseVolume, this.modelMatrix, this._baseVolumeWC));
                var ne, re = d.IDENTITY;
                i.mode === x.SCENE3D ? (re = this.modelMatrix, ne = e.clone(this._baseVolumeWC, this._boundingVolume)) : ne = e.clone(this._baseVolume2D, this._boundingVolume), B(this, t, i, ne);
                var oe, ae, se, ue, le, ce;
                if (p.render) {
                    var he = this._colorCommands;
                    for (a(this._rs) || (this._rs = v.fromCache({
                        depthTest: {enabled: !0},
                        blending: b.ALPHA_BLEND
                    })), (!a(this._sp) || this._shaderScaleByDistance && !this._compiledShaderScaleByDistance || this._shaderTranslucencyByDistance && !this._compiledShaderTranslucencyByDistance) && (le = new y({sources: [S]}), this._shaderScaleByDistance && le.defines.push("EYE_DISTANCE_SCALING"), this._shaderTranslucencyByDistance && le.defines.push("EYE_DISTANCE_TRANSLUCENCY"), this._sp = g.replaceCache({
                        context: t,
                        shaderProgram: this._sp,
                        vertexShaderSource: le,
                        fragmentShaderSource: E,
                        attributeLocations: Y
                    }), this._compiledShaderScaleByDistance = this._shaderScaleByDistance, this._compiledShaderTranslucencyByDistance = this._shaderTranslucencyByDistance), oe = this._vaf.va, ae = oe.length, he.length = ae, ue = 0; ae > ue; ++ue)se = he[ue], a(se) || (se = he[ue] = new _({
                        primitiveType: m.POINTS,
                        pass: w.OPAQUE,
                        owner: this
                    })), se.boundingVolume = ne, se.modelMatrix = re, se.shaderProgram = this._sp, se.uniformMap = this._uniforms, se.vertexArray = oe[ue].va, se.renderState = this._rs, se.debugShowBoundingVolume = this.debugShowBoundingVolume, n.push(se)
                }
                if (C) {
                    var de = this._pickCommands;
                    for ((!a(this._spPick) || this._shaderScaleByDistance && !this._compiledShaderScaleByDistancePick || this._shaderTranslucencyByDistance && !this._compiledShaderTranslucencyByDistancePick) && (le = new y({
                        defines: ["RENDER_FOR_PICK"],
                        sources: [S]
                    }), this._shaderScaleByDistance && le.defines.push("EYE_DISTANCE_SCALING"), this._shaderTranslucencyByDistance && le.defines.push("EYE_DISTANCE_TRANSLUCENCY"), ce = new y({
                        defines: ["RENDER_FOR_PICK"],
                        sources: [E]
                    }), this._spPick = g.replaceCache({
                        context: t,
                        shaderProgram: this._spPick,
                        vertexShaderSource: le,
                        fragmentShaderSource: ce,
                        attributeLocations: Y
                    }), this._compiledShaderScaleByDistancePick = this._shaderScaleByDistance, this._compiledShaderTranslucencyByDistancePick = this._shaderTranslucencyByDistance), oe = this._vaf.va, ae = oe.length, de.length = ae, ue = 0; ae > ue; ++ue)se = de[ue], a(se) || (se = de[ue] = new _({
                        primitiveType: m.POINTS,
                        pass: w.OPAQUE,
                        owner: this
                    })), se.boundingVolume = ne, se.modelMatrix = re, se.shaderProgram = this._spPick, se.uniformMap = this._uniforms, se.vertexArray = oe[ue].va, se.renderState = this._rs, n.push(se)
                }
            }
        }, X.prototype.isDestroyed = function () {
            return !1
        }, X.prototype.destroy = function () {
            return this._sp = this._sp && this._sp.destroy(), this._spPick = this._spPick && this._spPick.destroy(), this._vaf = this._vaf && this._vaf.destroy(), A(this._pointPrimitives), u(this)
        }, X
    }),define("Cesium/DataSources/PointVisualizer", ["../Core/AssociativeArray", "../Core/Cartesian3", "../Core/Color", "../Core/defined", "../Core/destroyObject", "../Core/DeveloperError", "../Core/NearFarScalar", "../Scene/PointPrimitiveCollection", "./BoundingSphereState", "./Property"], function (e, t, i, n, r, o, a, s, u, l) {
        "use strict";
        function c(e, t) {
            if (n(e)) {
                var i = e.pointPrimitive;
                n(i) && (e.pointPrimitive = void 0, i.show = !1, t.push(i._index))
            }
        }

        var h = i.WHITE, d = i.BLACK, m = 0, p = 1, f = new i, _ = new t, v = new i, g = new a, y = new a, C = function (e) {
            this.entity = e, this.pointPrimitive = void 0, this.color = void 0, this.outlineColor = void 0, this.pixelSize = void 0, this.outlineWidth = void 0
        }, E = function (t, i) {
            i.collectionChanged.addEventListener(E.prototype._onCollectionChanged, this), this._scene = t, this._unusedIndexes = [], this._entityCollection = i, this._pointPrimitiveCollection = void 0, this._items = new e, this._onCollectionChanged(i, i.values, [], [])
        };
        return E.prototype.update = function (e) {
            for (var t = this._items.values, i = this._unusedIndexes, r = 0, o = t.length; o > r; r++) {
                var a = t[r], u = a.entity, C = u._point, E = a.pointPrimitive, S = u.isShowing && u.isAvailable(e) && l.getValueOrDefault(C._show, e, !0);
                if (S && (_ = l.getValueOrUndefined(u._position, e, _), S = n(_)), S) {
                    if (!n(E)) {
                        var T = this._pointPrimitiveCollection;
                        n(T) || (T = new s, this._pointPrimitiveCollection = T, this._scene.primitives.add(T));
                        var b = i.length;
                        E = b > 0 ? T.get(i.pop()) : T.add(), E.id = u, a.pointPrimitive = E
                    }
                    E.show = !0, E.position = _, E.scaleByDistance = l.getValueOrUndefined(C._scaleByDistance, e, g), E.translucencyByDistance = l.getValueOrUndefined(C._translucencyByDistance, e, y), E.color = l.getValueOrDefault(C._color, e, h, f), E.outlineColor = l.getValueOrDefault(C._outlineColor, e, d, v), E.outlineWidth = l.getValueOrDefault(C._outlineWidth, e, m), E.pixelSize = l.getValueOrDefault(C._pixelSize, e, p)
                } else c(a, i)
            }
            return !0
        }, E.prototype.getBoundingSphere = function (e, i) {
            var r = this._items.get(e.id);
            return n(r) && n(r.pointPrimitive) ? (i.center = t.clone(r.pointPrimitive.position, i.center), i.radius = 0, u.DONE) : u.FAILED
        }, E.prototype.isDestroyed = function () {
            return !1
        }, E.prototype.destroy = function () {
            return this._entityCollection.collectionChanged.removeEventListener(E.prototype._onCollectionChanged, this), n(this._pointPrimitiveCollection) && this._scene.primitives.remove(this._pointPrimitiveCollection), r(this)
        }, E.prototype._onCollectionChanged = function (e, t, i, r) {
            var o, a, s = this._unusedIndexes, u = this._items;
            for (o = t.length - 1; o > -1; o--)a = t[o], n(a._point) && n(a._position) && u.set(a.id, new C(a));
            for (o = r.length - 1; o > -1; o--)a = r[o], n(a._point) && n(a._position) ? u.contains(a.id) || u.set(a.id, new C(a)) : (c(u.get(a.id), s), u.remove(a.id));
            for (o = i.length - 1; o > -1; o--)a = i[o], c(u.get(a.id), s), u.remove(a.id)
        }, E
    }),define("Cesium/Core/PolygonGeometryLibrary", ["./Cartesian3", "./ComponentDatatype", "./defaultValue", "./defined", "./Ellipsoid", "./EllipsoidTangentPlane", "./Geometry", "./GeometryAttribute", "./GeometryAttributes", "./IndexDatatype", "./Math", "./PolygonPipeline", "./PrimitiveType", "./Queue", "./WindingOrder"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p) {
        "use strict";
        function f(t, i, n, r) {
            return e.subtract(i, t, v), e.multiplyByScalar(v, n / r, v), e.add(t, v, v), [v.x, v.y, v.z]
        }

        var _ = {};
        _.computeHierarchyPackedLength = function (t) {
            for (var i = 0, r = [t]; r.length > 0;) {
                var o = r.pop();
                if (n(o)) {
                    i += 2;
                    var a = o.positions, s = o.holes;
                    if (n(a) && (i += a.length * e.packedLength), n(s))for (var u = s.length, l = 0; u > l; ++l)r.push(s[l])
                }
            }
            return i
        }, _.packPolygonHierarchy = function (t, i, r) {
            for (var o = [t]; o.length > 0;) {
                var a = o.pop();
                if (n(a)) {
                    var s = a.positions, u = a.holes;
                    if (i[r++] = n(s) ? s.length : 0, i[r++] = n(u) ? u.length : 0, n(s))for (var l = s.length, c = 0; l > c; ++c, r += 3)e.pack(s[c], i, r);
                    if (n(u))for (var h = u.length, d = 0; h > d; ++d)o.push(u[d])
                }
            }
            return r
        }, _.unpackPolygonHierarchy = function (t, i) {
            for (var n = t[i++], r = t[i++], o = new Array(n), a = r > 0 ? new Array(r) : void 0, s = 0; n > s; ++s, i += e.packedLength)o[s] = e.unpack(t, i);
            for (var u = 0; r > u; ++u)a[u] = _.unpackPolygonHierarchy(t, i), i = a[u].startingIndex, delete a[u].startingIndex;
            return {positions: o, holes: a, startingIndex: i}
        };
        var v = new e;
        _.subdivideLineCount = function (t, i, n) {
            var r = e.distance(t, i), o = r / n, a = Math.max(0, Math.ceil(Math.log(o) / Math.log(2)));
            return Math.pow(2, a)
        }, _.subdivideLine = function (t, i, r, o) {
            var a = _.subdivideLineCount(t, i, r), s = e.distance(t, i), u = s / a;
            n(o) || (o = []);
            var l = o;
            l.length = 3 * a;
            for (var c = 0, h = 0; a > h; h++) {
                var d = f(t, i, h * u, s);
                l[c++] = d[0], l[c++] = d[1], l[c++] = d[2]
            }
            return l
        };
        var g = new e, y = new e, C = new e, E = new e;
        _.scaleToGeodeticHeightExtruded = function (t, o, a, s, u) {
            s = i(s, r.WGS84);
            var l = g, c = y, h = C, d = E;
            if (n(t) && n(t.attributes) && n(t.attributes.position))for (var m = t.attributes.position.values, p = m.length / 2, f = 0; p > f; f += 3)e.fromArray(m, f, h), s.geodeticSurfaceNormal(h, l), d = s.scaleToGeodeticSurface(h, d), c = e.multiplyByScalar(l, a, c), c = e.add(d, c, c), m[f + p] = c.x, m[f + 1 + p] = c.y, m[f + 2 + p] = c.z, u && (d = e.clone(h, d)), c = e.multiplyByScalar(l, o, c), c = e.add(d, c, c), m[f] = c.x, m[f + 1] = c.y, m[f + 2] = c.z;
            return t
        }, _.polygonsFromHierarchy = function (e) {
            var t = [], i = [], r = new m;
            for (r.enqueue(e); 0 !== r.length;) {
                var o = r.dequeue(), a = o.positions, s = o.holes;
                if (a = h.removeDuplicates(a), !(a.length < 3)) {
                    for (var u = n(s) ? s.length : 0, l = [], c = 0; u > c; c++) {
                        var d = s[c];
                        if (d.positions = h.removeDuplicates(d.positions), !(d.positions.length < 3)) {
                            l.push(d.positions);
                            var p = 0;
                            n(d.holes) && (p = d.holes.length);
                            for (var f = 0; p > f; f++)r.enqueue(d.holes[f])
                        }
                    }
                    i.push({outerRing: a, holes: l});
                    var _ = l.length > 0 ? h.eliminateHoles(a, l) : a;
                    t.push(_)
                }
            }
            return {hierarchy: i, polygons: t}
        };
        var S = [];
        _.createGeometryFromPositions = function (e, i, n, r) {
            var u = o.fromPoints(i, e), l = u.projectPointsOntoPlane(i, S), c = h.computeWindingOrder2D(l);
            c === p.CLOCKWISE && (l.reverse(), i = i.slice().reverse());
            var m = h.triangulate(l);
            if (m.length < 3 && (m = [0, 1, 2]), r) {
                for (var f = i.length, _ = new Array(3 * f), v = 0, g = 0; f > g; g++) {
                    var y = i[g];
                    _[v++] = y.x, _[v++] = y.y, _[v++] = y.z
                }
                return new a({
                    attributes: {
                        position: new s({
                            componentDatatype: t.DOUBLE,
                            componentsPerAttribute: 3,
                            values: _
                        })
                    }, indices: m, primitiveType: d.TRIANGLES
                })
            }
            return h.computeSubdivision(e, i, m, n)
        };
        var T = [], b = new e, w = new e;
        return _.computeWallGeometry = function (i, n, r, o) {
            var h, m, p, f, v, g = i.length, y = 0;
            if (o)for (m = 3 * g * 2, h = new Array(2 * m), p = 0; g > p; p++)f = i[p], v = i[(p + 1) % g], h[y] = h[y + m] = f.x, ++y, h[y] = h[y + m] = f.y, ++y, h[y] = h[y + m] = f.z, ++y, h[y] = h[y + m] = v.x, ++y, h[y] = h[y + m] = v.y, ++y, h[y] = h[y + m] = v.z, ++y; else {
                var C = c.chordLength(r, n.maximumRadius), E = 0;
                for (p = 0; g > p; p++)E += _.subdivideLineCount(i[p], i[(p + 1) % g], C);
                for (m = 3 * (E + g), h = new Array(2 * m), p = 0; g > p; p++) {
                    f = i[p], v = i[(p + 1) % g];
                    for (var S = _.subdivideLine(f, v, C, T), x = S.length, A = 0; x > A; ++A, ++y)h[y] = S[A], h[y + m] = S[A];
                    h[y] = v.x, h[y + m] = v.x, ++y, h[y] = v.y, h[y + m] = v.y, ++y, h[y] = v.z, h[y + m] = v.z, ++y
                }
            }
            g = h.length;
            var P = l.createTypedArray(g / 3, g - 6 * i.length), I = 0;
            for (g /= 6, p = 0; g > p; p++) {
                var D = p, M = D + 1, O = D + g, R = O + 1;
                f = e.fromArray(h, 3 * D, b), v = e.fromArray(h, 3 * M, w), e.equalsEpsilon(f, v, c.EPSILON14) || (P[I++] = D, P[I++] = O, P[I++] = M, P[I++] = M, P[I++] = O, P[I++] = R)
            }
            return new a({
                attributes: new u({
                    position: new s({
                        componentDatatype: t.DOUBLE,
                        componentsPerAttribute: 3,
                        values: h
                    })
                }), indices: P, primitiveType: d.TRIANGLES
            })
        }, _
    }),define("Cesium/Core/PolygonGeometry", ["./BoundingRectangle", "./BoundingSphere", "./Cartesian2", "./Cartesian3", "./ComponentDatatype", "./defaultValue", "./defined", "./DeveloperError", "./Ellipsoid", "./EllipsoidTangentPlane", "./Geometry", "./GeometryAttribute", "./GeometryAttributes", "./GeometryInstance", "./GeometryPipeline", "./IndexDatatype", "./Math", "./Matrix3", "./PolygonGeometryLibrary", "./PolygonPipeline", "./Quaternion", "./VertexFormat", "./WindingOrder"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S) {
        "use strict";
        function T(e, t, i, r) {
            for (var o = C.fromAxisAngle(e._plane.normal, i, P), s = v.fromQuaternion(o, I), u = Number.POSITIVE_INFINITY, l = Number.NEGATIVE_INFINITY, c = Number.POSITIVE_INFINITY, h = Number.NEGATIVE_INFINITY, d = t.length, m = 0; d > m; ++m) {
                var p = n.clone(t[m], A);
                v.multiplyByVector(s, p, p);
                var f = e.projectPointOntoPlane(p, x);
                a(f) && (u = Math.min(u, f.x), l = Math.max(l, f.x), c = Math.min(c, f.y), h = Math.max(h, f.y))
            }
            return r.x = u, r.y = c, r.width = l - u, r.height = h - c, r
        }

        function b(e, t, o, a, s, u, c) {
            if (e.st || e.normal || e.tangent || e.binormal) {
                var d = l.fromPoints(o, a), m = T(d, o, s, D), p = B;
                p.x = m.x, p.y = m.y;
                var f = t.attributes.position.values, g = f.length, y = e.st ? new Float32Array(2 * (g / 3)) : void 0, E = e.normal ? new Float32Array(g) : void 0, S = e.tangent ? new Float32Array(g) : void 0, b = e.binormal ? new Float32Array(g) : void 0, w = 0, x = 0, A = O, P = R, I = N, G = !0, H = C.fromAxisAngle(d._plane.normal, s, U), W = v.fromQuaternion(H, k), q = g / 2, j = g / 3;
                u && (g /= 2);
                for (var Y = 0; g > Y; Y += 3) {
                    var X = n.fromArray(f, Y, V);
                    if (e.st) {
                        var Z = v.multiplyByVector(W, X, M), K = d.projectPointOntoPlane(Z, z);
                        i.subtract(K, p, K), u && (y[w + j] = K.x / m.width, y[w + 1 + j] = K.y / m.height), y[w] = K.x / m.width, y[w + 1] = K.y / m.height, w += 2
                    }
                    if (e.normal || e.tangent || e.binormal) {
                        var J = x + 1, Q = x + 2;
                        if (c) {
                            if (g > Y + 3) {
                                var $ = n.fromArray(f, Y + 3, L);
                                if (G) {
                                    var ee = n.fromArray(f, Y + g, F);
                                    n.subtract($, X, $), n.subtract(ee, X, ee), A = n.normalize(n.cross(ee, $, A), A), G = !1
                                }
                                n.equalsEpsilon($, X, _.EPSILON10) && (G = !0)
                            }
                            (e.tangent || e.binormal) && (I = a.geodeticSurfaceNormal(X, I), e.tangent && (P = n.normalize(n.cross(I, A, P), P)))
                        } else A = a.geodeticSurfaceNormal(X, A), (e.tangent || e.binormal) && (P = n.cross(n.UNIT_Z, A, P), P = n.normalize(v.multiplyByVector(W, P, P), P), e.binormal && (I = n.normalize(n.cross(A, P, I), I)));
                        e.normal && (u && !c ? (E[x + q] = -A.x, E[J + q] = -A.y, E[Q + q] = -A.z) : (E[x + q] = A.x, E[J + q] = A.y, E[Q + q] = A.z), E[x] = A.x, E[J] = A.y, E[Q] = A.z), e.tangent && (u && !c ? (S[x + q] = -P.x, S[J + q] = -P.y, S[Q + q] = -P.z) : (S[x + q] = P.x, S[J + q] = P.y, S[Q + q] = P.z), S[x] = P.x, S[J] = P.y, S[Q] = P.z), e.binormal && (u && (b[x + q] = I.x, b[J + q] = I.y, b[Q + q] = I.z), b[x] = I.x, b[J] = I.y, b[Q] = I.z), x += 3
                    }
                }
                e.st && (t.attributes.st = new h({
                    componentDatatype: r.FLOAT,
                    componentsPerAttribute: 2,
                    values: y
                })), e.normal && (t.attributes.normal = new h({
                    componentDatatype: r.FLOAT,
                    componentsPerAttribute: 3,
                    values: E
                })), e.tangent && (t.attributes.tangent = new h({
                    componentDatatype: r.FLOAT,
                    componentsPerAttribute: 3,
                    values: S
                })), e.binormal && (t.attributes.binormal = new h({
                    componentDatatype: r.FLOAT,
                    componentsPerAttribute: 3,
                    values: b
                }))
            }
            return t
        }

        function w(e, t, i, n, o) {
            var a = g.createGeometryFromPositions(e, t, i, o), s = a.attributes.position.values, u = a.indices, p = s.concat(s), _ = p.length / 3, v = f.createTypedArray(_, 2 * u.length);
            v.set(u);
            var C, E = u.length, T = _ / 2;
            for (C = 0; E > C; C += 3) {
                var b = v[C] + T, w = v[C + 1] + T, x = v[C + 2] + T;
                v[C + E] = x, v[C + 1 + E] = w, v[C + 2 + E] = b
            }
            var A = new c({
                attributes: new d({
                    position: new h({
                        componentDatatype: r.DOUBLE,
                        componentsPerAttribute: 3,
                        values: p
                    })
                }), indices: v, primitiveType: a.primitiveType
            }), P = {
                topAndBottom: new m({geometry: A}),
                walls: []
            }, I = n.outerRing, D = l.fromPoints(I, e), M = D.projectPointsOntoPlane(I, G), O = y.computeWindingOrder2D(M);
            O === S.CLOCKWISE && (I = I.slice().reverse());
            var R = g.computeWallGeometry(I, e, i, o);
            P.walls.push(new m({geometry: R}));
            var N = n.holes;
            for (C = 0; C < N.length; C++) {
                var L = N[C];
                D = l.fromPoints(L, e), M = D.projectPointsOntoPlane(L, G), O = y.computeWindingOrder2D(M), O === S.COUNTER_CLOCKWISE && (L = L.slice().reverse()), R = g.computeWallGeometry(L, e, i), P.walls.push(new m({geometry: R}))
            }
            return P
        }

        var x = new i, A = new n, P = new C, I = new v, D = new e, M = new n, O = new n, R = new n, N = new n, L = new n, F = new n, B = new i, z = new i, V = new n, U = new C, k = new v, G = [], H = function (e) {
            var t = e.polygonHierarchy, i = o(e.vertexFormat, E.DEFAULT), n = o(e.ellipsoid, u.WGS84), r = o(e.granularity, _.RADIANS_PER_DEGREE), s = o(e.stRotation, 0), l = o(e.height, 0), c = o(e.perPositionHeight, !1), h = e.extrudedHeight, d = a(h);
            if (d && !c) {
                var m = h;
                h = Math.min(m, l), l = Math.max(m, l)
            }
            this._vertexFormat = E.clone(i), this._ellipsoid = u.clone(n), this._granularity = r, this._stRotation = s, this._height = l, this._extrudedHeight = o(h, 0), this._extrude = d, this._open = o(e.open, !1), this._polygonHierarchy = t, this._perPositionHeight = c, this._workerName = "createPolygonGeometry", this.packedLength = g.computeHierarchyPackedLength(t) + u.packedLength + E.packedLength + 8
        };
        H.fromPositions = function (e) {
            e = o(e, o.EMPTY_OBJECT);
            var t = {
                polygonHierarchy: {positions: e.positions},
                height: e.height,
                extrudedHeight: e.extrudedHeight,
                vertexFormat: e.vertexFormat,
                stRotation: e.stRotation,
                ellipsoid: e.ellipsoid,
                granularity: e.granularity,
                perPositionHeight: e.perPositionHeight,
                open: e.open
            };
            return new H(t)
        }, H.pack = function (e, t, i) {
            i = o(i, 0), i = g.packPolygonHierarchy(e._polygonHierarchy, t, i), u.pack(e._ellipsoid, t, i), i += u.packedLength, E.pack(e._vertexFormat, t, i), i += E.packedLength, t[i++] = e._height, t[i++] = e._extrudedHeight, t[i++] = e._granularity, t[i++] = e._stRotation, t[i++] = e._extrude ? 1 : 0, t[i++] = e._perPositionHeight ? 1 : 0, t[i++] = e._open ? 1 : 0, t[i] = e.packedLength
        };
        var W = u.clone(u.UNIT_SPHERE), q = new E, j = {polygonHierarchy: {}};
        return H.unpack = function (e, t, i) {
            t = o(t, 0);
            var n = g.unpackPolygonHierarchy(e, t);
            t = n.startingIndex, delete n.startingIndex;
            var r = u.unpack(e, t, W);
            t += u.packedLength;
            var s = E.unpack(e, t, q);
            t += E.packedLength;
            var l = e[t++], c = e[t++], h = e[t++], d = e[t++], m = 1 === e[t++], p = 1 === e[t++], f = 1 === e[t++], _ = e[t];
            return a(i) || (i = new H(j)), i._polygonHierarchy = n, i._ellipsoid = u.clone(r, i._ellipsoid), i._vertexFormat = E.clone(s, i._vertexFormat), i._height = l, i._extrudedHeight = c, i._granularity = h, i._stRotation = d, i._extrude = m, i._perPositionHeight = p, i._open = f, i.packedLength = _, i
        }, H.createGeometry = function (e) {
            var i, n, r, o = e._vertexFormat, a = e._ellipsoid, s = e._granularity, u = e._stRotation, l = e._height, h = e._extrudedHeight, d = e._extrude, _ = e._polygonHierarchy, v = e._perPositionHeight, C = e._open, E = g.polygonsFromHierarchy(_), S = E.hierarchy, T = E.polygons;
            if (0 === T.length)return void 0;
            r = T[0];
            var x, A, P = [];
            if (d)for (A = 0; A < T.length; A++) {
                x = w(a, T[A], s, S[A], v), C || (n = x.topAndBottom, n.geometry = g.scaleToGeodeticHeightExtruded(n.geometry, l, h, a, v), n.geometry = b(o, n.geometry, r, a, u, !0, !1), P.push(n)), i = x.walls;
                for (var I = 0; I < i.length; I++) {
                    var D = i[I];
                    D.geometry = g.scaleToGeodeticHeightExtruded(D.geometry, l, h, a, v), D.geometry = b(o, D.geometry, r, a, u, !0, !0), P.push(D)
                }
            } else for (A = 0; A < T.length; A++)x = new m({geometry: g.createGeometryFromPositions(a, T[A], s, v)}), x.geometry = y.scaleToGeodeticHeight(x.geometry, l, a, !v), x.geometry = b(o, x.geometry, r, a, u, !1, !1), P.push(x);
            x = p.combineInstances(P)[0], x.attributes.position.values = new Float64Array(x.attributes.position.values), x.indices = f.createTypedArray(x.attributes.position.values.length / 3, x.indices);
            var M = x.attributes, O = t.fromVertices(M.position.values);
            return o.position || delete M.position, new c({
                attributes: M,
                indices: x.indices,
                primitiveType: x.primitiveType,
                boundingSphere: O
            })
        }, H.createShadowVolume = function (e, t, i) {
            var n = e._granularity, r = e._ellipsoid, o = t(n, r), a = i(n, r);
            return new H({
                polygonHierarchy: e._polygonHierarchy,
                ellipsoid: r,
                stRotation: e._stRotation,
                granularity: n,
                perPositionHeight: !1,
                extrudedHeight: o,
                height: a,
                vertexFormat: E.POSITION_ONLY
            })
        }, H
    }),define("Cesium/Core/PolygonHierarchy", ["./defined"], function (e) {
        "use strict";
        var t = function (t, i) {
            this.positions = e(t) ? t : [], this.holes = e(i) ? i : []
        };
        return t
    }),define("Cesium/Core/PolygonOutlineGeometry", ["./BoundingSphere", "./ComponentDatatype", "./defaultValue", "./defined", "./DeveloperError", "./Ellipsoid", "./EllipsoidTangentPlane", "./Geometry", "./GeometryAttribute", "./GeometryAttributes", "./GeometryInstance", "./GeometryPipeline", "./IndexDatatype", "./Math", "./PolygonGeometryLibrary", "./PolygonPipeline", "./PrimitiveType", "./Queue", "./WindingOrder"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g) {
        "use strict";
        function y(e, i, n, r) {
            var o = a.fromPoints(i, e), h = o.projectPointsOntoPlane(i, E), m = f.computeWindingOrder2D(h);
            m === g.CLOCKWISE && (h.reverse(), i = i.slice().reverse());
            var v, y, C = i.length, T = 0;
            if (r)for (v = new Float64Array(2 * C * 3), y = 0; C > y; y++) {
                var b = i[y], w = i[(y + 1) % C];
                v[T++] = b.x, v[T++] = b.y, v[T++] = b.z, v[T++] = w.x, v[T++] = w.y, v[T++] = w.z
            } else {
                var x = 0;
                for (y = 0; C > y; y++)x += p.subdivideLineCount(i[y], i[(y + 1) % C], n);
                for (v = new Float64Array(3 * x), y = 0; C > y; y++)for (var A = p.subdivideLine(i[y], i[(y + 1) % C], n, S), P = A.length, I = 0; P > I; ++I)v[T++] = A[I]
            }
            C = v.length / 3;
            var D = 2 * C, M = d.createTypedArray(C, D);
            for (T = 0, y = 0; C - 1 > y; y++)M[T++] = y, M[T++] = y + 1;
            return M[T++] = C - 1, M[T++] = 0, new c({
                geometry: new s({
                    attributes: new l({
                        position: new u({
                            componentDatatype: t.DOUBLE,
                            componentsPerAttribute: 3,
                            values: v
                        })
                    }), indices: M, primitiveType: _.LINES
                })
            })
        }

        function C(e, i, n, r) {
            var o = a.fromPoints(i, e), h = o.projectPointsOntoPlane(i, E), m = f.computeWindingOrder2D(h);
            m === g.CLOCKWISE && (h.reverse(), i = i.slice().reverse());
            var v, y, C = i.length, T = new Array(C), b = 0;
            if (r)for (v = new Float64Array(2 * C * 3 * 2), y = 0; C > y; ++y) {
                T[y] = b / 3;
                var w = i[y], x = i[(y + 1) % C];
                v[b++] = w.x, v[b++] = w.y, v[b++] = w.z, v[b++] = x.x, v[b++] = x.y, v[b++] = x.z
            } else {
                var A = 0;
                for (y = 0; C > y; y++)A += p.subdivideLineCount(i[y], i[(y + 1) % C], n);
                for (v = new Float64Array(3 * A * 2), y = 0; C > y; ++y) {
                    T[y] = b / 3;
                    for (var P = p.subdivideLine(i[y], i[(y + 1) % C], n, S), I = P.length, D = 0; I > D; ++D)v[b++] = P[D]
                }
            }
            C = v.length / 6;
            var M = T.length, O = 2 * (2 * C + M), R = d.createTypedArray(C, O);
            for (b = 0, y = 0; C > y; ++y)R[b++] = y, R[b++] = (y + 1) % C, R[b++] = y + C, R[b++] = (y + 1) % C + C;
            for (y = 0; M > y; y++) {
                var N = T[y];
                R[b++] = N, R[b++] = N + C
            }
            return new c({
                geometry: new s({
                    attributes: new l({
                        position: new u({
                            componentDatatype: t.DOUBLE,
                            componentsPerAttribute: 3,
                            values: v
                        })
                    }), indices: R, primitiveType: _.LINES
                })
            })
        }

        var E = [], S = [], T = function (e) {
            var t = e.polygonHierarchy, r = i(e.ellipsoid, o.WGS84), a = i(e.granularity, m.RADIANS_PER_DEGREE), s = i(e.height, 0), u = i(e.perPositionHeight, !1), l = e.extrudedHeight, c = n(l);
            if (c && !u) {
                var h = l;
                l = Math.min(h, s), s = Math.max(h, s)
            }
            this._ellipsoid = o.clone(r), this._granularity = a, this._height = s, this._extrudedHeight = i(l, 0), this._extrude = c, this._polygonHierarchy = t, this._perPositionHeight = u, this._workerName = "createPolygonOutlineGeometry", this.packedLength = p.computeHierarchyPackedLength(t) + o.packedLength + 6
        };
        T.pack = function (e, t, n) {
            n = i(n, 0), n = p.packPolygonHierarchy(e._polygonHierarchy, t, n), o.pack(e._ellipsoid, t, n), n += o.packedLength, t[n++] = e._height, t[n++] = e._extrudedHeight, t[n++] = e._granularity, t[n++] = e._extrude ? 1 : 0, t[n++] = e._perPositionHeight ? 1 : 0, t[n++] = e.packedLength
        };
        var b = o.clone(o.UNIT_SPHERE), w = {polygonHierarchy: {}};
        return T.unpack = function (e, t, r) {
            t = i(t, 0);
            var a = p.unpackPolygonHierarchy(e, t);
            t = a.startingIndex, delete a.startingIndex;
            var s = o.unpack(e, t, b);
            t += o.packedLength;
            var u = e[t++], l = e[t++], c = e[t++], h = 1 === e[t++], d = 1 === e[t++], m = e[t++];
            return n(r) || (r = new T(w)), r._polygonHierarchy = a, r._ellipsoid = o.clone(s, r._ellipsoid), r._height = u, r._extrudedHeight = l, r._granularity = c, r._extrude = h, r._perPositionHeight = d, r.packedLength = m, r
        }, T.fromPositions = function (e) {
            e = i(e, i.EMPTY_OBJECT);
            var t = {
                polygonHierarchy: {positions: e.positions},
                height: e.height,
                extrudedHeight: e.extrudedHeight,
                ellipsoid: e.ellipsoid,
                granularity: e.granularity,
                perPositionHeight: e.perPositionHeight
            };
            return new T(t)
        }, T.createGeometry = function (t) {
            var i = t._ellipsoid, r = t._granularity, o = t._height, a = t._extrudedHeight, u = t._extrude, l = t._polygonHierarchy, c = t._perPositionHeight, d = [], _ = new v;
            _.enqueue(l);
            for (var g; 0 !== _.length;) {
                var E = _.dequeue(), S = E.positions;
                if (S = f.removeDuplicates(S), !(S.length < 3)) {
                    var T = E.holes ? E.holes.length : 0;
                    for (g = 0; T > g; g++) {
                        var b = E.holes[g];
                        if (b.positions = f.removeDuplicates(b.positions), !(b.positions.length < 3)) {
                            d.push(b.positions);
                            var w = 0;
                            n(b.holes) && (w = b.holes.length);
                            for (var x = 0; w > x; x++)_.enqueue(b.holes[x])
                        }
                    }
                    d.push(S)
                }
            }
            if (0 === d.length)return void 0;
            var A, P = [], I = m.chordLength(r, i.maximumRadius);
            if (u)for (g = 0; g < d.length; g++)A = C(i, d[g], I, c), A.geometry = p.scaleToGeodeticHeightExtruded(A.geometry, o, a, i, c), P.push(A); else for (g = 0; g < d.length; g++)A = y(i, d[g], I, c), A.geometry = f.scaleToGeodeticHeight(A.geometry, o, i, !c), P.push(A);
            A = h.combineInstances(P)[0];
            var D = e.fromVertices(A.attributes.position.values);
            return new s({
                attributes: A.attributes,
                indices: A.indices,
                primitiveType: A.primitiveType,
                boundingSphere: D
            })
        }, T
    }),define("Cesium/DataSources/PolygonGeometryUpdater", ["../Core/Color", "../Core/ColorGeometryInstanceAttribute", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Event", "../Core/GeometryInstance", "../Core/isArray", "../Core/Iso8601", "../Core/PolygonGeometry", "../Core/PolygonHierarchy", "../Core/PolygonOutlineGeometry", "../Core/ShowGeometryInstanceAttribute", "../Scene/MaterialAppearance", "../Scene/PerInstanceColorAppearance", "../Scene/Primitive", "./ColorMaterialProperty", "./ConstantProperty", "./dynamicGeometryGetBoundingSphere", "./MaterialProperty", "./Property"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S) {
        "use strict";
        var T = new g(e.WHITE), b = new y(!0), w = new y(!0), x = new y(!1), A = new y(e.BLACK), P = new e, I = function (e) {
            this.id = e, this.vertexFormat = void 0, this.polygonHierarchy = void 0, this.perPositionHeight = void 0, this.height = void 0, this.extrudedHeight = void 0, this.granularity = void 0, this.stRotation = void 0
        }, D = function (e, t) {
            this._entity = e, this._scene = t, this._entitySubscription = e.definitionChanged.addEventListener(D.prototype._onEntityPropertyChanged, this), this._fillEnabled = !1, this._isClosed = !1, this._dynamic = !1, this._outlineEnabled = !1, this._geometryChanged = new s, this._showProperty = void 0, this._materialProperty = void 0, this._hasConstantOutline = !0, this._showOutlineProperty = void 0, this._outlineColorProperty = void 0, this._outlineWidth = 1, this._options = new I(e), this._onEntityPropertyChanged(e, "polygon", e.polygon, void 0)
        };
        r(D, {
            perInstanceColorAppearanceType: {value: _},
            materialAppearanceType: {value: f}
        }), r(D.prototype, {
            entity: {
                get: function () {
                    return this._entity
                }
            }, fillEnabled: {
                get: function () {
                    return this._fillEnabled
                }
            }, hasConstantFill: {
                get: function () {
                    return !this._fillEnabled || !n(this._entity.availability) && S.isConstant(this._showProperty) && S.isConstant(this._fillProperty)
                }
            }, fillMaterialProperty: {
                get: function () {
                    return this._materialProperty
                }
            }, outlineEnabled: {
                get: function () {
                    return this._outlineEnabled
                }
            }, hasConstantOutline: {
                get: function () {
                    return !this._outlineEnabled || !n(this._entity.availability) && S.isConstant(this._showProperty) && S.isConstant(this._showOutlineProperty)
                }
            }, outlineColorProperty: {
                get: function () {
                    return this._outlineColorProperty
                }
            }, outlineWidth: {
                get: function () {
                    return this._outlineWidth
                }
            }, isDynamic: {
                get: function () {
                    return this._dynamic
                }
            }, isClosed: {
                get: function () {
                    return this._isClosed
                }
            }, geometryChanged: {
                get: function () {
                    return this._geometryChanged
                }
            }
        }), D.prototype.isOutlineVisible = function (e) {
            var t = this._entity;
            return this._outlineEnabled && t.isAvailable(e) && this._showProperty.getValue(e) && this._showOutlineProperty.getValue(e)
        }, D.prototype.isFilled = function (e) {
            var t = this._entity;
            return this._fillEnabled && t.isAvailable(e) && this._showProperty.getValue(e) && this._fillProperty.getValue(e)
        }, D.prototype.createFillGeometryInstance = function (i) {
            var r, o, a = this._entity, s = a.isAvailable(i), l = new p(s && a.isShowing && this._showProperty.getValue(i) && this._fillProperty.getValue(i));
            if (this._materialProperty instanceof g) {
                var c = e.WHITE;
                n(this._materialProperty.color) && (this._materialProperty.color.isConstant || s) && (c = this._materialProperty.color.getValue(i)), o = t.fromColor(c), r = {
                    show: l,
                    color: o
                }
            } else r = {show: l};
            return new u({id: a, geometry: new h(this._options), attributes: r})
        }, D.prototype.createOutlineGeometryInstance = function (i) {
            var n = this._entity, r = n.isAvailable(i), o = S.getValueOrDefault(this._outlineColorProperty, i, e.BLACK);
            return new u({
                id: n,
                geometry: new m(this._options),
                attributes: {
                    show: new p(r && n.isShowing && this._showProperty.getValue(i) && this._showOutlineProperty.getValue(i)),
                    color: t.fromColor(o)
                }
            })
        }, D.prototype.isDestroyed = function () {
            return !1
        }, D.prototype.destroy = function () {
            this._entitySubscription(), o(this)
        }, D.prototype._onEntityPropertyChanged = function (e, t, r, o) {
            if ("availability" === t || "polygon" === t) {
                var a = this._entity.polygon;
                if (!n(a))return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var s = a.fill, u = n(s) && s.isConstant ? s.getValue(c.MINIMUM_VALUE) : !0, h = a.outline, m = n(h);
                if (m && h.isConstant && (m = h.getValue(c.MINIMUM_VALUE)), !u && !m)return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var p = a.hierarchy, v = a.show;
                if (n(v) && v.isConstant && !v.getValue(c.MINIMUM_VALUE) || !n(p))return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var y = i(a.material, T), C = y instanceof g;
                this._materialProperty = y, this._fillProperty = i(s, w), this._showProperty = i(v, b), this._showOutlineProperty = i(a.outline, x), this._outlineColorProperty = m ? i(a.outlineColor, A) : void 0;
                var E = a.height, P = a.extrudedHeight, I = a.granularity, D = a.stRotation, M = a.outlineWidth, O = a.perPositionHeight;
                if (this._fillEnabled = u, this._outlineEnabled = m, p.isConstant && S.isConstant(E) && S.isConstant(P) && S.isConstant(I) && S.isConstant(D) && S.isConstant(M) && S.isConstant(O)) {
                    var R = this._options;
                    R.vertexFormat = C ? _.VERTEX_FORMAT : f.MaterialSupport.TEXTURED.vertexFormat;
                    var N = p.getValue(c.MINIMUM_VALUE);
                    l(N) && (N = new d(N));
                    var L = n(E) ? E.getValue(c.MINIMUM_VALUE) : void 0, F = n(P) ? P.getValue(c.MINIMUM_VALUE) : void 0;
                    R.polygonHierarchy = N, R.height = L, R.extrudedHeight = F, R.granularity = n(I) ? I.getValue(c.MINIMUM_VALUE) : void 0, R.stRotation = n(D) ? D.getValue(c.MINIMUM_VALUE) : void 0, R.perPositionHeight = n(O) ? O.getValue(c.MINIMUM_VALUE) : void 0, this._outlineWidth = n(M) ? M.getValue(c.MINIMUM_VALUE) : 1, this._isClosed = n(F) && F !== L, this._dynamic = !1, this._geometryChanged.raiseEvent(this)
                } else this._dynamic || (this._dynamic = !0, this._geometryChanged.raiseEvent(this))
            }
        }, D.prototype.createDynamicUpdater = function (e) {
            return new M(e, this)
        };
        var M = function (e, t) {
            this._primitives = e, this._primitive = void 0, this._outlinePrimitive = void 0, this._geometryUpdater = t, this._options = new I(t._entity)
        };
        return M.prototype.update = function (i) {
            var r = this._primitives;
            r.removeAndDestroy(this._primitive), r.removeAndDestroy(this._outlinePrimitive), this._primitive = void 0, this._outlinePrimitive = void 0;
            var o = this._geometryUpdater, a = o._entity, s = a.polygon;
            if (a.isShowing && a.isAvailable(i) && S.getValueOrDefault(s.show, i, !0)) {
                var c = this._options, p = S.getValueOrUndefined(s.hierarchy, i);
                if (n(p)) {
                    if (l(p) ? c.polygonHierarchy = new d(p) : c.polygonHierarchy = p, c.height = S.getValueOrUndefined(s.height, i), c.extrudedHeight = S.getValueOrUndefined(s.extrudedHeight, i), c.granularity = S.getValueOrUndefined(s.granularity, i), c.stRotation = S.getValueOrUndefined(s.stRotation, i), c.perPositionHeight = S.getValueOrUndefined(s.perPositionHeight, i), S.getValueOrDefault(s.fill, i, !0)) {
                        var g = E.getValue(i, o.fillMaterialProperty, this._material);
                        this._material = g;
                        var y = new f({
                            material: g,
                            translucent: g.isTranslucent(),
                            closed: n(c.extrudedHeight) && c.extrudedHeight !== c.height
                        });
                        c.vertexFormat = y.vertexFormat, this._primitive = r.add(new v({
                            geometryInstances: new u({
                                id: a,
                                geometry: new h(c)
                            }), appearance: y, asynchronous: !1
                        }))
                    }
                    if (S.getValueOrDefault(s.outline, i, !1)) {
                        c.vertexFormat = _.VERTEX_FORMAT;
                        var C = S.getValueOrClonedDefault(s.outlineColor, i, e.BLACK, P), T = S.getValueOrDefault(s.outlineWidth, i, 1), b = 1 !== C.alpha;
                        this._outlinePrimitive = r.add(new v({
                            geometryInstances: new u({
                                id: a,
                                geometry: new m(c),
                                attributes: {color: t.fromColor(C)}
                            }),
                            appearance: new _({
                                flat: !0,
                                translucent: b,
                                renderState: {lineWidth: o._scene.clampLineWidth(T)}
                            }),
                            asynchronous: !1
                        }))
                    }
                }
            }
        }, M.prototype.getBoundingSphere = function (e, t) {
            return C(e, this._primitive, this._outlinePrimitive, t)
        }, M.prototype.isDestroyed = function () {
            return !1
        }, M.prototype.destroy = function () {
            var e = this._primitives;
            e.removeAndDestroy(this._primitive), e.removeAndDestroy(this._outlinePrimitive), o(this)
        }, D
    }),define("Cesium/Core/PolylineGeometry", ["./BoundingSphere", "./Cartesian3", "./Color", "./ComponentDatatype", "./defaultValue", "./defined", "./DeveloperError", "./Ellipsoid", "./Geometry", "./GeometryAttribute", "./GeometryAttributes", "./GeometryType", "./IndexDatatype", "./Math", "./PolylinePipeline", "./PrimitiveType", "./VertexFormat"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _) {
        "use strict";
        function v(e, t, n, r, o) {
            var a = g;
            a.length = o;
            var s, u = n.red, l = n.green, c = n.blue, h = n.alpha, d = r.red, m = r.green, p = r.blue, f = r.alpha;
            if (i.equals(n, r)) {
                for (s = 0; o > s; s++)a[s] = i.clone(n);
                return a
            }
            var _ = (d - u) / o, v = (m - l) / o, y = (p - c) / o, C = (f - h) / o;
            for (s = 0; o > s; s++)a[s] = new i(u + s * _, l + s * v, c + s * y, h + s * C);
            return a
        }

        var g = [], y = function (e) {
            e = r(e, r.EMPTY_OBJECT);
            var n = e.positions, a = e.colors, u = r(e.width, 1), l = r(e.colorsPerVertex, !1);
            this._positions = n, this._colors = a, this._width = u, this._colorsPerVertex = l, this._vertexFormat = _.clone(r(e.vertexFormat, _.DEFAULT)), this._followSurface = r(e.followSurface, !0), this._granularity = r(e.granularity, m.RADIANS_PER_DEGREE), this._ellipsoid = s.clone(r(e.ellipsoid, s.WGS84)), this._workerName = "createPolylineGeometry";
            var c = 1 + n.length * t.packedLength;
            c += o(a) ? 1 + a.length * i.packedLength : 1, this.packedLength = c + s.packedLength + _.packedLength + 4
        };
        y.pack = function (e, n, a) {
            a = r(a, 0);
            var u, l = e._positions, c = l.length;
            for (n[a++] = c, u = 0; c > u; ++u, a += t.packedLength)t.pack(l[u], n, a);
            var h = e._colors;
            for (c = o(h) ? h.length : 0, n[a++] = c, u = 0; c > u; ++u, a += i.packedLength)i.pack(h[u], n, a);
            s.pack(e._ellipsoid, n, a), a += s.packedLength, _.pack(e._vertexFormat, n, a), a += _.packedLength, n[a++] = e._width, n[a++] = e._colorsPerVertex ? 1 : 0, n[a++] = e._followSurface ? 1 : 0, n[a] = e._granularity
        };
        var C = s.clone(s.UNIT_SPHERE), E = new _, S = {
            positions: void 0,
            colors: void 0,
            ellipsoid: C,
            vertexFormat: E,
            width: void 0,
            colorsPerVertex: void 0,
            followSurface: void 0,
            granularity: void 0
        };
        y.unpack = function (e, n, a) {
            n = r(n, 0);
            var u, l = e[n++], c = new Array(l);
            for (u = 0; l > u; ++u, n += t.packedLength)c[u] = t.unpack(e, n);
            l = e[n++];
            var h = l > 0 ? new Array(l) : void 0;
            for (u = 0; l > u; ++u, n += i.packedLength)h[u] = i.unpack(e, n);
            var d = s.unpack(e, n, C);
            n += s.packedLength;
            var m = _.unpack(e, n, E);
            n += _.packedLength;
            var p = e[n++], f = 1 === e[n++], v = 1 === e[n++], g = e[n];
            return o(a) ? (a._positions = c, a._colors = h, a._ellipsoid = s.clone(d, a._ellipsoid), a._vertexFormat = _.clone(m, a._vertexFormat), a._width = p, a._colorsPerVertex = f, a._followSurface = v, a._granularity = g, a) : (S.positions = c, S.colors = h, S.width = p, S.colorsPerVertex = f, S.followSurface = v, S.granularity = g, new y(S))
        };
        var T = new t, b = new t, w = new t, x = new t;
        return y.createGeometry = function (r) {
            var a, s, _, y = r._width, C = r._vertexFormat, E = r._colors, S = r._colorsPerVertex, A = r._followSurface, P = r._granularity, I = r._ellipsoid, D = m.chordLength(P, I.maximumRadius), M = p.removeDuplicates(r._positions), O = M.length;
            if (2 > O)return void 0;
            if (A) {
                var R = p.extractHeights(M, I);
                if (o(E)) {
                    var N = 1;
                    for (a = 0; O - 1 > a; ++a)N += p.numberOfPoints(M[a], M[a + 1], D);
                    var L = new Array(N), F = 0;
                    for (a = 0; O - 1 > a; ++a) {
                        var B = M[a], z = M[a + 1], V = E[a], U = p.numberOfPoints(B, z, D);
                        if (S && N > a) {
                            var k = E[a + 1], G = v(B, z, V, k, U), H = G.length;
                            for (s = 0; H > s; ++s)L[F++] = G[s]
                        } else for (s = 0; U > s; ++s)L[F++] = i.clone(V)
                    }
                    L[F] = i.clone(E[E.length - 1]), E = L, g.length = 0
                }
                M = p.generateCartesianArc({positions: M, minDistance: D, ellipsoid: I, height: R})
            }
            O = M.length;
            var W, q = 4 * O - 4, j = new Float64Array(3 * q), Y = new Float64Array(3 * q), X = new Float64Array(3 * q), Z = new Float32Array(2 * q), K = C.st ? new Float32Array(2 * q) : void 0, J = o(E) ? new Uint8Array(4 * q) : void 0, Q = 0, $ = 0, ee = 0, te = 0;
            for (s = 0; O > s; ++s) {
                0 === s ? (W = T, t.subtract(M[0], M[1], W), t.add(M[0], W, W)) : W = M[s - 1], t.clone(W, w), t.clone(M[s], b), s === O - 1 ? (W = T, t.subtract(M[O - 1], M[O - 2], W), t.add(M[O - 1], W, W)) : W = M[s + 1], t.clone(W, x);
                var ie, ne;
                o(J) && (ie = 0 === s || S ? E[s] : E[s - 1], s !== O - 1 && (ne = E[s]));
                var re = 0 === s ? 2 : 0, oe = s === O - 1 ? 2 : 4;
                for (_ = re; oe > _; ++_) {
                    t.pack(b, j, Q), t.pack(w, Y, Q), t.pack(x, X, Q), Q += 3;
                    var ae = 0 > _ - 2 ? -1 : 1;
                    if (Z[$++] = 2 * (_ % 2) - 1, Z[$++] = ae * y, C.st && (K[ee++] = s / (O - 1), K[ee++] = Math.max(Z[$ - 2], 0)), o(J)) {
                        var se = 2 > _ ? ie : ne;
                        J[te++] = i.floatToByte(se.red), J[te++] = i.floatToByte(se.green), J[te++] = i.floatToByte(se.blue), J[te++] = i.floatToByte(se.alpha)
                    }
                }
            }
            var ue = new c;
            ue.position = new l({
                componentDatatype: n.DOUBLE,
                componentsPerAttribute: 3,
                values: j
            }), ue.prevPosition = new l({
                componentDatatype: n.DOUBLE,
                componentsPerAttribute: 3,
                values: Y
            }), ue.nextPosition = new l({
                componentDatatype: n.DOUBLE,
                componentsPerAttribute: 3,
                values: X
            }), ue.expandAndWidth = new l({
                componentDatatype: n.FLOAT,
                componentsPerAttribute: 2,
                values: Z
            }), C.st && (ue.st = new l({
                componentDatatype: n.FLOAT,
                componentsPerAttribute: 2,
                values: K
            })), o(J) && (ue.color = new l({
                componentDatatype: n.UNSIGNED_BYTE,
                componentsPerAttribute: 4,
                values: J,
                normalize: !0
            }));
            var le = d.createTypedArray(q, 6 * O - 6), ce = 0, he = 0, de = O - 1;
            for (s = 0; de > s; ++s)le[he++] = ce, le[he++] = ce + 2, le[he++] = ce + 1, le[he++] = ce + 1, le[he++] = ce + 2, le[he++] = ce + 3, ce += 4;
            return new u({
                attributes: ue,
                indices: le,
                primitiveType: f.TRIANGLES,
                boundingSphere: e.fromPoints(M),
                geometryType: h.POLYLINES
            })
        }, y
    }),define("Cesium/Shaders/Appearances/PolylineColorAppearanceVS", [], function () {
        "use strict";
        return "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 prevPosition3DHigh;\nattribute vec3 prevPosition3DLow;\nattribute vec3 nextPosition3DHigh;\nattribute vec3 nextPosition3DLow;\nattribute vec2 expandAndWidth;\nattribute vec4 color;\n\nvarying vec4 v_color;\n\nvoid main() \n{\n    float expandDir = expandAndWidth.x;\n    float width = abs(expandAndWidth.y) + 0.5;\n    bool usePrev = expandAndWidth.y < 0.0;\n    \n    vec4 p = czm_computePosition();\n    vec4 prev = czm_computePrevPosition();\n    vec4 next = czm_computeNextPosition();\n    \n    v_color = color;\n    \n    vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev);\n    gl_Position = czm_viewportOrthographic * positionWC;\n}\n"
    }),define("Cesium/Scene/PolylineColorAppearance", ["../Core/defaultValue", "../Core/defineProperties", "../Core/VertexFormat", "../Shaders/Appearances/PerInstanceFlatColorAppearanceFS", "../Shaders/Appearances/PolylineColorAppearanceVS", "../Shaders/PolylineCommon", "./Appearance"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = o + "\n" + r, u = n, l = function (t) {
            t = e(t, e.EMPTY_OBJECT);
            var i = e(t.translucent, !0), n = !1, r = l.VERTEX_FORMAT;
            this.material = void 0, this.translucent = i, this._vertexShaderSource = e(t.vertexShaderSource, s), this._fragmentShaderSource = e(t.fragmentShaderSource, u), this._renderState = a.getDefaultRenderState(i, n, t.renderState), this._closed = n, this._vertexFormat = r
        };
        return t(l.prototype, {
            vertexShaderSource: {
                get: function () {
                    return this._vertexShaderSource
                }
            }, fragmentShaderSource: {
                get: function () {
                    return this._fragmentShaderSource
                }
            }, renderState: {
                get: function () {
                    return this._renderState
                }
            }, closed: {
                get: function () {
                    return this._closed
                }
            }, vertexFormat: {
                get: function () {
                    return this._vertexFormat
                }
            }
        }), l.VERTEX_FORMAT = i.POSITION_ONLY, l.prototype.getFragmentShaderSource = a.prototype.getFragmentShaderSource, l.prototype.isTranslucent = a.prototype.isTranslucent, l.prototype.getRenderState = a.prototype.getRenderState, l
    }),define("Cesium/Shaders/Appearances/PolylineMaterialAppearanceVS", [], function () {
        "use strict";
        return "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 prevPosition3DHigh;\nattribute vec3 prevPosition3DLow;\nattribute vec3 nextPosition3DHigh;\nattribute vec3 nextPosition3DLow;\nattribute vec2 expandAndWidth;\nattribute vec2 st;\n\nvarying float v_width;\nvarying vec2 v_st;\n\nvoid main() \n{\n    float expandDir = expandAndWidth.x;\n    float width = abs(expandAndWidth.y) + 0.5;\n    bool usePrev = expandAndWidth.y < 0.0;\n    \n    vec4 p = czm_computePosition();\n    vec4 prev = czm_computePrevPosition();\n    vec4 next = czm_computeNextPosition();\n    \n    v_width = width;\n    v_st = st;\n    \n    vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev);\n    gl_Position = czm_viewportOrthographic * positionWC;\n}\n"
    }),define("Cesium/Scene/PolylineMaterialAppearance", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/VertexFormat", "../Shaders/Appearances/PolylineMaterialAppearanceVS", "../Shaders/PolylineCommon", "../Shaders/PolylineFS", "./Appearance", "./Material"], function (e, t, i, n, r, o, a, s, u) {
        "use strict";
        var l = o + "\n" + r, c = a, h = function (i) {
            i = e(i, e.EMPTY_OBJECT);
            var n = e(i.translucent, !0), r = !1, o = h.VERTEX_FORMAT;
            this.material = t(i.material) ? i.material : u.fromType(u.ColorType), this.translucent = n, this._vertexShaderSource = e(i.vertexShaderSource, l), this._fragmentShaderSource = e(i.fragmentShaderSource, c), this._renderState = s.getDefaultRenderState(n, r, i.renderState), this._closed = r, this._vertexFormat = o
        };
        return i(h.prototype, {
            vertexShaderSource: {
                get: function () {
                    return this._vertexShaderSource
                }
            }, fragmentShaderSource: {
                get: function () {
                    return this._fragmentShaderSource
                }
            }, renderState: {
                get: function () {
                    return this._renderState
                }
            }, closed: {
                get: function () {
                    return this._closed
                }
            }, vertexFormat: {
                get: function () {
                    return this._vertexFormat
                }
            }
        }), h.VERTEX_FORMAT = n.POSITION_AND_ST, h.prototype.getFragmentShaderSource = s.prototype.getFragmentShaderSource, h.prototype.isTranslucent = s.prototype.isTranslucent, h.prototype.getRenderState = s.prototype.getRenderState, h
    }),define("Cesium/DataSources/PolylineGeometryUpdater", ["../Core/BoundingSphere", "../Core/Color", "../Core/ColorGeometryInstanceAttribute", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Ellipsoid", "../Core/Event", "../Core/GeometryInstance", "../Core/Iso8601", "../Core/PolylineGeometry", "../Core/PolylinePipeline", "../Core/ShowGeometryInstanceAttribute", "../Scene/PolylineCollection", "../Scene/PolylineColorAppearance", "../Scene/PolylineMaterialAppearance", "./BoundingSphereState", "./ColorMaterialProperty", "./ConstantProperty", "./MaterialProperty", "./Property"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S) {
        "use strict";
        var T = {}, b = new y(t.WHITE), w = new C(!0), x = function (e) {
            this.id = e, this.vertexFormat = void 0, this.positions = void 0, this.width = void 0, this.followSurface = void 0, this.granularity = void 0
        }, A = function (e, t) {
            this._entity = e, this._scene = t, this._entitySubscription = e.definitionChanged.addEventListener(A.prototype._onEntityPropertyChanged, this), this._fillEnabled = !1, this._dynamic = !1, this._geometryChanged = new l, this._showProperty = void 0, this._materialProperty = void 0, this._options = new x(e), this._onEntityPropertyChanged(e, "polyline", e.polyline, void 0)
        };
        o(A, {
            perInstanceColorAppearanceType: {value: _},
            materialAppearanceType: {value: v}
        }), o(A.prototype, {
            entity: {
                get: function () {
                    return this._entity
                }
            },
            fillEnabled: {
                get: function () {
                    return this._fillEnabled
                }
            },
            hasConstantFill: {
                get: function () {
                    return !this._fillEnabled || !r(this._entity.availability) && S.isConstant(this._showProperty)
                }
            },
            fillMaterialProperty: {
                get: function () {
                    return this._materialProperty
                }
            },
            outlineEnabled: {value: !1},
            hasConstantOutline: {value: !0},
            outlineColorProperty: {value: void 0},
            isDynamic: {
                get: function () {
                    return this._dynamic
                }
            },
            isClosed: {value: !1},
            geometryChanged: {
                get: function () {
                    return this._geometryChanged
                }
            }
        }), A.prototype.isOutlineVisible = function (e) {
            return !1
        }, A.prototype.isFilled = function (e) {
            var t = this._entity;
            return this._fillEnabled && t.isAvailable(e) && this._showProperty.getValue(e)
        }, A.prototype.createFillGeometryInstance = function (e) {
            var n, o, a = this._entity, s = a.isAvailable(e), u = new p(s && a.isShowing && this._showProperty.getValue(e));
            if (this._materialProperty instanceof y) {
                var l = t.WHITE;
                r(this._materialProperty.color) && (this._materialProperty.color.isConstant || s) && (l = this._materialProperty.color.getValue(e)), n = i.fromColor(l), o = {
                    show: u,
                    color: n
                }
            } else o = {show: u};
            return new c({id: a, geometry: new d(this._options), attributes: o})
        }, A.prototype.createOutlineGeometryInstance = function (e) {
        }, A.prototype.isDestroyed = function () {
            return !1
        }, A.prototype.destroy = function () {
            this._entitySubscription(), a(this)
        }, A.prototype._onEntityPropertyChanged = function (e, t, i, o) {
            if ("availability" === t || "polyline" === t) {
                var a = this._entity.polyline;
                if (!r(a))return void(this._fillEnabled && (this._fillEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var s = a.positions, u = a.show;
                if (r(u) && u.isConstant && !u.getValue(h.MINIMUM_VALUE) || !r(s))return void(this._fillEnabled && (this._fillEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var l = n(a.material, b), c = l instanceof y;
                this._materialProperty = l, this._showProperty = n(u, w), this._fillEnabled = !0;
                var d = a.width, m = a.followSurface, p = a.granularity;
                if (s.isConstant && S.isConstant(d) && S.isConstant(m) && S.isConstant(p)) {
                    var f = this._options, g = s.getValue(h.MINIMUM_VALUE, f.positions);
                    if (!r(g) || g.length < 2)return void(this._fillEnabled && (this._fillEnabled = !1, this._geometryChanged.raiseEvent(this)));
                    f.vertexFormat = c ? _.VERTEX_FORMAT : v.VERTEX_FORMAT, f.positions = g, f.width = r(d) ? d.getValue(h.MINIMUM_VALUE) : void 0, f.followSurface = r(m) ? m.getValue(h.MINIMUM_VALUE) : void 0, f.granularity = r(p) ? p.getValue(h.MINIMUM_VALUE) : void 0, this._dynamic = !1, this._geometryChanged.raiseEvent(this)
                } else this._dynamic || (this._dynamic = !0, this._geometryChanged.raiseEvent(this))
            }
        }, A.prototype.createDynamicUpdater = function (e) {
            return new P(e, this)
        };
        var P = function (e, t) {
            var i = t._scene.id, n = T[i];
            !r(n) || n.isDestroyed() ? (n = new f, T[i] = n, e.add(n)) : e.contains(n) || e.add(n);
            var o = n.add();
            o.id = t._entity, this._line = o, this._primitives = e, this._geometryUpdater = t, this._positions = []
        }, I = {positions: void 0, granularity: void 0, height: void 0};
        return P.prototype.update = function (e) {
            var t = this._geometryUpdater, i = t._entity, n = i.polyline, o = this._line;
            if (!i.isShowing || !i.isAvailable(e) || !S.getValueOrDefault(n._show, e, !0))return void(o.show = !1);
            var a = n.positions, s = S.getValueOrUndefined(a, e, this._positions);
            if (!r(s) || s.length < 2)return void(o.show = !1);
            var u = S.getValueOrDefault(n._followSurface, e, !0);
            u && (I.positions = s, I.granularity = S.getValueOrUndefined(n._granularity, e), I.height = m.extractHeights(s, this._geometryUpdater._scene.globe.ellipsoid), s = m.generateCartesianArc(I)), o.show = !0, o.positions = s, o.material = E.getValue(e, t.fillMaterialProperty, o.material), o.width = S.getValueOrDefault(n._width, e, 1)
        }, P.prototype.getBoundingSphere = function (t, i) {
            var n = this._line;
            return n.show && n.positions.length > 0 ? (e.fromPoints(n.positions, i), g.DONE) : g.FAILED
        }, P.prototype.isDestroyed = function () {
            return !1
        }, P.prototype.destroy = function () {
            var e = this._geometryUpdater, t = e._scene.id, i = T[t];
            i.remove(this._line), 0 === i.length && (this._primitives.removeAndDestroy(i), delete T[t]), a(this)
        }, A
    }),define("Cesium/Core/PolylineVolumeGeometry", ["./BoundingRectangle", "./BoundingSphere", "./Cartesian2", "./Cartesian3", "./ComponentDatatype", "./CornerType", "./defaultValue", "./defined", "./DeveloperError", "./Ellipsoid", "./Geometry", "./GeometryAttribute", "./GeometryAttributes", "./GeometryPipeline", "./IndexDatatype", "./Math", "./PolygonPipeline", "./PolylineVolumeGeometryLibrary", "./PrimitiveType", "./VertexFormat", "./WindingOrder"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C) {
        "use strict";
        function E(e, i, n, o) {
            var a = new d;
            o.position && (a.position = new h({componentDatatype: r.DOUBLE, componentsPerAttribute: 3, values: e}));
            var s, u, l, f, v, y, C = i.length, E = e.length / 3, S = (E - 2 * C) / (2 * C), T = _.triangulate(i), b = (S - 1) * C * 6 + 2 * T.length, w = p.createTypedArray(E, b), x = 2 * C, A = 0;
            for (s = 0; S - 1 > s; s++) {
                for (u = 0; C - 1 > u; u++)l = 2 * u + s * C * 2, y = l + x, f = l + 1, v = f + x, w[A++] = f, w[A++] = l, w[A++] = v, w[A++] = v, w[A++] = l, w[A++] = y;
                l = 2 * C - 2 + s * C * 2, f = l + 1, v = f + x, y = l + x, w[A++] = f, w[A++] = l, w[A++] = v, w[A++] = v, w[A++] = l, w[A++] = y
            }
            if (o.st || o.tangent || o.binormal) {
                var P, I, D = new Float32Array(2 * E), M = 1 / (S - 1), O = 1 / n.height, R = n.height / 2, N = 0;
                for (s = 0; S > s; s++) {
                    for (P = s * M, I = O * (i[0].y + R), D[N++] = P, D[N++] = I, u = 1; C > u; u++)I = O * (i[u].y + R), D[N++] = P, D[N++] = I, D[N++] = P, D[N++] = I;
                    I = O * (i[0].y + R), D[N++] = P, D[N++] = I
                }
                for (u = 0; C > u; u++)P = 0, I = O * (i[u].y + R), D[N++] = P, D[N++] = I;
                for (u = 0; C > u; u++)P = (S - 1) * M, I = O * (i[u].y + R), D[N++] = P, D[N++] = I;
                a.st = new h({componentDatatype: r.FLOAT, componentsPerAttribute: 2, values: new Float32Array(D)})
            }
            var L = E - 2 * C;
            for (s = 0; s < T.length; s += 3) {
                var F = T[s] + L, B = T[s + 1] + L, z = T[s + 2] + L;
                w[A++] = F, w[A++] = B, w[A++] = z, w[A++] = z + C, w[A++] = B + C, w[A++] = F + C
            }
            var V = new c({attributes: a, indices: w, boundingSphere: t.fromVertices(e), primitiveType: g.TRIANGLES});
            return o.normal && (V = m.computeNormal(V)), (o.tangent || o.binormal) && (V = m.computeBinormalAndTangent(V), o.tangent || (V.attributes.tangent = void 0), o.binormal || (V.attributes.binormal = void 0), o.st || (V.attributes.st = void 0)), V
        }

        var S = function (e) {
            e = a(e, a.EMPTY_OBJECT);
            var t = e.polylinePositions, r = e.shapePositions;
            this._positions = t, this._shape = r, this._ellipsoid = l.clone(a(e.ellipsoid, l.WGS84)), this._cornerType = a(e.cornerType, o.ROUNDED), this._vertexFormat = y.clone(a(e.vertexFormat, y.DEFAULT)), this._granularity = a(e.granularity, f.RADIANS_PER_DEGREE), this._workerName = "createPolylineVolumeGeometry";
            var s = 1 + t.length * n.packedLength;
            s += 1 + r.length * i.packedLength, this.packedLength = s + l.packedLength + y.packedLength + 2
        };
        S.pack = function (e, t, r) {
            r = a(r, 0);
            var o, s = e._positions, u = s.length;
            for (t[r++] = u, o = 0; u > o; ++o, r += n.packedLength)n.pack(s[o], t, r);
            var c = e._shape;
            for (u = c.length, t[r++] = u, o = 0; u > o; ++o, r += i.packedLength)i.pack(c[o], t, r);
            l.pack(e._ellipsoid, t, r), r += l.packedLength, y.pack(e._vertexFormat, t, r), r += y.packedLength, t[r++] = e._cornerType, t[r] = e._granularity
        };
        var T = l.clone(l.UNIT_SPHERE), b = new y, w = {
            polylinePositions: void 0,
            shapePositions: void 0,
            ellipsoid: T,
            vertexFormat: b,
            cornerType: void 0,
            granularity: void 0
        };
        S.unpack = function (e, t, r) {
            t = a(t, 0);
            var o, u = e[t++], c = new Array(u);
            for (o = 0; u > o; ++o, t += n.packedLength)c[o] = n.unpack(e, t);
            u = e[t++];
            var h = new Array(u);
            for (o = 0; u > o; ++o, t += i.packedLength)h[o] = i.unpack(e, t);
            var d = l.unpack(e, t, T);
            t += l.packedLength;
            var m = y.unpack(e, t, b);
            t += y.packedLength;
            var p = e[t++], f = e[t];
            return s(r) ? (r._positions = c, r._shape = h, r._ellipsoid = l.clone(d, r._ellipsoid), r._vertexFormat = y.clone(m, r._vertexFormat), r._cornerType = p, r._granularity = f, r) : (w.polylinePositions = c, w.shapePositions = h, w.cornerType = p, w.granularity = f, new S(w))
        };
        var x = new e;
        return S.createGeometry = function (t) {
            var i = t._positions, n = v.removeDuplicatesFromPositions(i, t._ellipsoid), r = t._shape;
            if (r = v.removeDuplicatesFromShape(r), n.length < 2 || r.length < 3)return void 0;
            _.computeWindingOrder2D(r) === C.CLOCKWISE && r.reverse();
            var o = e.fromPoints(r, x), a = v.computePositions(n, r, o, t, !0);
            return E(a, r, o, t._vertexFormat)
        }, S
    }),define("Cesium/Core/PolylineVolumeOutlineGeometry", ["./BoundingRectangle", "./BoundingSphere", "./Cartesian2", "./Cartesian3", "./ComponentDatatype", "./CornerType", "./defaultValue", "./defined", "./DeveloperError", "./Ellipsoid", "./Geometry", "./GeometryAttribute", "./GeometryAttributes", "./IndexDatatype", "./Math", "./PolygonPipeline", "./PolylineVolumeGeometryLibrary", "./PrimitiveType", "./WindingOrder"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g) {
        "use strict";
        function y(e, i) {
            var n = new d;
            n.position = new h({componentDatatype: r.DOUBLE, componentsPerAttribute: 3, values: e});
            var o, a, s = i.length, u = n.position.values.length / 3, l = e.length / 3, p = l / s, f = m.createTypedArray(u, 2 * s * (p + 1)), _ = 0;
            o = 0;
            var g = o * s;
            for (a = 0; s - 1 > a; a++)f[_++] = a + g, f[_++] = a + g + 1;
            for (f[_++] = s - 1 + g, f[_++] = g, o = p - 1, g = o * s, a = 0; s - 1 > a; a++)f[_++] = a + g, f[_++] = a + g + 1;
            for (f[_++] = s - 1 + g, f[_++] = g, o = 0; p - 1 > o; o++) {
                var y = s * o, C = y + s;
                for (a = 0; s > a; a++)f[_++] = a + y, f[_++] = a + C
            }
            var E = new c({
                attributes: n,
                indices: m.createTypedArray(u, f),
                boundingSphere: t.fromVertices(e),
                primitiveType: v.LINES
            });
            return E
        }

        var C = function (e) {
            e = a(e, a.EMPTY_OBJECT);
            var t = e.polylinePositions, r = e.shapePositions;
            this._positions = t, this._shape = r, this._ellipsoid = l.clone(a(e.ellipsoid, l.WGS84)), this._cornerType = a(e.cornerType, o.ROUNDED), this._granularity = a(e.granularity, p.RADIANS_PER_DEGREE), this._workerName = "createPolylineVolumeOutlineGeometry";
            var s = 1 + t.length * n.packedLength;
            s += 1 + r.length * i.packedLength, this.packedLength = s + l.packedLength + 2
        };
        C.pack = function (e, t, r) {
            r = a(r, 0);
            var o, s = e._positions, u = s.length;
            for (t[r++] = u, o = 0; u > o; ++o, r += n.packedLength)n.pack(s[o], t, r);
            var c = e._shape;
            for (u = c.length, t[r++] = u, o = 0; u > o; ++o, r += i.packedLength)i.pack(c[o], t, r);
            l.pack(e._ellipsoid, t, r), r += l.packedLength, t[r++] = e._cornerType, t[r] = e._granularity
        };
        var E = l.clone(l.UNIT_SPHERE), S = {
            polylinePositions: void 0,
            shapePositions: void 0,
            ellipsoid: E,
            height: void 0,
            cornerType: void 0,
            granularity: void 0
        };
        C.unpack = function (e, t, r) {
            t = a(t, 0);
            var o, u = e[t++], c = new Array(u);
            for (o = 0; u > o; ++o, t += n.packedLength)c[o] = n.unpack(e, t);
            u = e[t++];
            var h = new Array(u);
            for (o = 0; u > o; ++o, t += i.packedLength)h[o] = i.unpack(e, t);
            var d = l.unpack(e, t, E);
            t += l.packedLength;
            var m = e[t++], p = e[t];
            return s(r) ? (r._positions = c, r._shape = h, r._ellipsoid = l.clone(d, r._ellipsoid), r._cornerType = m, r._granularity = p, r) : (S.polylinePositions = c, S.shapePositions = h, S.cornerType = m, S.granularity = p, new C(S))
        };
        var T = new e;
        return C.createGeometry = function (t) {
            var i = t._positions, n = _.removeDuplicatesFromPositions(i, t._ellipsoid), r = t._shape;
            if (r = _.removeDuplicatesFromShape(r), n.length < 2 || r.length < 3)return void 0;
            f.computeWindingOrder2D(r) === g.CLOCKWISE && r.reverse();
            var o = e.fromPoints(r, T), a = _.computePositions(n, r, o, t, !1);
            return y(a, r)
        }, C
    }),define("Cesium/DataSources/PolylineVolumeGeometryUpdater", ["../Core/Color", "../Core/ColorGeometryInstanceAttribute", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Event", "../Core/GeometryInstance", "../Core/Iso8601", "../Core/PolylineVolumeGeometry", "../Core/PolylineVolumeOutlineGeometry", "../Core/ShowGeometryInstanceAttribute", "../Scene/MaterialAppearance", "../Scene/PerInstanceColorAppearance", "../Scene/Primitive", "./ColorMaterialProperty", "./ConstantProperty", "./dynamicGeometryGetBoundingSphere", "./MaterialProperty", "./Property"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C) {
        "use strict";
        var E = new _(e.WHITE), S = new v(!0), T = new v(!0), b = new v(!1), w = new v(e.BLACK), x = new e, A = function (e) {
            this.id = e, this.vertexFormat = void 0, this.polylinePositions = void 0, this.shapePositions = void 0, this.cornerType = void 0, this.granularity = void 0
        }, P = function (e, t) {
            this._entity = e, this._scene = t, this._entitySubscription = e.definitionChanged.addEventListener(P.prototype._onEntityPropertyChanged, this), this._fillEnabled = !1, this._dynamic = !1, this._outlineEnabled = !1, this._geometryChanged = new s, this._showProperty = void 0, this._materialProperty = void 0, this._hasConstantOutline = !0, this._showOutlineProperty = void 0, this._outlineColorProperty = void 0, this._outlineWidth = 1, this._options = new A(e), this._onEntityPropertyChanged(e, "polylineVolume", e.polylineVolume, void 0)
        };
        r(P, {
            perInstanceColorAppearanceType: {value: p},
            materialAppearanceType: {value: m}
        }), r(P.prototype, {
            entity: {
                get: function () {
                    return this._entity
                }
            }, fillEnabled: {
                get: function () {
                    return this._fillEnabled
                }
            }, hasConstantFill: {
                get: function () {
                    return !this._fillEnabled || !n(this._entity.availability) && C.isConstant(this._showProperty) && C.isConstant(this._fillProperty)
                }
            }, fillMaterialProperty: {
                get: function () {
                    return this._materialProperty
                }
            }, outlineEnabled: {
                get: function () {
                    return this._outlineEnabled
                }
            }, hasConstantOutline: {
                get: function () {
                    return !this._outlineEnabled || !n(this._entity.availability) && C.isConstant(this._showProperty) && C.isConstant(this._showOutlineProperty)
                }
            }, outlineColorProperty: {
                get: function () {
                    return this._outlineColorProperty
                }
            }, outlineWidth: {
                get: function () {
                    return this._outlineWidth
                }
            }, isDynamic: {
                get: function () {
                    return this._dynamic
                }
            }, isClosed: {value: !0}, geometryChanged: {
                get: function () {
                    return this._geometryChanged
                }
            }
        }), P.prototype.isOutlineVisible = function (e) {
            var t = this._entity;
            return this._outlineEnabled && t.isAvailable(e) && this._showProperty.getValue(e) && this._showOutlineProperty.getValue(e)
        }, P.prototype.isFilled = function (e) {
            var t = this._entity;
            return this._fillEnabled && t.isAvailable(e) && this._showProperty.getValue(e) && this._fillProperty.getValue(e)
        }, P.prototype.createFillGeometryInstance = function (i) {
            var r, o, a = this._entity, s = a.isAvailable(i), l = new d(s && a.isShowing && this._showProperty.getValue(i) && this._fillProperty.getValue(i));
            if (this._materialProperty instanceof _) {
                var h = e.WHITE;
                n(this._materialProperty.color) && (this._materialProperty.color.isConstant || s) && (h = this._materialProperty.color.getValue(i)), o = t.fromColor(h), r = {
                    show: l,
                    color: o
                }
            } else r = {show: l};
            return new u({id: a, geometry: new c(this._options), attributes: r})
        }, P.prototype.createOutlineGeometryInstance = function (i) {
            var n = this._entity, r = n.isAvailable(i), o = C.getValueOrDefault(this._outlineColorProperty, i, e.BLACK);
            return new u({
                id: n,
                geometry: new h(this._options),
                attributes: {
                    show: new d(r && n.isShowing && this._showProperty.getValue(i) && this._showOutlineProperty.getValue(i)),
                    color: t.fromColor(o)
                }
            })
        }, P.prototype.isDestroyed = function () {
            return !1
        }, P.prototype.destroy = function () {
            this._entitySubscription(), o(this)
        }, P.prototype._onEntityPropertyChanged = function (e, t, r, o) {
            if ("availability" === t || "polylineVolume" === t) {
                var a = this._entity.polylineVolume;
                if (!n(a))return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var s = a.fill, u = n(s) && s.isConstant ? s.getValue(l.MINIMUM_VALUE) : !0, c = a.outline, h = n(c);
                if (h && c.isConstant && (h = c.getValue(l.MINIMUM_VALUE)), !u && !h)return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var d = a.positions, f = a.shape, v = a.show;
                if (!n(d) || !n(f) || n(v) && v.isConstant && !v.getValue(l.MINIMUM_VALUE))return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var g = i(a.material, E), y = g instanceof _;
                this._materialProperty = g, this._fillProperty = i(s, T), this._showProperty = i(v, S), this._showOutlineProperty = i(a.outline, b), this._outlineColorProperty = h ? i(a.outlineColor, w) : void 0;
                var x = a.granularity, A = a.outlineWidth, P = a.cornerType;
                if (this._fillEnabled = u, this._outlineEnabled = h, d.isConstant && f.isConstant && C.isConstant(x) && C.isConstant(A) && C.isConstant(P)) {
                    var I = this._options;
                    I.vertexFormat = y ? p.VERTEX_FORMAT : m.MaterialSupport.TEXTURED.vertexFormat, I.polylinePositions = d.getValue(l.MINIMUM_VALUE, I.polylinePositions), I.shapePositions = f.getValue(l.MINIMUM_VALUE, I.shape), I.granularity = n(x) ? x.getValue(l.MINIMUM_VALUE) : void 0, I.cornerType = n(P) ? P.getValue(l.MINIMUM_VALUE) : void 0, this._outlineWidth = n(A) ? A.getValue(l.MINIMUM_VALUE) : 1, this._dynamic = !1, this._geometryChanged.raiseEvent(this)
                } else this._dynamic || (this._dynamic = !0, this._geometryChanged.raiseEvent(this))
            }
        }, P.prototype.createDynamicUpdater = function (e) {
            return new I(e, this)
        };
        var I = function (e, t) {
            this._primitives = e, this._primitive = void 0, this._outlinePrimitive = void 0, this._geometryUpdater = t, this._options = new A(t._entity)
        };
        return I.prototype.update = function (i) {
            var r = this._primitives;
            r.removeAndDestroy(this._primitive), r.removeAndDestroy(this._outlinePrimitive), this._primitive = void 0, this._outlinePrimitive = void 0;
            var o = this._geometryUpdater, a = o._entity, s = a.polylineVolume;
            if (a.isShowing && a.isAvailable(i) && C.getValueOrDefault(s.show, i, !0)) {
                var l = this._options, d = C.getValueOrUndefined(s.positions, i, l.polylinePositions), _ = C.getValueOrUndefined(s.shape, i);
                if (n(d) && n(_)) {
                    if (l.polylinePositions = d, l.shapePositions = _, l.granularity = C.getValueOrUndefined(s.granularity, i), l.cornerType = C.getValueOrUndefined(s.cornerType, i), !n(s.fill) || s.fill.getValue(i)) {
                        var v = y.getValue(i, o.fillMaterialProperty, this._material);
                        this._material = v;
                        var g = new m({material: v, translucent: v.isTranslucent(), closed: !0});
                        l.vertexFormat = g.vertexFormat, this._primitive = r.add(new f({
                            geometryInstances: new u({
                                id: a,
                                geometry: new c(l)
                            }), appearance: g, asynchronous: !1
                        }))
                    }
                    if (n(s.outline) && s.outline.getValue(i)) {
                        l.vertexFormat = p.VERTEX_FORMAT;
                        var E = C.getValueOrClonedDefault(s.outlineColor, i, e.BLACK, x), S = C.getValueOrDefault(s.outlineWidth, i, 1), T = 1 !== E.alpha;
                        this._outlinePrimitive = r.add(new f({
                            geometryInstances: new u({
                                id: a,
                                geometry: new h(l),
                                attributes: {color: t.fromColor(E)}
                            }),
                            appearance: new p({
                                flat: !0,
                                translucent: T,
                                renderState: {lineWidth: o._scene.clampLineWidth(S)}
                            }),
                            asynchronous: !1
                        }))
                    }
                }
            }
        }, I.prototype.getBoundingSphere = function (e, t) {
            return g(e, this._primitive, this._outlinePrimitive, t)
        }, I.prototype.isDestroyed = function () {
            return !1
        }, I.prototype.destroy = function () {
            var e = this._primitives;
            e.removeAndDestroy(this._primitive), e.removeAndDestroy(this._outlinePrimitive), o(this)
        }, P
    }),define("Cesium/Core/RectangleGeometry", ["./BoundingSphere", "./Cartesian2", "./Cartesian3", "./Cartographic", "./ComponentDatatype", "./defaultValue", "./defined", "./DeveloperError", "./Ellipsoid", "./Geometry", "./GeometryAttribute", "./GeometryAttributes", "./GeometryInstance", "./GeometryPipeline", "./IndexDatatype", "./Math", "./Matrix2", "./Matrix3", "./PolygonPipeline", "./PrimitiveType", "./Quaternion", "./Rectangle", "./RectangleGeometryLibrary", "./VertexFormat"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S, T) {
        "use strict";
        function b(e, t) {
            var i = new l({attributes: new h, primitiveType: y.TRIANGLES});
            return i.attributes.position = new c({
                componentDatatype: r.DOUBLE,
                componentsPerAttribute: 3,
                values: t.positions
            }), e.normal && (i.attributes.normal = new c({
                componentDatatype: r.FLOAT,
                componentsPerAttribute: 3,
                values: t.normals
            })), e.tangent && (i.attributes.tangent = new c({
                componentDatatype: r.FLOAT,
                componentsPerAttribute: 3,
                values: t.tangents
            })), e.binormal && (i.attributes.binormal = new c({
                componentDatatype: r.FLOAT,
                componentsPerAttribute: 3,
                values: t.binormals
            })), i
        }

        function w(e, t, n, r) {
            for (var o = e.length, a = t.normal ? new Float32Array(o) : void 0, s = t.tangent ? new Float32Array(o) : void 0, u = t.binormal ? new Float32Array(o) : void 0, l = 0, c = N, h = R, d = O, m = 0; o > m; m += 3) {
                var p = i.fromArray(e, m, M), f = l + 1, _ = l + 2;
                (t.normal || t.tangent || t.binormal) && (d = n.geodeticSurfaceNormal(p, d), (t.tangent || t.binormal) && (i.cross(i.UNIT_Z, d, h), v.multiplyByVector(r, h, h), i.normalize(h, h), t.binormal && i.normalize(i.cross(d, h, c), c)), t.normal && (a[l] = d.x, a[f] = d.y, a[_] = d.z), t.tangent && (s[l] = h.x, s[f] = h.y, s[_] = h.z), t.binormal && (u[l] = c.x, u[f] = c.y, u[_] = c.z)), l += 3
            }
            return b(t, {positions: e, normals: a, tangents: s, binormals: u})
        }

        function x(e, t, n) {
            for (var r = e.length, o = t.normal ? new Float32Array(r) : void 0, a = t.tangent ? new Float32Array(r) : void 0, s = t.binormal ? new Float32Array(r) : void 0, u = 0, l = 0, c = 0, h = !0, d = N, m = R, p = O, _ = 0; r > _; _ += 6) {
                var v = i.fromArray(e, _, M);
                if (t.normal || t.tangent || t.binormal) {
                    var g = i.fromArray(e, (_ + 6) % r, V);
                    if (h) {
                        var y = i.fromArray(e, (_ + 3) % r, U);
                        i.subtract(g, v, g), i.subtract(y, v, y), p = i.normalize(i.cross(y, g, p), p), h = !1
                    }
                    i.equalsEpsilon(g, v, f.EPSILON10) && (h = !0), (t.tangent || t.binormal) && (d = n.geodeticSurfaceNormal(v, d), t.tangent && (m = i.normalize(i.cross(d, p, m), m))), t.normal && (o[u++] = p.x, o[u++] = p.y, o[u++] = p.z, o[u++] = p.x, o[u++] = p.y, o[u++] = p.z), t.tangent && (a[l++] = m.x, a[l++] = m.y, a[l++] = m.z, a[l++] = m.x, a[l++] = m.y, a[l++] = m.z), t.binormal && (s[c++] = d.x, s[c++] = d.y, s[c++] = d.z, s[c++] = d.x, s[c++] = d.y, s[c++] = d.z)
                }
            }
            return b(t, {positions: e, normals: o, tangents: a, binormals: s})
        }

        function A(e) {
            for (var t = e.vertexFormat, i = e.ellipsoid, n = e.size, o = e.height, a = e.width, s = t.position ? new Float64Array(3 * n) : void 0, u = t.st ? new Float32Array(2 * n) : void 0, l = 0, h = 0, d = M, m = F, f = Number.MAX_VALUE, _ = Number.MAX_VALUE, v = Number.MIN_VALUE, g = Number.MIN_VALUE, y = 0; o > y; ++y)for (var C = 0; a > C; ++C)S.computePosition(e, y, C, d, m), s[l++] = d.x, s[l++] = d.y, s[l++] = d.z, t.st && (u[h++] = m.x, u[h++] = m.y, f = Math.min(f, m.x), _ = Math.min(_, m.y), v = Math.max(v, m.x), g = Math.max(g, m.y));
            if (t.st && (0 > f || 0 > _ || v > 1 || g > 1))for (var E = 0; E < u.length; E += 2)u[E] = (u[E] - f) / (v - f), u[E + 1] = (u[E + 1] - _) / (g - _);
            for (var T = w(s, t, i, e.tangentRotationMatrix), b = 6 * (a - 1) * (o - 1), x = p.createTypedArray(n, b), A = 0, P = 0, I = 0; o - 1 > I; ++I) {
                for (var D = 0; a - 1 > D; ++D) {
                    var O = A, R = O + a, N = R + 1, L = O + 1;
                    x[P++] = O, x[P++] = R, x[P++] = L, x[P++] = L, x[P++] = R, x[P++] = N, ++A
                }
                ++A
            }
            return T.indices = x, t.st && (T.attributes.st = new c({
                componentDatatype: r.FLOAT,
                componentsPerAttribute: 2,
                values: u
            })), T
        }

        function P(e, t, i, n, r) {
            return e[t++] = n[i], e[t++] = n[i + 1], e[t++] = n[i + 2], e[t++] = r[i], e[t++] = r[i + 1], e[t++] = r[i + 2], e
        }

        function I(e, t, i, n) {
            return e[t++] = n[i], e[t++] = n[i + 1], e[t++] = n[i], e[t++] = n[i + 1], e
        }

        function D(e) {
            var t, n = e.vertexFormat, o = e.surfaceHeight, a = e.extrudedHeight, s = Math.min(a, o), u = Math.max(a, o), l = e.height, h = e.width, _ = e.ellipsoid, v = A(e);
            if (f.equalsEpsilon(s, u, f.EPSILON10))return v;
            v = g.scaleToGeodeticHeight(v, u, _, !1);
            var y = new Float64Array(v.attributes.position.values), C = y.length, E = 2 * C, S = new Float64Array(E);
            S.set(y), v = g.scaleToGeodeticHeight(v, s, _);
            var T = v.attributes.position.values;
            S.set(T, C), v.attributes.position.values = S;
            var b, w = n.normal ? new Float32Array(E) : void 0, D = n.tangent ? new Float32Array(E) : void 0, M = n.binormal ? new Float32Array(E) : void 0, O = n.st ? new Float32Array(E / 3 * 2) : void 0;
            if (n.normal) {
                var R = v.attributes.normal.values;
                for (w.set(R), t = 0; C > t; t++)R[t] = -R[t];
                w.set(R, C), v.attributes.normal.values = w
            }
            if (n.tangent) {
                var N = v.attributes.tangent.values;
                for (D.set(N), t = 0; C > t; t++)N[t] = -N[t];
                D.set(N, C), v.attributes.tangent.values = D
            }
            if (n.binormal) {
                var L = v.attributes.binormal.values;
                M.set(L), M.set(L, C), v.attributes.binormal.values = M
            }
            n.st && (b = v.attributes.st.values, O.set(b), O.set(b, C / 3 * 2), v.attributes.st.values = O);
            var F = v.indices, B = F.length, z = C / 3, k = p.createTypedArray(E / 3, 2 * B);
            for (k.set(F), t = 0; B > t; t += 3)k[t + B] = F[t + 2] + z, k[t + 1 + B] = F[t + 1] + z, k[t + 2 + B] = F[t] + z;
            v.indices = k;
            var G = 2 * h + 2 * l - 4, H = 2 * (G + 4), W = new Float64Array(3 * H), q = n.st ? new Float32Array(2 * H) : void 0, j = 0, Y = 0, X = h * l;
            for (t = 0; X > t; t += h)W = P(W, j, 3 * t, y, T), j += 6, n.st && (q = I(q, Y, 2 * t, b), Y += 4);
            for (t = X - h; X > t; t++)W = P(W, j, 3 * t, y, T), j += 6, n.st && (q = I(q, Y, 2 * t, b), Y += 4);
            for (t = X - 1; t > 0; t -= h)W = P(W, j, 3 * t, y, T), j += 6, n.st && (q = I(q, Y, 2 * t, b), Y += 4);
            for (t = h - 1; t >= 0; t--)W = P(W, j, 3 * t, y, T), j += 6, n.st && (q = I(q, Y, 2 * t, b), Y += 4);
            var Z = x(W, n, _);
            n.st && (Z.attributes.st = new c({componentDatatype: r.FLOAT, componentsPerAttribute: 2, values: q}));
            var K, J, Q, $, ee = p.createTypedArray(H, 6 * G);
            C = W.length / 3;
            var te = 0;
            for (t = 0; C - 1 > t; t += 2) {
                K = t, $ = (K + 2) % C;
                var ie = i.fromArray(W, 3 * K, V), ne = i.fromArray(W, 3 * $, U);
                i.equalsEpsilon(ie, ne, f.EPSILON10) || (J = (K + 1) % C, Q = (J + 2) % C, ee[te++] = K, ee[te++] = J, ee[te++] = $, ee[te++] = $, ee[te++] = J, ee[te++] = Q)
            }
            return Z.indices = ee, Z = m.combineInstances([new d({geometry: v}), new d({geometry: Z})]), Z[0]
        }

        var M = new i, O = new i, R = new i, N = new i, L = new E, F = new t, B = new e, z = new e, V = new i, U = new i, k = function (e) {
            e = o(e, o.EMPTY_OBJECT);
            var t = e.rectangle, i = o(e.granularity, f.RADIANS_PER_DEGREE), n = o(e.ellipsoid, u.WGS84), r = o(e.height, 0), s = o(e.rotation, 0), l = o(e.stRotation, 0), c = o(e.vertexFormat, T.DEFAULT), h = e.extrudedHeight, d = a(h), m = o(e.closeTop, !0), p = o(e.closeBottom, !0);
            this._rectangle = t, this._granularity = i, this._ellipsoid = u.clone(n), this._surfaceHeight = r, this._rotation = s, this._stRotation = l, this._vertexFormat = T.clone(c), this._extrudedHeight = o(h, 0), this._extrude = d, this._closeTop = m, this._closeBottom = p, this._workerName = "createRectangleGeometry"
        };
        k.packedLength = E.packedLength + u.packedLength + T.packedLength + 8, k.pack = function (e, t, i) {
            i = o(i, 0), E.pack(e._rectangle, t, i), i += E.packedLength, u.pack(e._ellipsoid, t, i), i += u.packedLength, T.pack(e._vertexFormat, t, i), i += T.packedLength, t[i++] = e._granularity, t[i++] = e._surfaceHeight, t[i++] = e._rotation, t[i++] = e._stRotation, t[i++] = e._extrudedHeight, t[i++] = e._extrude ? 1 : 0, t[i++] = e._closeTop ? 1 : 0, t[i] = e._closeBottom ? 1 : 0
        };
        var G = new E, H = u.clone(u.UNIT_SPHERE), W = new T, q = {
            rectangle: G,
            ellipsoid: H,
            vertexFormat: W,
            granularity: void 0,
            height: void 0,
            rotation: void 0,
            stRotation: void 0,
            extrudedHeight: void 0,
            closeTop: void 0,
            closeBottom: void 0
        };
        k.unpack = function (e, t, i) {
            t = o(t, 0);
            var n = E.unpack(e, t, G);
            t += E.packedLength;
            var r = u.unpack(e, t, H);
            t += u.packedLength;
            var s = T.unpack(e, t, W);
            t += T.packedLength;
            var l = e[t++], c = e[t++], h = e[t++], d = e[t++], m = e[t++], p = 1 === e[t++], f = 1 === e[t++], _ = 1 === e[t];
            return a(i) ? (i._rectangle = E.clone(n, i._rectangle), i._ellipsoid = u.clone(r, i._ellipsoid), i._vertexFormat = T.clone(s, i._vertexFormat), i._granularity = l, i._surfaceHeight = c, i._rotation = h, i._stRotation = d, i._extrudedHeight = p ? m : void 0, i._extrude = p, i._closeTop = f, i._closeBottom = _, i) : (q.granularity = l, q.height = c, q.rotation = h, q.stRotation = d, q.extrudedHeight = p ? m : void 0, q.closeTop = f, q.closeBottom = _, new k(q))
        };
        var j = new _, Y = new v, X = new n, Z = new C, K = new n;
        return k.createGeometry = function (t) {
            var n = E.clone(t._rectangle, L), r = t._ellipsoid, o = t._surfaceHeight, s = t._extrude, u = t._extrudedHeight, c = t._stRotation, d = t._vertexFormat, m = S.computeOptions(t, n, X), p = j, f = Y;
            if (a(c)) {
                _.fromRotation(-c, p);
                var y = E.center(n, K), T = r.cartographicToCartesian(y, V);
                i.normalize(T, T), C.fromAxisAngle(T, -c, Z), v.fromQuaternion(Z, f)
            } else _.clone(_.IDENTITY, p), v.clone(v.IDENTITY, f);
            m.lonScalar = 1 / n.width, m.latScalar = 1 / n.height, m.vertexFormat = d, m.textureMatrix = p, m.tangentRotationMatrix = f, m.size = m.width * m.height;
            var b, w;
            if (n = t._rectangle, s) {
                b = D(m);
                var x = e.fromRectangle3D(n, r, o, z), P = e.fromRectangle3D(n, r, u, B);
                w = e.union(x, P)
            } else b = A(m), b = g.scaleToGeodeticHeight(b, o, r, !1), w = e.fromRectangle3D(n, r, o);
            return d.position || delete b.attributes.position, new l({
                attributes: new h(b.attributes),
                indices: b.indices,
                primitiveType: b.primitiveType,
                boundingSphere: w
            })
        }, k.createShadowVolume = function (e, t, i) {
            var n = e._granularity, r = e._ellipsoid, o = t(n, r), a = i(n, r);
            return new k({
                rectangle: e._rectangle,
                rotation: e._rotation,
                ellipsoid: r,
                stRotation: e._stRotation,
                granularity: n,
                extrudedHeight: a,
                height: o,
                closeTop: !0,
                closeBottom: !0,
                vertexFormat: T.POSITION_ONLY
            })
        }, k
    }),define("Cesium/DataSources/RectangleGeometryUpdater", ["../Core/Color", "../Core/ColorGeometryInstanceAttribute", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Event", "../Core/GeometryInstance", "../Core/Iso8601", "../Core/RectangleGeometry", "../Core/RectangleOutlineGeometry", "../Core/ShowGeometryInstanceAttribute", "../Scene/MaterialAppearance", "../Scene/PerInstanceColorAppearance", "../Scene/Primitive", "./ColorMaterialProperty", "./ConstantProperty", "./dynamicGeometryGetBoundingSphere", "./MaterialProperty", "./Property"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C) {
        "use strict";
        var E = new _(e.WHITE), S = new v(!0), T = new v(!0), b = new v(!1), w = new v(e.BLACK), x = new e, A = function (e) {
            this.id = e, this.vertexFormat = void 0, this.rectangle = void 0, this.closeBottom = void 0, this.closeTop = void 0, this.height = void 0, this.extrudedHeight = void 0, this.granularity = void 0, this.stRotation = void 0, this.rotation = void 0
        }, P = function (e, t) {
            this._entity = e, this._scene = t, this._entitySubscription = e.definitionChanged.addEventListener(P.prototype._onEntityPropertyChanged, this), this._fillEnabled = !1, this._isClosed = !1, this._dynamic = !1, this._outlineEnabled = !1, this._geometryChanged = new s, this._showProperty = void 0, this._materialProperty = void 0, this._hasConstantOutline = !0, this._showOutlineProperty = void 0, this._outlineColorProperty = void 0, this._outlineWidth = 1, this._options = new A(e), this._onEntityPropertyChanged(e, "rectangle", e.rectangle, void 0)
        };
        r(P, {
            perInstanceColorAppearanceType: {value: p},
            materialAppearanceType: {value: m}
        }), r(P.prototype, {
            entity: {
                get: function () {
                    return this._entity
                }
            }, fillEnabled: {
                get: function () {
                    return this._fillEnabled
                }
            }, hasConstantFill: {
                get: function () {
                    return !this._fillEnabled || !n(this._entity.availability) && C.isConstant(this._showProperty) && C.isConstant(this._fillProperty)
                }
            }, fillMaterialProperty: {
                get: function () {
                    return this._materialProperty
                }
            }, outlineEnabled: {
                get: function () {
                    return this._outlineEnabled
                }
            }, hasConstantOutline: {
                get: function () {
                    return !this._outlineEnabled || !n(this._entity.availability) && C.isConstant(this._showProperty) && C.isConstant(this._showOutlineProperty)
                }
            }, outlineColorProperty: {
                get: function () {
                    return this._outlineColorProperty
                }
            }, outlineWidth: {
                get: function () {
                    return this._outlineWidth
                }
            }, isDynamic: {
                get: function () {
                    return this._dynamic
                }
            }, isClosed: {
                get: function () {
                    return this._isClosed
                }
            }, geometryChanged: {
                get: function () {
                    return this._geometryChanged
                }
            }
        }), P.prototype.isOutlineVisible = function (e) {
            var t = this._entity;
            return this._outlineEnabled && t.isAvailable(e) && this._showProperty.getValue(e) && this._showOutlineProperty.getValue(e)
        }, P.prototype.isFilled = function (e) {
            var t = this._entity;
            return this._fillEnabled && t.isAvailable(e) && this._showProperty.getValue(e) && this._fillProperty.getValue(e)
        }, P.prototype.createFillGeometryInstance = function (i) {
            var r, o, a = this._entity, s = a.isAvailable(i), l = new d(s && a.isShowing && this._showProperty.getValue(i) && this._fillProperty.getValue(i));
            if (this._materialProperty instanceof _) {
                var h = e.WHITE;
                n(this._materialProperty.color) && (this._materialProperty.color.isConstant || s) && (h = this._materialProperty.color.getValue(i)), o = t.fromColor(h), r = {
                    show: l,
                    color: o
                }
            } else r = {show: l};
            return new u({id: a, geometry: new c(this._options), attributes: r})
        }, P.prototype.createOutlineGeometryInstance = function (i) {
            var n = this._entity, r = n.isAvailable(i), o = C.getValueOrDefault(this._outlineColorProperty, i, e.BLACK);
            return new u({
                id: n,
                geometry: new h(this._options),
                attributes: {
                    show: new d(r && n.isShowing && this._showProperty.getValue(i) && this._showOutlineProperty.getValue(i)),
                    color: t.fromColor(o)
                }
            })
        }, P.prototype.isDestroyed = function () {
            return !1
        }, P.prototype.destroy = function () {
            this._entitySubscription(), o(this)
        }, P.prototype._onEntityPropertyChanged = function (e, t, r, o) {
            if ("availability" === t || "rectangle" === t) {
                var a = this._entity.rectangle;
                if (!n(a))return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var s = a.fill, u = n(s) && s.isConstant ? s.getValue(l.MINIMUM_VALUE) : !0, c = a.outline, h = n(c);
                if (h && c.isConstant && (h = c.getValue(l.MINIMUM_VALUE)), !u && !h)return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var d = a.coordinates, f = a.show;
                if (n(f) && f.isConstant && !f.getValue(l.MINIMUM_VALUE) || !n(d))return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var v = i(a.material, E), g = v instanceof _;
                this._materialProperty = v, this._fillProperty = i(s, T), this._showProperty = i(f, S), this._showOutlineProperty = i(a.outline, b), this._outlineColorProperty = h ? i(a.outlineColor, w) : void 0;
                var y = a.height, x = a.extrudedHeight, A = a.granularity, P = a.stRotation, I = a.rotation, D = a.outlineWidth, M = a.closeBottom, O = a.closeTop;
                if (this._fillEnabled = u, this._outlineEnabled = h, d.isConstant && C.isConstant(y) && C.isConstant(x) && C.isConstant(A) && C.isConstant(P) && C.isConstant(I) && C.isConstant(D) && C.isConstant(M) && C.isConstant(O)) {
                    var R = this._options;
                    R.vertexFormat = g ? p.VERTEX_FORMAT : m.MaterialSupport.TEXTURED.vertexFormat, R.rectangle = d.getValue(l.MINIMUM_VALUE, R.rectangle), R.height = n(y) ? y.getValue(l.MINIMUM_VALUE) : void 0, R.extrudedHeight = n(x) ? x.getValue(l.MINIMUM_VALUE) : void 0, R.granularity = n(A) ? A.getValue(l.MINIMUM_VALUE) : void 0, R.stRotation = n(P) ? P.getValue(l.MINIMUM_VALUE) : void 0, R.rotation = n(I) ? I.getValue(l.MINIMUM_VALUE) : void 0, R.closeBottom = n(M) ? M.getValue(l.MINIMUM_VALUE) : void 0, R.closeTop = n(O) ? O.getValue(l.MINIMUM_VALUE) : void 0, this._isClosed = n(x) && n(R.closeTop) && n(R.closeBottom) && R.closeTop && R.closeBottom, this._outlineWidth = n(D) ? D.getValue(l.MINIMUM_VALUE) : 1, this._dynamic = !1, this._geometryChanged.raiseEvent(this)
                } else this._dynamic || (this._dynamic = !0, this._geometryChanged.raiseEvent(this))
            }
        }, P.prototype.createDynamicUpdater = function (e) {
            return new I(e, this)
        };
        var I = function (e, t) {
            this._primitives = e, this._primitive = void 0, this._outlinePrimitive = void 0, this._geometryUpdater = t, this._options = new A(t._entity)
        };
        return I.prototype.update = function (i) {
            var r = this._primitives;
            r.removeAndDestroy(this._primitive), r.removeAndDestroy(this._outlinePrimitive), this._primitive = void 0, this._outlinePrimitive = void 0;
            var o = this._geometryUpdater, a = o._entity, s = a.rectangle;
            if (a.isShowing && a.isAvailable(i) && C.getValueOrDefault(s.show, i, !0)) {
                var l = this._options, d = C.getValueOrUndefined(s.coordinates, i, l.rectangle);
                if (n(d)) {
                    if (l.rectangle = d, l.height = C.getValueOrUndefined(s.height, i), l.extrudedHeight = C.getValueOrUndefined(s.extrudedHeight, i), l.granularity = C.getValueOrUndefined(s.granularity, i), l.stRotation = C.getValueOrUndefined(s.stRotation, i), l.rotation = C.getValueOrUndefined(s.rotation, i), l.closeBottom = C.getValueOrUndefined(s.closeBottom, i), l.closeTop = C.getValueOrUndefined(s.closeTop, i), C.getValueOrDefault(s.fill, i, !0)) {
                        var _ = y.getValue(i, o.fillMaterialProperty, this._material);
                        this._material = _;
                        var v = new m({material: _, translucent: _.isTranslucent(), closed: n(l.extrudedHeight)});
                        l.vertexFormat = v.vertexFormat, this._primitive = r.add(new f({
                            geometryInstances: new u({
                                id: a,
                                geometry: new c(l)
                            }), appearance: v, asynchronous: !1
                        }))
                    }
                    if (C.getValueOrDefault(s.outline, i, !1)) {
                        l.vertexFormat = p.VERTEX_FORMAT;
                        var g = C.getValueOrClonedDefault(s.outlineColor, i, e.BLACK, x), E = C.getValueOrDefault(s.outlineWidth, i, 1), S = 1 !== g.alpha;
                        this._outlinePrimitive = r.add(new f({
                            geometryInstances: new u({
                                id: a,
                                geometry: new h(l),
                                attributes: {color: t.fromColor(g)}
                            }),
                            appearance: new p({
                                flat: !0,
                                translucent: S,
                                renderState: {lineWidth: o._scene.clampLineWidth(E)}
                            }),
                            asynchronous: !1
                        }))
                    }
                }
            }
        }, I.prototype.getBoundingSphere = function (e, t) {
            return g(e, this._primitive, this._outlinePrimitive, t)
        }, I.prototype.isDestroyed = function () {
            return !1
        }, I.prototype.destroy = function () {
            var e = this._primitives;
            e.removeAndDestroy(this._primitive), e.removeAndDestroy(this._outlinePrimitive), o(this)
        }, P
    }),define("Cesium/Core/WallGeometryLibrary", ["./Cartographic", "./defined", "./DeveloperError", "./EllipsoidTangentPlane", "./Math", "./PolygonPipeline", "./PolylinePipeline", "./WindingOrder"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        function u(e, t) {
            return r.equalsEpsilon(e.latitude, t.latitude, r.EPSILON14) && r.equalsEpsilon(e.longitude, t.longitude, r.EPSILON14)
        }

        function l(i, n, r, o) {
            var a = n.length;
            if (2 > a)return {positions: n};
            var s = t(o), l = t(r), c = new Array(a), m = new Array(a), p = new Array(a), f = n[0];
            c[0] = f;
            var _ = i.cartesianToCartographic(f, h);
            l && (_.height = r[0]), m[0] = _.height, s ? p[0] = o[0] : p[0] = 0;
            for (var v = 1, g = 1; a > g; ++g) {
                var y = n[g], C = i.cartesianToCartographic(y, d);
                l && (C.height = r[g]), u(_, C) ? _.height < C.height && (m[v - 1] = C.height) : (c[v] = y, m[v] = C.height, s ? p[v] = o[g] : p[v] = 0, e.clone(C, _), ++v)
            }
            return c.length = v, m.length = v, p.length = v, {positions: c, topHeights: m, bottomHeights: p}
        }

        var c = {}, h = new e, d = new e, m = new Array(2), p = new Array(2), f = {
            positions: void 0,
            height: void 0,
            granularity: void 0,
            ellipsoid: void 0
        };
        return c.computePositions = function (e, t, i, u, c, h) {
            var d = l(e, t, i, u);
            if (t = d.positions, i = d.topHeights, u = d.bottomHeights, t.length < 2)return void 0;
            if (t.length >= 3) {
                var _ = n.fromPoints(t, e), v = _.projectPointsOntoPlane(t);
                o.computeWindingOrder2D(v) === s.CLOCKWISE && (t.reverse(), i.reverse(), u.reverse())
            }
            var g, y, C = t.length, E = r.chordLength(c, e.maximumRadius), S = f;
            if (S.minDistance = E, S.ellipsoid = e, h) {
                var T, b = 0;
                for (T = 0; C - 1 > T; T++)b += a.numberOfPoints(t[T], t[T + 1], E) + 1;
                g = new Float64Array(3 * b), y = new Float64Array(3 * b);
                var w = m, x = p;
                S.positions = w, S.height = x;
                var A = 0;
                for (T = 0; C - 1 > T; T++) {
                    w[0] = t[T], w[1] = t[T + 1], x[0] = i[T], x[1] = i[T + 1];
                    var P = a.generateArc(S);
                    g.set(P, A), x[0] = u[T], x[1] = u[T + 1], y.set(a.generateArc(S), A), A += P.length
                }
            } else S.positions = t, S.height = i, g = new Float64Array(a.generateArc(S)), S.height = u, y = new Float64Array(a.generateArc(S));
            return {bottomPositions: y, topPositions: g}
        }, c
    }),define("Cesium/Core/WallGeometry", ["./BoundingSphere", "./Cartesian3", "./ComponentDatatype", "./defaultValue", "./defined", "./DeveloperError", "./Ellipsoid", "./Geometry", "./GeometryAttribute", "./GeometryAttributes", "./IndexDatatype", "./Math", "./PrimitiveType", "./VertexFormat", "./WallGeometryLibrary"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p) {
        "use strict";
        var f = new t, _ = new t, v = new t, g = new t, y = new t, C = new t, E = new t, S = new t, T = function (e) {
            e = n(e, n.EMPTY_OBJECT);
            var i = e.positions, o = e.maximumHeights, s = e.minimumHeights, u = n(e.vertexFormat, m.DEFAULT), l = n(e.granularity, h.RADIANS_PER_DEGREE), c = n(e.ellipsoid, a.WGS84);
            this._positions = i, this._minimumHeights = s, this._maximumHeights = o, this._vertexFormat = m.clone(u), this._granularity = l, this._ellipsoid = a.clone(c), this._workerName = "createWallGeometry";
            var d = 1 + i.length * t.packedLength + 2;
            r(s) && (d += s.length), r(o) && (d += o.length), this.packedLength = d + a.packedLength + m.packedLength + 1
        };
        T.pack = function (e, i, o) {
            o = n(o, 0);
            var s, u = e._positions, l = u.length;
            for (i[o++] = l, s = 0; l > s; ++s, o += t.packedLength)t.pack(u[s], i, o);
            var c = e._minimumHeights;
            if (l = r(c) ? c.length : 0, i[o++] = l, r(c))for (s = 0; l > s; ++s)i[o++] = c[s];
            var h = e._maximumHeights;
            if (l = r(h) ? h.length : 0, i[o++] = l, r(h))for (s = 0; l > s; ++s)i[o++] = h[s];
            a.pack(e._ellipsoid, i, o), o += a.packedLength, m.pack(e._vertexFormat, i, o), o += m.packedLength, i[o] = e._granularity
        };
        var b = a.clone(a.UNIT_SPHERE), w = new m, x = {
            positions: void 0,
            minimumHeights: void 0,
            maximumHeights: void 0,
            ellipsoid: b,
            vertexFormat: w,
            granularity: void 0
        };
        return T.unpack = function (e, i, o) {
            i = n(i, 0);
            var s, u = e[i++], l = new Array(u);
            for (s = 0; u > s; ++s, i += t.packedLength)l[s] = t.unpack(e, i);
            u = e[i++];
            var c;
            if (u > 0)for (c = new Array(u), s = 0; u > s; ++s)c[s] = e[i++];
            u = e[i++];
            var h;
            if (u > 0)for (h = new Array(u), s = 0; u > s; ++s)h[s] = e[i++];
            var d = a.unpack(e, i, b);
            i += a.packedLength;
            var p = m.unpack(e, i, w);
            i += m.packedLength;
            var f = e[i];
            return r(o) ? (o._positions = l, o._minimumHeights = c, o._maximumHeights = h, o._ellipsoid = a.clone(d, o._ellipsoid), o._vertexFormat = m.clone(p, o._vertexFormat), o._granularity = f, o) : (x.positions = l, x.minimumHeights = c, x.maximumHeights = h, x.granularity = f, new T(x))
        }, T.fromConstantHeights = function (e) {
            e = n(e, n.EMPTY_OBJECT);
            var t, i, o = e.positions, a = e.minimumHeight, s = e.maximumHeight, u = r(a), l = r(s);
            if (u || l) {
                var c = o.length;
                t = u ? new Array(c) : void 0, i = l ? new Array(c) : void 0;
                for (var h = 0; c > h; ++h)u && (t[h] = a), l && (i[h] = s)
            }
            var d = {
                positions: o,
                maximumHeights: i,
                minimumHeights: t,
                ellipsoid: e.ellipsoid,
                vertexFormat: e.vertexFormat
            };
            return new T(d)
        }, T.createGeometry = function (n) {
            var o = n._positions, a = n._minimumHeights, m = n._maximumHeights, T = n._vertexFormat, b = n._granularity, w = n._ellipsoid, x = p.computePositions(w, o, m, a, b, !0);
            if (!r(x))return void 0;
            var A = x.bottomPositions, P = x.topPositions, I = P.length, D = 2 * I, M = T.position ? new Float64Array(D) : void 0, O = T.normal ? new Float32Array(D) : void 0, R = T.tangent ? new Float32Array(D) : void 0, N = T.binormal ? new Float32Array(D) : void 0, L = T.st ? new Float32Array(D / 3 * 2) : void 0, F = 0, B = 0, z = 0, V = 0, U = 0, k = S, G = E, H = C, W = !0;
            I /= 3;
            var q, j = 0, Y = 1 / (I - o.length + 1);
            for (q = 0; I > q; ++q) {
                var X = 3 * q, Z = t.fromArray(P, X, f), K = t.fromArray(A, X, _);
                if (T.position && (M[F++] = K.x, M[F++] = K.y, M[F++] = K.z, M[F++] = Z.x, M[F++] = Z.y, M[F++] = Z.z), T.st && (L[U++] = j, L[U++] = 0, L[U++] = j, L[U++] = 1), T.normal || T.tangent || T.binormal) {
                    var J, Q = t.clone(t.ZERO, y), $ = w.scaleToGeodeticSurface(t.fromArray(P, X, _), _);
                    if (I > q + 1 && (J = w.scaleToGeodeticSurface(t.fromArray(P, X + 3, v), v), Q = t.fromArray(P, X + 3, y)), W) {
                        var ee = t.subtract(Q, Z, g), te = t.subtract($, Z, f);
                        k = t.normalize(t.cross(te, ee, k), k), W = !1
                    }
                    t.equalsEpsilon(J, $, h.EPSILON10) ? W = !0 : (j += Y, T.tangent && (G = t.normalize(t.subtract(J, $, G), G)), T.binormal && (H = t.normalize(t.cross(k, G, H), H))), T.normal && (O[B++] = k.x, O[B++] = k.y, O[B++] = k.z, O[B++] = k.x, O[B++] = k.y, O[B++] = k.z), T.tangent && (R[V++] = G.x, R[V++] = G.y, R[V++] = G.z, R[V++] = G.x, R[V++] = G.y, R[V++] = G.z), T.binormal && (N[z++] = H.x, N[z++] = H.y, N[z++] = H.z, N[z++] = H.x, N[z++] = H.y, N[z++] = H.z)
                }
            }
            var ie = new l;
            T.position && (ie.position = new u({
                componentDatatype: i.DOUBLE,
                componentsPerAttribute: 3,
                values: M
            })), T.normal && (ie.normal = new u({
                componentDatatype: i.FLOAT,
                componentsPerAttribute: 3,
                values: O
            })), T.tangent && (ie.tangent = new u({
                componentDatatype: i.FLOAT,
                componentsPerAttribute: 3,
                values: R
            })), T.binormal && (ie.binormal = new u({
                componentDatatype: i.FLOAT,
                componentsPerAttribute: 3,
                values: N
            })), T.st && (ie.st = new u({componentDatatype: i.FLOAT, componentsPerAttribute: 2, values: L}));
            var ne = D / 3;
            D -= 6;
            var re = c.createTypedArray(ne, D), oe = 0;
            for (q = 0; ne - 2 > q; q += 2) {
                var ae = q, se = q + 2, ue = t.fromArray(M, 3 * ae, f), le = t.fromArray(M, 3 * se, _);
                if (!t.equalsEpsilon(ue, le, h.EPSILON10)) {
                    var ce = q + 1, he = q + 3;
                    re[oe++] = ce, re[oe++] = ae, re[oe++] = he, re[oe++] = he, re[oe++] = ae, re[oe++] = se
                }
            }
            return new s({
                attributes: ie,
                indices: re,
                primitiveType: d.TRIANGLES,
                boundingSphere: new e.fromVertices(M)
            })
        }, T
    }),define("Cesium/Core/WallOutlineGeometry", ["./BoundingSphere", "./Cartesian3", "./ComponentDatatype", "./defaultValue", "./defined", "./DeveloperError", "./Ellipsoid", "./Geometry", "./GeometryAttribute", "./GeometryAttributes", "./IndexDatatype", "./Math", "./PrimitiveType", "./WallGeometryLibrary"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m) {
        "use strict";
        var p = new t, f = new t, _ = function (e) {
            e = n(e, n.EMPTY_OBJECT);
            var i = e.positions, o = e.maximumHeights, s = e.minimumHeights, u = n(e.granularity, h.RADIANS_PER_DEGREE), l = n(e.ellipsoid, a.WGS84);
            this._positions = i, this._minimumHeights = s, this._maximumHeights = o, this._granularity = u, this._ellipsoid = a.clone(l), this._workerName = "createWallOutlineGeometry";
            var c = 1 + i.length * t.packedLength + 2;
            r(s) && (c += s.length), r(o) && (c += o.length), this.packedLength = c + a.packedLength + 1
        };
        _.pack = function (e, i, o) {
            o = n(o, 0);
            var s, u = e._positions, l = u.length;
            for (i[o++] = l, s = 0; l > s; ++s, o += t.packedLength)t.pack(u[s], i, o);
            var c = e._minimumHeights;
            if (l = r(c) ? c.length : 0, i[o++] = l, r(c))for (s = 0; l > s; ++s)i[o++] = c[s];
            var h = e._maximumHeights;
            if (l = r(h) ? h.length : 0, i[o++] = l, r(h))for (s = 0; l > s; ++s)i[o++] = h[s];
            a.pack(e._ellipsoid, i, o), o += a.packedLength, i[o] = e._granularity
        };
        var v = a.clone(a.UNIT_SPHERE), g = {
            positions: void 0,
            minimumHeights: void 0,
            maximumHeights: void 0,
            ellipsoid: v,
            granularity: void 0
        };
        return _.unpack = function (e, i, o) {
            i = n(i, 0);
            var s, u = e[i++], l = new Array(u);
            for (s = 0; u > s; ++s, i += t.packedLength)l[s] = t.unpack(e, i);
            u = e[i++];
            var c;
            if (u > 0)for (c = new Array(u), s = 0; u > s; ++s)c[s] = e[i++];
            u = e[i++];
            var h;
            if (u > 0)for (h = new Array(u), s = 0; u > s; ++s)h[s] = e[i++];
            var d = a.unpack(e, i, v);
            i += a.packedLength;
            var m = e[i];
            return r(o) ? (o._positions = l, o._minimumHeights = c, o._maximumHeights = h, o._ellipsoid = a.clone(d, o._ellipsoid), o._granularity = m, o) : (g.positions = l, g.minimumHeights = c, g.maximumHeights = h, g.granularity = m, new _(g))
        }, _.fromConstantHeights = function (e) {
            e = n(e, n.EMPTY_OBJECT);
            var t, i, o = e.positions, a = e.minimumHeight, s = e.maximumHeight, u = r(a), l = r(s);
            if (u || l) {
                var c = o.length;
                t = u ? new Array(c) : void 0, i = l ? new Array(c) : void 0;
                for (var h = 0; c > h; ++h)u && (t[h] = a), l && (i[h] = s)
            }
            var d = {positions: o, maximumHeights: i, minimumHeights: t, ellipsoid: e.ellipsoid};
            return new _(d)
        }, _.createGeometry = function (n) {
            var o = n._positions, a = n._minimumHeights, _ = n._maximumHeights, v = n._granularity, g = n._ellipsoid, y = m.computePositions(g, o, _, a, v, !1);
            if (!r(y))return void 0;
            var C = y.bottomPositions, E = y.topPositions, S = E.length, T = 2 * S, b = new Float64Array(T), w = 0;
            S /= 3;
            var x;
            for (x = 0; S > x; ++x) {
                var A = 3 * x, P = t.fromArray(E, A, p), I = t.fromArray(C, A, f);
                b[w++] = I.x, b[w++] = I.y, b[w++] = I.z, b[w++] = P.x, b[w++] = P.y, b[w++] = P.z
            }
            var D = new l({
                position: new u({
                    componentDatatype: i.DOUBLE,
                    componentsPerAttribute: 3,
                    values: b
                })
            }), M = T / 3;
            T = 2 * M - 4 + M;
            var O = c.createTypedArray(M, T), R = 0;
            for (x = 0; M - 2 > x; x += 2) {
                var N = x, L = x + 2, F = t.fromArray(b, 3 * N, p), B = t.fromArray(b, 3 * L, f);
                if (!t.equalsEpsilon(F, B, h.EPSILON10)) {
                    var z = x + 1, V = x + 3;
                    O[R++] = z, O[R++] = N, O[R++] = z, O[R++] = V, O[R++] = N, O[R++] = L
                }
            }
            return O[R++] = M - 2, O[R++] = M - 1, new s({
                attributes: D,
                indices: O,
                primitiveType: d.LINES,
                boundingSphere: new e.fromVertices(b)
            })
        }, _
    }),define("Cesium/DataSources/WallGeometryUpdater", ["../Core/Color", "../Core/ColorGeometryInstanceAttribute", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Event", "../Core/GeometryInstance", "../Core/Iso8601", "../Core/ShowGeometryInstanceAttribute", "../Core/WallGeometry", "../Core/WallOutlineGeometry", "../Scene/MaterialAppearance", "../Scene/PerInstanceColorAppearance", "../Scene/Primitive", "./ColorMaterialProperty", "./ConstantProperty", "./dynamicGeometryGetBoundingSphere", "./MaterialProperty", "./Property"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C) {
        "use strict";
        var E = new _(e.WHITE), S = new v(!0), T = new v(!0), b = new v(!1), w = new v(e.BLACK), x = new e, A = function (e) {
            this.id = e, this.vertexFormat = void 0, this.positions = void 0, this.minimumHeights = void 0, this.maximumHeights = void 0, this.granularity = void 0
        }, P = function (e, t) {
            this._entity = e, this._scene = t, this._entitySubscription = e.definitionChanged.addEventListener(P.prototype._onEntityPropertyChanged, this), this._fillEnabled = !1, this._dynamic = !1, this._outlineEnabled = !1, this._geometryChanged = new s, this._showProperty = void 0, this._materialProperty = void 0, this._hasConstantOutline = !0, this._showOutlineProperty = void 0, this._outlineColorProperty = void 0, this._outlineWidth = 1, this._options = new A(e), this._onEntityPropertyChanged(e, "wall", e.wall, void 0)
        };
        r(P, {
            perInstanceColorAppearanceType: {
                value: p
            }, materialAppearanceType: {value: m}
        }), r(P.prototype, {
            entity: {
                get: function () {
                    return this._entity
                }
            }, fillEnabled: {
                get: function () {
                    return this._fillEnabled
                }
            }, hasConstantFill: {
                get: function () {
                    return !this._fillEnabled || !n(this._entity.availability) && C.isConstant(this._showProperty) && C.isConstant(this._fillProperty)
                }
            }, fillMaterialProperty: {
                get: function () {
                    return this._materialProperty
                }
            }, outlineEnabled: {
                get: function () {
                    return this._outlineEnabled
                }
            }, hasConstantOutline: {
                get: function () {
                    return !this._outlineEnabled || !n(this._entity.availability) && C.isConstant(this._showProperty) && C.isConstant(this._showOutlineProperty)
                }
            }, outlineColorProperty: {
                get: function () {
                    return this._outlineColorProperty
                }
            }, outlineWidth: {
                get: function () {
                    return this._outlineWidth
                }
            }, isDynamic: {
                get: function () {
                    return this._dynamic
                }
            }, isClosed: {
                get: function () {
                    return !1
                }
            }, geometryChanged: {
                get: function () {
                    return this._geometryChanged
                }
            }
        }), P.prototype.isOutlineVisible = function (e) {
            var t = this._entity;
            return this._outlineEnabled && t.isAvailable(e) && this._showProperty.getValue(e) && this._showOutlineProperty.getValue(e)
        }, P.prototype.isFilled = function (e) {
            var t = this._entity;
            return this._fillEnabled && t.isAvailable(e) && this._showProperty.getValue(e) && this._fillProperty.getValue(e)
        }, P.prototype.createFillGeometryInstance = function (i) {
            var r, o, a = this._entity, s = a.isAvailable(i), l = new c(s && a.isShowing && this._showProperty.getValue(i) && this._fillProperty.getValue(i));
            if (this._materialProperty instanceof _) {
                var d = e.WHITE;
                n(this._materialProperty.color) && (this._materialProperty.color.isConstant || s) && (d = this._materialProperty.color.getValue(i)), o = t.fromColor(d), r = {
                    show: l,
                    color: o
                }
            } else r = {show: l};
            return new u({id: a, geometry: new h(this._options), attributes: r})
        }, P.prototype.createOutlineGeometryInstance = function (i) {
            var n = this._entity, r = n.isAvailable(i), o = C.getValueOrDefault(this._outlineColorProperty, i, e.BLACK);
            return new u({
                id: n,
                geometry: new d(this._options),
                attributes: {
                    show: new c(r && n.isShowing && this._showProperty.getValue(i) && this._showOutlineProperty.getValue(i)),
                    color: t.fromColor(o)
                }
            })
        }, P.prototype.isDestroyed = function () {
            return !1
        }, P.prototype.destroy = function () {
            this._entitySubscription(), o(this)
        }, P.prototype._onEntityPropertyChanged = function (e, t, r, o) {
            if ("availability" === t || "wall" === t) {
                var a = this._entity.wall;
                if (!n(a))return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var s = a.fill, u = n(s) && s.isConstant ? s.getValue(l.MINIMUM_VALUE) : !0, c = a.outline, h = n(c);
                if (h && c.isConstant && (h = c.getValue(l.MINIMUM_VALUE)), !u && !h)return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var d = a.positions, f = a.show;
                if (n(f) && f.isConstant && !f.getValue(l.MINIMUM_VALUE) || !n(d))return void((this._fillEnabled || this._outlineEnabled) && (this._fillEnabled = !1, this._outlineEnabled = !1, this._geometryChanged.raiseEvent(this)));
                var v = i(a.material, E), g = v instanceof _;
                this._materialProperty = v, this._fillProperty = i(s, T), this._showProperty = i(f, S), this._showOutlineProperty = i(a.outline, b), this._outlineColorProperty = h ? i(a.outlineColor, w) : void 0;
                var y = a.minimumHeights, x = a.maximumHeights, A = a.outlineWidth, P = a.granularity;
                if (this._fillEnabled = u, this._outlineEnabled = h, d.isConstant && C.isConstant(y) && C.isConstant(x) && C.isConstant(A) && C.isConstant(P)) {
                    var I = this._options;
                    I.vertexFormat = g ? p.VERTEX_FORMAT : m.MaterialSupport.TEXTURED.vertexFormat, I.positions = d.getValue(l.MINIMUM_VALUE, I.positions), I.minimumHeights = n(y) ? y.getValue(l.MINIMUM_VALUE, I.minimumHeights) : void 0, I.maximumHeights = n(x) ? x.getValue(l.MINIMUM_VALUE, I.maximumHeights) : void 0, I.granularity = n(P) ? P.getValue(l.MINIMUM_VALUE) : void 0, this._outlineWidth = n(A) ? A.getValue(l.MINIMUM_VALUE) : 1, this._dynamic = !1, this._geometryChanged.raiseEvent(this)
                } else this._dynamic || (this._dynamic = !0, this._geometryChanged.raiseEvent(this))
            }
        }, P.prototype.createDynamicUpdater = function (e) {
            return new I(e, this)
        };
        var I = function (e, t) {
            this._primitives = e, this._primitive = void 0, this._outlinePrimitive = void 0, this._geometryUpdater = t, this._options = new A(t._entity)
        };
        return I.prototype.update = function (i) {
            var r = this._primitives;
            r.removeAndDestroy(this._primitive), r.removeAndDestroy(this._outlinePrimitive), this._primitive = void 0, this._outlinePrimitive = void 0;
            var o = this._geometryUpdater, a = o._entity, s = a.wall;
            if (a.isShowing && a.isAvailable(i) && C.getValueOrDefault(s.show, i, !0)) {
                var l = this._options, c = C.getValueOrUndefined(s.positions, i, l.positions);
                if (n(c)) {
                    if (l.positions = c, l.minimumHeights = C.getValueOrUndefined(s.minimumHeights, i, l.minimumHeights), l.maximumHeights = C.getValueOrUndefined(s.maximumHeights, i, l.maximumHeights), l.granularity = C.getValueOrUndefined(s.granularity, i), C.getValueOrDefault(s.fill, i, !0)) {
                        var _ = y.getValue(i, o.fillMaterialProperty, this._material);
                        this._material = _;
                        var v = new m({material: _, translucent: _.isTranslucent(), closed: n(l.extrudedHeight)});
                        l.vertexFormat = v.vertexFormat, this._primitive = r.add(new f({
                            geometryInstances: new u({
                                id: a,
                                geometry: new h(l)
                            }), appearance: v, asynchronous: !1
                        }))
                    }
                    if (C.getValueOrDefault(s.outline, i, !1)) {
                        l.vertexFormat = p.VERTEX_FORMAT;
                        var g = C.getValueOrClonedDefault(s.outlineColor, i, e.BLACK, x), E = C.getValueOrDefault(s.outlineWidth, i, 1), S = 1 !== g.alpha;
                        this._outlinePrimitive = r.add(new f({
                            geometryInstances: new u({
                                id: a,
                                geometry: new d(l),
                                attributes: {color: t.fromColor(g)}
                            }),
                            appearance: new p({
                                flat: !0,
                                translucent: S,
                                renderState: {lineWidth: o._scene.clampLineWidth(E)}
                            }),
                            asynchronous: !1
                        }))
                    }
                }
            }
        }, I.prototype.getBoundingSphere = function (e, t) {
            return g(e, this._primitive, this._outlinePrimitive, t)
        }, I.prototype.isDestroyed = function () {
            return !1
        }, I.prototype.destroy = function () {
            var e = this._primitives;
            e.removeAndDestroy(this._primitive), e.removeAndDestroy(this._outlinePrimitive), o(this)
        }, P
    }),define("Cesium/DataSources/DataSourceDisplay", ["../Core/BoundingSphere", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/EventHelper", "./BillboardVisualizer", "./BoundingSphereState", "./BoxGeometryUpdater", "./CorridorGeometryUpdater", "./CustomDataSource", "./CylinderGeometryUpdater", "./EllipseGeometryUpdater", "./EllipsoidGeometryUpdater", "./GeometryVisualizer", "./LabelVisualizer", "./ModelVisualizer", "./PathVisualizer", "./PointVisualizer", "./PolygonGeometryUpdater", "./PolylineGeometryUpdater", "./PolylineVolumeGeometryUpdater", "./RectangleGeometryUpdater", "./WallGeometryUpdater"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S, T, b) {
        "use strict";
        var w = function (e) {
            var i = e.scene, n = e.dataSourceCollection;
            this._eventHelper = new a, this._eventHelper.add(n.dataSourceAdded, this._onDataSourceAdded, this), this._eventHelper.add(n.dataSourceRemoved, this._onDataSourceRemoved, this), this._dataSourceCollection = n, this._scene = i, this._visualizersCallback = t(e.visualizersCallback, w.defaultVisualizersCallback);
            for (var r = 0, o = n.length; o > r; r++)this._onDataSourceAdded(n, n.get(r));
            var s = new h;
            this._onDataSourceAdded(void 0, s), this._defaultDataSource = s
        };
        w.defaultVisualizersCallback = function (e, t) {
            var i = t.entities;
            return [new s(e, i), new f(l, e, i), new f(d, e, i), new f(c, e, i), new f(m, e, i), new f(p, e, i), new f(C, e, i), new f(E, e, i), new f(S, e, i), new f(T, e, i), new f(b, e, i), new _(e, i), new v(e, i), new y(e, i), new g(e, i)]
        }, n(w.prototype, {
            scene: {
                get: function () {
                    return this._scene
                }
            }, dataSources: {
                get: function () {
                    return this._dataSourceCollection
                }
            }, defaultDataSource: {
                get: function () {
                    return this._defaultDataSource
                }
            }
        }), w.prototype.isDestroyed = function () {
            return !1
        }, w.prototype.destroy = function () {
            this._eventHelper.removeAll();
            for (var e = this._dataSourceCollection, t = 0, i = e.length; i > t; ++t)this._onDataSourceRemoved(this._dataSourceCollection, e.get(t));
            return this._onDataSourceRemoved(void 0, this._defaultDataSource), r(this)
        }, w.prototype.update = function (e) {
            var t, n, r, o, a = !0, s = this._dataSourceCollection, u = s.length;
            for (t = 0; u > t; t++) {
                var l = s.get(t);
                for (i(l.update) && (a = l.update(e) && a), r = l._visualizers, o = r.length, n = 0; o > n; n++)a = r[n].update(e) && a
            }
            for (r = this._defaultDataSource._visualizers, o = r.length, n = 0; o > n; n++)a = r[n].update(e) && a;
            return a
        };
        var x = [], A = new e;
        return w.prototype.getBoundingSphere = function (t, n, r) {
            var o, a, s = this._defaultDataSource;
            if (!s.entities.contains(t)) {
                s = void 0;
                var l = this._dataSourceCollection;
                for (a = l.length, o = 0; a > o; o++) {
                    var c = l.get(o);
                    if (c.entities.contains(t)) {
                        s = c;
                        break
                    }
                }
            }
            if (!i(s))return u.FAILED;
            var h = x, d = A, m = 0, p = u.DONE, f = s._visualizers, _ = f.length;
            for (o = 0; _ > o; o++) {
                var v = f[o];
                if (i(v.getBoundingSphere)) {
                    if (p = f[o].getBoundingSphere(t, d), !n && p === u.PENDING)return u.PENDING;
                    p === u.DONE && (h[m] = e.clone(d, h[m]), m++)
                }
            }
            return 0 === m ? u.FAILED : (h.length = m, e.fromBoundingSpheres(h, r), u.DONE)
        }, w.prototype._onDataSourceAdded = function (e, t) {
            var i = this._visualizersCallback(this._scene, t);
            t._visualizers = i
        }, w.prototype._onDataSourceRemoved = function (e, t) {
            for (var i = t._visualizers, n = i.length, r = 0; n > r; r++)i[r].destroy(), t._visualizers = void 0
        }, w
    }),define("Cesium/Scene/HeadingPitchRange", ["../Core/defaultValue", "../Core/defined"], function (e, t) {
        "use strict";
        var i = function (t, i, n) {
            this.heading = e(t, 0), this.pitch = e(i, 0), this.range = e(n, 0)
        };
        return i.clone = function (e, n) {
            return t(e) ? (t(n) || (n = new i), n.heading = e.heading, n.pitch = e.pitch, n.range = e.range, n) : void 0
        }, i
    }),define("Cesium/DataSources/EntityView", ["../Core/BoundingSphere", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Ellipsoid", "../Core/JulianDate", "../Core/Math", "../Core/Matrix3", "../Core/Matrix4", "../Core/Transforms", "../Scene/HeadingPitchRange", "../Scene/SceneMode"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p) {
        "use strict";
        function f(e, i, n, o, a, s, h) {
            var m = e.scene.mode, f = a.getValue(s, e._lastCartesian);
            if (r(f)) {
                var P, I, D, M = !1;
                if (m === p.SCENE3D) {
                    x = u.addSeconds(s, .001, x);
                    var O = a.getValue(x, C);
                    if (r(O)) {
                        var R, N = d.computeFixedToIcrfMatrix(s, _), L = d.computeFixedToIcrfMatrix(x, v);
                        r(N) && r(L) ? R = c.transpose(N, g) : (R = d.computeTemeToPseudoFixedMatrix(s, g), N = c.transpose(R, _), L = d.computeTemeToPseudoFixedMatrix(x, v), c.transpose(L, L));
                        var F = c.multiplyByVector(N, f, b), B = c.multiplyByVector(L, O, w);
                        t.subtract(F, B, T);
                        var z = 1e3 * t.magnitude(T), V = 3986004418e5, U = -V / (z * z - 2 * V / t.magnitude(F));
                        0 > U || U > A * h.maximumRadius ? (P = E, t.normalize(f, P), t.negate(P, P), D = t.clone(t.UNIT_Z, S), I = t.cross(D, P, C), t.magnitude(I) > l.EPSILON7 && (t.normalize(P, P), t.normalize(I, I), D = t.cross(P, I, S), t.normalize(D, D), M = !0)) : t.equalsEpsilon(f, O, l.EPSILON7) || (D = E, t.normalize(F, D), t.normalize(B, B), I = t.cross(D, B, S), t.equalsEpsilon(I, t.ZERO, l.EPSILON7) || (P = t.cross(I, D, C), c.multiplyByVector(R, P, P), c.multiplyByVector(R, I, I), c.multiplyByVector(R, D, D), t.normalize(P, P), t.normalize(I, I), t.normalize(D, D), M = !0))
                    }
                }
                r(e._boundingSphereOffset) && t.add(e._boundingSphereOffset, f, f);
                var k, G, H;
                o && (k = t.clone(i.position, T), G = t.clone(i.direction, b), H = t.clone(i.up, w));
                var W = y;
                M ? (W[0] = P.x, W[1] = P.y, W[2] = P.z, W[3] = 0, W[4] = I.x, W[5] = I.y, W[6] = I.z, W[7] = 0, W[8] = D.x, W[9] = D.y, W[10] = D.z, W[11] = 0, W[12] = f.x, W[13] = f.y, W[14] = f.z, W[15] = 0) : d.eastNorthUpToFixedFrame(f, h, W), i._setTransform(W), o && (t.clone(k, i.position), t.clone(G, i.direction), t.clone(H, i.up), t.cross(G, H, i.right))
            }
            if (n) {
                var q = m === p.SCENE2D || t.equals(e._offset3D, t.ZERO) ? void 0 : e._offset3D;
                i.lookAtTransform(i.transform, q)
            }
        }

        var _ = new c, v = new c, g = new c, y = new h, C = new t, E = new t, S = new t, T = new t, b = new t, w = new t, x = new u, A = 1.25, P = function (i, r, o, a) {
            this.entity = i, this.scene = r, this.ellipsoid = n(o, s.WGS84), this.boundingSphere = e.clone(a), this._boundingSphereOffset = void 0, this._lastEntity = void 0, this._mode = void 0, this._lastCartesian = new t, this._defaultOffset3D = void 0, this._offset3D = new t
        };
        o(P, {
            defaultOffset3D: {
                get: function () {
                    return this._defaultOffset3D
                }, set: function (e) {
                    this._defaultOffset3D = t.clone(e, new t)
                }
            }
        }), P.defaultOffset3D = new t(-14e3, 3500, 3500);
        var I = new m, D = new t;
        return P.prototype.update = function (e) {
            var i = this.scene, n = this.entity, o = this.ellipsoid, a = i.mode;
            if (a !== p.MORPHING) {
                var s = n.position, u = n !== this._lastEntity, c = a !== this._mode, h = this._offset3D, d = i.camera, m = u || c, _ = !0;
                if (u) {
                    var v = n.viewFrom, g = r(v), y = this.boundingSphere;
                    if (this._boundingSphereOffset = void 0, !g && r(y)) {
                        var C = i.screenSpaceCameraController;
                        C.minimumZoomDistance = Math.min(C.minimumZoomDistance, .5 * y.radius), I.pitch = -l.PI_OVER_FOUR, I.range = 0;
                        var E = s.getValue(e, D);
                        if (r(E)) {
                            var S = 2 - 1 / Math.max(1, t.magnitude(E) / o.maximumRadius);
                            I.pitch *= S
                        }
                        d.viewBoundingSphere(y, I), this._boundingSphereOffset = t.subtract(y.center, n.position.getValue(e), new t), m = !1, _ = !1
                    } else g && r(v.getValue(e, h)) || t.clone(P._defaultOffset3D, h)
                } else c || i.mode === p.MORPHING || this._mode === p.SCENE2D || t.clone(d.position, h);
                this._lastEntity = n, this._mode = i.mode !== p.MORPHING ? i.mode : this._mode, i.mode !== p.MORPHING && f(this, d, m, _, s, e, o)
            }
        }, P
    }),function () {
        !function (e) {
            var t = this || (0, eval)("this"), i = t.document, n = t.navigator, r = t.jQuery, o = t.JSON;
            !function (e) {
                "function" == typeof require && "object" == typeof exports && "object" == typeof module ? e(module.exports || exports, require) : "function" == typeof define && define.amd ? define("Cesium/ThirdParty/knockout-3.2.0", ["exports", "require"], e) : e(t.ko = {})
            }(function (a, s) {
                function u(e, t) {
                    return null === e || typeof e in m ? e === t : !1
                }

                function l(t, i) {
                    var n;
                    return function () {
                        n || (n = setTimeout(function () {
                            n = e, t()
                        }, i))
                    }
                }

                function c(e, t) {
                    var i;
                    return function () {
                        clearTimeout(i), i = setTimeout(e, t)
                    }
                }

                function h(e, t, i, n) {
                    d.d[e] = {
                        init: function (e, r, o, a, s) {
                            var u, l;
                            return d.s(function () {
                                var o = d.a.c(r()), a = !i != !o, c = !l;
                                (c || t || a !== u) && (c && d.Y.la() && (l = d.a.ia(d.f.childNodes(e), !0)), a ? (c || d.f.T(e, d.a.ia(l)), d.Ca(n ? n(s, o) : s, e)) : d.f.ja(e), u = a)
                            }, null, {o: e}), {controlsDescendantBindings: !0}
                        }
                    }, d.h.ha[e] = !1, d.f.Q[e] = !0
                }

                var d = "undefined" != typeof a ? a : {};
                d.b = function (e, t) {
                    for (var i = e.split("."), n = d, r = 0; r < i.length - 1; r++)n = n[i[r]];
                    n[i[i.length - 1]] = t
                }, d.A = function (e, t, i) {
                    e[t] = i
                }, d.version = "3.2.0", d.b("version", d.version), d.a = function () {
                    function a(e, t) {
                        for (var i in e)e.hasOwnProperty(i) && t(i, e[i])
                    }

                    function s(e, t) {
                        if (t)for (var i in t)t.hasOwnProperty(i) && (e[i] = t[i]);
                        return e
                    }

                    function u(e, t) {
                        return e.__proto__ = t, e
                    }

                    var l = {__proto__: []}instanceof Array, c = {}, h = {};
                    c[n && /Firefox\/2/i.test(n.userAgent) ? "KeyboardEvent" : "UIEvents"] = ["keyup", "keydown", "keypress"], c.MouseEvents = "click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave".split(" "), a(c, function (e, t) {
                        if (t.length)for (var i = 0, n = t.length; n > i; i++)h[t[i]] = e
                    });
                    var m = {propertychange: !0}, p = i && function () {
                            for (var t = 3, n = i.createElement("div"), r = n.getElementsByTagName("i"); n.innerHTML = "<!--[if gt IE " + ++t + "]><i></i><![endif]-->", r[0];);
                            return t > 4 ? t : e
                        }();
                    return {
                        vb: ["authenticity_token", /^__RequestVerificationToken(_.*)?$/], u: function (e, t) {
                            for (var i = 0, n = e.length; n > i; i++)t(e[i], i)
                        }, m: function (e, t) {
                            if ("function" == typeof Array.prototype.indexOf)return Array.prototype.indexOf.call(e, t);
                            for (var i = 0, n = e.length; n > i; i++)if (e[i] === t)return i;
                            return -1
                        }, qb: function (e, t, i) {
                            for (var n = 0, r = e.length; r > n; n++)if (t.call(i, e[n], n))return e[n];
                            return null
                        }, ua: function (e, t) {
                            var i = d.a.m(e, t);
                            i > 0 ? e.splice(i, 1) : 0 === i && e.shift()
                        }, rb: function (e) {
                            e = e || [];
                            for (var t = [], i = 0, n = e.length; n > i; i++)0 > d.a.m(t, e[i]) && t.push(e[i]);
                            return t
                        }, Da: function (e, t) {
                            e = e || [];
                            for (var i = [], n = 0, r = e.length; r > n; n++)i.push(t(e[n], n));
                            return i
                        }, ta: function (e, t) {
                            e = e || [];
                            for (var i = [], n = 0, r = e.length; r > n; n++)t(e[n], n) && i.push(e[n]);
                            return i
                        }, ga: function (e, t) {
                            if (t instanceof Array)e.push.apply(e, t); else for (var i = 0, n = t.length; n > i; i++)e.push(t[i]);
                            return e
                        }, ea: function (e, t, i) {
                            var n = d.a.m(d.a.Xa(e), t);
                            0 > n ? i && e.push(t) : i || e.splice(n, 1)
                        }, xa: l, extend: s, za: u, Aa: l ? u : s, G: a, na: function (e, t) {
                            if (!e)return e;
                            var i, n = {};
                            for (i in e)e.hasOwnProperty(i) && (n[i] = t(e[i], i, e));
                            return n
                        }, Ka: function (e) {
                            for (; e.firstChild;)d.removeNode(e.firstChild)
                        }, oc: function (e) {
                            e = d.a.S(e);
                            for (var t = i.createElement("div"), n = 0, r = e.length; r > n; n++)t.appendChild(d.R(e[n]));
                            return t
                        }, ia: function (e, t) {
                            for (var i = 0, n = e.length, r = []; n > i; i++) {
                                var o = e[i].cloneNode(!0);
                                r.push(t ? d.R(o) : o)
                            }
                            return r
                        }, T: function (e, t) {
                            if (d.a.Ka(e), t)for (var i = 0, n = t.length; n > i; i++)e.appendChild(t[i])
                        }, Lb: function (e, t) {
                            var i = e.nodeType ? [e] : e;
                            if (0 < i.length) {
                                for (var n = i[0], r = n.parentNode, o = 0, a = t.length; a > o; o++)r.insertBefore(t[o], n);
                                for (o = 0, a = i.length; a > o; o++)d.removeNode(i[o])
                            }
                        }, ka: function (e, t) {
                            if (e.length) {
                                for (t = 8 === t.nodeType && t.parentNode || t; e.length && e[0].parentNode !== t;)e.shift();
                                if (1 < e.length) {
                                    var i = e[0], n = e[e.length - 1];
                                    for (e.length = 0; i !== n;)if (e.push(i), i = i.nextSibling, !i)return;
                                    e.push(n)
                                }
                            }
                            return e
                        }, Nb: function (e, t) {
                            7 > p ? e.setAttribute("selected", t) : e.selected = t
                        }, cb: function (t) {
                            return null === t || t === e ? "" : t.trim ? t.trim() : t.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g, "")
                        }, vc: function (e, t) {
                            return e = e || "", t.length > e.length ? !1 : e.substring(0, t.length) === t
                        }, cc: function (e, t) {
                            if (e === t)return !0;
                            if (11 === e.nodeType)return !1;
                            if (t.contains)return t.contains(3 === e.nodeType ? e.parentNode : e);
                            if (t.compareDocumentPosition)return 16 == (16 & t.compareDocumentPosition(e));
                            for (; e && e != t;)e = e.parentNode;
                            return !!e
                        }, Ja: function (e) {
                            return d.a.cc(e, e.ownerDocument.documentElement)
                        }, ob: function (e) {
                            return !!d.a.qb(e, d.a.Ja)
                        }, t: function (e) {
                            return e && e.tagName && e.tagName.toLowerCase()
                        }, n: function (e, t, i) {
                            var n = p && m[t];
                            if (!n && r)r(e).bind(t, i); else if (n || "function" != typeof e.addEventListener) {
                                if ("undefined" == typeof e.attachEvent)throw Error("Browser doesn't support addEventListener or attachEvent");
                                var o = function (t) {
                                    i.call(e, t)
                                }, a = "on" + t;
                                e.attachEvent(a, o), d.a.w.da(e, function () {
                                    e.detachEvent(a, o)
                                })
                            } else e.addEventListener(t, i, !1)
                        }, oa: function (e, n) {
                            if (!e || !e.nodeType)throw Error("element must be a DOM node when calling triggerEvent");
                            var o;
                            if ("input" === d.a.t(e) && e.type && "click" == n.toLowerCase() ? (o = e.type, o = "checkbox" == o || "radio" == o) : o = !1, r && !o)r(e).trigger(n); else if ("function" == typeof i.createEvent) {
                                if ("function" != typeof e.dispatchEvent)throw Error("The supplied element doesn't support dispatchEvent");
                                o = i.createEvent(h[n] || "HTMLEvents"), o.initEvent(n, !0, !0, t, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, e), e.dispatchEvent(o)
                            } else if (o && e.click)e.click(); else {
                                if ("undefined" == typeof e.fireEvent)throw Error("Browser doesn't support triggering events");
                                e.fireEvent("on" + n)
                            }
                        }, c: function (e) {
                            return d.C(e) ? e() : e
                        }, Xa: function (e) {
                            return d.C(e) ? e.v() : e
                        }, Ba: function (e, t, i) {
                            if (t) {
                                var n = /\S+/g, r = e.className.match(n) || [];
                                d.a.u(t.match(n), function (e) {
                                    d.a.ea(r, e, i)
                                }), e.className = r.join(" ")
                            }
                        }, bb: function (t, i) {
                            var n = d.a.c(i);
                            (null === n || n === e) && (n = "");
                            var r = d.f.firstChild(t);
                            !r || 3 != r.nodeType || d.f.nextSibling(r) ? d.f.T(t, [t.ownerDocument.createTextNode(n)]) : r.data = n, d.a.fc(t)
                        }, Mb: function (e, t) {
                            if (e.name = t, 7 >= p)try {
                                e.mergeAttributes(i.createElement("<input name='" + e.name + "'/>"), !1)
                            } catch (n) {
                            }
                        }, fc: function (e) {
                            p >= 9 && (e = 1 == e.nodeType ? e : e.parentNode, e.style && (e.style.zoom = e.style.zoom))
                        }, dc: function (e) {
                            if (p) {
                                var t = e.style.width;
                                e.style.width = 0, e.style.width = t
                            }
                        }, sc: function (e, t) {
                            e = d.a.c(e), t = d.a.c(t);
                            for (var i = [], n = e; t >= n; n++)i.push(n);
                            return i
                        }, S: function (e) {
                            for (var t = [], i = 0, n = e.length; n > i; i++)t.push(e[i]);
                            return t
                        }, yc: 6 === p, zc: 7 === p, L: p, xb: function (e, t) {
                            for (var i = d.a.S(e.getElementsByTagName("input")).concat(d.a.S(e.getElementsByTagName("textarea"))), n = "string" == typeof t ? function (e) {
                                return e.name === t
                            } : function (e) {
                                return t.test(e.name)
                            }, r = [], o = i.length - 1; o >= 0; o--)n(i[o]) && r.push(i[o]);
                            return r
                        }, pc: function (e) {
                            return "string" == typeof e && (e = d.a.cb(e)) ? o && o.parse ? o.parse(e) : new Function("return " + e)() : null
                        }, eb: function (e, t, i) {
                            if (!o || !o.stringify)throw Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
                            return o.stringify(d.a.c(e), t, i)
                        }, qc: function (e, t, n) {
                            n = n || {};
                            var r = n.params || {}, o = n.includeFields || this.vb, s = e;
                            if ("object" == typeof e && "form" === d.a.t(e))for (var s = e.action, u = o.length - 1; u >= 0; u--)for (var l = d.a.xb(e, o[u]), c = l.length - 1; c >= 0; c--)r[l[c].name] = l[c].value;
                            t = d.a.c(t);
                            var h = i.createElement("form");
                            h.style.display = "none", h.action = s, h.method = "post";
                            for (var m in t)e = i.createElement("input"), e.type = "hidden", e.name = m, e.value = d.a.eb(d.a.c(t[m])), h.appendChild(e);
                            a(r, function (e, t) {
                                var n = i.createElement("input");
                                n.type = "hidden", n.name = e, n.value = t, h.appendChild(n)
                            }), i.body.appendChild(h), n.submitter ? n.submitter(h) : h.submit(), setTimeout(function () {
                                h.parentNode.removeChild(h)
                            }, 0)
                        }
                    }
                }(), d.b("utils", d.a), d.b("utils.arrayForEach", d.a.u), d.b("utils.arrayFirst", d.a.qb), d.b("utils.arrayFilter", d.a.ta), d.b("utils.arrayGetDistinctValues", d.a.rb), d.b("utils.arrayIndexOf", d.a.m), d.b("utils.arrayMap", d.a.Da), d.b("utils.arrayPushAll", d.a.ga), d.b("utils.arrayRemoveItem", d.a.ua), d.b("utils.extend", d.a.extend), d.b("utils.fieldsIncludedWithJsonPost", d.a.vb), d.b("utils.getFormFields", d.a.xb), d.b("utils.peekObservable", d.a.Xa), d.b("utils.postJson", d.a.qc), d.b("utils.parseJson", d.a.pc), d.b("utils.registerEventHandler", d.a.n), d.b("utils.stringifyJson", d.a.eb), d.b("utils.range", d.a.sc), d.b("utils.toggleDomNodeCssClass", d.a.Ba), d.b("utils.triggerEvent", d.a.oa), d.b("utils.unwrapObservable", d.a.c), d.b("utils.objectForEach", d.a.G), d.b("utils.addOrRemoveItem", d.a.ea), d.b("unwrap", d.a.c), Function.prototype.bind || (Function.prototype.bind = function (e) {
                    var t = this, i = Array.prototype.slice.call(arguments);
                    return e = i.shift(), function () {
                        return t.apply(e, i.concat(Array.prototype.slice.call(arguments)))
                    }
                }), d.a.e = new function () {
                    function t(t, o) {
                        var a = t[n];
                        if (!a || "null" === a || !r[a]) {
                            if (!o)return e;
                            a = t[n] = "ko" + i++, r[a] = {}
                        }
                        return r[a]
                    }

                    var i = 0, n = "__ko__" + (new Date).getTime(), r = {};
                    return {
                        get: function (i, n) {
                            var r = t(i, !1);
                            return r === e ? e : r[n]
                        }, set: function (i, n, r) {
                            (r !== e || t(i, !1) !== e) && (t(i, !0)[n] = r)
                        }, clear: function (e) {
                            var t = e[n];
                            return t ? (delete r[t], e[n] = null, !0) : !1
                        }, F: function () {
                            return i++ + n
                        }
                    }
                }, d.b("utils.domData", d.a.e), d.b("utils.domData.clear", d.a.e.clear), d.a.w = new function () {
                    function t(t, i) {
                        var r = d.a.e.get(t, n);
                        return r === e && i && (r = [], d.a.e.set(t, n, r)), r
                    }

                    function i(e) {
                        var n = t(e, !1);
                        if (n)for (var n = n.slice(0), r = 0; r < n.length; r++)n[r](e);
                        if (d.a.e.clear(e), d.a.w.cleanExternalData(e), a[e.nodeType])for (n = e.firstChild; e = n;)n = e.nextSibling, 8 === e.nodeType && i(e)
                    }

                    var n = d.a.e.F(), o = {1: !0, 8: !0, 9: !0}, a = {1: !0, 9: !0};
                    return {
                        da: function (e, i) {
                            if ("function" != typeof i)throw Error("Callback must be a function");
                            t(e, !0).push(i)
                        }, Kb: function (i, r) {
                            var o = t(i, !1);
                            o && (d.a.ua(o, r), 0 == o.length && d.a.e.set(i, n, e))
                        }, R: function (e) {
                            if (o[e.nodeType] && (i(e), a[e.nodeType])) {
                                var t = [];
                                d.a.ga(t, e.getElementsByTagName("*"));
                                for (var n = 0, r = t.length; r > n; n++)i(t[n])
                            }
                            return e
                        }, removeNode: function (e) {
                            d.R(e), e.parentNode && e.parentNode.removeChild(e)
                        }, cleanExternalData: function (e) {
                            r && "function" == typeof r.cleanData && r.cleanData([e])
                        }
                    }
                }, d.R = d.a.w.R, d.removeNode = d.a.w.removeNode, d.b("cleanNode", d.R), d.b("removeNode", d.removeNode), d.b("utils.domNodeDisposal", d.a.w), d.b("utils.domNodeDisposal.addDisposeCallback", d.a.w.da), d.b("utils.domNodeDisposal.removeDisposeCallback", d.a.w.Kb), function () {
                    d.a.ba = function (e) {
                        var n;
                        if (r) {
                            if (r.parseHTML)n = r.parseHTML(e) || []; else if ((n = r.clean([e])) && n[0]) {
                                for (e = n[0]; e.parentNode && 11 !== e.parentNode.nodeType;)e = e.parentNode;
                                e.parentNode && e.parentNode.removeChild(e)
                            }
                        } else {
                            var o = d.a.cb(e).toLowerCase();
                            for (n = i.createElement("div"), o = o.match(/^<(thead|tbody|tfoot)/) && [1, "<table>", "</table>"] || !o.indexOf("<tr") && [2, "<table><tbody>", "</tbody></table>"] || (!o.indexOf("<td") || !o.indexOf("<th")) && [3, "<table><tbody><tr>", "</tr></tbody></table>"] || [0, "", ""], e = "ignored<div>" + o[1] + e + o[2] + "</div>", "function" == typeof t.innerShiv ? n.appendChild(t.innerShiv(e)) : n.innerHTML = e; o[0]--;)n = n.lastChild;
                            n = d.a.S(n.lastChild.childNodes)
                        }
                        return n
                    }, d.a.$a = function (t, i) {
                        if (d.a.Ka(t), i = d.a.c(i), null !== i && i !== e)if ("string" != typeof i && (i = i.toString()), r)r(t).html(i); else for (var n = d.a.ba(i), o = 0; o < n.length; o++)t.appendChild(n[o])
                    }
                }(), d.b("utils.parseHtmlFragment", d.a.ba), d.b("utils.setHtml", d.a.$a), d.D = function () {
                    function t(e, i) {
                        if (e)if (8 == e.nodeType) {
                            var n = d.D.Gb(e.nodeValue);
                            null != n && i.push({bc: e, mc: n})
                        } else if (1 == e.nodeType)for (var n = 0, r = e.childNodes, o = r.length; o > n; n++)t(r[n], i)
                    }

                    var i = {};
                    return {
                        Ua: function (e) {
                            if ("function" != typeof e)throw Error("You can only pass a function to ko.memoization.memoize()");
                            var t = (4294967296 * (1 + Math.random()) | 0).toString(16).substring(1) + (4294967296 * (1 + Math.random()) | 0).toString(16).substring(1);
                            return i[t] = e, "<!--[ko_memo:" + t + "]-->"
                        }, Rb: function (t, n) {
                            var r = i[t];
                            if (r === e)throw Error("Couldn't find any memo with ID " + t + ". Perhaps it's already been unmemoized.");
                            try {
                                return r.apply(null, n || []), !0
                            } finally {
                                delete i[t]
                            }
                        }, Sb: function (e, i) {
                            var n = [];
                            t(e, n);
                            for (var r = 0, o = n.length; o > r; r++) {
                                var a = n[r].bc, s = [a];
                                i && d.a.ga(s, i), d.D.Rb(n[r].mc, s), a.nodeValue = "", a.parentNode && a.parentNode.removeChild(a)
                            }
                        }, Gb: function (e) {
                            return (e = e.match(/^\[ko_memo\:(.*?)\]$/)) ? e[1] : null
                        }
                    }
                }(), d.b("memoization", d.D), d.b("memoization.memoize", d.D.Ua), d.b("memoization.unmemoize", d.D.Rb), d.b("memoization.parseMemoText", d.D.Gb), d.b("memoization.unmemoizeDomNodeAndDescendants", d.D.Sb), d.La = {
                    throttle: function (e, t) {
                        e.throttleEvaluation = t;
                        var i = null;
                        return d.j({
                            read: e, write: function (n) {
                                clearTimeout(i), i = setTimeout(function () {
                                    e(n)
                                }, t)
                            }
                        })
                    }, rateLimit: function (e, t) {
                        var i, n, r;
                        "number" == typeof t ? i = t : (i = t.timeout, n = t.method), r = "notifyWhenChangesStop" == n ? c : l, e.Ta(function (e) {
                            return r(e, i)
                        })
                    }, notify: function (e, t) {
                        e.equalityComparer = "always" == t ? null : u
                    }
                };
                var m = {undefined: 1, "boolean": 1, number: 1, string: 1};
                d.b("extenders", d.La), d.Pb = function (e, t, i) {
                    this.target = e, this.wa = t, this.ac = i, this.Cb = !1, d.A(this, "dispose", this.K)
                }, d.Pb.prototype.K = function () {
                    this.Cb = !0, this.ac()
                }, d.P = function () {
                    d.a.Aa(this, d.P.fn), this.M = {}
                };
                var p = "change", f = {
                    U: function (e, t, i) {
                        var n = this;
                        i = i || p;
                        var r = new d.Pb(n, t ? e.bind(t) : e, function () {
                            d.a.ua(n.M[i], r), n.nb && n.nb()
                        });
                        return n.va && n.va(i), n.M[i] || (n.M[i] = []), n.M[i].push(r), r
                    }, notifySubscribers: function (e, t) {
                        if (t = t || p, this.Ab(t))try {
                            d.k.Ea();
                            for (var i, n = this.M[t].slice(0), r = 0; i = n[r]; ++r)i.Cb || i.wa(e)
                        } finally {
                            d.k.end()
                        }
                    }, Ta: function (e) {
                        var t, i, n, r = this, o = d.C(r);
                        r.qa || (r.qa = r.notifySubscribers, r.notifySubscribers = function (e, t) {
                            t && t !== p ? "beforeChange" === t ? r.kb(e) : r.qa(e, t) : r.lb(e)
                        });
                        var a = e(function () {
                            o && n === r && (n = r()), t = !1, r.Pa(i, n) && r.qa(i = n)
                        });
                        r.lb = function (e) {
                            t = !0, n = e, a()
                        }, r.kb = function (e) {
                            t || (i = e, r.qa(e, "beforeChange"))
                        }
                    }, Ab: function (e) {
                        return this.M[e] && this.M[e].length
                    }, yb: function () {
                        var e = 0;
                        return d.a.G(this.M, function (t, i) {
                            e += i.length
                        }), e
                    }, Pa: function (e, t) {
                        return !this.equalityComparer || !this.equalityComparer(e, t)
                    }, extend: function (e) {
                        var t = this;
                        return e && d.a.G(e, function (e, i) {
                            var n = d.La[e];
                            "function" == typeof n && (t = n(t, i) || t)
                        }), t
                    }
                };
                d.A(f, "subscribe", f.U), d.A(f, "extend", f.extend), d.A(f, "getSubscriptionsCount", f.yb), d.a.xa && d.a.za(f, Function.prototype), d.P.fn = f, d.Db = function (e) {
                    return null != e && "function" == typeof e.U && "function" == typeof e.notifySubscribers
                }, d.b("subscribable", d.P), d.b("isSubscribable", d.Db), d.Y = d.k = function () {
                    function e(e) {
                        n.push(i), i = e
                    }

                    function t() {
                        i = n.pop()
                    }

                    var i, n = [], r = 0;
                    return {
                        Ea: e, end: t, Jb: function (e) {
                            if (i) {
                                if (!d.Db(e))throw Error("Only subscribable things can act as dependencies");
                                i.wa(e, e.Vb || (e.Vb = ++r))
                            }
                        }, B: function (i, n, r) {
                            try {
                                return e(), i.apply(n, r || [])
                            } finally {
                                t()
                            }
                        }, la: function () {
                            return i ? i.s.la() : void 0
                        }, ma: function () {
                            return i ? i.ma : void 0
                        }
                    }
                }(), d.b("computedContext", d.Y), d.b("computedContext.getDependenciesCount", d.Y.la), d.b("computedContext.isInitial", d.Y.ma), d.b("computedContext.isSleeping", d.Y.Ac), d.p = function (e) {
                    function t() {
                        return 0 < arguments.length ? (t.Pa(i, arguments[0]) && (t.X(), i = arguments[0], t.W()), this) : (d.k.Jb(t), i)
                    }

                    var i = e;
                    return d.P.call(t), d.a.Aa(t, d.p.fn), t.v = function () {
                        return i
                    }, t.W = function () {
                        t.notifySubscribers(i)
                    }, t.X = function () {
                        t.notifySubscribers(i, "beforeChange")
                    }, d.A(t, "peek", t.v), d.A(t, "valueHasMutated", t.W), d.A(t, "valueWillMutate", t.X), t
                }, d.p.fn = {equalityComparer: u};
                var _ = d.p.rc = "__ko_proto__";
                d.p.fn[_] = d.p, d.a.xa && d.a.za(d.p.fn, d.P.fn), d.Ma = function (t, i) {
                    return null === t || t === e || t[_] === e ? !1 : t[_] === i ? !0 : d.Ma(t[_], i)
                }, d.C = function (e) {
                    return d.Ma(e, d.p)
                }, d.Ra = function (e) {
                    return "function" == typeof e && e[_] === d.p || "function" == typeof e && e[_] === d.j && e.hc ? !0 : !1
                }, d.b("observable", d.p), d.b("isObservable", d.C), d.b("isWriteableObservable", d.Ra), d.b("isWritableObservable", d.Ra), d.aa = function (e) {
                    if (e = e || [], "object" != typeof e || !("length"in e))throw Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");
                    return e = d.p(e), d.a.Aa(e, d.aa.fn), e.extend({trackArrayChanges: !0})
                }, d.aa.fn = {
                    remove: function (e) {
                        for (var t = this.v(), i = [], n = "function" != typeof e || d.C(e) ? function (t) {
                            return t === e
                        } : e, r = 0; r < t.length; r++) {
                            var o = t[r];
                            n(o) && (0 === i.length && this.X(), i.push(o), t.splice(r, 1), r--)
                        }
                        return i.length && this.W(), i
                    }, removeAll: function (t) {
                        if (t === e) {
                            var i = this.v(), n = i.slice(0);
                            return this.X(), i.splice(0, i.length), this.W(), n
                        }
                        return t ? this.remove(function (e) {
                            return 0 <= d.a.m(t, e)
                        }) : []
                    }, destroy: function (e) {
                        var t = this.v(), i = "function" != typeof e || d.C(e) ? function (t) {
                            return t === e
                        } : e;
                        this.X();
                        for (var n = t.length - 1; n >= 0; n--)i(t[n]) && (t[n]._destroy = !0);
                        this.W()
                    }, destroyAll: function (t) {
                        return t === e ? this.destroy(function () {
                            return !0
                        }) : t ? this.destroy(function (e) {
                            return 0 <= d.a.m(t, e)
                        }) : []
                    }, indexOf: function (e) {
                        var t = this();
                        return d.a.m(t, e)
                    }, replace: function (e, t) {
                        var i = this.indexOf(e);
                        i >= 0 && (this.X(), this.v()[i] = t, this.W())
                    }
                }, d.a.u("pop push reverse shift sort splice unshift".split(" "), function (e) {
                    d.aa.fn[e] = function () {
                        var t = this.v();
                        return this.X(), this.sb(t, e, arguments), t = t[e].apply(t, arguments), this.W(), t
                    }
                }), d.a.u(["slice"], function (e) {
                    d.aa.fn[e] = function () {
                        var t = this();
                        return t[e].apply(t, arguments)
                    }
                }), d.a.xa && d.a.za(d.aa.fn, d.p.fn), d.b("observableArray", d.aa);
                var v = "arrayChange";
                d.La.trackArrayChanges = function (e) {
                    function t() {
                        if (!i) {
                            i = !0;
                            var t = e.notifySubscribers;
                            e.notifySubscribers = function (e, i) {
                                return i && i !== p || ++r, t.apply(this, arguments)
                            };
                            var o = [].concat(e.v() || []);
                            n = null, e.U(function (t) {
                                if (t = [].concat(t || []), e.Ab(v)) {
                                    var i;
                                    (!n || r > 1) && (n = d.a.Fa(o, t, {sparse: !0})), i = n, i.length && e.notifySubscribers(i, v)
                                }
                                o = t, n = null, r = 0
                            })
                        }
                    }

                    if (!e.sb) {
                        var i = !1, n = null, r = 0, o = e.U;
                        e.U = e.subscribe = function (e, i, n) {
                            return n === v && t(), o.apply(this, arguments)
                        }, e.sb = function (e, t, o) {
                            function a(e, t, i) {
                                return s[s.length] = {status: e, value: t, index: i}
                            }

                            if (i && !r) {
                                var s = [], u = e.length, l = o.length, c = 0;
                                switch (t) {
                                    case"push":
                                        c = u;
                                    case"unshift":
                                        for (t = 0; l > t; t++)a("added", o[t], c + t);
                                        break;
                                    case"pop":
                                        c = u - 1;
                                    case"shift":
                                        u && a("deleted", e[c], c);
                                        break;
                                    case"splice":
                                        t = Math.min(Math.max(0, 0 > o[0] ? u + o[0] : o[0]), u);
                                        for (var u = 1 === l ? u : Math.min(t + (o[1] || 0), u), l = t + l - 2, c = Math.max(u, l), h = [], m = [], p = 2; c > t; ++t, ++p)u > t && m.push(a("deleted", e[t], t)), l > t && h.push(a("added", o[p], t));
                                        d.a.wb(m, h);
                                        break;
                                    default:
                                        return
                                }
                                n = s
                            }
                        }
                    }
                }, d.s = d.j = function (t, i, n) {
                    function r() {
                        d.a.G(w, function (e, t) {
                            t.K()
                        }), w = {}
                    }

                    function o() {
                        r(), x = 0, _ = !0, m = !1
                    }

                    function a() {
                        var e = u.throttleEvaluation;
                        e && e >= 0 ? (clearTimeout(A), A = setTimeout(s, e)) : u.ib ? u.ib() : s()
                    }

                    function s(t) {
                        if (p) {
                            if (g)throw Error("A 'pure' computed must not be called recursively")
                        } else if (!_) {
                            if (T && T()) {
                                if (!f)return void b()
                            } else f = !1;
                            if (p = !0, y)try {
                                var n = {};
                                d.k.Ea({
                                    wa: function (e, t) {
                                        n[t] || (n[t] = 1, ++x)
                                    }, s: u, ma: e
                                }), x = 0, h = v.call(i)
                            } finally {
                                d.k.end(), p = !1
                            } else try {
                                var r = w, o = x;
                                d.k.Ea({
                                    wa: function (e, t) {
                                        _ || (o && r[t] ? (w[t] = r[t], ++x, delete r[t], --o) : w[t] || (w[t] = e.U(a), ++x))
                                    }, s: u, ma: g ? e : !x
                                }), w = {}, x = 0;
                                try {
                                    var s = i ? v.call(i) : v()
                                } finally {
                                    d.k.end(), o && d.a.G(r, function (e, t) {
                                        t.K()
                                    }), m = !1
                                }
                                u.Pa(h, s) && (u.notifySubscribers(h, "beforeChange"), h = s, !0 !== t && u.notifySubscribers(h))
                            } finally {
                                p = !1
                            }
                            x || b()
                        }
                    }

                    function u() {
                        if (0 < arguments.length) {
                            if ("function" != typeof C)throw Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");
                            return C.apply(i, arguments), this
                        }
                        return d.k.Jb(u), m && s(!0), h
                    }

                    function l() {
                        return m && !x && s(!0), h
                    }

                    function c() {
                        return m || x > 0
                    }

                    var h, m = !0, p = !1, f = !1, _ = !1, v = t, g = !1, y = !1;
                    if (v && "object" == typeof v ? (n = v, v = n.read) : (n = n || {}, v || (v = n.read)), "function" != typeof v)throw Error("Pass a function that returns the value of the ko.computed");
                    var C = n.write, E = n.disposeWhenNodeIsRemoved || n.o || null, S = n.disposeWhen || n.Ia, T = S, b = o, w = {}, x = 0, A = null;
                    i || (i = n.owner), d.P.call(u), d.a.Aa(u, d.j.fn), u.v = l, u.la = function () {
                        return x
                    }, u.hc = "function" == typeof n.write, u.K = function () {
                        b()
                    }, u.Z = c;
                    var P = u.Ta;
                    return u.Ta = function (e) {
                        P.call(u, e), u.ib = function () {
                            u.kb(h), m = !0, u.lb(u)
                        }
                    }, n.pure ? (y = g = !0, u.va = function () {
                        y && (y = !1, s(!0))
                    }, u.nb = function () {
                        u.yb() || (r(),
                            y = m = !0)
                    }) : n.deferEvaluation && (u.va = function () {
                        l(), delete u.va
                    }), d.A(u, "peek", u.v), d.A(u, "dispose", u.K), d.A(u, "isActive", u.Z), d.A(u, "getDependenciesCount", u.la), E && (f = !0, E.nodeType && (T = function () {
                        return !d.a.Ja(E) || S && S()
                    })), y || n.deferEvaluation || s(), E && c() && E.nodeType && (b = function () {
                        d.a.w.Kb(E, b), o()
                    }, d.a.w.da(E, b)), u
                }, d.jc = function (e) {
                    return d.Ma(e, d.j)
                }, f = d.p.rc, d.j[f] = d.p, d.j.fn = {equalityComparer: u}, d.j.fn[f] = d.j, d.a.xa && d.a.za(d.j.fn, d.P.fn), d.b("dependentObservable", d.j), d.b("computed", d.j), d.b("isComputed", d.jc), d.Ib = function (e, t) {
                    return "function" == typeof e ? d.s(e, t, {pure: !0}) : (e = d.a.extend({}, e), e.pure = !0, d.s(e, t))
                }, d.b("pureComputed", d.Ib), function () {
                    function t(r, o, a) {
                        if (a = a || new n, r = o(r), "object" != typeof r || null === r || r === e || r instanceof Date || r instanceof String || r instanceof Number || r instanceof Boolean)return r;
                        var s = r instanceof Array ? [] : {};
                        return a.save(r, s), i(r, function (i) {
                            var n = o(r[i]);
                            switch (typeof n) {
                                case"boolean":
                                case"number":
                                case"string":
                                case"function":
                                    s[i] = n;
                                    break;
                                case"object":
                                case"undefined":
                                    var u = a.get(n);
                                    s[i] = u !== e ? u : t(n, o, a)
                            }
                        }), s
                    }

                    function i(e, t) {
                        if (e instanceof Array) {
                            for (var i = 0; i < e.length; i++)t(i);
                            "function" == typeof e.toJSON && t("toJSON")
                        } else for (i in e)t(i)
                    }

                    function n() {
                        this.keys = [], this.hb = []
                    }

                    d.Qb = function (e) {
                        if (0 == arguments.length)throw Error("When calling ko.toJS, pass the object you want to convert.");
                        return t(e, function (e) {
                            for (var t = 0; d.C(e) && 10 > t; t++)e = e();
                            return e
                        })
                    }, d.toJSON = function (e, t, i) {
                        return e = d.Qb(e), d.a.eb(e, t, i)
                    }, n.prototype = {
                        save: function (e, t) {
                            var i = d.a.m(this.keys, e);
                            i >= 0 ? this.hb[i] = t : (this.keys.push(e), this.hb.push(t))
                        }, get: function (t) {
                            return t = d.a.m(this.keys, t), t >= 0 ? this.hb[t] : e
                        }
                    }
                }(), d.b("toJS", d.Qb), d.b("toJSON", d.toJSON), function () {
                    d.i = {
                        q: function (t) {
                            switch (d.a.t(t)) {
                                case"option":
                                    return !0 === t.__ko__hasDomDataOptionValue__ ? d.a.e.get(t, d.d.options.Va) : 7 >= d.a.L ? t.getAttributeNode("value") && t.getAttributeNode("value").specified ? t.value : t.text : t.value;
                                case"select":
                                    return 0 <= t.selectedIndex ? d.i.q(t.options[t.selectedIndex]) : e;
                                default:
                                    return t.value
                            }
                        }, ca: function (t, i, n) {
                            switch (d.a.t(t)) {
                                case"option":
                                    switch (typeof i) {
                                        case"string":
                                            d.a.e.set(t, d.d.options.Va, e), "__ko__hasDomDataOptionValue__"in t && delete t.__ko__hasDomDataOptionValue__, t.value = i;
                                            break;
                                        default:
                                            d.a.e.set(t, d.d.options.Va, i), t.__ko__hasDomDataOptionValue__ = !0, t.value = "number" == typeof i ? i : ""
                                    }
                                    break;
                                case"select":
                                    ("" === i || null === i) && (i = e);
                                    for (var r, o = -1, a = 0, s = t.options.length; s > a; ++a)if (r = d.i.q(t.options[a]), r == i || "" == r && i === e) {
                                        o = a;
                                        break
                                    }
                                    (n || o >= 0 || i === e && 1 < t.size) && (t.selectedIndex = o);
                                    break;
                                default:
                                    (null === i || i === e) && (i = ""), t.value = i
                            }
                        }
                    }
                }(), d.b("selectExtensions", d.i), d.b("selectExtensions.readValue", d.i.q), d.b("selectExtensions.writeValue", d.i.ca), d.h = function () {
                    function e(e) {
                        e = d.a.cb(e), 123 === e.charCodeAt(0) && (e = e.slice(1, -1));
                        var t, i, a = [], s = e.match(n), u = 0;
                        if (s) {
                            s.push(",");
                            for (var l, c = 0; l = s[c]; ++c) {
                                var h = l.charCodeAt(0);
                                if (44 === h) {
                                    if (0 >= u) {
                                        t && a.push(i ? {key: t, value: i.join("")} : {unknown: t}), t = i = u = 0;
                                        continue
                                    }
                                } else if (58 === h) {
                                    if (!i)continue
                                } else if (47 === h && c && 1 < l.length)(h = s[c - 1].match(r)) && !o[h[0]] && (e = e.substr(e.indexOf(l) + 1), s = e.match(n), s.push(","), c = -1, l = "/"); else if (40 === h || 123 === h || 91 === h)++u; else if (41 === h || 125 === h || 93 === h)--u; else if (!t && !i) {
                                    t = 34 === h || 39 === h ? l.slice(1, -1) : l;
                                    continue
                                }
                                i ? i.push(l) : i = [l]
                            }
                        }
                        return a
                    }

                    var t = ["true", "false", "null", "undefined"], i = /^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i, n = RegExp("\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\\\.)*'|/(?:[^/\\\\]|\\\\.)*/w*|[^\\s:,/][^,\"'{}()/:[\\]]*[^\\s,\"'{}()/:[\\]]|[^\\s]", "g"), r = /[\])"'A-Za-z0-9_$]+$/, o = {
                        "in": 1,
                        "return": 1,
                        "typeof": 1
                    }, a = {};
                    return {
                        ha: [], V: a, Wa: e, ya: function (n, r) {
                            function o(e, n) {
                                var r;
                                if (!c) {
                                    var h = d.getBindingHandler(e);
                                    if (h && h.preprocess && !(n = h.preprocess(n, e, o)))return;
                                    (h = a[e]) && (r = n, 0 <= d.a.m(t, r) ? r = !1 : (h = r.match(i), r = null === h ? !1 : h[1] ? "Object(" + h[1] + ")" + h[2] : r), h = r), h && u.push("'" + e + "':function(_z){" + r + "=_z}")
                                }
                                l && (n = "function(){return " + n + " }"), s.push("'" + e + "':" + n)
                            }

                            r = r || {};
                            var s = [], u = [], l = r.valueAccessors, c = r.bindingParams, h = "string" == typeof n ? e(n) : n;
                            return d.a.u(h, function (e) {
                                o(e.key || e.unknown, e.value)
                            }), u.length && o("_ko_property_writers", "{" + u.join(",") + " }"), s.join(",")
                        }, lc: function (e, t) {
                            for (var i = 0; i < e.length; i++)if (e[i].key == t)return !0;
                            return !1
                        }, pa: function (e, t, i, n, r) {
                            e && d.C(e) ? !d.Ra(e) || r && e.v() === n || e(n) : (e = t.get("_ko_property_writers")) && e[i] && e[i](n)
                        }
                    }
                }(), d.b("expressionRewriting", d.h), d.b("expressionRewriting.bindingRewriteValidators", d.h.ha), d.b("expressionRewriting.parseObjectLiteral", d.h.Wa), d.b("expressionRewriting.preProcessBindings", d.h.ya), d.b("expressionRewriting._twoWayBindings", d.h.V), d.b("jsonExpressionRewriting", d.h), d.b("jsonExpressionRewriting.insertPropertyAccessorsIntoJson", d.h.ya), function () {
                    function e(e) {
                        return 8 == e.nodeType && a.test(o ? e.text : e.nodeValue)
                    }

                    function t(e) {
                        return 8 == e.nodeType && s.test(o ? e.text : e.nodeValue)
                    }

                    function n(i, n) {
                        for (var r = i, o = 1, a = []; r = r.nextSibling;) {
                            if (t(r) && (o--, 0 === o))return a;
                            a.push(r), e(r) && o++
                        }
                        if (!n)throw Error("Cannot find closing comment tag to match: " + i.nodeValue);
                        return null
                    }

                    function r(e, t) {
                        var i = n(e, t);
                        return i ? 0 < i.length ? i[i.length - 1].nextSibling : e.nextSibling : null
                    }

                    var o = i && "<!--test-->" === i.createComment("test").text, a = o ? /^\x3c!--\s*ko(?:\s+([\s\S]+))?\s*--\x3e$/ : /^\s*ko(?:\s+([\s\S]+))?\s*$/, s = o ? /^\x3c!--\s*\/ko\s*--\x3e$/ : /^\s*\/ko\s*$/, u = {
                        ul: !0,
                        ol: !0
                    };
                    d.f = {
                        Q: {}, childNodes: function (t) {
                            return e(t) ? n(t) : t.childNodes
                        }, ja: function (t) {
                            if (e(t)) {
                                t = d.f.childNodes(t);
                                for (var i = 0, n = t.length; n > i; i++)d.removeNode(t[i])
                            } else d.a.Ka(t)
                        }, T: function (t, i) {
                            if (e(t)) {
                                d.f.ja(t);
                                for (var n = t.nextSibling, r = 0, o = i.length; o > r; r++)n.parentNode.insertBefore(i[r], n)
                            } else d.a.T(t, i)
                        }, Hb: function (t, i) {
                            e(t) ? t.parentNode.insertBefore(i, t.nextSibling) : t.firstChild ? t.insertBefore(i, t.firstChild) : t.appendChild(i)
                        }, Bb: function (t, i, n) {
                            n ? e(t) ? t.parentNode.insertBefore(i, n.nextSibling) : n.nextSibling ? t.insertBefore(i, n.nextSibling) : t.appendChild(i) : d.f.Hb(t, i)
                        }, firstChild: function (i) {
                            return e(i) ? !i.nextSibling || t(i.nextSibling) ? null : i.nextSibling : i.firstChild
                        }, nextSibling: function (i) {
                            return e(i) && (i = r(i)), i.nextSibling && t(i.nextSibling) ? null : i.nextSibling
                        }, gc: e, xc: function (e) {
                            return (e = (o ? e.text : e.nodeValue).match(a)) ? e[1] : null
                        }, Fb: function (i) {
                            if (u[d.a.t(i)]) {
                                var n = i.firstChild;
                                if (n)do if (1 === n.nodeType) {
                                    var o;
                                    o = n.firstChild;
                                    var a = null;
                                    if (o)do if (a)a.push(o); else if (e(o)) {
                                        var s = r(o, !0);
                                        s ? o = s : a = [o]
                                    } else t(o) && (a = [o]); while (o = o.nextSibling);
                                    if (o = a)for (a = n.nextSibling, s = 0; s < o.length; s++)a ? i.insertBefore(o[s], a) : i.appendChild(o[s])
                                } while (n = n.nextSibling)
                            }
                        }
                    }
                }(), d.b("virtualElements", d.f), d.b("virtualElements.allowedBindings", d.f.Q), d.b("virtualElements.emptyNode", d.f.ja), d.b("virtualElements.insertAfter", d.f.Bb), d.b("virtualElements.prepend", d.f.Hb), d.b("virtualElements.setDomNodeChildren", d.f.T), function () {
                    d.J = function () {
                        this.Yb = {}
                    }, d.a.extend(d.J.prototype, {
                        nodeHasBindings: function (e) {
                            switch (e.nodeType) {
                                case 1:
                                    return null != e.getAttribute("data-bind") || d.g.getComponentNameForNode(e);
                                case 8:
                                    return d.f.gc(e);
                                default:
                                    return !1
                            }
                        }, getBindings: function (e, t) {
                            var i = this.getBindingsString(e, t), i = i ? this.parseBindingsString(i, t, e) : null;
                            return d.g.mb(i, e, t, !1)
                        }, getBindingAccessors: function (e, t) {
                            var i = this.getBindingsString(e, t), i = i ? this.parseBindingsString(i, t, e, {valueAccessors: !0}) : null;
                            return d.g.mb(i, e, t, !0)
                        }, getBindingsString: function (e) {
                            switch (e.nodeType) {
                                case 1:
                                    return e.getAttribute("data-bind");
                                case 8:
                                    return d.f.xc(e);
                                default:
                                    return null
                            }
                        }, parseBindingsString: function (e, t, i, n) {
                            try {
                                var r, o = this.Yb, a = e + (n && n.valueAccessors || "");
                                if (!(r = o[a])) {
                                    var s, u = "with($context){with($data||{}){return{" + d.h.ya(e, n) + "}}}";
                                    s = new Function("$context", "$element", u), r = o[a] = s
                                }
                                return r(t, i)
                            } catch (l) {
                                throw l.message = "Unable to parse bindings.\nBindings value: " + e + "\nMessage: " + l.message, l
                            }
                        }
                    }), d.J.instance = new d.J
                }(), d.b("bindingProvider", d.J), function () {
                    function i(e) {
                        return function () {
                            return e
                        }
                    }

                    function n(e) {
                        return e()
                    }

                    function o(e) {
                        return d.a.na(d.k.B(e), function (t, i) {
                            return function () {
                                return e()[i]
                            }
                        })
                    }

                    function a(e, t) {
                        return o(this.getBindings.bind(this, e, t))
                    }

                    function s(e, t, i) {
                        var n, r = d.f.firstChild(t), o = d.J.instance, a = o.preprocessNode;
                        if (a) {
                            for (; n = r;)r = d.f.nextSibling(n), a.call(o, n);
                            r = d.f.firstChild(t)
                        }
                        for (; n = r;)r = d.f.nextSibling(n), u(e, n, i)
                    }

                    function u(e, t, i) {
                        var n = !0, r = 1 === t.nodeType;
                        r && d.f.Fb(t), (r && i || d.J.instance.nodeHasBindings(t)) && (n = c(t, null, e, i).shouldBindDescendants), n && !m[d.a.t(t)] && s(e, t, !r)
                    }

                    function l(e) {
                        var t = [], i = {}, n = [];
                        return d.a.G(e, function r(o) {
                            if (!i[o]) {
                                var a = d.getBindingHandler(o);
                                a && (a.after && (n.push(o), d.a.u(a.after, function (t) {
                                    if (e[t]) {
                                        if (-1 !== d.a.m(n, t))throw Error("Cannot combine the following bindings, because they have a cyclic dependency: " + n.join(", "));
                                        r(t)
                                    }
                                }), n.length--), t.push({key: o, zb: a})), i[o] = !0
                            }
                        }), t
                    }

                    function c(t, i, r, o) {
                        var s = d.a.e.get(t, p);
                        if (!i) {
                            if (s)throw Error("You cannot apply bindings multiple times to the same element.");
                            d.a.e.set(t, p, !0)
                        }
                        !s && o && d.Ob(t, r);
                        var u;
                        if (i && "function" != typeof i)u = i; else {
                            var c = d.J.instance, h = c.getBindingAccessors || a, m = d.j(function () {
                                return (u = i ? i(r, t) : h.call(c, t, r)) && r.I && r.I(), u
                            }, null, {o: t});
                            u && m.Z() || (m = null)
                        }
                        var f;
                        if (u) {
                            var _ = m ? function (e) {
                                return function () {
                                    return n(m()[e])
                                }
                            } : function (e) {
                                return u[e]
                            }, v = function () {
                                return d.a.na(m ? m() : u, n)
                            };
                            v.get = function (e) {
                                return u[e] && n(_(e))
                            }, v.has = function (e) {
                                return e in u
                            }, o = l(u), d.a.u(o, function (i) {
                                var n = i.zb.init, o = i.zb.update, a = i.key;
                                if (8 === t.nodeType && !d.f.Q[a])throw Error("The binding '" + a + "' cannot be used with virtual elements");
                                try {
                                    "function" == typeof n && d.k.B(function () {
                                        var i = n(t, _(a), v, r.$data, r);
                                        if (i && i.controlsDescendantBindings) {
                                            if (f !== e)throw Error("Multiple bindings (" + f + " and " + a + ") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");
                                            f = a
                                        }
                                    }), "function" == typeof o && d.j(function () {
                                        o(t, _(a), v, r.$data, r)
                                    }, null, {o: t})
                                } catch (s) {
                                    throw s.message = 'Unable to process binding "' + a + ": " + u[a] + '"\nMessage: ' + s.message, s
                                }
                            })
                        }
                        return {shouldBindDescendants: f === e}
                    }

                    function h(e) {
                        return e && e instanceof d.N ? e : new d.N(e)
                    }

                    d.d = {};
                    var m = {script: !0};
                    d.getBindingHandler = function (e) {
                        return d.d[e]
                    }, d.N = function (t, i, n, r) {
                        var o, a = this, s = "function" == typeof t && !d.C(t), u = d.j(function () {
                            var e = s ? t() : t, o = d.a.c(e);
                            return i ? (i.I && i.I(), d.a.extend(a, i), u && (a.I = u)) : (a.$parents = [], a.$root = o, a.ko = d), a.$rawData = e, a.$data = o, n && (a[n] = o), r && r(a, i, o), a.$data
                        }, null, {
                            Ia: function () {
                                return o && !d.a.ob(o)
                            }, o: !0
                        });
                        u.Z() && (a.I = u, u.equalityComparer = null, o = [], u.Tb = function (t) {
                            o.push(t), d.a.w.da(t, function (t) {
                                d.a.ua(o, t), o.length || (u.K(), a.I = u = e)
                            })
                        })
                    }, d.N.prototype.createChildContext = function (e, t, i) {
                        return new d.N(e, this, t, function (e, t) {
                            e.$parentContext = t, e.$parent = t.$data, e.$parents = (t.$parents || []).slice(0), e.$parents.unshift(e.$parent), i && i(e)
                        })
                    }, d.N.prototype.extend = function (e) {
                        return new d.N(this.I || this.$data, this, null, function (t, i) {
                            t.$rawData = i.$rawData, d.a.extend(t, "function" == typeof e ? e() : e)
                        })
                    };
                    var p = d.a.e.F(), f = d.a.e.F();
                    d.Ob = function (e, t) {
                        return 2 != arguments.length ? d.a.e.get(e, f) : (d.a.e.set(e, f, t), void(t.I && t.I.Tb(e)))
                    }, d.ra = function (e, t, i) {
                        return 1 === e.nodeType && d.f.Fb(e), c(e, t, h(i), !0)
                    }, d.Wb = function (e, t, n) {
                        return n = h(n), d.ra(e, "function" == typeof t ? o(t.bind(null, n, e)) : d.a.na(t, i), n)
                    }, d.Ca = function (e, t) {
                        1 !== t.nodeType && 8 !== t.nodeType || s(h(e), t, !0)
                    }, d.pb = function (e, i) {
                        if (!r && t.jQuery && (r = t.jQuery), i && 1 !== i.nodeType && 8 !== i.nodeType)throw Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");
                        i = i || t.document.body, u(h(e), i, !0)
                    }, d.Ha = function (t) {
                        switch (t.nodeType) {
                            case 1:
                            case 8:
                                var i = d.Ob(t);
                                if (i)return i;
                                if (t.parentNode)return d.Ha(t.parentNode)
                        }
                        return e
                    }, d.$b = function (t) {
                        return (t = d.Ha(t)) ? t.$data : e
                    }, d.b("bindingHandlers", d.d), d.b("applyBindings", d.pb), d.b("applyBindingsToDescendants", d.Ca), d.b("applyBindingAccessorsToNode", d.ra), d.b("applyBindingsToNode", d.Wb), d.b("contextFor", d.Ha), d.b("dataFor", d.$b)
                }(), function (e) {
                    function t(t, n) {
                        var a, s = r.hasOwnProperty(t) ? r[t] : e;
                        s || (s = r[t] = new d.P, i(t, function (e) {
                            o[t] = e, delete r[t], a ? s.notifySubscribers(e) : setTimeout(function () {
                                s.notifySubscribers(e)
                            }, 0)
                        }), a = !0), s.U(n)
                    }

                    function i(e, t) {
                        n("getConfig", [e], function (i) {
                            i ? n("loadComponent", [e, i], function (e) {
                                t(e)
                            }) : t(null)
                        })
                    }

                    function n(t, i, r, o) {
                        o || (o = d.g.loaders.slice(0));
                        var a = o.shift();
                        if (a) {
                            var s = a[t];
                            if (s) {
                                var u = !1;
                                if (s.apply(a, i.concat(function (e) {
                                        u ? r(null) : null !== e ? r(e) : n(t, i, r, o)
                                    })) !== e && (u = !0, !a.suppressLoaderExceptions))throw Error("Component loaders must supply values by invoking the callback, not by returning values synchronously.")
                            } else n(t, i, r, o)
                        } else r(null)
                    }

                    var r = {}, o = {};
                    d.g = {
                        get: function (i, n) {
                            var r = o.hasOwnProperty(i) ? o[i] : e;
                            r ? setTimeout(function () {
                                n(r)
                            }, 0) : t(i, n)
                        }, tb: function (e) {
                            delete o[e]
                        }, jb: n
                    }, d.g.loaders = [], d.b("components", d.g), d.b("components.get", d.g.get), d.b("components.clearCachedDefinition", d.g.tb)
                }(), function () {
                    function e(e, t, i, n) {
                        function r() {
                            0 === --s && n(o)
                        }

                        var o = {}, s = 2, u = i.template;
                        i = i.viewModel, u ? a(t, u, function (t) {
                            d.g.jb("loadTemplate", [e, t], function (e) {
                                o.template = e, r()
                            })
                        }) : r(), i ? a(t, i, function (t) {
                            d.g.jb("loadViewModel", [e, t], function (e) {
                                o[c] = e, r()
                            })
                        }) : r()
                    }

                    function n(e, t, i) {
                        if ("function" == typeof t)i(function (e) {
                            return new t(e)
                        }); else if ("function" == typeof t[c])i(t[c]); else if ("instance"in t) {
                            var r = t.instance;
                            i(function () {
                                return r
                            })
                        } else"viewModel"in t ? n(e, t.viewModel, i) : e("Unknown viewModel value: " + t)
                    }

                    function r(e) {
                        switch (d.a.t(e)) {
                            case"script":
                                return d.a.ba(e.text);
                            case"textarea":
                                return d.a.ba(e.value);
                            case"template":
                                if (o(e.content))return d.a.ia(e.content.childNodes)
                        }
                        return d.a.ia(e.childNodes)
                    }

                    function o(e) {
                        return t.DocumentFragment ? e instanceof DocumentFragment : e && 11 === e.nodeType
                    }

                    function a(e, i, n) {
                        "string" == typeof i.require ? s || t.require ? (s || t.require)([i.require], n) : e("Uses require, but no AMD loader is present") : n(i)
                    }

                    function u(e) {
                        return function (t) {
                            throw Error("Component '" + e + "': " + t)
                        }
                    }

                    var l = {};
                    d.g.tc = function (e, t) {
                        if (!t)throw Error("Invalid configuration for " + e);
                        if (d.g.Qa(e))throw Error("Component " + e + " is already registered");
                        l[e] = t
                    }, d.g.Qa = function (e) {
                        return e in l
                    }, d.g.wc = function (e) {
                        delete l[e], d.g.tb(e)
                    }, d.g.ub = {
                        getConfig: function (e, t) {
                            t(l.hasOwnProperty(e) ? l[e] : null)
                        }, loadComponent: function (t, i, n) {
                            var r = u(t);
                            a(r, i, function (i) {
                                e(t, r, i, n)
                            })
                        }, loadTemplate: function (e, n, a) {
                            if (e = u(e), "string" == typeof n)a(d.a.ba(n)); else if (n instanceof Array)a(n); else if (o(n))a(d.a.S(n.childNodes)); else if (n.element)if (n = n.element, t.HTMLElement ? n instanceof HTMLElement : n && n.tagName && 1 === n.nodeType)a(r(n)); else if ("string" == typeof n) {
                                var s = i.getElementById(n);
                                s ? a(r(s)) : e("Cannot find element with ID " + n)
                            } else e("Unknown element type: " + n); else e("Unknown template value: " + n)
                        }, loadViewModel: function (e, t, i) {
                            n(u(e), t, i)
                        }
                    };
                    var c = "createViewModel";
                    d.b("components.register", d.g.tc), d.b("components.isRegistered", d.g.Qa), d.b("components.unregister", d.g.wc), d.b("components.defaultLoader", d.g.ub), d.g.loaders.push(d.g.ub), d.g.Ub = l
                }(), function () {
                    function e(e, i) {
                        var n = e.getAttribute("params");
                        if (n) {
                            var n = t.parseBindingsString(n, i, e, {
                                valueAccessors: !0,
                                bindingParams: !0
                            }), n = d.a.na(n, function (t) {
                                return d.s(t, null, {o: e})
                            }), r = d.a.na(n, function (t) {
                                return t.Z() ? d.s(function () {
                                    return d.a.c(t())
                                }, null, {o: e}) : t.v()
                            });
                            return r.hasOwnProperty("$raw") || (r.$raw = n), r
                        }
                        return {$raw: {}}
                    }

                    d.g.getComponentNameForNode = function (e) {
                        return e = d.a.t(e), d.g.Qa(e) && e
                    }, d.g.mb = function (t, i, n, r) {
                        if (1 === i.nodeType) {
                            var o = d.g.getComponentNameForNode(i);
                            if (o) {
                                if (t = t || {}, t.component)throw Error('Cannot use the "component" binding on a custom element matching a component');
                                var a = {name: o, params: e(i, n)};
                                t.component = r ? function () {
                                    return a
                                } : a
                            }
                        }
                        return t
                    };
                    var t = new d.J;
                    9 > d.a.L && (d.g.register = function (e) {
                        return function (t) {
                            return i.createElement(t), e.apply(this, arguments)
                        }
                    }(d.g.register), i.createDocumentFragment = function (e) {
                        return function () {
                            var t, i = e(), n = d.g.Ub;
                            for (t in n)n.hasOwnProperty(t) && i.createElement(t);
                            return i
                        }
                    }(i.createDocumentFragment))
                }(), function () {
                    var e = 0;
                    d.d.component = {
                        init: function (t, i, n, r, o) {
                            function a() {
                                var e = s && s.dispose;
                                "function" == typeof e && e.call(s), u = null
                            }

                            var s, u;
                            return d.a.w.da(t, a), d.s(function () {
                                var n, r, l = d.a.c(i());
                                if ("string" == typeof l ? n = l : (n = d.a.c(l.name), r = d.a.c(l.params)), !n)throw Error("No component name specified");
                                var c = u = ++e;
                                d.g.get(n, function (e) {
                                    if (u === c) {
                                        if (a(), !e)throw Error("Unknown component '" + n + "'");
                                        var i = e.template;
                                        if (!i)throw Error("Component '" + n + "' has no template");
                                        i = d.a.ia(i), d.f.T(t, i);
                                        var i = r, l = e.createViewModel;
                                        e = l ? l.call(e, i, {element: t}) : i, i = o.createChildContext(e), s = e, d.Ca(i, t)
                                    }
                                })
                            }, null, {o: t}), {controlsDescendantBindings: !0}
                        }
                    }, d.f.Q.component = !0
                }();
                var g = {"class": "className", "for": "htmlFor"};
                d.d.attr = {
                    update: function (t, i) {
                        var n = d.a.c(i()) || {};
                        d.a.G(n, function (i, n) {
                            n = d.a.c(n);
                            var r = !1 === n || null === n || n === e;
                            r && t.removeAttribute(i), 8 >= d.a.L && i in g ? (i = g[i], r ? t.removeAttribute(i) : t[i] = n) : r || t.setAttribute(i, n.toString()), "name" === i && d.a.Mb(t, r ? "" : n.toString())
                        })
                    }
                }, function () {
                    d.d.checked = {
                        after: ["value", "attr"], init: function (t, i, n) {
                            function r() {
                                var e = t.checked, r = h ? a() : e;
                                if (!d.Y.ma() && (!u || e)) {
                                    var o = d.k.B(i);
                                    l ? c !== r ? (e && (d.a.ea(o, r, !0), d.a.ea(o, c, !1)), c = r) : d.a.ea(o, r, e) : d.h.pa(o, n, "checked", r, !0)
                                }
                            }

                            function o() {
                                var e = d.a.c(i());
                                t.checked = l ? 0 <= d.a.m(e, a()) : s ? e : a() === e
                            }

                            var a = d.Ib(function () {
                                return n.has("checkedValue") ? d.a.c(n.get("checkedValue")) : n.has("value") ? d.a.c(n.get("value")) : t.value
                            }), s = "checkbox" == t.type, u = "radio" == t.type;
                            if (s || u) {
                                var l = s && d.a.c(i())instanceof Array, c = l ? a() : e, h = u || l;
                                u && !t.name && d.d.uniqueName.init(t, function () {
                                    return !0
                                }), d.s(r, null, {o: t}), d.a.n(t, "click", r), d.s(o, null, {o: t})
                            }
                        }
                    }, d.h.V.checked = !0, d.d.checkedValue = {
                        update: function (e, t) {
                            e.value = d.a.c(t())
                        }
                    }
                }(), d.d.css = {
                    update: function (e, t) {
                        var i = d.a.c(t());
                        "object" == typeof i ? d.a.G(i, function (t, i) {
                            i = d.a.c(i), d.a.Ba(e, t, i)
                        }) : (i = String(i || ""), d.a.Ba(e, e.__ko__cssValue, !1), e.__ko__cssValue = i, d.a.Ba(e, i, !0))
                    }
                }, d.d.enable = {
                    update: function (e, t) {
                        var i = d.a.c(t());
                        i && e.disabled ? e.removeAttribute("disabled") : i || e.disabled || (e.disabled = !0)
                    }
                }, d.d.disable = {
                    update: function (e, t) {
                        d.d.enable.update(e, function () {
                            return !d.a.c(t())
                        })
                    }
                }, d.d.event = {
                    init: function (e, t, i, n, r) {
                        var o = t() || {};
                        d.a.G(o, function (o) {
                            "string" == typeof o && d.a.n(e, o, function (e) {
                                var a, s = t()[o];
                                if (s) {
                                    try {
                                        var u = d.a.S(arguments);
                                        n = r.$data, u.unshift(n), a = s.apply(n, u)
                                    } finally {
                                        !0 !== a && (e.preventDefault ? e.preventDefault() : e.returnValue = !1)
                                    }
                                    !1 === i.get(o + "Bubble") && (e.cancelBubble = !0, e.stopPropagation && e.stopPropagation())
                                }
                            })
                        })
                    }
                }, d.d.foreach = {
                    Eb: function (e) {
                        return function () {
                            var t = e(), i = d.a.Xa(t);
                            return i && "number" != typeof i.length ? (d.a.c(t), {
                                foreach: i.data,
                                as: i.as,
                                includeDestroyed: i.includeDestroyed,
                                afterAdd: i.afterAdd,
                                beforeRemove: i.beforeRemove,
                                afterRender: i.afterRender,
                                beforeMove: i.beforeMove,
                                afterMove: i.afterMove,
                                templateEngine: d.O.Oa
                            }) : {foreach: t, templateEngine: d.O.Oa}
                        }
                    }, init: function (e, t) {
                        return d.d.template.init(e, d.d.foreach.Eb(t))
                    }, update: function (e, t, i, n, r) {
                        return d.d.template.update(e, d.d.foreach.Eb(t), i, n, r)
                    }
                }, d.h.ha.foreach = !1, d.f.Q.foreach = !0, d.d.hasfocus = {
                    init: function (e, t, i) {
                        function n(n) {
                            e.__ko_hasfocusUpdating = !0;
                            var r = e.ownerDocument;
                            if ("activeElement"in r) {
                                var o;
                                try {
                                    o = r.activeElement
                                } catch (a) {
                                    o = r.body
                                }
                                n = o === e
                            }
                            r = t(), d.h.pa(r, i, "hasfocus", n, !0), e.__ko_hasfocusLastValue = n, e.__ko_hasfocusUpdating = !1
                        }

                        var r = n.bind(null, !0), o = n.bind(null, !1);
                        d.a.n(e, "focus", r), d.a.n(e, "focusin", r), d.a.n(e, "blur", o), d.a.n(e, "focusout", o)
                    }, update: function (e, t) {
                        var i = !!d.a.c(t());
                        e.__ko_hasfocusUpdating || e.__ko_hasfocusLastValue === i || (i ? e.focus() : e.blur(), d.k.B(d.a.oa, null, [e, i ? "focusin" : "focusout"]))
                    }
                }, d.h.V.hasfocus = !0, d.d.hasFocus = d.d.hasfocus, d.h.V.hasFocus = !0, d.d.html = {
                    init: function () {
                        return {controlsDescendantBindings: !0}
                    }, update: function (e, t) {
                        d.a.$a(e, t())
                    }
                }, h("if"), h("ifnot", !1, !0), h("with", !0, !1, function (e, t) {
                    return e.createChildContext(t)
                });
                var y = {};
                d.d.options = {
                    init: function (e) {
                        if ("select" !== d.a.t(e))throw Error("options binding applies only to SELECT elements");
                        for (; 0 < e.length;)e.remove(0);
                        return {controlsDescendantBindings: !0}
                    }, update: function (t, i, n) {
                        function r() {
                            return d.a.ta(t.options, function (e) {
                                return e.selected
                            })
                        }

                        function o(e, t, i) {
                            var n = typeof t;
                            return "function" == n ? t(e) : "string" == n ? e[t] : i
                        }

                        function a(e, i) {
                            if (h.length) {
                                var n = 0 <= d.a.m(h, d.i.q(i[0]));
                                d.a.Nb(i[0], n), m && !n && d.k.B(d.a.oa, null, [t, "change"])
                            }
                        }

                        var s = 0 != t.length && t.multiple ? t.scrollTop : null, u = d.a.c(i()), l = n.get("optionsIncludeDestroyed");
                        i = {};
                        var c, h;
                        h = t.multiple ? d.a.Da(r(), d.i.q) : 0 <= t.selectedIndex ? [d.i.q(t.options[t.selectedIndex])] : [], u && ("undefined" == typeof u.length && (u = [u]), c = d.a.ta(u, function (t) {
                            return l || t === e || null === t || !d.a.c(t._destroy)
                        }), n.has("optionsCaption") && (u = d.a.c(n.get("optionsCaption")), null !== u && u !== e && c.unshift(y)));
                        var m = !1;
                        i.beforeRemove = function (e) {
                            t.removeChild(e)
                        }, u = a, n.has("optionsAfterRender") && (u = function (t, i) {
                            a(0, i), d.k.B(n.get("optionsAfterRender"), null, [i[0], t !== y ? t : e])
                        }), d.a.Za(t, c, function (i, r, a) {
                            return a.length && (h = a[0].selected ? [d.i.q(a[0])] : [], m = !0), r = t.ownerDocument.createElement("option"), i === y ? (d.a.bb(r, n.get("optionsCaption")), d.i.ca(r, e)) : (a = o(i, n.get("optionsValue"), i), d.i.ca(r, d.a.c(a)), i = o(i, n.get("optionsText"), a), d.a.bb(r, i)), [r]
                        }, i, u), d.k.B(function () {
                            n.get("valueAllowUnset") && n.has("value") ? d.i.ca(t, d.a.c(n.get("value")), !0) : (t.multiple ? h.length && r().length < h.length : h.length && 0 <= t.selectedIndex ? d.i.q(t.options[t.selectedIndex]) !== h[0] : h.length || 0 <= t.selectedIndex) && d.a.oa(t, "change")
                        }), d.a.dc(t), s && 20 < Math.abs(s - t.scrollTop) && (t.scrollTop = s)
                    }
                }, d.d.options.Va = d.a.e.F(), d.d.selectedOptions = {
                    after: ["options", "foreach"],
                    init: function (e, t, i) {
                        d.a.n(e, "change", function () {
                            var n = t(), r = [];
                            d.a.u(e.getElementsByTagName("option"), function (e) {
                                e.selected && r.push(d.i.q(e))
                            }), d.h.pa(n, i, "selectedOptions", r)
                        })
                    },
                    update: function (e, t) {
                        if ("select" != d.a.t(e))throw Error("values binding applies only to SELECT elements");
                        var i = d.a.c(t());
                        i && "number" == typeof i.length && d.a.u(e.getElementsByTagName("option"), function (e) {
                            var t = 0 <= d.a.m(i, d.i.q(e));
                            d.a.Nb(e, t)
                        })
                    }
                }, d.h.V.selectedOptions = !0, d.d.style = {
                    update: function (t, i) {
                        var n = d.a.c(i() || {});
                        d.a.G(n, function (i, n) {
                            n = d.a.c(n), (null === n || n === e || !1 === n) && (n = ""), t.style[i] = n
                        })
                    }
                }, d.d.submit = {
                    init: function (e, t, i, n, r) {
                        if ("function" != typeof t())throw Error("The value for a submit binding must be a function");
                        d.a.n(e, "submit", function (i) {
                            var n, o = t();
                            try {
                                n = o.call(r.$data, e)
                            } finally {
                                !0 !== n && (i.preventDefault ? i.preventDefault() : i.returnValue = !1)
                            }
                        })
                    }
                }, d.d.text = {
                    init: function () {
                        return {controlsDescendantBindings: !0}
                    }, update: function (e, t) {
                        d.a.bb(e, t())
                    }
                }, d.f.Q.text = !0, function () {
                    if (t && t.navigator)var i = function (e) {
                        return e ? parseFloat(e[1]) : void 0
                    }, n = t.opera && t.opera.version && parseInt(t.opera.version()), r = t.navigator.userAgent, o = i(r.match(/^(?:(?!chrome).)*version\/([^ ]*) safari/i)), a = i(r.match(/Firefox\/([^ ]*)/));
                    if (10 > d.a.L)var s = d.a.e.F(), u = d.a.e.F(), l = function (e) {
                        var t = this.activeElement;
                        (t = t && d.a.e.get(t, u)) && t(e)
                    }, c = function (e, t) {
                        var i = e.ownerDocument;
                        d.a.e.get(i, s) || (d.a.e.set(i, s, !0), d.a.n(i, "selectionchange", l)), d.a.e.set(e, u, t)
                    };
                    d.d.textInput = {
                        init: function (t, i, r) {
                            function s(e, i) {
                                d.a.n(t, e, i)
                            }

                            function u() {
                                var n = d.a.c(i());
                                (null === n || n === e) && (n = ""), p !== e && n === p ? setTimeout(u, 4) : t.value !== n && (f = n, t.value = n)
                            }

                            function l() {
                                m || (p = t.value, m = setTimeout(h, 4))
                            }

                            function h() {
                                clearTimeout(m), p = m = e;
                                var n = t.value;
                                f !== n && (f = n, d.h.pa(i(), r, "textInput", n))
                            }

                            var m, p, f = t.value;
                            10 > d.a.L ? (s("propertychange", function (e) {
                                "value" === e.propertyName && h()
                            }), 8 == d.a.L && (s("keyup", h), s("keydown", h)), 8 <= d.a.L && (c(t, h), s("dragend", l))) : (s("input", h), 5 > o && "textarea" === d.a.t(t) ? (s("keydown", l), s("paste", l), s("cut", l)) : 11 > n ? s("keydown", l) : 4 > a && (s("DOMAutoComplete", h), s("dragdrop", h), s("drop", h))), s("change", h), d.s(u, null, {o: t})
                        }
                    }, d.h.V.textInput = !0, d.d.textinput = {
                        preprocess: function (e, t, i) {
                            i("textInput", e)
                        }
                    }
                }(), d.d.uniqueName = {
                    init: function (e, t) {
                        if (t()) {
                            var i = "ko_unique_" + ++d.d.uniqueName.Zb;
                            d.a.Mb(e, i)
                        }
                    }
                }, d.d.uniqueName.Zb = 0, d.d.value = {
                    after: ["options", "foreach"], init: function (e, t, i) {
                        if ("input" != e.tagName.toLowerCase() || "checkbox" != e.type && "radio" != e.type) {
                            var n = ["change"], r = i.get("valueUpdate"), o = !1, a = null;
                            r && ("string" == typeof r && (r = [r]), d.a.ga(n, r), n = d.a.rb(n));
                            var s = function () {
                                a = null, o = !1;
                                var n = t(), r = d.i.q(e);
                                d.h.pa(n, i, "value", r)
                            };
                            !d.a.L || "input" != e.tagName.toLowerCase() || "text" != e.type || "off" == e.autocomplete || e.form && "off" == e.form.autocomplete || -1 != d.a.m(n, "propertychange") || (d.a.n(e, "propertychange", function () {
                                o = !0
                            }), d.a.n(e, "focus", function () {
                                o = !1
                            }), d.a.n(e, "blur", function () {
                                o && s()
                            })), d.a.u(n, function (t) {
                                var i = s;
                                d.a.vc(t, "after") && (i = function () {
                                    a = d.i.q(e), setTimeout(s, 0)
                                }, t = t.substring(5)), d.a.n(e, t, i)
                            });
                            var u = function () {
                                var n = d.a.c(t()), r = d.i.q(e);
                                if (null !== a && n === a)setTimeout(u, 0); else if (n !== r)if ("select" === d.a.t(e)) {
                                    var o = i.get("valueAllowUnset"), r = function () {
                                        d.i.ca(e, n, o)
                                    };
                                    r(), o || n === d.i.q(e) ? setTimeout(r, 0) : d.k.B(d.a.oa, null, [e, "change"])
                                } else d.i.ca(e, n)
                            };
                            d.s(u, null, {o: e})
                        } else d.ra(e, {checkedValue: t})
                    }, update: function () {
                    }
                }, d.h.V.value = !0, d.d.visible = {
                    update: function (e, t) {
                        var i = d.a.c(t()), n = "none" != e.style.display;
                        i && !n ? e.style.display = "" : !i && n && (e.style.display = "none")
                    }
                }, function (e) {
                    d.d[e] = {
                        init: function (t, i, n, r, o) {
                            return d.d.event.init.call(this, t, function () {
                                var t = {};
                                return t[e] = i(), t
                            }, n, r, o)
                        }
                    }
                }("click"), d.H = function () {
                }, d.H.prototype.renderTemplateSource = function () {
                    throw Error("Override renderTemplateSource")
                }, d.H.prototype.createJavaScriptEvaluatorBlock = function () {
                    throw Error("Override createJavaScriptEvaluatorBlock")
                }, d.H.prototype.makeTemplateSource = function (e, t) {
                    if ("string" == typeof e) {
                        t = t || i;
                        var n = t.getElementById(e);
                        if (!n)throw Error("Cannot find template with ID " + e);
                        return new d.r.l(n)
                    }
                    if (1 == e.nodeType || 8 == e.nodeType)return new d.r.fa(e);
                    throw Error("Unknown template type: " + e)
                }, d.H.prototype.renderTemplate = function (e, t, i, n) {
                    return e = this.makeTemplateSource(e, n), this.renderTemplateSource(e, t, i)
                }, d.H.prototype.isTemplateRewritten = function (e, t) {
                    return !1 === this.allowTemplateRewriting ? !0 : this.makeTemplateSource(e, t).data("isRewritten")
                }, d.H.prototype.rewriteTemplate = function (e, t, i) {
                    e = this.makeTemplateSource(e, i), t = t(e.text()), e.text(t), e.data("isRewritten", !0)
                }, d.b("templateEngine", d.H), d.fb = function () {
                    function e(e, t, i, n) {
                        e = d.h.Wa(e);
                        for (var r = d.h.ha, o = 0; o < e.length; o++) {
                            var a = e[o].key;
                            if (r.hasOwnProperty(a)) {
                                var s = r[a];
                                if ("function" == typeof s) {
                                    if (a = s(e[o].value))throw Error(a)
                                } else if (!s)throw Error("This template engine does not support the '" + a + "' binding within its templates")
                            }
                        }
                        return i = "ko.__tr_ambtns(function($context,$element){return(function(){return{ " + d.h.ya(e, {valueAccessors: !0}) + " } })()},'" + i.toLowerCase() + "')", n.createJavaScriptEvaluatorBlock(i) + t
                    }

                    var t = /(<([a-z]+\d*)(?:\s+(?!data-bind\s*=\s*)[a-z0-9\-]+(?:=(?:\"[^\"]*\"|\'[^\']*\'))?)*\s+)data-bind\s*=\s*(["'])([\s\S]*?)\3/gi, i = /\x3c!--\s*ko\b\s*([\s\S]*?)\s*--\x3e/g;
                    return {
                        ec: function (e, t, i) {
                            t.isTemplateRewritten(e, i) || t.rewriteTemplate(e, function (e) {
                                return d.fb.nc(e, t)
                            }, i)
                        }, nc: function (n, r) {
                            return n.replace(t, function (t, i, n, o, a) {
                                return e(a, i, n, r)
                            }).replace(i, function (t, i) {
                                return e(i, "<!-- ko -->", "#comment", r)
                            })
                        }, Xb: function (e, t) {
                            return d.D.Ua(function (i, n) {
                                var r = i.nextSibling;
                                r && r.nodeName.toLowerCase() === t && d.ra(r, e, n)
                            })
                        }
                    }
                }(), d.b("__tr_ambtns", d.fb.Xb), function () {
                    d.r = {}, d.r.l = function (e) {
                        this.l = e
                    }, d.r.l.prototype.text = function () {
                        var e = d.a.t(this.l), e = "script" === e ? "text" : "textarea" === e ? "value" : "innerHTML";
                        if (0 == arguments.length)return this.l[e];
                        var t = arguments[0];
                        "innerHTML" === e ? d.a.$a(this.l, t) : this.l[e] = t
                    };
                    var t = d.a.e.F() + "_";
                    d.r.l.prototype.data = function (e) {
                        return 1 === arguments.length ? d.a.e.get(this.l, t + e) : void d.a.e.set(this.l, t + e, arguments[1])
                    };
                    var i = d.a.e.F();
                    d.r.fa = function (e) {
                        this.l = e
                    }, d.r.fa.prototype = new d.r.l, d.r.fa.prototype.text = function () {
                        if (0 == arguments.length) {
                            var t = d.a.e.get(this.l, i) || {};
                            return t.gb === e && t.Ga && (t.gb = t.Ga.innerHTML), t.gb
                        }
                        d.a.e.set(this.l, i, {gb: arguments[0]})
                    }, d.r.l.prototype.nodes = function () {
                        return 0 == arguments.length ? (d.a.e.get(this.l, i) || {}).Ga : void d.a.e.set(this.l, i, {Ga: arguments[0]})
                    }, d.b("templateSources", d.r), d.b("templateSources.domElement", d.r.l), d.b("templateSources.anonymousTemplate", d.r.fa)
                }(), function () {
                    function t(e, t, i) {
                        var n;
                        for (t = d.f.nextSibling(t); e && (n = e) !== t;)e = d.f.nextSibling(n), i(n, e)
                    }

                    function i(e, i) {
                        if (e.length) {
                            var n = e[0], r = e[e.length - 1], o = n.parentNode, a = d.J.instance, s = a.preprocessNode;
                            if (s) {
                                if (t(n, r, function (e, t) {
                                        var i = e.previousSibling, o = s.call(a, e);
                                        o && (e === n && (n = o[0] || t), e === r && (r = o[o.length - 1] || i))
                                    }), e.length = 0, !n)return;
                                n === r ? e.push(n) : (e.push(n, r), d.a.ka(e, o))
                            }
                            t(n, r, function (e) {
                                1 !== e.nodeType && 8 !== e.nodeType || d.pb(i, e)
                            }), t(n, r, function (e) {
                                1 !== e.nodeType && 8 !== e.nodeType || d.D.Sb(e, [i])
                            }), d.a.ka(e, o)
                        }
                    }

                    function n(e) {
                        return e.nodeType ? e : 0 < e.length ? e[0] : null
                    }

                    function r(e, t, r, a, s) {
                        s = s || {};
                        var u = e && n(e), u = u && u.ownerDocument, l = s.templateEngine || o;
                        if (d.fb.ec(r, l, u), r = l.renderTemplate(r, a, s, u), "number" != typeof r.length || 0 < r.length && "number" != typeof r[0].nodeType)throw Error("Template engine must return an array of DOM nodes");
                        switch (u = !1, t) {
                            case"replaceChildren":
                                d.f.T(e, r), u = !0;
                                break;
                            case"replaceNode":
                                d.a.Lb(e, r), u = !0;
                                break;
                            case"ignoreTargetNode":
                                break;
                            default:
                                throw Error("Unknown renderMode: " + t)
                        }
                        return u && (i(r, a), s.afterRender && d.k.B(s.afterRender, null, [r, a.$data])), r
                    }

                    var o;
                    d.ab = function (t) {
                        if (t != e && !(t instanceof d.H))throw Error("templateEngine must inherit from ko.templateEngine");
                        o = t
                    }, d.Ya = function (t, i, a, s, u) {
                        if (a = a || {}, (a.templateEngine || o) == e)throw Error("Set a template engine before calling renderTemplate");
                        if (u = u || "replaceChildren", s) {
                            var l = n(s);
                            return d.j(function () {
                                var e = i && i instanceof d.N ? i : new d.N(d.a.c(i)), o = d.C(t) ? t() : "function" == typeof t ? t(e.$data, e) : t, e = r(s, u, o, e, a);
                                "replaceNode" == u && (s = e, l = n(s))
                            }, null, {
                                Ia: function () {
                                    return !l || !d.a.Ja(l)
                                }, o: l && "replaceNode" == u ? l.parentNode : l
                            })
                        }
                        return d.D.Ua(function (e) {
                            d.Ya(t, i, a, e, "replaceNode")
                        })
                    }, d.uc = function (t, n, o, a, s) {
                        function u(e, t) {
                            i(t, c), o.afterRender && o.afterRender(t, e)
                        }

                        function l(e, i) {
                            c = s.createChildContext(e, o.as, function (e) {
                                e.$index = i
                            });
                            var n = d.C(t) ? t() : "function" == typeof t ? t(e, c) : t;
                            return r(null, "ignoreTargetNode", n, c, o)
                        }

                        var c;
                        return d.j(function () {
                            var t = d.a.c(n) || [];
                            "undefined" == typeof t.length && (t = [t]), t = d.a.ta(t, function (t) {
                                return o.includeDestroyed || t === e || null === t || !d.a.c(t._destroy)
                            }), d.k.B(d.a.Za, null, [a, t, l, o, u])
                        }, null, {o: a})
                    };
                    var a = d.a.e.F();
                    d.d.template = {
                        init: function (e, t) {
                            var i = d.a.c(t());
                            return "string" == typeof i || i.name ? d.f.ja(e) : (i = d.f.childNodes(e), i = d.a.oc(i), new d.r.fa(e).nodes(i)), {controlsDescendantBindings: !0}
                        }, update: function (t, i, n, r, o) {
                            var s, u = i();
                            i = d.a.c(u), n = !0, r = null, "string" == typeof i ? i = {} : (u = i.name, "if"in i && (n = d.a.c(i["if"])), n && "ifnot"in i && (n = !d.a.c(i.ifnot)), s = d.a.c(i.data)), "foreach"in i ? r = d.uc(u || t, n && i.foreach || [], i, t, o) : n ? (o = "data"in i ? o.createChildContext(s, i.as) : o, r = d.Ya(u || t, o, i, t)) : d.f.ja(t), o = r, (s = d.a.e.get(t, a)) && "function" == typeof s.K && s.K(), d.a.e.set(t, a, o && o.Z() ? o : e)
                        }
                    }, d.h.ha.template = function (e) {
                        return e = d.h.Wa(e), 1 == e.length && e[0].unknown || d.h.lc(e, "name") ? null : "This template engine does not support anonymous templates nested within its templates"
                    }, d.f.Q.template = !0
                }(), d.b("setTemplateEngine", d.ab), d.b("renderTemplate", d.Ya), d.a.wb = function (e, t, i) {
                    if (e.length && t.length) {
                        var n, r, o, a, s;
                        for (n = r = 0; (!i || i > n) && (a = e[r]); ++r) {
                            for (o = 0; s = t[o]; ++o)if (a.value === s.value) {
                                a.moved = s.index, s.moved = a.index, t.splice(o, 1), n = o = 0;
                                break
                            }
                            n += o
                        }
                    }
                }, d.a.Fa = function () {
                    function e(e, t, i, n, r) {
                        var o, a, s, u, l, c = Math.min, h = Math.max, m = [], p = e.length, f = t.length, _ = f - p || 1, v = p + f + 1;
                        for (o = 0; p >= o; o++)for (u = s, m.push(s = []), l = c(f, o + _), a = h(0, o - 1); l >= a; a++)s[a] = a ? o ? e[o - 1] === t[a - 1] ? u[a - 1] : c(u[a] || v, s[a - 1] || v) + 1 : a + 1 : o + 1;
                        for (c = [], h = [], _ = [], o = p, a = f; o || a;)f = m[o][a] - 1, a && f === m[o][a - 1] ? h.push(c[c.length] = {
                            status: i,
                            value: t[--a],
                            index: a
                        }) : o && f === m[o - 1][a] ? _.push(c[c.length] = {
                            status: n,
                            value: e[--o],
                            index: o
                        }) : (--a, --o, r.sparse || c.push({status: "retained", value: t[a]}));
                        return d.a.wb(h, _, 10 * p), c.reverse()
                    }

                    return function (t, i, n) {
                        return n = "boolean" == typeof n ? {dontLimitMoves: n} : n || {}, t = t || [], i = i || [], t.length <= i.length ? e(t, i, "added", "deleted", n) : e(i, t, "deleted", "added", n)
                    }
                }(), d.b("utils.compareArrays", d.a.Fa), function () {
                    function t(t, i, n, r, o) {
                        var a = [], s = d.j(function () {
                            var e = i(n, o, d.a.ka(a, t)) || [];
                            0 < a.length && (d.a.Lb(a, e), r && d.k.B(r, null, [n, e, o])), a.length = 0, d.a.ga(a, e)
                        }, null, {
                            o: t, Ia: function () {
                                return !d.a.ob(a)
                            }
                        });
                        return {
                            $: a, j: s.Z() ? s : e
                        }
                    }

                    var i = d.a.e.F();
                    d.a.Za = function (n, r, o, a, s) {
                        function u(e, t) {
                            C = h[t], v !== t && (T[e] = C), C.Na(v++), d.a.ka(C.$, n), f.push(C), y.push(C)
                        }

                        function l(e, t) {
                            if (e)for (var i = 0, n = t.length; n > i; i++)t[i] && d.a.u(t[i].$, function (n) {
                                e(n, i, t[i].sa)
                            })
                        }

                        r = r || [], a = a || {};
                        var c = d.a.e.get(n, i) === e, h = d.a.e.get(n, i) || [], m = d.a.Da(h, function (e) {
                            return e.sa
                        }), p = d.a.Fa(m, r, a.dontLimitMoves), f = [], _ = 0, v = 0, g = [], y = [];
                        r = [];
                        for (var C, E, S, T = [], m = [], b = 0; E = p[b]; b++)switch (S = E.moved, E.status) {
                            case"deleted":
                                S === e && (C = h[_], C.j && C.j.K(), g.push.apply(g, d.a.ka(C.$, n)), a.beforeRemove && (r[b] = C, y.push(C))), _++;
                                break;
                            case"retained":
                                u(b, _++);
                                break;
                            case"added":
                                S !== e ? u(b, S) : (C = {
                                    sa: E.value,
                                    Na: d.p(v++)
                                }, f.push(C), y.push(C), c || (m[b] = C))
                        }
                        l(a.beforeMove, T), d.a.u(g, a.beforeRemove ? d.R : d.removeNode);
                        for (var w, b = 0, c = d.f.firstChild(n); C = y[b]; b++) {
                            for (C.$ || d.a.extend(C, t(n, o, C.sa, s, C.Na)), _ = 0; p = C.$[_]; c = p.nextSibling, w = p, _++)p !== c && d.f.Bb(n, p, w);
                            !C.ic && s && (s(C.sa, C.$, C.Na), C.ic = !0)
                        }
                        l(a.beforeRemove, r), l(a.afterMove, T), l(a.afterAdd, m), d.a.e.set(n, i, f)
                    }
                }(), d.b("utils.setDomNodeChildrenFromArrayMapping", d.a.Za), d.O = function () {
                    this.allowTemplateRewriting = !1
                }, d.O.prototype = new d.H, d.O.prototype.renderTemplateSource = function (e) {
                    var t = (9 > d.a.L ? 0 : e.nodes) ? e.nodes() : null;
                    return t ? d.a.S(t.cloneNode(!0).childNodes) : (e = e.text(), d.a.ba(e))
                }, d.O.Oa = new d.O, d.ab(d.O.Oa), d.b("nativeTemplateEngine", d.O), function () {
                    d.Sa = function () {
                        var e = this.kc = function () {
                            if (!r || !r.tmpl)return 0;
                            try {
                                if (0 <= r.tmpl.tag.tmpl.open.toString().indexOf("__"))return 2
                            } catch (e) {
                            }
                            return 1
                        }();
                        this.renderTemplateSource = function (t, n, o) {
                            if (o = o || {}, 2 > e)throw Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");
                            var a = t.data("precompiled");
                            return a || (a = t.text() || "", a = r.template(null, "{{ko_with $item.koBindingContext}}" + a + "{{/ko_with}}"), t.data("precompiled", a)), t = [n.$data], n = r.extend({koBindingContext: n}, o.templateOptions), n = r.tmpl(a, t, n), n.appendTo(i.createElement("div")), r.fragments = {}, n
                        }, this.createJavaScriptEvaluatorBlock = function (e) {
                            return "{{ko_code ((function() { return " + e + " })()) }}"
                        }, this.addTemplate = function (e, t) {
                            i.write("<script type='text/html' id='" + e + "'>" + t + "</script>")
                        }, e > 0 && (r.tmpl.tag.ko_code = {open: "__.push($1 || '');"}, r.tmpl.tag.ko_with = {
                            open: "with($1) {",
                            close: "} "
                        })
                    }, d.Sa.prototype = new d.H;
                    var e = new d.Sa;
                    0 < e.kc && d.ab(e), d.b("jqueryTmplTemplateEngine", d.Sa)
                }()
            })
        }()
    }(),define("Cesium/ThirdParty/knockout-es5", [], function () {
        "use strict";
        function e(e, i) {
            if (!e)throw new Error("When calling ko.track, you must pass an object as the first parameter.");
            var r = this, o = t(e, !0);
            return i = i || Object.getOwnPropertyNames(e), i.forEach(function (t) {
                if (t !== h && t !== d && !(t in o)) {
                    var i = e[t], a = i instanceof Array, s = r.isObservable(i) ? i : a ? r.observableArray(i) : r.observable(i);
                    Object.defineProperty(e, t, {
                        configurable: !0,
                        enumerable: !0,
                        get: s,
                        set: r.isWriteableObservable(s) ? s : void 0
                    }), o[t] = s, a && n(r, s)
                }
            }), e
        }

        function t(e, t) {
            var i = e[h];
            return !i && t && (i = {}, Object.defineProperty(e, h, {value: i})), i
        }

        function i(t, i, n) {
            var r = this, o = {owner: t, deferEvaluation: !0};
            if ("function" == typeof n)o.read = n; else {
                if ("value"in n)throw new Error('For ko.defineProperty, you must not specify a "value" for the property. You must provide a "get" function.');
                if ("function" != typeof n.get)throw new Error('For ko.defineProperty, the third parameter must be either an evaluator function, or an options object containing a function called "get".');
                o.read = n.get, o.write = n.set
            }
            return t[i] = r.computed(o), e.call(r, t, [i]), t
        }

        function n(e, t) {
            var i = null;
            e.computed(function () {
                i && (i.dispose(), i = null);
                var n = t();
                n instanceof Array && (i = r(e, t, n))
            })
        }

        function r(e, t, i) {
            var n = o(e, i);
            return n.subscribe(t)
        }

        function o(e, t) {
            var i = t[d];
            if (!i) {
                i = new e.subscribable, Object.defineProperty(t, d, {value: i});
                var n = {};
                a(t, i, n), s(e, t, i, n)
            }
            return i
        }

        function a(e, t, i) {
            ["pop", "push", "reverse", "shift", "sort", "splice", "unshift"].forEach(function (n) {
                var r = e[n];
                e[n] = function () {
                    var e = r.apply(this, arguments);
                    return i.pause !== !0 && t.notifySubscribers(this), e
                }
            })
        }

        function s(e, t, i, n) {
            ["remove", "removeAll", "destroy", "destroyAll", "replace"].forEach(function (r) {
                Object.defineProperty(t, r, {
                    enumerable: !1, value: function () {
                        var o;
                        n.pause = !0;
                        try {
                            o = e.observableArray.fn[r].apply(e.observableArray(t), arguments)
                        } finally {
                            n.pause = !1
                        }
                        return i.notifySubscribers(t), o
                    }
                })
            })
        }

        function u(e, i) {
            if (!e)return null;
            var n = t(e, !1);
            return n && n[i] || null
        }

        function l(e, t) {
            var i = u(e, t);
            i && i.valueHasMutated()
        }

        function c(t) {
            t.track = e, t.getObservable = u, t.valueHasMutated = l, t.defineProperty = i
        }

        var h = "__knockoutObservables", d = "__knockoutSubscribable";
        return {attachToKo: c}
    }),define("Cesium/Widgets/SvgPathBindingHandler", [], function () {
        "use strict";
        var e = "http://www.w3.org/2000/svg", t = "cesium-svgPath-svg", i = {
            register: function (i) {
                i.bindingHandlers.cesiumSvgPath = {
                    init: function (n, r) {
                        var o = document.createElementNS(e, "svg:svg");
                        o.setAttribute("class", t);
                        var a = document.createElementNS(e, "path");
                        return o.appendChild(a), i.virtualElements.setDomNodeChildren(n, [o]), i.computed({
                            read: function () {
                                var e = i.unwrap(r());
                                a.setAttribute("d", i.unwrap(e.path));
                                var n = i.unwrap(e.width), s = i.unwrap(e.height);
                                o.setAttribute("width", n), o.setAttribute("height", s), o.setAttribute("viewBox", "0 0 " + n + " " + s), e.css && o.setAttribute("class", t + " " + i.unwrap(e.css))
                            }, disposeWhenNodeIsRemoved: n
                        }), {controlsDescendantBindings: !0}
                    }
                }, i.virtualElements.allowedBindings.cesiumSvgPath = !0
            }
        };
        return i
    }),define("Cesium/ThirdParty/knockout", ["./knockout-3.2.0", "./knockout-es5", "../Widgets/SvgPathBindingHandler"], function (e, t, i) {
        "use strict";
        return t.attachToKo(e), i.register(e), e
    }),define("Cesium/Widgets/getElement", ["../Core/DeveloperError"], function (e) {
        "use strict";
        var t = function (e) {
            if ("string" == typeof e) {
                var t = document.getElementById(e);
                e = t
            }
            return e
        };
        return t
    }),define("Cesium/Widgets/subscribeAndEvaluate", ["../ThirdParty/knockout"], function (e) {
        "use strict";
        var t = function (t, i, n, r, o) {
            return n.call(r, t[i]), e.getObservable(t, i).subscribe(n, r, o)
        };
        return t
    }),define("Cesium/Widgets/Animation/Animation", ["../../Core/Color", "../../Core/defined", "../../Core/defineProperties", "../../Core/destroyObject", "../../Core/DeveloperError", "../getElement", "../subscribeAndEvaluate"], function (e, t, i, n, r, o, a) {
        "use strict";
        function s(t) {
            return e.fromCssColorString(window.getComputedStyle(t).getPropertyValue("color"))
        }

        function u(e) {
            var t = document.createElementNS(_, e.tagName);
            for (var i in e)if (e.hasOwnProperty(i) && "tagName" !== i)if ("children" === i) {
                var n, r = e.children.length;
                for (n = 0; r > n; ++n)t.appendChild(u(e.children[n]))
            } else 0 === i.indexOf("xlink:") ? t.setAttributeNS(v, i.substring(6), e[i]) : "textContent" === i ? t.textContent = e[i] : t.setAttribute(i, e[i]);
            return t
        }

        function l(e, t, i) {
            var n = document.createElementNS(_, "text");
            n.setAttribute("x", e), n.setAttribute("y", t), n.setAttribute("class", "cesium-animation-svgText");
            var r = document.createElementNS(_, "tspan");
            return r.textContent = i, n.appendChild(r), n
        }

        function c(e, t, i) {
            e.setAttribute("transform", "translate(100,100) rotate(" + i + ")"), t.setAttribute("transform", "rotate(" + i + ")")
        }

        function h(e, t) {
            var i = t.alpha, n = 1 - i;
            return x.red = e.red * n + t.red * i, x.green = e.green * n + t.green * i, x.blue = e.blue * n + t.blue * i, x.toCssColorString()
        }

        function d(e, t, i) {
            var n = {
                tagName: "g",
                "class": "cesium-animation-rectButton",
                transform: "translate(" + e + "," + t + ")",
                children: [{
                    tagName: "rect",
                    "class": "cesium-animation-buttonGlow",
                    width: 32,
                    height: 32,
                    rx: 2,
                    ry: 2
                }, {
                    tagName: "rect",
                    "class": "cesium-animation-buttonMain",
                    width: 32,
                    height: 32,
                    rx: 4,
                    ry: 4
                }, {tagName: "use", "class": "cesium-animation-buttonPath", "xlink:href": i}, {
                    tagName: "title",
                    textContent: ""
                }]
            };
            return u(n)
        }

        function m(e, t, i) {
            var n = {
                tagName: "g",
                "class": "cesium-animation-rectButton",
                transform: "translate(" + e + "," + t + ")",
                children: [{
                    tagName: "use",
                    "class": "cesium-animation-buttonGlow",
                    "xlink:href": "#animation_pathWingButton"
                }, {
                    tagName: "use",
                    "class": "cesium-animation-buttonMain",
                    "xlink:href": "#animation_pathWingButton"
                }, {tagName: "use", "class": "cesium-animation-buttonPath", "xlink:href": i}, {
                    tagName: "title",
                    textContent: ""
                }]
            };
            return u(n)
        }

        function p(e, t) {
            var i = e._viewModel, n = i.shuttleRingDragging;
            if (!n || f === e)if ("mousedown" === t.type || n && "mousemove" === t.type || "touchstart" === t.type && 1 === t.touches.length || n && "touchmove" === t.type && 1 === t.touches.length) {
                var r, o, a = e._centerX, s = e._centerY, u = e._svgNode, l = u.getBoundingClientRect();
                if ("touchstart" === t.type || "touchmove" === t.type ? (r = t.touches[0].clientX, o = t.touches[0].clientY) : (r = t.clientX, o = t.clientY), !n && (r > l.right || r < l.left || o < l.top || o > l.bottom))return;
                var c = e._shuttleRingPointer.getBoundingClientRect(), h = r - a - l.left, d = o - s - l.top, m = 180 * Math.atan2(d, h) / Math.PI + 90;
                m > 180 && (m -= 360);
                var p = i.shuttleRingAngle;
                n || r < c.right && r > c.left && o > c.top && o < c.bottom ? (f = e, i.shuttleRingDragging = !0, i.shuttleRingAngle = m) : p > m ? i.slower() : m > p && i.faster(), t.preventDefault()
            } else e === f && (f = void 0), i.shuttleRingDragging = !1
        }

        var f, _ = "http://www.w3.org/2000/svg", v = "http://www.w3.org/1999/xlink", g = e.fromCssColorString("rgba(247,250,255,0.384)"), y = e.fromCssColorString("rgba(143,191,255,0.216)"), C = e.fromCssColorString("rgba(153,197,255,0.098)"), E = e.fromCssColorString("rgba(255,255,255,0.086)"), S = e.fromCssColorString("rgba(255,255,255,0.267)"), T = e.fromCssColorString("rgba(255,255,255,0)"), b = e.fromCssColorString("rgba(66,67,68,0.3)"), w = e.fromCssColorString("rgba(0,0,0,0.5)"), x = new e, A = function (e, t) {
            this._viewModel = t, this.svgElement = e, this._enabled = void 0, this._toggled = void 0;
            var i = this;
            this._clickFunction = function () {
                var e = i._viewModel.command;
                e.canExecute && e()
            }, e.addEventListener("click", this._clickFunction, !0), this._subscriptions = [a(t, "toggled", this.setToggled, this), a(t, "tooltip", this.setTooltip, this), a(t.command, "canExecute", this.setEnabled, this)]
        };
        A.prototype.destroy = function () {
            this.svgElement.removeEventListener("click", this._clickFunction, !0);
            for (var e = this._subscriptions, t = 0, i = e.length; i > t; t++)e[t].dispose();
            n(this)
        }, A.prototype.isDestroyed = function () {
            return !1
        }, A.prototype.setEnabled = function (e) {
            if (this._enabled !== e) {
                if (this._enabled = e, !e)return void this.svgElement.setAttribute("class", "cesium-animation-buttonDisabled");
                if (this._toggled)return void this.svgElement.setAttribute("class", "cesium-animation-rectButton cesium-animation-buttonToggled");
                this.svgElement.setAttribute("class", "cesium-animation-rectButton")
            }
        }, A.prototype.setToggled = function (e) {
            this._toggled !== e && (this._toggled = e, this._enabled && (e ? this.svgElement.setAttribute("class", "cesium-animation-rectButton cesium-animation-buttonToggled") : this.svgElement.setAttribute("class", "cesium-animation-rectButton")))
        }, A.prototype.setTooltip = function (e) {
            this.svgElement.getElementsByTagName("title")[0].textContent = e
        };
        var P = function (e, t) {
            e = o(e), this._viewModel = t, this._container = e, this._centerX = 0, this._centerY = 0, this._defsElement = void 0, this._svgNode = void 0, this._topG = void 0, this._lastHeight = void 0, this._lastWidth = void 0;
            var i = document.createElement("style");
            i.textContent = ".cesium-animation-rectButton .cesium-animation-buttonGlow { filter: url(#animation_blurred); }.cesium-animation-rectButton .cesium-animation-buttonMain { fill: url(#animation_buttonNormal); }.cesium-animation-buttonToggled .cesium-animation-buttonMain { fill: url(#animation_buttonToggled); }.cesium-animation-rectButton:hover .cesium-animation-buttonMain { fill: url(#animation_buttonHovered); }.cesium-animation-buttonDisabled .cesium-animation-buttonMain { fill: url(#animation_buttonDisabled); }.cesium-animation-shuttleRingG .cesium-animation-shuttleRingSwoosh { fill: url(#animation_shuttleRingSwooshGradient); }.cesium-animation-shuttleRingG:hover .cesium-animation-shuttleRingSwoosh { fill: url(#animation_shuttleRingSwooshHovered); }.cesium-animation-shuttleRingPointer { fill: url(#animation_shuttleRingPointerGradient); }.cesium-animation-shuttleRingPausePointer { fill: url(#animation_shuttleRingPointerPaused); }.cesium-animation-knobOuter { fill: url(#animation_knobOuter); }.cesium-animation-knobInner { fill: url(#animation_knobInner); }", document.head.insertBefore(i, document.head.childNodes[0]);
            var n = document.createElement("div");
            n.className = "cesium-animation-theme", n.innerHTML = '<div class="cesium-animation-themeNormal"></div><div class="cesium-animation-themeHover"></div><div class="cesium-animation-themeSelect"></div><div class="cesium-animation-themeDisabled"></div><div class="cesium-animation-themeKnob"></div><div class="cesium-animation-themePointer"></div><div class="cesium-animation-themeSwoosh"></div><div class="cesium-animation-themeSwooshHover"></div>', this._theme = n, this._themeNormal = n.childNodes[0], this._themeHover = n.childNodes[1], this._themeSelect = n.childNodes[2], this._themeDisabled = n.childNodes[3], this._themeKnob = n.childNodes[4], this._themePointer = n.childNodes[5], this._themeSwoosh = n.childNodes[6], this._themeSwooshHover = n.childNodes[7];
            var r = document.createElementNS(_, "svg:svg");
            this._svgNode = r, r.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", v);
            var s = document.createElementNS(_, "g");
            this._topG = s, this._realtimeSVG = new A(m(3, 4, "#animation_pathClock"), t.playRealtimeViewModel), this._playReverseSVG = new A(d(44, 99, "#animation_pathPlayReverse"), t.playReverseViewModel), this._playForwardSVG = new A(d(124, 99, "#animation_pathPlay"), t.playForwardViewModel), this._pauseSVG = new A(d(84, 99, "#animation_pathPause"), t.pauseViewModel);
            var h = document.createElementNS(_, "g");
            h.appendChild(this._realtimeSVG.svgElement), h.appendChild(this._playReverseSVG.svgElement), h.appendChild(this._playForwardSVG.svgElement), h.appendChild(this._pauseSVG.svgElement);
            var f = u({tagName: "circle", "class": "cesium-animation-shuttleRingBack", cx: 100, cy: 100, r: 99});
            this._shuttleRingBackPanel = f;
            var g = u({
                tagName: "g",
                "class": "cesium-animation-shuttleRingSwoosh",
                children: [{
                    tagName: "use",
                    transform: "translate(100,97) scale(-1,1)",
                    "xlink:href": "#animation_pathSwooshFX"
                }, {
                    tagName: "use",
                    transform: "translate(100,97)",
                    "xlink:href": "#animation_pathSwooshFX"
                }, {tagName: "line", x1: 100, y1: 8, x2: 100, y2: 22}]
            });
            this._shuttleRingSwooshG = g, this._shuttleRingPointer = u({
                tagName: "use",
                "class": "cesium-animation-shuttleRingPointer",
                "xlink:href": "#animation_pathPointer"
            });
            var y = u({tagName: "g", transform: "translate(100,100)"});
            this._knobOuter = u({tagName: "circle", "class": "cesium-animation-knobOuter", cx: 0, cy: 0, r: 71});
            var C = 61, E = u({tagName: "circle", "class": "cesium-animation-knobInner", cx: 0, cy: 0, r: C});
            this._knobDate = l(0, -24, ""), this._knobTime = l(0, -7, ""), this._knobStatus = l(0, -41, "");
            var S = u({
                tagName: "circle",
                "class": "cesium-animation-blank",
                cx: 0,
                cy: 0,
                r: C
            }), T = document.createElementNS(_, "g");
            T.setAttribute("class", "cesium-animation-shuttleRingG"), e.appendChild(n), s.appendChild(T), s.appendChild(y), s.appendChild(h), T.appendChild(f), T.appendChild(g), T.appendChild(this._shuttleRingPointer), y.appendChild(this._knobOuter), y.appendChild(E), y.appendChild(this._knobDate), y.appendChild(this._knobTime), y.appendChild(this._knobStatus), y.appendChild(S), r.appendChild(s), e.appendChild(r);
            var b = this, w = function (e) {
                p(b, e)
            };
            this._mouseCallback = w, f.addEventListener("mousedown", w, !0), f.addEventListener("touchstart", w, !0), g.addEventListener("mousedown", w, !0), g.addEventListener("touchstart", w, !0), document.addEventListener("mousemove", w, !0), document.addEventListener("touchmove", w, !0), document.addEventListener("mouseup", w, !0), document.addEventListener("touchend", w, !0), this._shuttleRingPointer.addEventListener("mousedown", w, !0), this._shuttleRingPointer.addEventListener("touchstart", w, !0), this._knobOuter.addEventListener("mousedown", w, !0), this._knobOuter.addEventListener("touchstart", w, !0);
            var x, P = this._knobTime.childNodes[0], I = this._knobDate.childNodes[0], D = this._knobStatus.childNodes[0];
            this._subscriptions = [a(t.pauseViewModel, "toggled", function (e) {
                x !== e && (x = e, x ? b._shuttleRingPointer.setAttribute("class", "cesium-animation-shuttleRingPausePointer") : b._shuttleRingPointer.setAttribute("class", "cesium-animation-shuttleRingPointer"))
            }), a(t, "shuttleRingAngle", function (e) {
                c(b._shuttleRingPointer, b._knobOuter, e)
            }), a(t, "dateLabel", function (e) {
                I.textContent !== e && (I.textContent = e)
            }), a(t, "timeLabel", function (e) {
                P.textContent !== e && (P.textContent = e)
            }), a(t, "multiplierLabel", function (e) {
                D.textContent !== e && (D.textContent = e)
            })], this.applyThemeChanges(), this.resize()
        };
        return i(P.prototype, {
            container: {
                get: function () {
                    return this._container
                }
            }, viewModel: {
                get: function () {
                    return this._viewModel
                }
            }
        }), P.prototype.isDestroyed = function () {
            return !1
        }, P.prototype.destroy = function () {
            var e = this._mouseCallback;
            this._shuttleRingBackPanel.removeEventListener("mousedown", e, !0), this._shuttleRingBackPanel.removeEventListener("touchstart", e, !0), this._shuttleRingSwooshG.removeEventListener("mousedown", e, !0), this._shuttleRingSwooshG.removeEventListener("touchstart", e, !0), document.removeEventListener("mousemove", e, !0), document.removeEventListener("touchmove", e, !0), document.removeEventListener("mouseup", e, !0), document.removeEventListener("touchend", e, !0), this._shuttleRingPointer.removeEventListener("mousedown", e, !0), this._shuttleRingPointer.removeEventListener("touchstart", e, !0), this._knobOuter.removeEventListener("mousedown", e, !0), this._knobOuter.removeEventListener("touchstart", e, !0), this._container.removeChild(this._svgNode), this._container.removeChild(this._theme), this._realtimeSVG.destroy(), this._playReverseSVG.destroy(), this._playForwardSVG.destroy(), this._pauseSVG.destroy();
            for (var t = this._subscriptions, i = 0, r = t.length; r > i; i++)t[i].dispose();
            return n(this)
        }, P.prototype.resize = function () {
            var e = this._container.clientWidth, t = this._container.clientHeight;
            if (e !== this._lastWidth || t !== this._lastHeight) {
                var i = this._svgNode, n = 200, r = 132, o = e, a = t;
                0 === e && 0 === t ? (o = n, a = r) : 0 === e ? (a = t, o = n * (t / r)) : 0 === t && (o = e, a = r * (e / n));
                var s = o / n, u = a / r;
                i.style.cssText = "width: " + o + "px; height: " + a + "px; position: absolute; bottom: 0; left: 0; overflow: hidden;", i.setAttribute("width", o), i.setAttribute("height", a), i.setAttribute("viewBox", "0 0 " + o + " " + a), this._topG.setAttribute("transform", "scale(" + s + "," + u + ")"), this._centerX = Math.max(1, 100 * s), this._centerY = Math.max(1, 100 * u), this._lastHeight = e, this._lastWidth = t
            }
        }, P.prototype.applyThemeChanges = function () {
            var e = s(this._themeNormal), i = s(this._themeHover), n = s(this._themeSelect), r = s(this._themeDisabled), o = s(this._themeKnob), a = s(this._themePointer), l = s(this._themeSwoosh), c = s(this._themeSwooshHover), d = u({
                tagName: "defs",
                children: [{
                    id: "animation_buttonNormal",
                    tagName: "linearGradient",
                    x1: "50%",
                    y1: "0%",
                    x2: "50%",
                    y2: "100%",
                    children: [{tagName: "stop", offset: "0%", "stop-color": h(e, g)}, {
                        tagName: "stop",
                        offset: "12%",
                        "stop-color": h(e, y)
                    }, {tagName: "stop", offset: "46%", "stop-color": h(e, C)}, {
                        tagName: "stop",
                        offset: "81%",
                        "stop-color": h(e, E)
                    }]
                }, {
                    id: "animation_buttonHovered",
                    tagName: "linearGradient",
                    x1: "50%",
                    y1: "0%",
                    x2: "50%",
                    y2: "100%",
                    children: [{tagName: "stop", offset: "0%", "stop-color": h(i, g)}, {
                        tagName: "stop",
                        offset: "12%",
                        "stop-color": h(i, y)
                    }, {tagName: "stop", offset: "46%", "stop-color": h(i, C)}, {
                        tagName: "stop",
                        offset: "81%",
                        "stop-color": h(i, E)
                    }]
                }, {
                    id: "animation_buttonToggled",
                    tagName: "linearGradient",
                    x1: "50%",
                    y1: "0%",
                    x2: "50%",
                    y2: "100%",
                    children: [{tagName: "stop", offset: "0%", "stop-color": h(n, g)}, {
                        tagName: "stop",
                        offset: "12%",
                        "stop-color": h(n, y)
                    }, {tagName: "stop", offset: "46%", "stop-color": h(n, C)}, {
                        tagName: "stop",
                        offset: "81%",
                        "stop-color": h(n, E)
                    }]
                }, {
                    id: "animation_buttonDisabled",
                    tagName: "linearGradient",
                    x1: "50%",
                    y1: "0%",
                    x2: "50%",
                    y2: "100%",
                    children: [{tagName: "stop", offset: "0%", "stop-color": h(r, S)}, {
                        tagName: "stop",
                        offset: "75%",
                        "stop-color": h(r, T)
                    }]
                }, {
                    id: "animation_blurred",
                    tagName: "filter",
                    width: "200%",
                    height: "200%",
                    x: "-50%",
                    y: "-50%",
                    children: [{tagName: "feGaussianBlur", stdDeviation: 4, "in": "SourceGraphic"}]
                }, {
                    id: "animation_shuttleRingSwooshGradient",
                    tagName: "linearGradient",
                    x1: "50%",
                    y1: "0%",
                    x2: "50%",
                    y2: "100%",
                    children: [{
                        tagName: "stop",
                        offset: "0%",
                        "stop-opacity": .2,
                        "stop-color": l.toCssColorString()
                    }, {
                        tagName: "stop",
                        offset: "85%",
                        "stop-opacity": .85,
                        "stop-color": l.toCssColorString()
                    }, {tagName: "stop", offset: "95%", "stop-opacity": .05, "stop-color": l.toCssColorString()}]
                }, {
                    id: "animation_shuttleRingSwooshHovered",
                    tagName: "linearGradient",
                    x1: "50%",
                    y1: "0%",
                    x2: "50%",
                    y2: "100%",
                    children: [{
                        tagName: "stop",
                        offset: "0%",
                        "stop-opacity": .2,
                        "stop-color": c.toCssColorString()
                    }, {
                        tagName: "stop",
                        offset: "85%",
                        "stop-opacity": .85,
                        "stop-color": c.toCssColorString()
                    }, {tagName: "stop", offset: "95%", "stop-opacity": .05, "stop-color": c.toCssColorString()}]
                }, {
                    id: "animation_shuttleRingPointerGradient",
                    tagName: "linearGradient",
                    x1: "0%",
                    y1: "50%",
                    x2: "100%",
                    y2: "50%",
                    children: [{tagName: "stop", offset: "0%", "stop-color": a.toCssColorString()}, {
                        tagName: "stop",
                        offset: "40%",
                        "stop-color": a.toCssColorString()
                    }, {tagName: "stop", offset: "60%", "stop-color": h(a, w)}, {
                        tagName: "stop",
                        offset: "100%",
                        "stop-color": h(a, w)
                    }]
                }, {
                    id: "animation_shuttleRingPointerPaused",
                    tagName: "linearGradient",
                    x1: "0%",
                    y1: "50%",
                    x2: "100%",
                    y2: "50%",
                    children: [{tagName: "stop", offset: "0%", "stop-color": "#CCC"}, {
                        tagName: "stop",
                        offset: "40%",
                        "stop-color": "#CCC"
                    }, {tagName: "stop", offset: "60%", "stop-color": "#555"}, {
                        tagName: "stop",
                        offset: "100%",
                        "stop-color": "#555"
                    }]
                }, {
                    id: "animation_knobOuter",
                    tagName: "linearGradient",
                    x1: "20%",
                    y1: "0%",
                    x2: "90%",
                    y2: "100%",
                    children: [{tagName: "stop", offset: "5%", "stop-color": h(o, g)}, {
                        tagName: "stop",
                        offset: "60%",
                        "stop-color": h(o, b)
                    }, {tagName: "stop", offset: "85%", "stop-color": h(o, y)}]
                }, {
                    id: "animation_knobInner",
                    tagName: "linearGradient",
                    x1: "20%",
                    y1: "0%",
                    x2: "90%",
                    y2: "100%",
                    children: [{tagName: "stop", offset: "5%", "stop-color": h(o, b)}, {
                        tagName: "stop",
                        offset: "60%",
                        "stop-color": h(o, g)
                    }, {tagName: "stop", offset: "85%", "stop-color": h(o, E)}]
                }, {
                    id: "animation_pathReset",
                    tagName: "path",
                    transform: "translate(16,16) scale(0.85) translate(-16,-16)",
                    d: "M24.316,5.318,9.833,13.682,9.833,5.5,5.5,5.5,5.5,25.5,9.833,25.5,9.833,17.318,24.316,25.682z"
                }, {
                    id: "animation_pathPause",
                    tagName: "path",
                    transform: "translate(16,16) scale(0.85) translate(-16,-16)",
                    d: "M13,5.5,7.5,5.5,7.5,25.5,13,25.5zM24.5,5.5,19,5.5,19,25.5,24.5,25.5z"
                }, {
                    id: "animation_pathPlay",
                    tagName: "path",
                    transform: "translate(16,16) scale(0.85) translate(-16,-16)",
                    d: "M6.684,25.682L24.316,15.5L6.684,5.318V25.682z"
                }, {
                    id: "animation_pathPlayReverse",
                    tagName: "path",
                    transform: "translate(16,16) scale(-0.85,0.85) translate(-16,-16)",
                    d: "M6.684,25.682L24.316,15.5L6.684,5.318V25.682z"
                }, {
                    id: "animation_pathLoop",
                    tagName: "path",
                    transform: "translate(16,16) scale(0.85) translate(-16,-16)",
                    d: "M24.249,15.499c-0.009,4.832-3.918,8.741-8.75,8.75c-2.515,0-4.768-1.064-6.365-2.763l2.068-1.442l-7.901-3.703l0.744,8.694l2.193-1.529c2.244,2.594,5.562,4.242,9.26,4.242c6.767,0,12.249-5.482,12.249-12.249H24.249zM15.499,6.75c2.516,0,4.769,1.065,6.367,2.764l-2.068,1.443l7.901,3.701l-0.746-8.693l-2.192,1.529c-2.245-2.594-5.562-4.245-9.262-4.245C8.734,3.25,3.25,8.734,3.249,15.499H6.75C6.758,10.668,10.668,6.758,15.499,6.75z"
                }, {
                    id: "animation_pathClock",
                    tagName: "path",
                    transform: "translate(16,16) scale(0.85) translate(-16,-15.5)",
                    d: "M15.5,2.374C8.251,2.375,2.376,8.251,2.374,15.5C2.376,22.748,8.251,28.623,15.5,28.627c7.249-0.004,13.124-5.879,13.125-13.127C28.624,8.251,22.749,2.375,15.5,2.374zM15.5,25.623C9.909,25.615,5.385,21.09,5.375,15.5C5.385,9.909,9.909,5.384,15.5,5.374c5.59,0.01,10.115,4.535,10.124,10.125C25.615,21.09,21.091,25.615,15.5,25.623zM8.625,15.5c-0.001-0.552-0.448-0.999-1.001-1c-0.553,0-1,0.448-1,1c0,0.553,0.449,1,1,1C8.176,16.5,8.624,16.053,8.625,15.5zM8.179,18.572c-0.478,0.277-0.642,0.889-0.365,1.367c0.275,0.479,0.889,0.641,1.365,0.365c0.479-0.275,0.643-0.887,0.367-1.367C9.27,18.461,8.658,18.297,8.179,18.572zM9.18,10.696c-0.479-0.276-1.09-0.112-1.366,0.366s-0.111,1.09,0.365,1.366c0.479,0.276,1.09,0.113,1.367-0.366C9.821,11.584,9.657,10.973,9.18,10.696zM22.822,12.428c0.478-0.275,0.643-0.888,0.366-1.366c-0.275-0.478-0.89-0.642-1.366-0.366c-0.479,0.278-0.642,0.89-0.366,1.367C21.732,12.54,22.344,12.705,22.822,12.428zM12.062,21.455c-0.478-0.275-1.089-0.111-1.366,0.367c-0.275,0.479-0.111,1.09,0.366,1.365c0.478,0.277,1.091,0.111,1.365-0.365C12.704,22.344,12.54,21.732,12.062,21.455zM12.062,9.545c0.479-0.276,0.642-0.888,0.366-1.366c-0.276-0.478-0.888-0.642-1.366-0.366s-0.642,0.888-0.366,1.366C10.973,9.658,11.584,9.822,12.062,9.545zM22.823,18.572c-0.48-0.275-1.092-0.111-1.367,0.365c-0.275,0.479-0.112,1.092,0.367,1.367c0.477,0.275,1.089,0.113,1.365-0.365C23.464,19.461,23.3,18.848,22.823,18.572zM19.938,7.813c-0.477-0.276-1.091-0.111-1.365,0.366c-0.275,0.48-0.111,1.091,0.366,1.367s1.089,0.112,1.366-0.366C20.581,8.702,20.418,8.089,19.938,7.813zM23.378,14.5c-0.554,0.002-1.001,0.45-1.001,1c0.001,0.552,0.448,1,1.001,1c0.551,0,1-0.447,1-1C24.378,14.949,23.929,14.5,23.378,14.5zM15.501,6.624c-0.552,0-1,0.448-1,1l-0.466,7.343l-3.004,1.96c-0.478,0.277-0.642,0.889-0.365,1.365c0.275,0.479,0.889,0.643,1.365,0.367l3.305-1.676C15.39,16.99,15.444,17,15.501,17c0.828,0,1.5-0.671,1.5-1.5l-0.5-7.876C16.501,7.072,16.053,6.624,15.501,6.624zM15.501,22.377c-0.552,0-1,0.447-1,1s0.448,1,1,1s1-0.447,1-1S16.053,22.377,15.501,22.377zM18.939,21.455c-0.479,0.277-0.643,0.889-0.366,1.367c0.275,0.477,0.888,0.643,1.366,0.365c0.478-0.275,0.642-0.889,0.366-1.365C20.028,21.344,19.417,21.18,18.939,21.455z"
                }, {
                    id: "animation_pathWingButton",
                    tagName: "path",
                    d: "m 4.5,0.5 c -2.216,0 -4,1.784 -4,4 l 0,24 c 0,2.216 1.784,4 4,4 l 13.71875,0 C 22.478584,27.272785 27.273681,22.511272 32.5,18.25 l 0,-13.75 c 0,-2.216 -1.784,-4 -4,-4 l -24,0 z"
                }, {
                    id: "animation_pathPointer",
                    tagName: "path",
                    d: "M-15,-65,-15,-55,15,-55,15,-65,0,-95z"
                }, {
                    id: "animation_pathSwooshFX",
                    tagName: "path",
                    d: "m 85,0 c 0,16.617 -4.813944,35.356 -13.131081,48.4508 h 6.099803 c 8.317138,-13.0948 13.13322,-28.5955 13.13322,-45.2124 0,-46.94483 -38.402714,-85.00262 -85.7743869,-85.00262 -1.0218522,0 -2.0373001,0.0241 -3.0506131,0.0589 45.958443,1.59437 82.723058,35.77285 82.723058,81.70532 z"
                }]
            });
            t(this._defsElement) ? this._svgNode.replaceChild(d, this._defsElement) : this._svgNode.appendChild(d), this._defsElement = d
        }, P
    }),define("Cesium/Core/ClockRange", ["./freezeObject"], function (e) {
        "use strict";
        var t = {UNBOUNDED: 0, CLAMPED: 1, LOOP_STOP: 2};
        return e(t)
    }),define("Cesium/Core/ClockStep", ["./freezeObject"], function (e) {
        "use strict";
        var t = {TICK_DEPENDENT: 0, SYSTEM_CLOCK_MULTIPLIER: 1, SYSTEM_CLOCK: 2};
        return e(t)
    }),define("Cesium/Widgets/createCommand", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "../ThirdParty/knockout"], function (e, t, i, n, r, o) {
        "use strict";
        var a = function (t, n) {
            function a() {
                var e, i = {args: arguments, cancel: !1};
                return s.raiseEvent(i), i.cancel || (e = t.apply(null, arguments), u.raiseEvent(e)), e
            }

            n = e(n, !0);
            var s = new r, u = new r;
            return a.canExecute = n, o.track(a, ["canExecute"]), i(a, {
                beforeExecute: {value: s},
                afterExecute: {value: u}
            }), a
        };
        return a
    }),define("Cesium/Widgets/ToggleButtonViewModel", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../ThirdParty/knockout"], function (e, t, i, n, r) {
        "use strict";
        var o = function (t, i) {
            this._command = t, i = e(i, e.EMPTY_OBJECT), this.toggled = e(i.toggled, !1), this.tooltip = e(i.tooltip, ""), r.track(this, ["toggled", "tooltip"])
        };
        return i(o.prototype, {
            command: {
                get: function () {
                    return this._command
                }
            }
        }), o
    }),define("Cesium/Widgets/Animation/AnimationViewModel", ["../../Core/binarySearch", "../../Core/ClockRange", "../../Core/ClockStep", "../../Core/defined", "../../Core/defineProperties", "../../Core/DeveloperError", "../../Core/JulianDate", "../../ThirdParty/knockout", "../../ThirdParty/sprintf", "../createCommand", "../ToggleButtonViewModel"], function (e, t, i, n, r, o, a, s, u, l, c) {
        "use strict";
        function h(e) {
            e.clockStep === i.SYSTEM_CLOCK && (e.clockStep = i.SYSTEM_CLOCK_MULTIPLIER, e.multiplier = 1)
        }

        function d(e) {
            h(e), e.shouldAnimate = !0
        }

        function m(e, t) {
            return e - t
        }

        function p(t, i) {
            var n = e(i, t, m);
            return 0 > n ? ~n : n
        }

        function f(e, t) {
            if (Math.abs(e) <= g)return e / g;
            var i, n, r = g, o = y, a = 0;
            return e > 0 ? (i = Math.log(t[t.length - 1]), n = (i - a) / (o - r), Math.exp(a + n * (e - r))) : (i = Math.log(-t[0]), n = (i - a) / (o - r), -Math.exp(a + n * (Math.abs(e) - r)))
        }

        function _(e, t, n) {
            if (n.clockStep === i.SYSTEM_CLOCK)return g;
            if (Math.abs(e) <= 1)return e * g;
            var r, o, a = g, s = y, u = 0;
            return e > 0 ? (r = Math.log(t[t.length - 1]), o = (r - u) / (s - a), (Math.log(e) - u) / o + a) : (r = Math.log(-t[0]), o = (r - u) / (s - a), -((Math.log(Math.abs(e)) - u) / o + a))
        }

        var v = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], g = 15, y = 105, C = function (e) {
            var n = this;
            this._clockViewModel = e, this._allShuttleRingTicks = [], this._dateFormatter = C.defaultDateFormatter, this._timeFormatter = C.defaultTimeFormatter, this.shuttleRingDragging = !1, this.snapToTicks = !1, s.track(this, ["_allShuttleRingTicks", "_dateFormatter", "_timeFormatter", "shuttleRingDragging", "snapToTicks"]), this._sortedFilteredPositiveTicks = [], this.setShuttleRingTicks(C.defaultTicks), this.timeLabel = void 0, s.defineProperty(this, "timeLabel", function () {
                return n._timeFormatter(n._clockViewModel.currentTime, n)
            }), this.dateLabel = void 0, s.defineProperty(this, "dateLabel", function () {
                return n._dateFormatter(n._clockViewModel.currentTime, n)
            }), this.multiplierLabel = void 0, s.defineProperty(this, "multiplierLabel", function () {
                var e = n._clockViewModel;
                if (e.clockStep === i.SYSTEM_CLOCK)return "Today";
                var t = e.multiplier;
                return t % 1 === 0 ? t.toFixed(0) + "x" : t.toFixed(3).replace(/0{0,3}$/, "") + "x"
            }), this.shuttleRingAngle = void 0, s.defineProperty(this, "shuttleRingAngle", {
                get: function () {
                    return _(e.multiplier, n._allShuttleRingTicks, e)
                }, set: function (e) {
                    e = Math.max(Math.min(e, y), -y);
                    var t = n._allShuttleRingTicks, r = n._clockViewModel;
                    if (r.clockStep = i.SYSTEM_CLOCK_MULTIPLIER, Math.abs(e) === y)return void(r.multiplier = e > 0 ? t[t.length - 1] : t[0]);
                    var o = f(e, t);
                    if (n.snapToTicks)o = t[p(o, t)]; else if (0 !== o) {
                        var a = Math.abs(o);
                        if (a > 100) {
                            var s = a.toFixed(0).length - 2, u = Math.pow(10, s);
                            o = Math.round(o / u) * u | 0
                        } else a > g ? o = Math.round(o) : a > 1 ? o = +o.toFixed(1) : a > 0 && (o = +o.toFixed(2))
                    }
                    r.multiplier = o
                }
            }), this._canAnimate = void 0, s.defineProperty(this, "_canAnimate", function () {
                var e = n._clockViewModel, i = e.clockRange;
                if (n.shuttleRingDragging || i === t.UNBOUNDED)return !0;
                var r = e.multiplier, o = e.currentTime, s = e.startTime, u = !1;
                if (i === t.LOOP_STOP)u = a.greaterThan(o, s) || o.equals(s) && r > 0; else {
                    var l = e.stopTime;
                    u = a.greaterThan(o, s) && a.lessThan(o, l) || o.equals(s) && r > 0 || o.equals(l) && 0 > r
                }
                return u || (e.shouldAnimate = !1), u
            }), this._isSystemTimeAvailable = void 0, s.defineProperty(this, "_isSystemTimeAvailable", function () {
                var e = n._clockViewModel, i = e.clockRange;
                if (i === t.UNBOUNDED)return !0;
                var r = e.systemTime;
                return a.greaterThanOrEquals(r, e.startTime) && a.lessThanOrEquals(r, e.stopTime)
            }), this._isAnimating = void 0, s.defineProperty(this, "_isAnimating", function () {
                return n._clockViewModel.shouldAnimate && (n._canAnimate || n.shuttleRingDragging)
            });
            var r = l(function () {
                var e = n._clockViewModel;
                e.shouldAnimate ? (h(e), e.shouldAnimate = !1) : n._canAnimate && d(e)
            });
            this._pauseViewModel = new c(r, {
                toggled: s.computed(function () {
                    return !n._isAnimating
                }), tooltip: "Pause"
            });
            var o = l(function () {
                var e = n._clockViewModel;
                h(e);
                var t = e.multiplier;
                t > 0 && (e.multiplier = -t), e.shouldAnimate = !0
            });
            this._playReverseViewModel = new c(o, {
                toggled: s.computed(function () {
                    return n._isAnimating && e.multiplier < 0
                }), tooltip: "Play Reverse"
            });
            var u = l(function () {
                var e = n._clockViewModel;
                h(e);
                var t = e.multiplier;
                0 > t && (e.multiplier = -t), e.shouldAnimate = !0
            });
            this._playForwardViewModel = new c(u, {
                toggled: s.computed(function () {
                    return n._isAnimating && e.multiplier > 0 && e.clockStep !== i.SYSTEM_CLOCK
                }), tooltip: "Play Forward"
            });
            var m = l(function () {
                var e = n._clockViewModel;
                e.clockStep = i.SYSTEM_CLOCK, e.multiplier = 1, e.shouldAnimate = !0
            }, s.getObservable(this, "_isSystemTimeAvailable"));
            this._playRealtimeViewModel = new c(m, {
                toggled: s.computed(function () {
                    return e.shouldAnimate && e.clockStep === i.SYSTEM_CLOCK
                }), tooltip: s.computed(function () {
                    return n._isSystemTimeAvailable ? "Today (real-time)" : "Current time not in range"
                })
            }), this._slower = l(function () {
                var e = n._clockViewModel;
                h(e);
                var t = n._allShuttleRingTicks, i = e.multiplier, r = p(i, t) - 1;
                r >= 0 && (e.multiplier = t[r])
            }), this._faster = l(function () {
                var e = n._clockViewModel;
                h(e);
                var t = n._allShuttleRingTicks, i = e.multiplier, r = p(i, t) + 1;
                r < t.length && (e.multiplier = t[r])
            })
        };
        return C.defaultDateFormatter = function (e, t) {
            var i = a.toGregorianDate(e);
            return v[i.month - 1] + " " + i.day + " " + i.year
        }, C.defaultTicks = [.001, .002, .005, .01, .02, .05, .1, .25, .5, 1, 2, 5, 10, 15, 30, 60, 120, 300, 600, 900, 1800, 3600, 7200, 14400, 21600, 43200, 86400, 172800, 345600, 604800], C.defaultTimeFormatter = function (e, t) {
            var i = a.toGregorianDate(e), n = Math.round(i.millisecond);
            return Math.abs(t._clockViewModel.multiplier) < 1 ? u("%02d:%02d:%02d.%03d", i.hour, i.minute, i.second, n) : u("%02d:%02d:%02d UTC", i.hour, i.minute, i.second);
        }, C.prototype.getShuttleRingTicks = function () {
            return this._sortedFilteredPositiveTicks.slice(0)
        }, C.prototype.setShuttleRingTicks = function (e) {
            var t, i, n, r = {}, o = this._sortedFilteredPositiveTicks;
            for (o.length = 0, t = 0, i = e.length; i > t; ++t)n = e[t], r.hasOwnProperty(n) || (r[n] = !0, o.push(n));
            o.sort(m);
            var a = [];
            for (i = o.length, t = i - 1; t >= 0; --t)n = o[t], 0 !== n && a.push(-n);
            Array.prototype.push.apply(a, o), this._allShuttleRingTicks = a
        }, r(C.prototype, {
            slower: {
                get: function () {
                    return this._slower
                }
            }, faster: {
                get: function () {
                    return this._faster
                }
            }, clockViewModel: {
                get: function () {
                    return this._clockViewModel
                }
            }, pauseViewModel: {
                get: function () {
                    return this._pauseViewModel
                }
            }, playReverseViewModel: {
                get: function () {
                    return this._playReverseViewModel
                }
            }, playForwardViewModel: {
                get: function () {
                    return this._playForwardViewModel
                }
            }, playRealtimeViewModel: {
                get: function () {
                    return this._playRealtimeViewModel
                }
            }, dateFormatter: {
                get: function () {
                    return this._dateFormatter
                }, set: function (e) {
                    this._dateFormatter = e
                }
            }, timeFormatter: {
                get: function () {
                    return this._timeFormatter
                }, set: function (e) {
                    this._timeFormatter = e
                }
            }
        }), C._maxShuttleRingAngle = y, C._realtimeShuttleRingAngle = g, C
    }),define("Cesium/Core/GeographicTilingScheme", ["./Cartesian2", "./defaultValue", "./defined", "./defineProperties", "./DeveloperError", "./Ellipsoid", "./GeographicProjection", "./Math", "./Rectangle"], function (e, t, i, n, r, o, a, s, u) {
        "use strict";
        var l = function (e) {
            e = t(e, {}), this._ellipsoid = t(e.ellipsoid, o.WGS84), this._rectangle = t(e.rectangle, u.MAX_VALUE), this._projection = new a(this._ellipsoid), this._numberOfLevelZeroTilesX = t(e.numberOfLevelZeroTilesX, 2), this._numberOfLevelZeroTilesY = t(e.numberOfLevelZeroTilesY, 1)
        };
        return n(l.prototype, {
            ellipsoid: {
                get: function () {
                    return this._ellipsoid
                }
            }, rectangle: {
                get: function () {
                    return this._rectangle
                }
            }, projection: {
                get: function () {
                    return this._projection
                }
            }
        }), l.prototype.getNumberOfXTilesAtLevel = function (e) {
            return this._numberOfLevelZeroTilesX << e
        }, l.prototype.getNumberOfYTilesAtLevel = function (e) {
            return this._numberOfLevelZeroTilesY << e
        }, l.prototype.rectangleToNativeRectangle = function (e, t) {
            var n = s.toDegrees(e.west), r = s.toDegrees(e.south), o = s.toDegrees(e.east), a = s.toDegrees(e.north);
            return i(t) ? (t.west = n, t.south = r, t.east = o, t.north = a, t) : new u(n, r, o, a)
        }, l.prototype.tileXYToNativeRectangle = function (e, t, i, n) {
            var r = this.tileXYToRectangle(e, t, i, n);
            return r.west = s.toDegrees(r.west), r.south = s.toDegrees(r.south), r.east = s.toDegrees(r.east), r.north = s.toDegrees(r.north), r
        }, l.prototype.tileXYToRectangle = function (e, t, n, r) {
            var o = this._rectangle, a = this.getNumberOfXTilesAtLevel(n), s = this.getNumberOfYTilesAtLevel(n), l = o.width / a, c = e * l + o.west, h = (e + 1) * l + o.west, d = o.height / s, m = o.north - t * d, p = o.north - (t + 1) * d;
            return i(r) || (r = new u(c, p, h, m)), r.west = c, r.south = p, r.east = h, r.north = m, r
        }, l.prototype.positionToTileXY = function (t, n, r) {
            var o = this._rectangle;
            if (!u.contains(o, t))return void 0;
            var a = this.getNumberOfXTilesAtLevel(n), l = this.getNumberOfYTilesAtLevel(n), c = o.width / a, h = o.height / l, d = t.longitude;
            o.east < o.west && (d += s.TWO_PI);
            var m = (d - o.west) / c | 0;
            m >= a && (m = a - 1);
            var p = (o.north - t.latitude) / h | 0;
            return p >= l && (p = l - 1), i(r) ? (r.x = m, r.y = p, r) : new e(m, p)
        }, l
    }),define("Cesium/Core/HeightmapTessellator", ["./Cartesian3", "./defaultValue", "./defined", "./DeveloperError", "./Ellipsoid", "./freezeObject", "./Math", "./Rectangle"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        var u = {};
        return u.DEFAULT_STRUCTURE = o({
            heightScale: 1,
            heightOffset: 0,
            elementsPerHeight: 1,
            stride: 1,
            elementMultiplier: 256,
            isBigEndian: !1
        }), u.computeVertices = function (n) {
            var o, l, c, h, d = Math.cos, m = Math.sin, p = Math.sqrt, f = Math.atan, _ = Math.exp, v = a.PI_OVER_TWO, g = a.toRadians, y = n.vertices, C = n.heightmap, E = n.width, S = n.height, T = n.skirtHeight, b = t(n.isGeographic, !0), w = t(n.ellipsoid, r.WGS84), x = 1 / w.maximumRadius, A = n.nativeRectangle, P = n.rectangle;
            i(P) ? (o = P.west, l = P.south, c = P.east, h = P.north) : b ? (o = g(A.west), l = g(A.south), c = g(A.east), h = g(A.north)) : (o = A.west * x, l = v - 2 * f(_(-A.south * x)), c = A.east * x, h = v - 2 * f(_(-A.north * x)));
            var I = t(n.relativeToCenter, e.ZERO), D = t(n.structure, u.DEFAULT_STRUCTURE), M = t(D.heightScale, u.DEFAULT_STRUCTURE.heightScale), O = t(D.heightOffset, u.DEFAULT_STRUCTURE.heightOffset), R = t(D.elementsPerHeight, u.DEFAULT_STRUCTURE.elementsPerHeight), N = t(D.stride, u.DEFAULT_STRUCTURE.stride), L = t(D.elementMultiplier, u.DEFAULT_STRUCTURE.elementMultiplier), F = t(D.isBigEndian, u.DEFAULT_STRUCTURE.isBigEndian), B = s.computeWidth(A) / (E - 1), z = s.computeHeight(A) / (S - 1), V = w.radiiSquared, U = V.x, k = V.y, G = V.z, H = 0, W = 65536, q = -65536, j = 0, Y = S, X = 0, Z = E;
            T > 0 && (--j, ++Y, --X, ++Z);
            for (var K = j; Y > K; ++K) {
                var J = K;
                0 > J && (J = 0), J >= S && (J = S - 1);
                var Q = A.north - z * J;
                Q = b ? g(Q) : v - 2 * f(_(-Q * x));
                for (var $ = d(Q), ee = m(Q), te = G * ee, ie = (Q - l) / (h - l), ne = X; Z > ne; ++ne) {
                    var re = ne;
                    0 > re && (re = 0), re >= E && (re = E - 1);
                    var oe = A.west + B * re;
                    b ? oe = g(oe) : oe *= x;
                    var ae, se = J * E * N + re * N;
                    if (1 === R)ae = C[se]; else {
                        ae = 0;
                        var ue;
                        if (F)for (ue = 0; R > ue; ++ue)ae = ae * L + C[se + ue]; else for (ue = R - 1; ue >= 0; --ue)ae = ae * L + C[se + ue]
                    }
                    ae = ae * M + O, q = Math.max(q, ae), W = Math.min(W, ae), (ne !== re || K !== J) && (ae -= T);
                    var le = $ * d(oe), ce = $ * m(oe), he = U * le, de = k * ce, me = p(he * le + de * ce + te * ee), pe = 1 / me, fe = he * pe, _e = de * pe, ve = te * pe;
                    y[H++] = fe + le * ae - I.x, y[H++] = _e + ce * ae - I.y, y[H++] = ve + ee * ae - I.z, y[H++] = ae;
                    var ge = (oe - o) / (c - o);
                    y[H++] = ge, y[H++] = ie
                }
            }
            return {maximumHeight: q, minimumHeight: W}
        }, u
    }),define("Cesium/Core/TerrainMesh", ["../Core/defaultValue"], function (e) {
        "use strict";
        var t = function (t, i, n, r, o, a, s, u, l) {
            this.center = t, this.vertices = i, this.stride = e(u, 6), this.indices = n, this.minimumHeight = r, this.maximumHeight = o, this.boundingSphere3D = a, this.occludeePointInScaledSpace = s, this.orientedBoundingBox = l
        };
        return t
    }),define("Cesium/Core/TerrainProvider", ["./defined", "./defineProperties", "./DeveloperError"], function (e, t, i) {
        "use strict";
        var n = function () {
            i.throwInstantiationError()
        };
        t(n.prototype, {
            errorEvent: {get: i.throwInstantiationError},
            credit: {get: i.throwInstantiationError},
            tilingScheme: {get: i.throwInstantiationError},
            ready: {get: i.throwInstantiationError},
            hasWaterMask: {get: i.throwInstantiationError},
            hasVertexNormals: {get: i.throwInstantiationError}
        });
        var r = [];
        return n.getRegularGridIndices = function (t, i) {
            var n = r[t];
            e(n) || (r[t] = n = []);
            var o = n[i];
            if (!e(o)) {
                o = n[i] = new Uint16Array((t - 1) * (i - 1) * 6);
                for (var a = 0, s = 0, u = 0; i - 1 > u; ++u) {
                    for (var l = 0; t - 1 > l; ++l) {
                        var c = a, h = c + t, d = h + 1, m = c + 1;
                        o[s++] = c, o[s++] = h, o[s++] = m, o[s++] = m, o[s++] = h, o[s++] = d, ++a
                    }
                    ++a
                }
            }
            return o
        }, n.heightmapTerrainQuality = .25, n.getEstimatedLevelZeroGeometricErrorForAHeightmap = function (e, t, i) {
            return 2 * e.maximumRadius * Math.PI * n.heightmapTerrainQuality / (t * i)
        }, n.prototype.requestTileGeometry = i.throwInstantiationError, n.prototype.getLevelMaximumGeometricError = i.throwInstantiationError, n.prototype.getTileDataAvailable = i.throwInstantiationError, n
    }),define("Cesium/Core/HeightmapTerrainData", ["../ThirdParty/when", "./defaultValue", "./defined", "./defineProperties", "./DeveloperError", "./GeographicTilingScheme", "./HeightmapTessellator", "./Math", "./Rectangle", "./TaskProcessor", "./TerrainMesh", "./TerrainProvider"], function (e, t, i, n, r, o, a, s, u, l, c, h) {
        "use strict";
        function d(e, t, i, n, r, o, a, s) {
            var u = 1, l = e._width, c = e._height, h = o * (l - 1), d = h + l - 1, m = a * (c - 1), p = m + c - 1, f = 1 << u;
            h /= f, d /= f, m /= f, p /= f;
            var _ = i * (l - 1), v = n * (c - 1);
            h -= _, d -= _, m -= v, p -= v;
            var g, C, E = 0 | h, S = 0 | d, T = 0 | m, b = 0 | p, w = S - E + 1, x = b - T + 1, A = e._buffer, P = e._structure, I = w * x, D = I * P.stride, M = new A.constructor(D), O = 0, R = P.stride;
            if (R > 1)for (C = T; b >= C; ++C)for (g = E; S >= g; ++g)for (var N = (C * l + g) * R, L = 0; R > L; ++L)M[O++] = A[N + L]; else for (C = T; b >= C; ++C)for (g = E; S >= g; ++g)M[O++] = A[C * l + g];
            return new y({
                buffer: M,
                width: w,
                height: x,
                childTileMask: 0,
                structure: e._structure,
                createdByUpsampling: !0
            })
        }

        function m(e, t, i, n, r, o, a, u) {
            var l, c, h, d, m = e._width, _ = e._height, v = e._structure, C = v.stride, E = e._buffer, S = new E.constructor(m * _ * C), T = t.tileXYToRectangle(i, n, r), b = t.tileXYToRectangle(o, a, u);
            if (C > 1) {
                var w = v.elementsPerHeight, x = v.elementMultiplier, A = v.isBigEndian, P = Math.pow(x, w - 1);
                for (c = 0; _ > c; ++c)for (h = s.lerp(b.north, b.south, c / (_ - 1)), l = 0; m > l; ++l) {
                    d = s.lerp(b.west, b.east, l / (m - 1));
                    var I = f(E, w, x, C, A, T, m, _, d, h);
                    g(S, w, x, P, C, A, c * m + l, I)
                }
            } else for (c = 0; _ > c; ++c)for (h = s.lerp(b.north, b.south, c / (_ - 1)), l = 0; m > l; ++l)d = s.lerp(b.west, b.east, l / (m - 1)), S[c * m + l] = p(E, T, m, _, d, h);
            return new y({
                buffer: S,
                width: m,
                height: _,
                childTileMask: 0,
                structure: e._structure,
                createdByUpsampling: !0
            })
        }

        function p(e, t, i, n, r, o) {
            var a = (r - t.west) * (i - 1) / (t.east - t.west), s = (o - t.south) * (n - 1) / (t.north - t.south), u = 0 | a, l = u + 1;
            l >= i && (l = i - 1, u = i - 2);
            var c = 0 | s, h = c + 1;
            h >= n && (h = n - 1, c = n - 2);
            var d = a - u, m = s - c;
            c = n - 1 - c, h = n - 1 - h;
            var p = e[c * i + u], f = e[c * i + l], v = e[h * i + u], g = e[h * i + l];
            return _(d, m, p, f, v, g)
        }

        function f(e, t, i, n, r, o, a, s, u, l) {
            var c = (u - o.west) * (a - 1) / (o.east - o.west), h = (l - o.south) * (s - 1) / (o.north - o.south), d = 0 | c, m = d + 1;
            m >= a && (m = a - 1, d = a - 2);
            var p = 0 | h, f = p + 1;
            f >= s && (f = s - 1, p = s - 2);
            var g = c - d, y = h - p;
            p = s - 1 - p, f = s - 1 - f;
            var C = v(e, t, i, n, r, p * a + d), E = v(e, t, i, n, r, p * a + m), S = v(e, t, i, n, r, f * a + d), T = v(e, t, i, n, r, f * a + m);
            return _(g, y, C, E, S, T)
        }

        function _(e, t, i, n, r, o) {
            return e > t ? i + e * (n - i) + t * (o - n) : i + e * (o - r) + t * (r - i)
        }

        function v(e, t, i, n, r, o) {
            o *= n;
            var a, s = 0;
            if (r)for (a = 0; t > a; ++a)s = s * i + e[o + a]; else for (a = t - 1; a >= 0; --a)s = s * i + e[o + a];
            return s
        }

        function g(e, t, i, n, r, o, a, s) {
            a *= r;
            var u;
            if (o)for (u = 0; t > u; ++u)e[a + u] = s / n | 0, s -= e[a + u] * n, n /= i; else for (u = t - 1; u >= 0; --u)e[a + u] = s / n | 0, s -= e[a + u] * n, n /= i
        }

        var y = function (e) {
            this._buffer = e.buffer, this._width = e.width, this._height = e.height, this._childTileMask = t(e.childTileMask, 15);
            var n = a.DEFAULT_STRUCTURE, r = e.structure;
            i(r) ? r !== n && (r.heightScale = t(r.heightScale, n.heightScale), r.heightOffset = t(r.heightOffset, n.heightOffset), r.elementsPerHeight = t(r.elementsPerHeight, n.elementsPerHeight), r.stride = t(r.stride, n.stride), r.elementMultiplier = t(r.elementMultiplier, n.elementMultiplier), r.isBigEndian = t(r.isBigEndian, n.isBigEndian)) : r = n, this._structure = r, this._createdByUpsampling = t(e.createdByUpsampling, !1), this._waterMask = e.waterMask
        };
        n(y.prototype, {
            waterMask: {
                get: function () {
                    return this._waterMask
                }
            }
        });
        var C = new l("createVerticesFromHeightmap");
        return y.prototype.createMesh = function (t, n, r, a) {
            var s = t.ellipsoid, l = t.tileXYToNativeRectangle(n, r, a), d = t.tileXYToRectangle(n, r, a), m = s.cartographicToCartesian(u.center(d)), p = this._structure, f = h.getEstimatedLevelZeroGeometricErrorForAHeightmap(s, this._width, t.getNumberOfXTilesAtLevel(0)), _ = f / (1 << a), v = C.scheduleTask({
                heightmap: this._buffer,
                structure: p,
                width: this._width,
                height: this._height,
                nativeRectangle: l,
                rectangle: d,
                relativeToCenter: m,
                ellipsoid: s,
                skirtHeight: Math.min(4 * _, 1e3),
                isGeographic: t instanceof o
            });
            return i(v) ? e(v, function (e) {
                return new c(m, new Float32Array(e.vertices), h.getRegularGridIndices(e.gridWidth, e.gridHeight), e.minimumHeight, e.maximumHeight, e.boundingSphere3D, e.occludeePointInScaledSpace, 6, e.orientedBoundingBox)
            }) : void 0
        }, y.prototype.interpolateHeight = function (e, t, i) {
            var n, r = this._width, o = this._height, a = this._structure, s = a.stride;
            if (s > 1) {
                var u = a.elementsPerHeight, l = a.elementMultiplier, c = a.isBigEndian;
                n = f(this._buffer, u, l, s, c, e, r, o, t, i)
            } else n = p(this._buffer, e, r, o, t, i);
            return n * a.heightScale + a.heightOffset
        }, y.prototype.upsample = function (e, t, i, n, r, o, a) {
            var s;
            return s = this._width % 2 === 1 && this._height % 2 === 1 ? d(this, e, t, i, n, r, o, a) : m(this, e, t, i, n, r, o, a)
        }, y.prototype.isChildAvailable = function (e, t, i, n) {
            var r = 2;
            return i !== 2 * e && ++r, n !== 2 * t && (r -= 2), 0 !== (this._childTileMask & 1 << r)
        }, y.prototype.wasCreatedByUpsampling = function () {
            return this._createdByUpsampling
        }, y
    }),define("Cesium/Core/EllipsoidTerrainProvider", ["./defaultValue", "./defined", "./defineProperties", "./Ellipsoid", "./Event", "./GeographicTilingScheme", "./HeightmapTerrainData", "./TerrainProvider"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        var u = function (i) {
            i = e(i, {}), this._tilingScheme = i.tilingScheme, t(this._tilingScheme) || (this._tilingScheme = new o({ellipsoid: e(i.ellipsoid, n.WGS84)})), this._levelZeroMaximumGeometricError = s.getEstimatedLevelZeroGeometricErrorForAHeightmap(this._tilingScheme.ellipsoid, 64, this._tilingScheme.getNumberOfXTilesAtLevel(0));
            var u = 16, l = 16;
            this._terrainData = new a({buffer: new Uint8Array(u * l), width: 16, height: 16}), this._errorEvent = new r
        };
        return i(u.prototype, {
            errorEvent: {
                get: function () {
                    return this._errorEvent
                }
            }, credit: {
                get: function () {
                    return void 0
                }
            }, tilingScheme: {
                get: function () {
                    return this._tilingScheme
                }
            }, ready: {
                get: function () {
                    return !0
                }
            }, hasWaterMask: {
                get: function () {
                    return !1
                }
            }, hasVertexNormals: {
                get: function () {
                    return !1
                }
            }
        }), u.prototype.requestTileGeometry = function (e, t, i, n) {
            return this._terrainData
        }, u.prototype.getLevelMaximumGeometricError = function (e) {
            return this._levelZeroMaximumGeometricError / (1 << e)
        }, u.prototype.getTileDataAvailable = function (e, t, i) {
            return void 0
        }, u
    }),define("Cesium/Widgets/BaseLayerPicker/BaseLayerPickerViewModel", ["../../Core/defaultValue", "../../Core/defined", "../../Core/defineProperties", "../../Core/DeveloperError", "../../Core/EllipsoidTerrainProvider", "../../Core/isArray", "../../ThirdParty/knockout", "../createCommand"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        var u = function (i) {
            i = e(i, e.EMPTY_OBJECT);
            var n = i.globe, u = e(i.imageryProviderViewModels, []), l = e(i.terrainProviderViewModels, []);
            this._globe = n, this.imageryProviderViewModels = u.slice(0), this.terrainProviderViewModels = l.slice(0), this.dropDownVisible = !1, a.track(this, ["imageryProviderViewModels", "terrainProviderViewModels", "dropDownVisible"]), this.buttonTooltip = void 0, a.defineProperty(this, "buttonTooltip", function () {
                var e = this.selectedImagery, i = this.selectedTerrain, n = t(e) ? e.name : void 0, r = t(i) ? i.name : void 0;
                return t(n) && t(r) ? n + "\n" + r : t(n) ? n : r
            }), this.buttonImageUrl = void 0, a.defineProperty(this, "buttonImageUrl", function () {
                var e = this.selectedImagery;
                return t(e) ? e.iconUrl : void 0
            }), this.selectedImagery = void 0;
            var c = a.observable();
            this._currentImageryProviders = [], a.defineProperty(this, "selectedImagery", {
                get: function () {
                    return c()
                }, set: function (e) {
                    if (c() === e)return void(this.dropDownVisible = !1);
                    var i, n = this._currentImageryProviders, r = n.length, a = this._globe.imageryLayers;
                    for (i = 0; r > i; i++)for (var s = a.length, u = 0; s > u; u++) {
                        var l = a.get(u);
                        if (l.imageryProvider === n[i]) {
                            a.remove(l);
                            break
                        }
                    }
                    if (t(e)) {
                        var h = e.creationCommand();
                        if (o(h)) {
                            var d = h.length;
                            for (i = d - 1; i >= 0; i--)a.addImageryProvider(h[i], 0);
                            this._currentImageryProviders = h.slice(0)
                        } else this._currentImageryProviders = [h], a.addImageryProvider(h, 0)
                    }
                    c(e), this.dropDownVisible = !1
                }
            }), this.selectedTerrain = void 0;
            var h = a.observable();
            a.defineProperty(this, "selectedTerrain", {
                get: function () {
                    return h()
                }, set: function (e) {
                    if (h() === e)return void(this.dropDownVisible = !1);
                    var i;
                    t(e) && (i = e.creationCommand()), this._globe.depthTestAgainstTerrain = !(i instanceof r), this._globe.terrainProvider = i, h(e), this.dropDownVisible = !1
                }
            });
            var d = this;
            this._toggleDropDown = s(function () {
                d.dropDownVisible = !d.dropDownVisible
            }), this.selectedImagery = e(i.selectedImageryProviderViewModel, u[0]), this.selectedTerrain = e(i.selectedTerrainProviderViewModel, l[0])
        };
        return i(u.prototype, {
            toggleDropDown: {
                get: function () {
                    return this._toggleDropDown
                }
            }, globe: {
                get: function () {
                    return this._globe
                }
            }
        }), u
    }),define("Cesium/Widgets/BaseLayerPicker/BaseLayerPicker", ["../../Core/defined", "../../Core/defineProperties", "../../Core/destroyObject", "../../Core/DeveloperError", "../../Core/FeatureDetection", "../../ThirdParty/knockout", "../getElement", "./BaseLayerPickerViewModel"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        var u = function (e, t) {
            e = a(e);
            var i = new s(t), n = document.createElement("button");
            n.type = "button", n.className = "cesium-button cesium-toolbar-button", n.setAttribute("data-bind", "attr: { title: buttonTooltip },click: toggleDropDown"), e.appendChild(n);
            var u = document.createElement("img");
            u.setAttribute("draggable", "false"), u.className = "cesium-baseLayerPicker-selected", u.setAttribute("data-bind", "attr: { src: buttonImageUrl }"), n.appendChild(u);
            var l = document.createElement("div");
            l.className = "cesium-baseLayerPicker-dropDown", l.setAttribute("data-bind", 'css: { "cesium-baseLayerPicker-dropDown-visible" : dropDownVisible }'), e.appendChild(l);
            var c = document.createElement("div");
            c.className = "cesium-baseLayerPicker-sectionTitle", c.setAttribute("data-bind", "visible: imageryProviderViewModels.length > 0"), c.innerHTML = "Imagery", l.appendChild(c);
            var h = document.createElement("div");
            h.className = "cesium-baseLayerPicker-choices", h.setAttribute("data-bind", "foreach: imageryProviderViewModels"), l.appendChild(h);
            var d = document.createElement("div");
            d.className = "cesium-baseLayerPicker-item", d.setAttribute("data-bind", 'css: { "cesium-baseLayerPicker-selectedItem" : $data === $parent.selectedImagery },attr: { title: tooltip },visible: creationCommand.canExecute,click: function($data) { $parent.selectedImagery = $data; }'), h.appendChild(d);
            var m = document.createElement("img");
            m.className = "cesium-baseLayerPicker-itemIcon", m.setAttribute("data-bind", "attr: { src: iconUrl }"), m.setAttribute("draggable", "false"), d.appendChild(m);
            var p = document.createElement("div");
            p.className = "cesium-baseLayerPicker-itemLabel", p.setAttribute("data-bind", "text: name"), d.appendChild(p);
            var f = document.createElement("div");
            f.className = "cesium-baseLayerPicker-sectionTitle", f.setAttribute("data-bind", "visible: terrainProviderViewModels.length > 0"), f.innerHTML = "Terrain", l.appendChild(f);
            var _ = document.createElement("div");
            _.className = "cesium-baseLayerPicker-choices", _.setAttribute("data-bind", "foreach: terrainProviderViewModels"), l.appendChild(_);
            var v = document.createElement("div");
            v.className = "cesium-baseLayerPicker-item", v.setAttribute("data-bind", 'css: { "cesium-baseLayerPicker-selectedItem" : $data === $parent.selectedTerrain },attr: { title: tooltip },visible: creationCommand.canExecute,click: function($data) { $parent.selectedTerrain = $data; }'), _.appendChild(v);
            var g = document.createElement("img");
            g.className = "cesium-baseLayerPicker-itemIcon", g.setAttribute("data-bind", "attr: { src: iconUrl }"), g.setAttribute("draggable", "false"), v.appendChild(g);
            var y = document.createElement("div");
            y.className = "cesium-baseLayerPicker-itemLabel", y.setAttribute("data-bind", "text: name"), v.appendChild(y), o.applyBindings(i, n), o.applyBindings(i, l), this._viewModel = i, this._container = e, this._element = n, this._dropPanel = l, this._closeDropDown = function (e) {
                n.contains(e.target) || l.contains(e.target) || (i.dropDownVisible = !1)
            }, r.supportsPointerEvents() ? document.addEventListener("pointerdown", this._closeDropDown, !0) : (document.addEventListener("mousedown", this._closeDropDown, !0), document.addEventListener("touchstart", this._closeDropDown, !0))
        };
        return t(u.prototype, {
            container: {
                get: function () {
                    return this._container
                }
            }, viewModel: {
                get: function () {
                    return this._viewModel
                }
            }
        }), u.prototype.isDestroyed = function () {
            return !1
        }, u.prototype.destroy = function () {
            return r.supportsPointerEvents() ? document.removeEventListener("pointerdown", this._closeDropDown, !0) : (document.removeEventListener("mousedown", this._closeDropDown, !0), document.removeEventListener("touchstart", this._closeDropDown, !0)), o.cleanNode(this._element), o.cleanNode(this._dropPanel), this._container.removeChild(this._element), this._container.removeChild(this._dropPanel), i(this)
        }, u
    }),define("Cesium/Core/jsonp", ["../ThirdParty/Uri", "../ThirdParty/when", "./combine", "./defaultValue", "./defined", "./DeveloperError", "./objectToQuery", "./queryToObject"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        var u = function (o, l) {
            l = n(l, n.EMPTY_OBJECT);
            var c;
            do c = "jsonp" + Math.random().toString().substring(2, 8); while (r(window[c]));
            var h = t.defer();
            window[c] = function (e) {
                h.resolve(e);
                try {
                    delete window[c]
                } catch (t) {
                    window[c] = void 0
                }
            };
            var d = new e(o), m = s(n(d.query, ""));
            r(l.parameters) && (m = i(l.parameters, m));
            var p = n(l.callbackParameterName, "callback");
            m[p] = c, d.query = a(m), o = d.toString();
            var f = l.proxy;
            return r(f) && (o = f.getURL(o)), u.loadAndExecuteScript(o, c, h), h.promise
        };
        return u.loadAndExecuteScript = function (e, t, i) {
            var n = document.createElement("script");
            n.async = !0, n.src = e;
            var r = document.getElementsByTagName("head")[0];
            n.onload = function () {
                n.onload = void 0, r.removeChild(n)
            }, n.onerror = function (e) {
                i.reject(e)
            }, r.appendChild(n)
        }, u.defaultLoadAndExecuteScript = u.loadAndExecuteScript, u
    }),define("Cesium/Core/TileProviderError", ["./defaultValue", "./defined", "./formatError"], function (e, t, i) {
        "use strict";
        var n = function (t, i, n, r, o, a, s) {
            this.provider = t, this.message = i, this.x = n, this.y = r, this.level = o, this.timesRetried = e(a, 0), this.retry = !1, this.error = s
        };
        return n.handleError = function (e, r, o, a, s, u, l, c, h) {
            var d = e;
            return t(e) ? (d.provider = r, d.message = a, d.x = s, d.y = u, d.level = l, d.retry = !1, d.error = h, ++d.timesRetried) : d = new n(r, a, s, u, l, 0, h), o.numberOfListeners > 0 ? o.raiseEvent(d) : console.log('An error occurred in "' + r.constructor.name + '": ' + i(a)), d.retry && t(c) && c(), d
        }, n.handleSuccess = function (e) {
            t(e) && (e.timesRetried = -1)
        }, n
    }),define("Cesium/Core/WebMercatorTilingScheme", ["./Cartesian2", "./defaultValue", "./defined", "./defineProperties", "./Ellipsoid", "./Rectangle", "./WebMercatorProjection"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = function (n) {
            if (n = t(n, {}), this._ellipsoid = t(n.ellipsoid, r.WGS84), this._numberOfLevelZeroTilesX = t(n.numberOfLevelZeroTilesX, 1), this._numberOfLevelZeroTilesY = t(n.numberOfLevelZeroTilesY, 1), this._projection = new a(this._ellipsoid), i(n.rectangleSouthwestInMeters) && i(n.rectangleNortheastInMeters))this._rectangleSouthwestInMeters = n.rectangleSouthwestInMeters, this._rectangleNortheastInMeters = n.rectangleNortheastInMeters; else {
                var s = this._ellipsoid.maximumRadius * Math.PI;
                this._rectangleSouthwestInMeters = new e(-s, -s), this._rectangleNortheastInMeters = new e(s, s)
            }
            var u = this._projection.unproject(this._rectangleSouthwestInMeters), l = this._projection.unproject(this._rectangleNortheastInMeters);
            this._rectangle = new o(u.longitude, u.latitude, l.longitude, l.latitude)
        };
        return n(s.prototype, {
            ellipsoid: {
                get: function () {
                    return this._ellipsoid
                }
            }, rectangle: {
                get: function () {
                    return this._rectangle
                }
            }, projection: {
                get: function () {
                    return this._projection
                }
            }
        }), s.prototype.getNumberOfXTilesAtLevel = function (e) {
            return this._numberOfLevelZeroTilesX << e
        }, s.prototype.getNumberOfYTilesAtLevel = function (e) {
            return this._numberOfLevelZeroTilesY << e
        }, s.prototype.rectangleToNativeRectangle = function (e, t) {
            var n = this._projection, r = n.project(o.southwest(e)), a = n.project(o.northeast(e));
            return i(t) ? (t.west = r.x, t.south = r.y, t.east = a.x, t.north = a.y, t) : new o(r.x, r.y, a.x, a.y)
        }, s.prototype.tileXYToNativeRectangle = function (e, t, n, r) {
            var a = this.getNumberOfXTilesAtLevel(n), s = this.getNumberOfYTilesAtLevel(n), u = (this._rectangleNortheastInMeters.x - this._rectangleSouthwestInMeters.x) / a, l = this._rectangleSouthwestInMeters.x + e * u, c = this._rectangleSouthwestInMeters.x + (e + 1) * u, h = (this._rectangleNortheastInMeters.y - this._rectangleSouthwestInMeters.y) / s, d = this._rectangleNortheastInMeters.y - t * h, m = this._rectangleNortheastInMeters.y - (t + 1) * h;
            return i(r) ? (r.west = l, r.south = m, r.east = c, r.north = d, r) : new o(l, m, c, d)
        }, s.prototype.tileXYToRectangle = function (t, i, n, r) {
            var o = this.tileXYToNativeRectangle(t, i, n, r), a = this._projection, s = a.unproject(new e(o.west, o.south)), u = a.unproject(new e(o.east, o.north));
            return o.west = s.longitude, o.south = s.latitude, o.east = u.longitude, o.north = u.latitude, o
        }, s.prototype.positionToTileXY = function (t, n, r) {
            var a = this._rectangle;
            if (!o.contains(a, t))return void 0;
            var s = this.getNumberOfXTilesAtLevel(n), u = this.getNumberOfYTilesAtLevel(n), l = this._rectangleNortheastInMeters.x - this._rectangleSouthwestInMeters.x, c = l / s, h = this._rectangleNortheastInMeters.y - this._rectangleSouthwestInMeters.y, d = h / u, m = this._projection, p = m.project(t), f = p.x - this._rectangleSouthwestInMeters.x, _ = this._rectangleNortheastInMeters.y - p.y, v = f / c | 0;
            v >= s && (v = s - 1);
            var g = _ / d | 0;
            return g >= u && (g = u - 1), i(r) ? (r.x = v, r.y = g, r) : new e(v, g)
        }, s
    }),define("Cesium/Core/getImagePixels", ["./defined"], function (e) {
        "use strict";
        var t = {}, i = function (i, n, r) {
            e(n) || (n = i.width), e(r) || (r = i.height);
            var o = t[n];
            e(o) || (o = {}, t[n] = o);
            var a = o[r];
            if (!e(a)) {
                var s = document.createElement("canvas");
                s.width = n, s.height = r, a = s.getContext("2d"), a.globalCompositeOperation = "copy", o[r] = a
            }
            return a.drawImage(i, 0, 0, n, r), a.getImageData(0, 0, n, r).data
        };
        return i
    }),define("Cesium/Core/loadBlob", ["./loadWithXhr"], function (e) {
        "use strict";
        var t = function (t, i) {
            return e({url: t, responseType: "blob", headers: i})
        };
        return t
    }),define("Cesium/Core/loadImageViaBlob", ["../ThirdParty/when", "./loadBlob", "./loadImage"], function (e, t, i) {
        "use strict";
        var n = /^data:/, r = function (r) {
            return n.test(r) ? i(r) : t(r).then(function (t) {
                var n = window.URL.createObjectURL(t);
                return i(n, !1).then(function (e) {
                    return e.blob = t, window.URL.revokeObjectURL(n), e
                }, function (t) {
                    return window.URL.revokeObjectURL(n), e.reject(t)
                })
            })
        }, o = function () {
            try {
                var e = new XMLHttpRequest;
                return e.open("GET", "#", !0), e.responseType = "blob", "blob" === e.responseType
            } catch (t) {
                return !1
            }
        }();
        return o ? r : i
    }),define("Cesium/Scene/DiscardMissingTileImagePolicy", ["../Core/defaultValue", "../Core/defined", "../Core/DeveloperError", "../Core/getImagePixels", "../Core/loadImageViaBlob", "../ThirdParty/when"], function (e, t, i, n, r, o) {
        "use strict";
        var a = function (a) {
            function s(e) {
                t(e.blob) && (l._missingImageByteLength = e.blob.size);
                var i = n(e);
                if (a.disableCheckIfAllPixelsAreTransparent) {
                    for (var r = !0, o = e.width, s = a.pixelsToCheck, u = 0, c = s.length; r && c > u; ++u) {
                        var h = s[u], d = 4 * h.x + h.y * o, m = i[d + 3];
                        m > 0 && (r = !1)
                    }
                    r && (i = void 0)
                }
                l._missingImagePixels = i, l._isReady = !0
            }

            function u() {
                l._missingImagePixels = void 0, l._isReady = !0
            }

            if (a = e(a, e.EMPTY_OBJECT), !t(a.missingImageUrl))throw new i("options.missingImageUrl is required.");
            if (!t(a.pixelsToCheck))throw new i("options.pixelsToCheck is required.");
            this._pixelsToCheck = a.pixelsToCheck, this._missingImagePixels = void 0, this._missingImageByteLength = void 0, this._isReady = !1;
            var l = this;
            o(r(a.missingImageUrl), s, u)
        };
        return a.prototype.isReady = function () {
            return this._isReady
        }, a.prototype.shouldDiscardImage = function (e) {
            if (!this._isReady)throw new i("shouldDiscardImage must not be called before the discard policy is ready.");
            var r = this._pixelsToCheck, o = this._missingImagePixels;
            if (!t(o))return !1;
            if (t(e.blob) && e.blob.size !== this._missingImageByteLength)return !1;
            for (var a = n(e), s = e.width, u = 0, l = r.length; l > u; ++u)for (var c = r[u], h = 4 * c.x + c.y * s, d = 0; 4 > d; ++d) {
                var m = h + d;
                if (a[m] !== o[m])return !1
            }
            return !0
        }, a
    }),define("Cesium/Scene/ImageryLayerFeatureInfo", ["../Core/defined"], function (e) {
        "use strict";
        var t = function () {
            this.name = void 0, this.description = void 0, this.position = void 0, this.data = void 0
        };
        return t.prototype.configureNameFromProperties = function (t) {
            var i, n = 10;
            for (var r in t)if (t.hasOwnProperty(r) && t[r]) {
                var o = r.toLowerCase();
                n > 1 && "name" === o ? (n = 1, i = r) : n > 2 && "title" === o ? (n = 2, i = r) : n > 3 && /name/i.test(r) ? (n = 3, i = r) : n > 4 && /title/i.test(r) && (n = 4, i = r)
            }
            e(i) && (this.name = t[i])
        }, t.prototype.configureDescriptionFromProperties = function (t) {
            function i(t) {
                var n = '<table class="cesium-infoBox-defaultTable">';
                for (var r in t)if (t.hasOwnProperty(r)) {
                    var o = t[r];
                    e(o) && (n += "object" == typeof o ? "<tr><td>" + r + "</td><td>" + i(o) + "</td></tr>" : "<tr><td>" + r + "</td><td>" + o + "</td></tr>")
                }
                return n += "</table>"
            }

            this.description = i(t)
        }, t
    }),define("Cesium/Core/throttleRequestByServer", ["../ThirdParty/Uri", "../ThirdParty/when", "./defaultValue"], function (e, t, i) {
        "use strict";
        function n(t) {
            var i = new e(t).resolve(o);
            i.normalize();
            var n = i.authority;
            return /:/.test(n) || (n = n + ":" + ("https" === i.scheme ? "443" : "80")), n
        }

        var r = {}, o = new e(document.location.href), a = function (e, o) {
            var s = n(e), u = i(r[s], 0);
            return u >= a.maximumRequestsPerServer ? void 0 : (r[s] = u + 1, t(o(e), function (e) {
                return r[s]--, e
            }).otherwise(function (e) {
                return r[s]--, t.reject(e)
            }))
        };
        return a.maximumRequestsPerServer = 6, a
    }),define("Cesium/Scene/ImageryProvider", ["../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/loadImage", "../Core/loadImageViaBlob", "../Core/throttleRequestByServer"], function (e, t, i, n, r, o) {
        "use strict";
        var a = function () {
            this.defaultAlpha = void 0, this.defaultBrightness = void 0, this.defaultContrast = void 0, this.defaultHue = void 0, this.defaultSaturation = void 0, this.defaultGamma = void 0, i.throwInstantiationError()
        };
        return t(a.prototype, {
            ready: {get: i.throwInstantiationError},
            rectangle: {get: i.throwInstantiationError},
            tileWidth: {get: i.throwInstantiationError},
            tileHeight: {get: i.throwInstantiationError},
            maximumLevel: {get: i.throwInstantiationError},
            minimumLevel: {get: i.throwInstantiationError},
            tilingScheme: {get: i.throwInstantiationError},
            tileDiscardPolicy: {get: i.throwInstantiationError},
            errorEvent: {get: i.throwInstantiationError},
            credit: {get: i.throwInstantiationError},
            proxy: {get: i.throwInstantiationError},
            hasAlphaChannel: {get: i.throwInstantiationError}
        }), a.prototype.getTileCredits = i.throwInstantiationError, a.prototype.requestImage = i.throwInstantiationError, a.prototype.pickFeatures = i.throwInstantiationError, a.loadImage = function (t, i) {
            return e(t.tileDiscardPolicy) ? o(i, r) : o(i, n)
        }, a
    }),define("Cesium/Scene/ArcGisMapServerImageryProvider", ["../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartographic", "../Core/Math", "../Core/Credit", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "../Core/GeographicProjection", "../Core/GeographicTilingScheme", "../Core/jsonp", "../Core/loadJson", "../Core/Rectangle", "../Core/TileProviderError", "../Core/WebMercatorProjection", "../Core/WebMercatorTilingScheme", "../ThirdParty/when", "./DiscardMissingTileImagePolicy", "./ImageryLayerFeatureInfo", "./ImageryProvider"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E) {
        "use strict";
        function S(e, t, i, n) {
            var r;
            if (e._useTiles)r = e._url + "/tile/" + n + "/" + i + "/" + t; else {
                var o = e._tilingScheme.tileXYToNativeRectangle(t, i, n), s = o.west + "%2C" + o.south + "%2C" + o.east + "%2C" + o.north;
                r = e._url + "/export?", r += "bbox=" + s, r += e._tilingScheme instanceof h ? "&bboxSR=4326&imageSR=4326" : "&bboxSR=3857&imageSR=3857", r += "&size=" + e._tileWidth + "%2C" + e._tileHeight, r += "&format=png&transparent=true&f=image", e.layers && (r += "&layers=show:" + e.layers)
            }
            var u = e._token;
            a(u) && (-1 === r.indexOf("?") && (r += "?"), r += "token=" + u);
            var l = e._proxy;
            return a(l) && (r = l.getURL(r)), r
        }

        var T = function (t) {
            function i(i) {
                var n = i.tileInfo;
                if (a(n)) {
                    if (c._tileWidth = n.rows, c._tileHeight = n.cols, 102100 === n.spatialReference.wkid || 102113 === n.spatialReference.wkid)c._tilingScheme = new v({ellipsoid: t.ellipsoid}); else {
                        if (4326 !== i.tileInfo.spatialReference.wkid) {
                            var o = "Tile spatial reference WKID " + i.tileInfo.spatialReference.wkid + " is not supported.";
                            return void(u = f.handleError(u, c, c._errorEvent, o, void 0, void 0, void 0, s))
                        }
                        c._tilingScheme = new h({ellipsoid: t.ellipsoid})
                    }
                    if (c._maximumLevel = i.tileInfo.lods.length - 1, a(i.fullExtent)) {
                        if (a(i.fullExtent.spatialReference) && a(i.fullExtent.spatialReference.wkid))if (102100 === i.fullExtent.spatialReference.wkid || 102113 === i.fullExtent.spatialReference.wkid) {
                            var l = new _, d = l.unproject(new e(i.fullExtent.xmin, i.fullExtent.ymin)), m = l.unproject(new e(i.fullExtent.xmax, i.fullExtent.ymax));
                            c._rectangle = new p(d.longitude, d.latitude, m.longitude, m.latitude)
                        } else {
                            if (4326 !== i.fullExtent.spatialReference.wkid) {
                                var g = "fullExtent.spatialReference WKID " + i.fullExtent.spatialReference.wkid + " is not supported.";
                                return void(u = f.handleError(u, c, c._errorEvent, g, void 0, void 0, void 0, s))
                            }
                            c._rectangle = p.fromDegrees(i.fullExtent.xmin, i.fullExtent.ymin, i.fullExtent.xmax, i.fullExtent.ymax)
                        }
                    } else c._rectangle = c._tilingScheme.rectangle;
                    a(c._tileDiscardPolicy) || (c._tileDiscardPolicy = new y({
                        missingImageUrl: S(c, 0, 0, c._maximumLevel),
                        pixelsToCheck: [new e(0, 0), new e(200, 20), new e(20, 200), new e(80, 110), new e(160, 130)],
                        disableCheckIfAllPixelsAreTransparent: !0
                    })), c._useTiles = !0
                } else c._useTiles = !1;
                a(i.copyrightText) && i.copyrightText.length > 0 && (c._credit = new r(i.copyrightText)), c._ready = !0, f.handleSuccess(u)
            }

            function n(e) {
                var t = "An error occurred while accessing " + c._url + ".";
                u = f.handleError(u, c, c._errorEvent, t, void 0, void 0, void 0, s)
            }

            function s() {
                var e = {f: "json"};
                a(c._token) && (e.token = c._token);
                var t = d(c._url, {parameters: e, proxy: c._proxy});
                g(t, i, n)
            }

            t = o(t, {}), this._url = t.url, this._token = t.token, this._tileDiscardPolicy = t.tileDiscardPolicy, this._proxy = t.proxy, this._tileWidth = o(t.tileWidth, 256), this._tileHeight = o(t.tileHeight, 256), this._maximumLevel = t.maximumLevel, this._tilingScheme = o(t.tilingScheme, new h({ellipsoid: t.ellipsoid})), this._credit = void 0, this._useTiles = o(t.usePreCachedTilesIfAvailable, !0), this._rectangle = o(t.rectangle, this._tilingScheme.rectangle), this._layers = t.layers, this._enablePickFeatures = o(t.enablePickFeatures, !0), this._errorEvent = new l, this._ready = !1;
            var u, c = this;
            this._useTiles ? s() : this._ready = !0
        };
        return s(T.prototype, {
            url: {
                get: function () {
                    return this._url
                }
            }, token: {
                get: function () {
                    return this._token
                }
            }, proxy: {
                get: function () {
                    return this._proxy
                }
            }, tileWidth: {
                get: function () {
                    return this._tileWidth
                }
            }, tileHeight: {
                get: function () {
                    return this._tileHeight
                }
            }, maximumLevel: {
                get: function () {
                    return this._maximumLevel;
                }
            }, minimumLevel: {
                get: function () {
                    return 0
                }
            }, tilingScheme: {
                get: function () {
                    return this._tilingScheme
                }
            }, rectangle: {
                get: function () {
                    return this._rectangle
                }
            }, tileDiscardPolicy: {
                get: function () {
                    return this._tileDiscardPolicy
                }
            }, errorEvent: {
                get: function () {
                    return this._errorEvent
                }
            }, ready: {
                get: function () {
                    return this._ready
                }
            }, credit: {
                get: function () {
                    return this._credit
                }
            }, usingPrecachedTiles: {
                get: function () {
                    return this._useTiles
                }
            }, hasAlphaChannel: {
                get: function () {
                    return !0
                }
            }, layers: {
                get: function () {
                    return this._layers
                }
            }, enablePickFeatures: {
                get: function () {
                    return this._enablePickFeatures
                }
            }
        }), T.prototype.getTileCredits = function (e, t, i) {
            return void 0
        }, T.prototype.requestImage = function (e, t, i) {
            var n = S(this, e, t, i);
            return E.loadImage(this, n)
        }, T.prototype.pickFeatures = function (e, r, o, s, u) {
            if (!this._enablePickFeatures)return void 0;
            var l, c, d, p = this._tilingScheme.tileXYToNativeRectangle(e, r, o);
            if (this._tilingScheme instanceof h)l = n.toDegrees(s), c = n.toDegrees(u), d = "4326"; else {
                var f = this._tilingScheme.projection.project(new i(s, u, 0));
                l = f.x, c = f.y, d = "3857"
            }
            var v = this._url + "/identify?f=json&tolerance=2&geometryType=esriGeometryPoint";
            return v += "&geometry=" + l + "," + c, v += "&mapExtent=" + p.west + "," + p.south + "," + p.east + "," + p.north, v += "&imageDisplay=" + this._tileWidth + "," + this._tileHeight + ",96", v += "&sr=" + d, v += "&layers=visible", a(this._layers) && (v += ":" + this._layers), a(this._token) && (v += "&token=" + this._token), a(this._proxy) && (v = this._proxy.getURL(v)), m(v).then(function (e) {
                var n = [], r = e.results;
                if (!a(r))return n;
                for (var o = 0; o < r.length; ++o) {
                    var s = r[o], u = new C;
                    if (u.data = s, u.name = s.value, u.properties = s.attributes, u.configureDescriptionFromProperties(s.attributes), "esriGeometryPoint" === s.geometryType && s.geometry) {
                        var l = s.geometry.spatialReference && s.geometry.spatialReference.wkid ? s.geometry.spatialReference.wkid : 4326;
                        if (4326 === l || 4283 === l)u.position = i.fromDegrees(s.geometry.x, s.geometry.y, s.geometry.z); else if (102100 === l || 900913 === l || 3857 === l) {
                            var c = new _;
                            u.position = c.unproject(new t(s.geometry.x, s.geometry.y, s.geometry.z))
                        }
                    }
                    n.push(u)
                }
                return n
            })
        }, T
    }),define("Cesium/Scene/BingMapsStyle", ["../Core/freezeObject"], function (e) {
        "use strict";
        var t = {
            AERIAL: "Aerial",
            AERIAL_WITH_LABELS: "AerialWithLabels",
            ROAD: "Road",
            ORDNANCE_SURVEY: "OrdnanceSurvey",
            COLLINS_BART: "CollinsBart"
        };
        return e(t)
    }),define("Cesium/Scene/BingMapsImageryProvider", ["../Core/BingMapsApi", "../Core/Cartesian2", "../Core/Credit", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "../Core/jsonp", "../Core/Math", "../Core/Rectangle", "../Core/TileProviderError", "../Core/WebMercatorTilingScheme", "../ThirdParty/when", "./BingMapsStyle", "./DiscardMissingTileImagePolicy", "./ImageryProvider"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _) {
        "use strict";
        function v(e, t, i, n) {
            var o = e._imageUrlTemplate, a = y.tileXYToQuadKey(t, i, n);
            o = o.replace("{quadkey}", a);
            var s = e._imageUrlSubdomains, u = (t + i + n) % s.length;
            o = o.replace("{subdomain}", s[u]);
            var l = e._proxy;
            return r(l) && (o = l.getURL(o)), o
        }

        function g(e, t, i) {
            ++t;
            for (var n = [], o = 0, a = e.length; a > o; ++o) {
                for (var s = e[o], u = s.coverageAreas, l = !1, h = 0, d = s.coverageAreas.length; !l && d > h; ++h) {
                    var m = u[h];
                    if (t >= m.zoomMin && t <= m.zoomMax) {
                        var p = c.intersection(i, m.bbox, E);
                        r(p) && (l = !0)
                    }
                }
                l && n.push(s.credit)
            }
            return n
        }

        var y = function S(o) {
            function a(e) {
                var n = e.resourceSets[0].resources[0];
                E._tileWidth = n.imageWidth, E._tileHeight = n.imageHeight, E._maximumLevel = n.zoomMax - 1, E._imageUrlSubdomains = n.imageUrlSubdomains, E._imageUrlTemplate = n.imageUrl.replace("{culture}", E._culture);
                var o = E._tileProtocol;
                if (!r(o)) {
                    var a = document.location.protocol;
                    o = /^http/.test(a) ? a : "http:"
                }
                E._imageUrlTemplate = E._imageUrlTemplate.replace(/^http:/, o), r(E._tileDiscardPolicy) || (E._tileDiscardPolicy = new f({
                    missingImageUrl: v(E, 0, 0, E._maximumLevel),
                    pixelsToCheck: [new t(0, 0), new t(120, 140), new t(130, 160), new t(200, 50), new t(200, 200)],
                    disableCheckIfAllPixelsAreTransparent: !0
                }));
                var s = E._attributionList = n.imageryProviders;
                s || (s = E._attributionList = []);
                for (var u = 0, d = s.length; d > u; ++u) {
                    var m = s[u];
                    m.credit = new i(m.attribution);
                    for (var p = m.coverageAreas, _ = 0, g = m.coverageAreas.length; g > _; ++_) {
                        var C = p[_], S = C.bbox;
                        C.bbox = new c(l.toRadians(S[1]), l.toRadians(S[0]), l.toRadians(S[3]), l.toRadians(S[2]))
                    }
                }
                E._ready = !0, h.handleSuccess(y)
            }

            function _(e) {
                var t = "An error occurred while accessing " + C + ".";
                y = h.handleError(y, E, E._errorEvent, t, void 0, void 0, void 0, g)
            }

            function g() {
                var e = u(C, {callbackParameterName: "jsonp", proxy: E._proxy});
                m(e, a, _)
            }

            o = n(o, {}), this._key = e.getKey(o.key), this._url = o.url, this._tileProtocol = o.tileProtocol, this._mapStyle = n(o.mapStyle, p.AERIAL), this._culture = n(o.culture, ""), this._tileDiscardPolicy = o.tileDiscardPolicy, this._proxy = o.proxy, this._credit = new i("Bing Imagery", S._logoData, "http://www.bing.com"), this.defaultGamma = 1, (this._mapStyle === p.AERIAL || this._mapStyle === p.AERIAL_WITH_LABELS) && (this.defaultGamma = 1.3), this._tilingScheme = new d({
                numberOfLevelZeroTilesX: 2,
                numberOfLevelZeroTilesY: 2,
                ellipsoid: o.ellipsoid
            }), this._tileWidth = void 0, this._tileHeight = void 0, this._maximumLevel = void 0, this._imageUrlTemplate = void 0, this._imageUrlSubdomains = void 0, this._errorEvent = new s, this._ready = !1;
            var y, C = this._url + "/REST/v1/Imagery/Metadata/" + this._mapStyle + "?incl=ImageryProviders&key=" + this._key, E = this;
            g()
        };
        o(y.prototype, {
            url: {
                get: function () {
                    return this._url
                }
            }, proxy: {
                get: function () {
                    return this._proxy
                }
            }, key: {
                get: function () {
                    return this._key
                }
            }, mapStyle: {
                get: function () {
                    return this._mapStyle
                }
            }, culture: {
                get: function () {
                    return this._culture
                }
            }, tileWidth: {
                get: function () {
                    return this._tileWidth
                }
            }, tileHeight: {
                get: function () {
                    return this._tileHeight
                }
            }, maximumLevel: {
                get: function () {
                    return this._maximumLevel
                }
            }, minimumLevel: {
                get: function () {
                    return 0
                }
            }, tilingScheme: {
                get: function () {
                    return this._tilingScheme
                }
            }, rectangle: {
                get: function () {
                    return this._tilingScheme.rectangle
                }
            }, tileDiscardPolicy: {
                get: function () {
                    return this._tileDiscardPolicy
                }
            }, errorEvent: {
                get: function () {
                    return this._errorEvent
                }
            }, ready: {
                get: function () {
                    return this._ready
                }
            }, credit: {
                get: function () {
                    return this._credit
                }
            }, hasAlphaChannel: {
                get: function () {
                    return !1
                }
            }
        });
        var C = new c;
        y.prototype.getTileCredits = function (e, t, i) {
            if (!this._ready)throw new a("getTileCredits must not be called before the imagery provider is ready.");
            var n = this._tilingScheme.tileXYToRectangle(e, t, i, C);
            return g(this._attributionList, i, n)
        }, y.prototype.requestImage = function (e, t, i) {
            var n = v(this, e, t, i);
            return _.loadImage(this, n)
        }, y.prototype.pickFeatures = function () {
            return void 0
        }, y._logoData = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD0AAAAaCAYAAAAEy1RnAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH3gIDEgcPTMnXOQAAClZJREFUWMPdWGtsFNcV/u689uH1+sXaONhlWQzBENtxiUFBpBSLd60IpXHSNig4URtSYQUkRJNSi0igViVVVBJBaBsiAgKRQJSG8AgEHCCWU4iBCprY2MSgXfOI16y9D3s9Mzsztz9yB12WNU2i9Ecy0tHOzN4793zn3POdcy7BnRfJ8I7iB3SRDPeEExswLz8Y0DZIAYDIRGAgLQAm+7Xle31J3L3Anp1MZPY+BUBjorN332vgYhpgV1FRUd6TTz45ubq6OtDV1SXpuu5g//Oept9wNwlMyAi8IXDjyF245TsDTdivDMATCATGNDU1/WbhwoWPTZs2bWx1dXWhx+Oxrl+/PqTrus5t9W8KWEzjinTAYhro/xuBStwiIgBnJBLxKIoy1u/3V/r9/krDMMz3339/Z3t7e38ikUgCMDLEt8W+Q0cAI3McYTDDmZxh7DESG5Ni43jg9Gsa+X+OsxWxPSJTSj3JZFK5ZRVJErOzs8e6XC4fgGwALhbzDgAKU1hK28KEA6PMmTMn56233qpevnz5PQDcbJ7EzVUAuMrLy3MBeABkcWOEDELSyFe4y7iMoHkriZZlKYZh8ASHZDKpJJPJHAC5APIA5APIAeBlCjo5TwlpXnbOmTPHP3fu3KZVq1atZKBcDJQ9x7V48WJfc3Pzhp6enj+tXLnyR8w4MjdG4gyVDk7KICMClzKlLUrpbQMNw5AkScppbGz8cWdn57WjR4/2caw+DEBlYjO8wX1foZQWuN3uKZIklQD4G+fhlG0Yl8uVm5WVVW6app6dne0D0G8vnxbjJntHubCUOK/badZICyWanrJuAaeUknTQpmlKkUhEWbx48U8LCwtHhUKha+fPn+85fPhwV0tLyzUACSZx9jvMFhIByNFoVDEMw/qKB5HPvJfkUqBr9+7deklJyZ/j8bi5ffv2OAslieMLsG+m2DybT2QuzEQOsF5SUqJfvXo1yc2l6Xn6rgSRSCSEc+fOhVeuXLmwoqJixvTp0wcWLFgQ7unpudHR0dF97ty5z/fu3XseQJh5adjeerquy5ZlCalUivh8Pt8HH3ywzOPxyD09PZ81NjZ+2NnZaQEQx40b54vFYqaqquEVK1b4a2tr/WvWrDn18ssv144fP36SqqoD69ev371nz57rDLwAwHHkyJGfjRs3rtowDOv06dOnu7q6rs6bN2/s7Nmz9zIjDKenWoFZKg/AlMLCwl82Nzf/m3LX22+/fXb06NF/ALC8u7u7m6ZdkUhksL29/UpLS0vzunXrVgAoBzAaQBGAiY2NjUui0ei1RCLRFwwG/9PX19cVi8WCqqoOdHd3HysrK6sDMCccDl8IBoOtiqIsOnbs2D+i0eiV3t7ez8Ph8GeRSKRT07TB/v7+i1OnTp0HYBqABzs7O/+paVo0Fot1RyKRi/F4/Gp/f39XIpHoZnoUMn6wU+ZtRDaymwmxZFk2AWjvvvvuJ/F4PMn/n5+fn1VeXu6fOXNmbU1NzUOM4Bz8QqIoyg6HwxuLxfq3bdu2a+vWrW/09/dfKy0tffDVV199BEC20+n0ud3uQgBup9Pp83g8JYqieE+ePPnxxo0bt33xxRen8/Ly7n3hhRcWASh47bXX5pWVldWFw+GuXbt27XjzzTd3BoPBDq/XG1AUZRRHmAKPVfqaoKkgCCkA+oYNG84Eg0FHTU1N5ezZs8eWlJQ4CSF8/LvZYhJPQoQQpFKpwcrKyo1su9HBwUF99erVv588eXINgOOmacIwDEopdaZSKUIpxYkTJz6sr68/BMBav379RcMwZk2aNOl+AP+qq6t7xDTNVEVFxR+j0WgSAJk4ceKlTz/9tNzpdHpZvIvpjVW6pykhhBJCbkvwgiAQQogEQL558ybdtGlTsLm5OWJZdxZmlmWll5OUEEJN0zSGhob6GcOrALSzZ8/2apqWcLlc2axGACNRkRAimqaph0Kh68xIwwB0y7IMSZKcABz5+fkl8Xj8y2g0apOb5na7rYGBgS/JV54Q0qpAAoBKaS0jBWClg1ZVFeFw2AlgVF1dXeDpp5+eWVFRUVpcXOzgvQwAbrcbDJhdudlGpKZpGtx6JCcnRxIEQbQsS2PjbjM+AMvlchnMSBaXkr7ymCCIhmEYfMoVRVESBEHI0CaTTNubssUsQRBuubCtra33pZdeCk6YMCGwZs2aipqaGn9paWmuJEl3JP0bN258eeTIkRMABrm0YomiaImiKGVlZeWxLecAgBkzZvgdDkfWjRs3ggA0bpfpoiiahBCqKEqKAy2yULMA6MlkMp6Xl3cP1x2SWCwmFhQU+CmlFhfHNFOevpX4LcvSJUkyAeDQoUOh119//fpTTz01Zf78+UWBQCBHUZQ7yE/TNGPfvn0n33vvvSP79+//BECMeZsCMGRZNgRBgNPpHHXx4sVVDQ0Nf1+wYMGYJ554YikAevDgwUMA4oIgQJZlSggZdDqdBiGEZGdn6ww0tQlJURTT4/EMHz9+/MCjjz7622AwuHbZsmVbiouLvWvXrm1wOp3ZqVRqaKQTIInf1gAMl8ulU0q1CxcuBGOxmL5u3bryQCDgycrKEjORXGtra8eOHTsOHz169OyVK1cuA+hlRYrGlNRkWR7UNO2mYRiaz+cb3dLS8gYhhOi6Hj116tSOVatWHQNALcsaME0zLghClBDSZ9+zQsZ2SoJS2udwOKLPPffcvsrKyrJAIPDQ/v37txiGofX19V3r7e29UlBQMHqEVpjwnrYA6PF4PK6q6s2qqqqpZWVlitvtljOB7enpiWzbtu3wgQMHTre1tV0E0MeKkkGuIhMAqHv37u30er3Px+NxlyiKygMPPOAnhFiXLl0Kbd68uYPNsXbu3Lk6mUwaqqr2btmyZUdtbe3hd955pwvAEFNcO3jw4K/b2tqiqqpGIpGI4/HHH/9rQ0PDCa/XOyoSidDLly8PNTU1PcZ4QuNK1ju6NYHFRAGASXPnzv1Fa2vrxzTDpapqateuXR/Nnz+/SVGUhwFMBzCBFSLZLF75DsrJGpXRAH4EIABgPIBxAEoBFAPwARjFif1sNzZ25+VlOhaxufcCqAFQC+BhAPVLliz5XSqVUkOhUAuAKWnFyR3dlsw+fg+A+8eMGfPzTZs2bY9GozEb8JkzZ9qXLl36l+Li4l8B+AmAyQDGsGrOzfXNPGPawG2l85jksmcPm+vihH+2W1iF3bvZPN+sWbPuGx4eDrW3t+85fvz41o6OjmZN04Y0TYvV19cvYIbN5QqUjG2mwj5YAqDK4XDMe+aZZ55vbW09+sorr2yuqqpqYFatAuBn3uB7XzJCY297XeaUd2RoGzOJmHb6IjFj5D777LP3DQwMfDw8PBxSVbUvkUj0hEKhj1588cXH2O7zMSPdplumoxveMx5Zlj3jx4/39vb26gMDA4MsvgYZo+p8Pr7LqQX5Ds/U7d0jFxUVZS1atKg4Nzc317Isp67rZldXV6y5ufkmI78hFtcmrx8ZweMit6XsUs4+6kmlgbW+peLf9gyMZNCR374G0y/FxEzX8b/8+bkXEBxKFwAAAABJRU5ErkJggg==", y.tileXYToQuadKey = function (e, t, i) {
            for (var n = "", r = i; r >= 0; --r) {
                var o = 1 << r, a = 0;
                0 !== (e & o) && (a |= 1), 0 !== (t & o) && (a |= 2), n += a
            }
            return n
        }, y.quadKeyToTileXY = function (e) {
            for (var t = 0, i = 0, n = e.length - 1, r = n; r >= 0; --r) {
                var o = 1 << r, a = +e[n - r];
                0 !== (1 & a) && (t |= o), 0 !== (2 & a) && (i |= o)
            }
            return {x: t, y: i, level: n}
        };
        var E = new c;
        return y
    }),define("Cesium/Core/MapboxApi", ["./defined"], function (e) {
        "use strict";
        var t = {};
        t.defaultAccessToken = void 0;
        var i = !1;
        return t.getAccessToken = function (n) {
            return e(n) ? n : e(t.defaultAccessToken) ? t.defaultAccessToken : (i || (console.log("This application is using Cesium's default Mapbox access token.  Please create a new access token for the application as soon as possible and prior to deployment by visiting https://www.mapbox.com/account/apps/, and provide your token to Cesium by setting the Cesium.MapboxApi.defaultAccessToken property before constructing the CesiumWidget or any other object that uses the Mapbox API."), i = !0), "pk.eyJ1IjoiYW5hbHl0aWNhbGdyYXBoaWNzIiwiYSI6IjA2YzBjOTM3YzFlYzljYmQ5NDAxZWI1Y2ZjNzZlM2E1In0.vDZL2SPFEpi_f7ziAIP_yw")
        }, t
    }),define("Cesium/Core/loadXML", ["./loadWithXhr"], function (e) {
        "use strict";
        var t = function (t, i) {
            return e({url: t, responseType: "document", headers: i, overrideMimeType: "text/xml"})
        };
        return t
    }),define("Cesium/Scene/UrlTemplateImageryProvider", ["../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartographic", "../Core/combine", "../Core/Math", "../Core/Credit", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "../Core/freezeObject", "../Core/GeographicTilingScheme", "../Core/loadJson", "../Core/loadText", "../Core/loadWithXhr", "../Core/loadXML", "../Core/Rectangle", "../Core/TileProviderError", "../Core/WebMercatorTilingScheme", "../ThirdParty/when", "./ImageryProvider"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E) {
        "use strict";
        function S(e, t, i, n) {
            return ne = !1, oe = !1, b(e, e._urlParts, function (r) {
                return r(e, t, i, n)
            })
        }

        function T(e, t, i, n, r, o, a) {
            return ne = !1, oe = !1, se = !1, ce = !1, b(e, e._pickFeaturesUrlParts, function (s) {
                return s(e, t, i, n, r, o, a)
            })
        }

        function b(e, t, i) {
            for (var n = "", r = 0; r < t.length; ++r) {
                var o = t[r];
                n += "string" == typeof o ? o : encodeURIComponent(i(o))
            }
            var a = e._proxy;
            return s(a) && (n = a.getURL(n)), n
        }

        function w(e, t) {
            if (!s(e))return void 0;
            for (var i, n, r = [], o = 0, a = Object.keys(t); o < e.length;) {
                i = Number.MAX_VALUE, n = void 0;
                for (var u = 0; u < a.length; ++u) {
                    var l = e.indexOf(a[u], o);
                    l >= 0 && i > l && (i = l, n = a[u])
                }
                s(n) ? (i > o && r.push(e.substring(o, i)), r.push(t[n]), o = i + n.length) : (r.push(e.substring(o)), o = e.length)
            }
            return r
        }

        function x(e, t, i, n) {
            return t
        }

        function A(e, t, i, n) {
            return e.tilingScheme.getNumberOfXTilesAtLevel(n) - t - 1
        }

        function P(e, t, i, n) {
            return i
        }

        function I(e, t, i, n) {
            return e.tilingScheme.getNumberOfYTilesAtLevel(n) - i - 1
        }

        function D(e, t, i, n) {
            var r = e.maximumLevel;
            return s(r) && r > n ? r - n - 1 : n
        }

        function M(e, t, i, n) {
            return n
        }

        function O(e, t, i, n) {
            var r = (t + i + n) % e._subdomains.length;
            return e._subdomains[r]
        }

        function R(e, t, i, n) {
            ne || (e.tilingScheme.tileXYToRectangle(t, i, n, re), re.west = r.toDegrees(re.west), re.south = r.toDegrees(re.south), re.east = r.toDegrees(re.east), re.north = r.toDegrees(re.north), ne = !0)
        }

        function N(e, t, i, n) {
            return R(e, t, i, n), re.west
        }

        function L(e, t, i, n) {
            return R(e, t, i, n), re.south
        }

        function F(e, t, i, n) {
            return R(e, t, i, n), re.east
        }

        function B(e, t, i, n) {
            return R(e, t, i, n), re.north
        }

        function z(e, t, i, n) {
            oe || (e.tilingScheme.tileXYToNativeRectangle(t, i, n, ae), oe = !0)
        }

        function V(e, t, i, n) {
            return z(e, t, i, n), ae.west
        }

        function U(e, t, i, n) {
            return z(e, t, i, n), ae.south
        }

        function k(e, t, i, n) {
            return z(e, t, i, n), ae.east
        }

        function G(e, t, i, n) {
            return z(e, t, i, n), ae.north
        }

        function H(e, t, i, n) {
            return e.tileWidth
        }

        function W(e, t, i, n) {
            return e.tileHeight
        }

        function q(e, t, i, n, r, o, a) {
            return Z(e, t, i, n, r, o), ue.x
        }

        function j(e, t, i, n, r, o, a) {
            return Z(e, t, i, n, r, o), ue.y
        }

        function Y(e, t, i, n, r, o, a) {
            return Z(e, t, i, n, r, o), e.tileWidth - ue.x - 1
        }

        function X(e, t, i, n, r, o, a) {
            return Z(e, t, i, n, r, o), e.tileHeight - ue.y - 1
        }

        function Z(e, t, i, n, r, o, a) {
            if (!se) {
                ee(e, t, i, n, r, o);
                var s = he, u = e.tilingScheme.tileXYToNativeRectangle(t, i, n, le);
                ue.x = e.tileWidth * (s.x - u.west) / u.width | 0, ue.y = e.tileHeight * (u.north - s.y) / u.height | 0, se = !0
            }
        }

        function K(e, t, i, n, o, a, s) {
            return r.toDegrees(o)
        }

        function J(e, t, i, n, o, a, s) {
            return r.toDegrees(a)
        }

        function Q(e, t, i, n, r, o, a) {
            return ee(e, t, i, n, r, o), he.x
        }

        function $(e, t, i, n, r, o, a) {
            return ee(e, t, i, n, r, o), he.y
        }

        function ee(e, t, i, n, o, a, s) {
            if (!ce) {
                var u;
                if (e.tilingScheme instanceof d)he.x = r.toDegrees(o), he.y = r.toDegrees(a); else {
                    var l = de;
                    l.longitude = o, l.latitude = a, u = e.tilingScheme.projection.project(l, he)
                }
                ce = !0
            }
        }

        function te(e, t, i, n, r, o, a) {
            return a
        }

        var ie = function (e) {
            this._url = e.url, this._pickFeaturesUrl = e.pickFeaturesUrl, this._proxy = e.proxy, this._tileDiscardPolicy = e.tileDiscardPolicy, this._getFeatureInfoFormats = e.getFeatureInfoFormats, this._errorEvent = new c, this._subdomains = e.subdomains, Array.isArray(this._subdomains) ? this._subdomains = this._subdomains.slice() : s(this._subdomains) && this._subdomains.length > 0 ? this._subdomains = this._subdomains.split("") : this._subdomains = ["a", "b", "c"], this._tileWidth = a(e.tileWidth, 256), this._tileHeight = a(e.tileHeight, 256), this._minimumLevel = a(e.minimumLevel, 0), this._maximumLevel = e.maximumLevel, this._tilingScheme = a(e.tilingScheme, new y({ellipsoid: e.ellipsoid})), this._rectangle = a(e.rectangle, this._tilingScheme.rectangle), this._rectangle = v.intersection(this._rectangle, this._tilingScheme.rectangle), this._hasAlphaChannel = a(e.hasAlphaChannel, !0);
            var t = e.credit;
            "string" == typeof t && (t = new o(t)), this._credit = t, this._urlParts = w(this._url, me), this._pickFeaturesUrlParts = w(this._pickFeaturesUrl, pe)
        };
        u(ie.prototype, {
            url: {
                get: function () {
                    return this._url
                }
            }, pickFeaturesUrl: {
                get: function () {
                    return this._pickFeaturesUrl
                }
            }, proxy: {
                get: function () {
                    return this._proxy
                }
            }, tileWidth: {
                get: function () {
                    return this._tileWidth
                }
            }, tileHeight: {
                get: function () {
                    return this._tileHeight
                }
            }, maximumLevel: {
                get: function () {
                    return this._maximumLevel
                }
            }, minimumLevel: {
                get: function () {
                    return this._minimumLevel
                }
            }, tilingScheme: {
                get: function () {
                    return this._tilingScheme
                }
            }, rectangle: {
                get: function () {
                    return this._rectangle
                }
            }, tileDiscardPolicy: {
                get: function () {
                    return this._tileDiscardPolicy
                }
            }, errorEvent: {
                get: function () {
                    return this._errorEvent
                }
            }, ready: {
                get: function () {
                    return !0
                }
            }, credit: {
                get: function () {
                    return this._credit
                }
            }, hasAlphaChannel: {
                get: function () {
                    return this._hasAlphaChannel
                }
            }
        }), ie.prototype.getTileCredits = function (e, t, i) {
            return void 0
        }, ie.prototype.requestImage = function (e, t, i) {
            var n = S(this, e, t, i);
            return E.loadImage(this, n)
        }, ie.prototype.pickFeatures = function (e, t, i, n, r) {
            function o(e, t) {
                return e.callback(t)
            }

            function a() {
                if (u >= l._getFeatureInfoFormats.length)return C([]);
                var s = l._getFeatureInfoFormats[u], c = T(l, e, t, i, n, r, s.format);
                return ++u, "json" === s.type ? m(c).then(s.callback).otherwise(a) : "xml" === s.type ? _(c).then(s.callback).otherwise(a) : "text" === s.type || "html" === s.type ? p(c).then(s.callback).otherwise(a) : f({
                    url: c,
                    responseType: s.format
                }).then(o.bind(void 0, s)).otherwise(a)
            }

            if (!s(this._pickFeaturesUrl) || 0 === this._getFeatureInfoFormats.length)return void 0;
            var u = 0, l = this;
            return a()
        };
        var ne = !1, re = new v, oe = !1, ae = new v, se = !1, ue = new e, le = new v, ce = !1, he = new t, de = new i, me = {
            "{x}": x,
            "{y}": P,
            "{z}": M,
            "{s}": O,
            "{reverseX}": A,
            "{reverseY}": I,
            "{reverseZ}": D,
            "{westDegrees}": N,
            "{southDegrees}": L,
            "{eastDegrees}": F,
            "{northDegrees}": B,
            "{westProjected}": V,
            "{southProjected}": U,
            "{eastProjected}": k,
            "{northProjected}": G,
            "{width}": H,
            "{height}": W
        }, pe = n(me, {
            "{i}": q,
            "{j}": j,
            "{reverseI}": Y,
            "{reverseJ}": X,
            "{longitudeDegrees}": K,
            "{latitudeDegrees}": J,
            "{longitudeProjected}": Q,
            "{latitudeProjected}": $,
            "{format}": te
        });
        return ie
    }),define("Cesium/Scene/MapboxImageryProvider", ["../Core/Credit", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/MapboxApi", "./UrlTemplateImageryProvider"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = /\/$/, u = new e("© Mapbox © OpenStreetMap", void 0, "https://www.mapbox.com/about/maps/"), l = [new e("Improve this map", void 0, "https://www.mapbox.com/map-feedback/")], c = function (n) {
            n = t(n, t.EMPTY_OBJECT);
            var r = n.mapId, c = t(n.url, "//api.mapbox.com/v4/");
            this._url = c, this._mapId = r, this._accessToken = o.getAccessToken(n.accessToken);
            var h = t(n.format, "png");
            this._format = h.replace(".", "");
            var d = c;
            if (s.test(c) || (d += "/"), d += r + "/{z}/{x}/{y}." + this._format, i(this._accessToken) && (d += "?access_token=" + this._accessToken), i(n.credit)) {
                var m = n.credit;
                "string" == typeof m && (m = new e(m)), u = m, l.length = 0
            }
            this._imageryProvider = new a({
                url: d,
                proxy: n.proxy,
                credit: u,
                ellipsoid: n.ellipsoid,
                minimumLevel: n.minimumLevel,
                maximumLevel: n.maximumLevel,
                rectangle: n.rectangle
            })
        };
        return n(c.prototype, {
            url: {
                get: function () {
                    return this._url
                }
            }, ready: {
                get: function () {
                    return this._imageryProvider.ready
                }
            }, rectangle: {
                get: function () {
                    return this._imageryProvider.rectangle
                }
            }, tileWidth: {
                get: function () {
                    return this._imageryProvider.tileWidth
                }
            }, tileHeight: {
                get: function () {
                    return this._imageryProvider.tileHeight
                }
            }, maximumLevel: {
                get: function () {
                    return this._imageryProvider.maximumLevel
                }
            }, minimumLevel: {
                get: function () {
                    return this._imageryProvider.minimumLevel
                }
            }, tilingScheme: {
                get: function () {
                    return this._imageryProvider.tilingScheme
                }
            }, tileDiscardPolicy: {
                get: function () {
                    return this._imageryProvider.tileDiscardPolicy
                }
            }, errorEvent: {
                get: function () {
                    return this._imageryProvider.errorEvent
                }
            }, credit: {
                get: function () {
                    return this._imageryProvider.credit
                }
            }, proxy: {
                get: function () {
                    return this._imageryProvider.proxy
                }
            }, hasAlphaChannel: {
                get: function () {
                    return this._imageryProvider.hasAlphaChannel
                }
            }
        }), c.prototype.getTileCredits = function (e, t, i) {
            return l
        }, c.prototype.requestImage = function (e, t, i) {
            return this._imageryProvider.requestImage(e, t, i)
        }, c.prototype.pickFeatures = function (e, t, i, n, r) {
            return this._imageryProvider.pickFeatures(e, t, i, n, r)
        }, c
    }),define("Cesium/Scene/OpenStreetMapImageryProvider", ["../Core/Credit", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "../Core/Rectangle", "../Core/WebMercatorTilingScheme", "./ImageryProvider"], function (e, t, i, n, r, o, a, s, u) {
        "use strict";
        function l(e, t, n, r) {
            var o = e._url + r + "/" + t + "/" + n + "." + e._fileExtension, a = e._proxy;
            return i(a) && (o = a.getURL(o)), o
        }

        var c = /\/$/, h = new e("MapQuest, Open Street Map and contributors, CC-BY-SA"), d = function (i) {
            i = t(i, {});
            var n = t(i.url, "//a.tile.openstreetmap.org/");
            c.test(n) || (n += "/"), this._url = n, this._fileExtension = t(i.fileExtension, "png"), this._proxy = i.proxy, this._tileDiscardPolicy = i.tileDiscardPolicy, this._tilingScheme = new s({ellipsoid: i.ellipsoid}), this._tileWidth = 256, this._tileHeight = 256, this._minimumLevel = t(i.minimumLevel, 0), this._maximumLevel = i.maximumLevel, this._rectangle = t(i.rectangle, this._tilingScheme.rectangle);
            var u = this._tilingScheme.positionToTileXY(a.southwest(this._rectangle), this._minimumLevel), l = this._tilingScheme.positionToTileXY(a.northeast(this._rectangle), this._minimumLevel), d = (Math.abs(l.x - u.x) + 1) * (Math.abs(l.y - u.y) + 1);
            if (d > 4)throw new r("The imagery provider's rectangle and minimumLevel indicate that there are " + d + " tiles at the minimum level. Imagery providers with more than four tiles at the minimum level are not supported.");
            this._errorEvent = new o, this._ready = !0;
            var m = t(i.credit, h);
            "string" == typeof m && (m = new e(m)), this._credit = m
        };
        return n(d.prototype, {
            url: {
                get: function () {
                    return this._url
                }
            }, proxy: {
                get: function () {
                    return this._proxy
                }
            }, tileWidth: {
                get: function () {
                    return this._tileWidth
                }
            }, tileHeight: {
                get: function () {
                    return this._tileHeight
                }
            }, maximumLevel: {
                get: function () {
                    return this._maximumLevel
                }
            }, minimumLevel: {
                get: function () {
                    return this._minimumLevel
                }
            }, tilingScheme: {
                get: function () {
                    return this._tilingScheme
                }
            }, rectangle: {
                get: function () {
                    return this._rectangle
                }
            }, tileDiscardPolicy: {
                get: function () {
                    return this._tileDiscardPolicy
                }
            }, errorEvent: {
                get: function () {
                    return this._errorEvent
                }
            }, ready: {
                get: function () {
                    return this._ready
                }
            }, credit: {
                get: function () {
                    return this._credit
                }
            }, hasAlphaChannel: {
                get: function () {
                    return !0
                }
            }
        }), d.prototype.getTileCredits = function (e, t, i) {
            return void 0
        }, d.prototype.requestImage = function (e, t, i) {
            var n = l(this, e, t, i);
            return u.loadImage(this, n)
        }, d.prototype.pickFeatures = function () {
            return void 0
        }, d
    }),define("Cesium/Scene/TileMapServiceImageryProvider", ["../Core/appendForwardSlash", "../Core/Cartesian2", "../Core/Cartographic", "../Core/Credit", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "../Core/GeographicTilingScheme", "../Core/loadXML", "../Core/Rectangle", "../Core/TileProviderError", "../Core/WebMercatorTilingScheme", "../ThirdParty/when", "./ImageryProvider"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f) {
        "use strict";
        function _(e, t, i, n) {
            var r = e._tilingScheme.getNumberOfYTilesAtLevel(n), a = e._url + n + "/" + t + "/" + (r - i - 1) + "." + e._fileExtension, s = e._proxy;
            return o(s) && (a = s.getURL(a)), a
        }

        var v = function (a) {
            function s(e) {
                for (var n, s, u, c, p = /tileformat/i, f = /tileset/i, g = /tilesets/i, E = /boundingbox/i, S = /srs/i, T = [], b = e.childNodes[0].childNodes, w = 0; w < b.length; w++)if (p.test(b.item(w).nodeName))n = b.item(w); else if (g.test(b.item(w).nodeName)) {
                    u = b.item(w);
                    for (var x = b.item(w).childNodes, A = 0; A < x.length; A++)f.test(x.item(A).nodeName) && T.push(x.item(A))
                } else E.test(b.item(w).nodeName) ? s = b.item(w) : S.test(b.item(w).nodeName) && (c = b.item(w).textContent);
                C._fileExtension = r(C._fileExtension, n.getAttribute("extension")), C._tileWidth = r(C._tileWidth, parseInt(n.getAttribute("width"), 10)), C._tileHeight = r(C._tileHeight, parseInt(n.getAttribute("height"), 10)), C._minimumLevel = r(C._minimumLevel, parseInt(T[0].getAttribute("order"), 10)), C._maximumLevel = r(C._maximumLevel, parseInt(T[T.length - 1].getAttribute("order"), 10));
                var P = u.getAttribute("profile"), I = !1;
                if (("geodetic" === P || "mercator" === P) && (I = !0), !o(C._tilingScheme))if ("geodetic" === P || "global-geodetic" === P)C._tilingScheme = new l({ellipsoid: a.ellipsoid}); else {
                    if ("mercator" !== P && "global-mercator" !== P) {
                        var D = v + "tilemapresource.xml specifies an unsupported profile attribute, " + P + ".";
                        return void(y = d.handleError(y, C, C._errorEvent, D, void 0, void 0, void 0, _))
                    }
                    C._tilingScheme = new m({ellipsoid: a.ellipsoid})
                }
                var M = C._tilingScheme;
                if (!o(C._rectangle)) {
                    var O, R, N, L;
                    if (I)O = new t(parseFloat(s.getAttribute("miny")), parseFloat(s.getAttribute("minx"))), R = new t(parseFloat(s.getAttribute("maxy")), parseFloat(s.getAttribute("maxx"))), N = i.fromDegrees(O.x, O.y), L = i.fromDegrees(R.x, R.y); else if (O = new t(parseFloat(s.getAttribute("minx")), parseFloat(s.getAttribute("miny"))), R = new t(parseFloat(s.getAttribute("maxx")), parseFloat(s.getAttribute("maxy"))), C._tilingScheme instanceof l)N = i.fromDegrees(O.x, O.y), L = i.fromDegrees(R.x, R.y); else {
                        var F = C._tilingScheme.projection;
                        N = F.unproject(O), L = F.unproject(R)
                    }
                    C._rectangle = new h(N.longitude, N.latitude, L.longitude, L.latitude)
                }
                C._rectangle.west < M.rectangle.west && (C._rectangle.west = M.rectangle.west), C._rectangle.east > M.rectangle.east && (C._rectangle.east = M.rectangle.east), C._rectangle.south < M.rectangle.south && (C._rectangle.south = M.rectangle.south), C._rectangle.north > M.rectangle.north && (C._rectangle.north = M.rectangle.north);
                var B = M.positionToTileXY(h.southwest(C._rectangle), C._minimumLevel), z = M.positionToTileXY(h.northeast(C._rectangle), C._minimumLevel), V = (Math.abs(z.x - B.x) + 1) * (Math.abs(z.y - B.y) + 1);
                V > 4 && (C._minimumLevel = 0), C._tilingScheme = M, C._ready = !0
            }

            function f(e) {
                C._fileExtension = r(a.fileExtension, "png"), C._tileWidth = r(a.tileWidth, 256), C._tileHeight = r(a.tileHeight, 256), C._minimumLevel = r(a.minimumLevel, 0), C._maximumLevel = a.maximumLevel, C._tilingScheme = o(a.tilingScheme) ? a.tilingScheme : new m({ellipsoid: a.ellipsoid}), C._rectangle = r(a.rectangle, C._tilingScheme.rectangle), C._ready = !0
            }

            function _() {
                var e = v + "tilemapresource.xml", t = C._proxy;
                o(t) && (e = t.getURL(e)), p(c(e), s, f)
            }

            a = r(a, {});
            var v = e(a.url);
            this._url = v, this._ready = !1, this._proxy = a.proxy, this._tileDiscardPolicy = a.tileDiscardPolicy, this._errorEvent = new u, this._fileExtension = a.fileExtension, this._tileWidth = a.tileWidth, this._tileHeight = a.tileHeight, this._minimumLevel = a.minimumLevel, this._maximumLevel = a.maximumLevel, this._rectangle = h.clone(a.rectangle), this._tilingScheme = a.tilingScheme;
            var g = a.credit;
            "string" == typeof g && (g = new n(g)), this._credit = g;
            var y, C = this;
            _()
        };
        return a(v.prototype, {
            url: {
                get: function () {
                    return this._url
                }
            }, proxy: {
                get: function () {
                    return this._proxy
                }
            }, tileWidth: {
                get: function () {
                    return this._tileWidth
                }
            }, tileHeight: {
                get: function () {
                    return this._tileHeight
                }
            }, maximumLevel: {
                get: function () {
                    return this._maximumLevel
                }
            }, minimumLevel: {
                get: function () {
                    return this._minimumLevel
                }
            }, tilingScheme: {
                get: function () {
                    return this._tilingScheme
                }
            }, rectangle: {
                get: function () {
                    return this._rectangle
                }
            }, tileDiscardPolicy: {
                get: function () {
                    return this._tileDiscardPolicy
                }
            }, errorEvent: {
                get: function () {
                    return this._errorEvent
                }
            }, ready: {
                get: function () {
                    return this._ready
                }
            }, credit: {
                get: function () {
                    return this._credit
                }
            }, hasAlphaChannel: {
                get: function () {
                    return !0
                }
            }
        }), v.prototype.getTileCredits = function (e, t, i) {
            return void 0
        }, v.prototype.requestImage = function (e, t, i) {
            var n = _(this, e, t, i);
            return f.loadImage(this, n)
        }, v.prototype.pickFeatures = function () {
            return void 0
        }, v
    }),define("Cesium/Widgets/BaseLayerPicker/ProviderViewModel", ["../../Core/defined", "../../Core/defineProperties", "../../Core/DeveloperError", "../../ThirdParty/knockout", "../createCommand"], function (e, t, i, n, r) {
        "use strict";
        var o = function (t) {
            var i = t.creationFunction;
            e(i.canExecute) || (i = r(i)), this._creationCommand = i, this.name = t.name, this.tooltip = t.tooltip, this.iconUrl = t.iconUrl, n.track(this, ["name", "tooltip", "iconUrl"])
        };
        return t(o.prototype, {
            creationCommand: {
                get: function () {
                    return this._creationCommand
                }
            }
        }), o
    }),define("Cesium/Widgets/BaseLayerPicker/createDefaultImageryProviderViewModels", ["../../Core/buildModuleUrl", "../../Scene/ArcGisMapServerImageryProvider", "../../Scene/BingMapsImageryProvider", "../../Scene/BingMapsStyle", "../../Scene/MapboxImageryProvider", "../../Scene/OpenStreetMapImageryProvider", "../../Scene/TileMapServiceImageryProvider", "../BaseLayerPicker/ProviderViewModel"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        function u() {
            var u = [];
            return u.push(new s({
                name: "Bing Maps Aerial",
                iconUrl: e("Widgets/Images/ImageryProviders/bingAerial.png"),
                tooltip: "Bing Maps aerial imagery \nhttp://www.bing.com/maps",
                creationFunction: function () {
                    return new i({url: "//dev.virtualearth.net", mapStyle: n.AERIAL})
                }
            })), u.push(new s({
                name: "Bing Maps Aerial with Labels",
                iconUrl: e("Widgets/Images/ImageryProviders/bingAerialLabels.png"),
                tooltip: "Bing Maps aerial imagery with label overlays \nhttp://www.bing.com/maps",
                creationFunction: function () {
                    return new i({url: "//dev.virtualearth.net", mapStyle: n.AERIAL_WITH_LABELS})
                }
            })), u.push(new s({
                name: "Bing Maps Roads",
                iconUrl: e("Widgets/Images/ImageryProviders/bingRoads.png"),
                tooltip: "Bing Maps standard road maps\nhttp://www.bing.com/maps",
                creationFunction: function () {
                    return new i({url: "//dev.virtualearth.net", mapStyle: n.ROAD})
                }
            })), u.push(new s({
                name: "Mapbox Satellite",
                tooltip: "Mapbox satellite imagery https://www.mapbox.com/maps/",
                iconUrl: e("Widgets/Images/ImageryProviders/mapboxSatellite.png"),
                creationFunction: function () {
                    return new r({mapId: "mapbox.satellite"})
                }
            })), u.push(new s({
                name: "Mapbox Streets",
                tooltip: "Mapbox streets imagery https://www.mapbox.com/maps/",
                iconUrl: e("Widgets/Images/ImageryProviders/mapboxTerrain.png"),
                creationFunction: function () {
                    return new r({mapId: "mapbox.streets"})
                }
            })), u.push(new s({
                name: "Mapbox Streets Classic",
                tooltip: "Mapbox streets basic imagery https://www.mapbox.com/maps/",
                iconUrl: e("Widgets/Images/ImageryProviders/mapboxStreets.png"),
                creationFunction: function () {
                    return new r({mapId: "mapbox.streets-basic"})
                }
            })), u.push(new s({
                name: "ESRI World Imagery",
                iconUrl: e("Widgets/Images/ImageryProviders/esriWorldImagery.png"),
                tooltip: "World Imagery provides one meter or better satellite and aerial imagery in many parts of the world and lower resolution satellite imagery worldwide.  The map includes NASA Blue Marble: Next Generation 500m resolution imagery at small scales (above 1:1,000,000), i-cubed 15m eSAT imagery at medium-to-large scales (down to 1:70,000) for the world, and USGS 15m Landsat imagery for Antarctica. The map features 0.3m resolution imagery in the continental United States and 0.6m resolution imagery in parts of Western Europe from DigitalGlobe. In other parts of the world, 1 meter resolution imagery is available from GeoEye IKONOS, i-cubed Nationwide Prime, Getmapping, AeroGRID, IGN Spain, and IGP Portugal.  Additionally, imagery at different resolutions has been contributed by the GIS User Community.\nhttp://www.esri.com",
                creationFunction: function () {
                    return new t({
                        url: "//services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer",
                        enablePickFeatures: !1
                    })
                }
            })), u.push(new s({
                name: "ESRI World Street Map",
                iconUrl: e("Widgets/Images/ImageryProviders/esriWorldStreetMap.png"),
                tooltip: "This worldwide street map presents highway-level data for the world. Street-level data includes the United States; much of Canada; Japan; most countries in Europe; Australia and New Zealand; India; parts of South America including Argentina, Brazil, Chile, Colombia, and Venezuela; Ghana; and parts of southern Africa including Botswana, Lesotho, Namibia, South Africa, and Swaziland.\nhttp://www.esri.com",
                creationFunction: function () {
                    return new t({
                        url: "//services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer",
                        enablePickFeatures: !1
                    })
                }
            })), u.push(new s({
                name: "ESRI National Geographic",
                iconUrl: e("Widgets/Images/ImageryProviders/esriNationalGeographic.png"),
                tooltip: "This web map contains the National Geographic World Map service. This map service is designed to be used as a general reference map for informational and educational purposes as well as a basemap by GIS professionals and other users for creating web maps and web mapping applications.\nhttp://www.esri.com",
                creationFunction: function () {
                    return new t({
                        url: "//services.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/",
                        enablePickFeatures: !1
                    })
                }
            })), u.push(new s({
                name: "Open­Street­Map",
                iconUrl: e("Widgets/Images/ImageryProviders/openStreetMap.png"),
                tooltip: "OpenStreetMap (OSM) is a collaborative project to create a free editable map of the world.\nhttp://www.openstreetmap.org",
                creationFunction: function () {
                    return new o({
                        url: "//a.tile.openstreetmap.org/"
                    })
                }
            })), u.push(new s({
                name: "Stamen Watercolor",
                iconUrl: e("Widgets/Images/ImageryProviders/stamenWatercolor.png"),
                tooltip: "Reminiscent of hand drawn maps, Stamen watercolor maps apply raster effect area washes and organic edges over a paper texture to add warm pop to any map.\nhttp://maps.stamen.com",
                creationFunction: function () {
                    return new o({
                        url: "//stamen-tiles.a.ssl.fastly.net/watercolor/",
                        credit: "Map tiles by Stamen Design, under CC BY 3.0. Data by OpenStreetMap, under CC BY SA."
                    })
                }
            })), u.push(new s({
                name: "Stamen Toner",
                iconUrl: e("Widgets/Images/ImageryProviders/stamenToner.png"),
                tooltip: "A high contrast black and white map.\nhttp://maps.stamen.com",
                creationFunction: function () {
                    return new o({
                        url: "//stamen-tiles.a.ssl.fastly.net/toner/",
                        credit: "Map tiles by Stamen Design, under CC BY 3.0. Data by OpenStreetMap, under CC BY SA."
                    })
                }
            })), u.push(new s({
                name: "MapQuest Open­Street­Map",
                iconUrl: e("Widgets/Images/ImageryProviders/mapQuestOpenStreetMap.png"),
                tooltip: "OpenStreetMap (OSM) is a collaborative project to create a free editable map of the world.\nhttp://www.openstreetmap.org",
                creationFunction: function () {
                    return new o({url: "//otile1-s.mqcdn.com/tiles/1.0.0/osm/"})
                }
            })), u.push(new s({
                name: "The Black Marble",
                iconUrl: e("Widgets/Images/ImageryProviders/blackMarble.png"),
                tooltip: "The lights of cities and villages trace the outlines of civilization in this global view of the Earth at night as seen by NASA/NOAA's Suomi NPP satellite.",
                creationFunction: function () {
                    return new a({
                        url: "//cesiumjs.org/blackmarble",
                        maximumLevel: 8,
                        credit: "Black Marble imagery courtesy NASA Earth Observatory"
                    })
                }
            })), u.push(new s({
                name: "Natural Earth II",
                iconUrl: e("Widgets/Images/ImageryProviders/naturalEarthII.png"),
                tooltip: "Natural Earth II, darkened for contrast.\nhttp://www.naturalearthdata.com/",
                creationFunction: function () {
                    return new a({url: e("Assets/Textures/NaturalEarthII")})
                }
            })), u
        }

        return u
    }),define("Cesium/Core/Intersections2D", ["./Cartesian3", "./defined", "./DeveloperError"], function (e, t, i) {
        "use strict";
        var n = {};
        return n.clipTriangleAtAxisAlignedThreshold = function (e, i, n, r, o, a) {
            t(a) ? a.length = 0 : a = [];
            var s, u, l;
            i ? (s = e > n, u = e > r, l = e > o) : (s = n > e, u = r > e, l = o > e);
            var c, h, d, m, p, f, _ = s + u + l;
            return 1 === _ ? s ? (c = (e - n) / (r - n), h = (e - n) / (o - n), a.push(1), a.push(2), 1 !== h && (a.push(-1), a.push(0), a.push(2), a.push(h)), 1 !== c && (a.push(-1), a.push(0), a.push(1), a.push(c))) : u ? (d = (e - r) / (o - r), m = (e - r) / (n - r), a.push(2), a.push(0), 1 !== m && (a.push(-1), a.push(1), a.push(0), a.push(m)), 1 !== d && (a.push(-1), a.push(1), a.push(2), a.push(d))) : l && (p = (e - o) / (n - o), f = (e - o) / (r - o), a.push(0), a.push(1), 1 !== f && (a.push(-1), a.push(2), a.push(1), a.push(f)), 1 !== p && (a.push(-1), a.push(2), a.push(0), a.push(p))) : 2 === _ ? s || n === e ? u || r === e ? l || o === e || (h = (e - n) / (o - n), d = (e - r) / (o - r), a.push(2), a.push(-1), a.push(0), a.push(2), a.push(h), a.push(-1), a.push(1), a.push(2), a.push(d)) : (f = (e - o) / (r - o), c = (e - n) / (r - n), a.push(1), a.push(-1), a.push(2), a.push(1), a.push(f), a.push(-1), a.push(0), a.push(1), a.push(c)) : (m = (e - r) / (n - r), p = (e - o) / (n - o), a.push(0), a.push(-1), a.push(1), a.push(0), a.push(m), a.push(-1), a.push(2), a.push(0), a.push(p)) : 3 === _ || (a.push(0), a.push(1), a.push(2)), a
        }, n.computeBarycentricCoordinates = function (i, n, r, o, a, s, u, l, c) {
            var h = r - u, d = u - a, m = s - l, p = o - l, f = 1 / (m * h + d * p), _ = n - l, v = i - u, g = (m * v + d * _) * f, y = (-p * v + h * _) * f, C = 1 - g - y;
            return t(c) ? (c.x = g, c.y = y, c.z = C, c) : new e(g, y, C)
        }, n
    }),define("Cesium/Core/QuantizedMeshTerrainData", ["../ThirdParty/when", "./BoundingSphere", "./Cartesian3", "./defaultValue", "./defined", "./defineProperties", "./DeveloperError", "./IndexDatatype", "./Intersections2D", "./Math", "./OrientedBoundingBox", "./TaskProcessor", "./TerrainMesh"], function (e, t, i, n, r, o, a, s, u, l, c, h, d) {
        "use strict";
        function m(e, t, i) {
            f.length = e.length;
            for (var n = !1, r = 0, o = e.length; o > r; ++r)f[r] = e[r], n = n || r > 0 && t(e[r - 1], e[r]) > 0;
            return n ? (f.sort(t), s.createTypedArray(i, f)) : e
        }

        var p = function (e) {
            function t(e, t) {
                return a[e] - a[t]
            }

            function i(e, t) {
                return o[e] - o[t]
            }

            this._quantizedVertices = e.quantizedVertices, this._encodedNormals = e.encodedNormals, this._indices = e.indices, this._minimumHeight = e.minimumHeight, this._maximumHeight = e.maximumHeight, this._boundingSphere = e.boundingSphere, this._orientedBoundingBox = e.orientedBoundingBox, this._horizonOcclusionPoint = e.horizonOcclusionPoint;
            var r = this._quantizedVertices.length / 3, o = this._uValues = this._quantizedVertices.subarray(0, r), a = this._vValues = this._quantizedVertices.subarray(r, 2 * r);
            this._heightValues = this._quantizedVertices.subarray(2 * r, 3 * r);
            this._westIndices = m(e.westIndices, t, r), this._southIndices = m(e.southIndices, i, r), this._eastIndices = m(e.eastIndices, t, r), this._northIndices = m(e.northIndices, i, r), this._westSkirtHeight = e.westSkirtHeight, this._southSkirtHeight = e.southSkirtHeight, this._eastSkirtHeight = e.eastSkirtHeight, this._northSkirtHeight = e.northSkirtHeight, this._childTileMask = n(e.childTileMask, 15), this._createdByUpsampling = n(e.createdByUpsampling, !1), this._waterMask = e.waterMask
        };
        o(p.prototype, {
            waterMask: {
                get: function () {
                    return this._waterMask
                }
            }
        });
        var f = [], _ = new h("createVerticesFromQuantizedTerrainMesh");
        p.prototype.createMesh = function (t, i, n, o) {
            var a = t.ellipsoid, u = t.tileXYToRectangle(i, n, o), l = _.scheduleTask({
                minimumHeight: this._minimumHeight,
                maximumHeight: this._maximumHeight,
                quantizedVertices: this._quantizedVertices,
                octEncodedNormals: this._encodedNormals,
                indices: this._indices,
                westIndices: this._westIndices,
                southIndices: this._southIndices,
                eastIndices: this._eastIndices,
                northIndices: this._northIndices,
                westSkirtHeight: this._westSkirtHeight,
                southSkirtHeight: this._southSkirtHeight,
                eastSkirtHeight: this._eastSkirtHeight,
                northSkirtHeight: this._northSkirtHeight,
                rectangle: u,
                relativeToCenter: this._boundingSphere.center,
                ellipsoid: a
            });
            if (!r(l))return void 0;
            var c = this;
            return e(l, function (e) {
                var t = c._quantizedVertices.length / 3;
                t += c._westIndices.length + c._southIndices.length + c._eastIndices.length + c._northIndices.length;
                var i = s.createTypedArray(t, e.indices);
                return new d(c._boundingSphere.center, new Float32Array(e.vertices), i, c._minimumHeight, c._maximumHeight, c._boundingSphere, c._horizonOcclusionPoint, r(c._encodedNormals) ? 7 : 6, c._orientedBoundingBox)
            })
        };
        var v = new h("upsampleQuantizedTerrainMesh");
        p.prototype.upsample = function (n, o, a, u, l, h, d) {
            var m = 2 * o !== l, f = 2 * a === h, _ = n.ellipsoid, g = n.tileXYToRectangle(l, h, d), y = v.scheduleTask({
                vertices: this._quantizedVertices,
                indices: this._indices,
                encodedNormals: this._encodedNormals,
                minimumHeight: this._minimumHeight,
                maximumHeight: this._maximumHeight,
                isEastChild: m,
                isNorthChild: f,
                childRectangle: g,
                ellipsoid: _
            });
            if (!r(y))return void 0;
            var C = Math.min(this._westSkirtHeight, this._eastSkirtHeight);
            C = Math.min(C, this._southSkirtHeight), C = Math.min(C, this._northSkirtHeight);
            var E = m ? .5 * C : this._westSkirtHeight, S = f ? .5 * C : this._southSkirtHeight, T = m ? this._eastSkirtHeight : .5 * C, b = f ? this._northSkirtHeight : .5 * C;
            return e(y, function (e) {
                var n, o = new Uint16Array(e.vertices), a = s.createTypedArray(o.length / 3, e.indices);
                return r(e.encodedNormals) && (n = new Uint8Array(e.encodedNormals)), new p({
                    quantizedVertices: o,
                    indices: a,
                    encodedNormals: n,
                    minimumHeight: e.minimumHeight,
                    maximumHeight: e.maximumHeight,
                    boundingSphere: t.clone(e.boundingSphere),
                    orientedBoundingBox: c.clone(e.orientedBoundingBox),
                    horizonOcclusionPoint: i.clone(e.horizonOcclusionPoint),
                    westIndices: e.westIndices,
                    southIndices: e.southIndices,
                    eastIndices: e.eastIndices,
                    northIndices: e.northIndices,
                    westSkirtHeight: E,
                    southSkirtHeight: S,
                    eastSkirtHeight: T,
                    northSkirtHeight: b,
                    childTileMask: 0,
                    createdByUpsampling: !0
                })
            })
        };
        var g = 32767, y = new i;
        return p.prototype.interpolateHeight = function (e, t, i) {
            var n = l.clamp((t - e.west) / e.width, 0, 1);
            n *= g;
            var r = l.clamp((i - e.south) / e.height, 0, 1);
            r *= g;
            for (var o = this._uValues, a = this._vValues, s = this._heightValues, c = this._indices, h = 0, d = c.length; d > h; h += 3) {
                var m = c[h], p = c[h + 1], f = c[h + 2], _ = o[m], v = o[p], C = o[f], E = a[m], S = a[p], T = a[f], b = u.computeBarycentricCoordinates(n, r, _, E, v, S, C, T, y);
                if (b.x >= -1e-15 && b.y >= -1e-15 && b.z >= -1e-15) {
                    var w = b.x * s[m] + b.y * s[p] + b.z * s[f];
                    return l.lerp(this._minimumHeight, this._maximumHeight, w / g)
                }
            }
            return void 0
        }, p.prototype.isChildAvailable = function (e, t, i, n) {
            var r = 2;
            return i !== 2 * e && ++r, n !== 2 * t && (r -= 2), 0 !== (this._childTileMask & 1 << r)
        }, p.prototype.wasCreatedByUpsampling = function () {
            return this._createdByUpsampling
        }, p
    }),define("Cesium/Core/CesiumTerrainProvider", ["../ThirdParty/Uri", "../ThirdParty/when", "./appendForwardSlash", "./BoundingSphere", "./Cartesian3", "./Credit", "./defaultValue", "./defined", "./defineProperties", "./DeveloperError", "./Event", "./GeographicTilingScheme", "./HeightmapTerrainData", "./IndexDatatype", "./loadArrayBuffer", "./loadJson", "./Math", "./Matrix3", "./OrientedBoundingBox", "./QuantizedMeshTerrainData", "./RuntimeError", "./TerrainProvider", "./throttleRequestByServer", "./TileProviderError"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S, T) {
        "use strict";
        function b(e) {
            if (s(e) && 0 !== e.length) {
                var t = e.join("-");
                return {Accept: "application/vnd.quantized-mesh;extensions=" + t + ",application/octet-stream;q=0.9,*/*;q=0.01"}
            }
            return {Accept: "application/vnd.quantized-mesh,application/octet-stream;q=0.9,*/*;q=0.01"}
        }

        function w(e, t, i, n, r, o) {
            var a = new Uint16Array(t, 0, e._heightmapWidth * e._heightmapWidth);
            return new d({
                buffer: a,
                childTileMask: new Uint8Array(t, a.byteLength, 1)[0],
                waterMask: new Uint8Array(t, a.byteLength + 1, t.byteLength - a.byteLength - 1),
                width: e._heightmapWidth,
                height: e._heightmapWidth,
                structure: e._heightmapStructure
            })
        }

        function x(e, t, i, o, a, s) {
            function u(e) {
                return e >> 1 ^ -(1 & e)
            }

            var l = 0, c = 3, h = c + 1, d = Float64Array.BYTES_PER_ELEMENT * c, p = Float64Array.BYTES_PER_ELEMENT * h, f = 3, v = Uint16Array.BYTES_PER_ELEMENT * f, C = 3, E = Uint16Array.BYTES_PER_ELEMENT, S = E * C, T = new DataView(t), b = new r(T.getFloat64(l, !0), T.getFloat64(l + 8, !0), T.getFloat64(l + 16, !0));
            l += d;
            var w = T.getFloat32(l, !0);
            l += Float32Array.BYTES_PER_ELEMENT;
            var x = T.getFloat32(l, !0);
            l += Float32Array.BYTES_PER_ELEMENT;
            var P = new n(new r(T.getFloat64(l, !0), T.getFloat64(l + 8, !0), T.getFloat64(l + 16, !0)), T.getFloat64(l + d, !0));
            l += p;
            var I = new r(T.getFloat64(l, !0), T.getFloat64(l + 8, !0), T.getFloat64(l + 16, !0));
            l += d;
            var M = T.getUint32(l, !0);
            l += Uint32Array.BYTES_PER_ELEMENT;
            var O = new Uint16Array(t, l, 3 * M);
            l += M * v, M > 65536 && (E = Uint32Array.BYTES_PER_ELEMENT, S = E * C);
            var R, N = O.subarray(0, M), L = O.subarray(M, 2 * M), F = O.subarray(2 * M, 3 * M), B = 0, z = 0, V = 0;
            for (R = 0; M > R; ++R)B += u(N[R]), z += u(L[R]), V += u(F[R]), N[R] = B, L[R] = z, F[R] = V;
            l % E !== 0 && (l += E - l % E);
            var U = T.getUint32(l, !0);
            l += Uint32Array.BYTES_PER_ELEMENT;
            var k = m.createTypedArrayFromArrayBuffer(M, t, l, U * C);
            l += U * S;
            var G = 0;
            for (R = 0; R < k.length; ++R) {
                var H = k[R];
                k[R] = G - H, 0 === H && ++G
            }
            var W = T.getUint32(l, !0);
            l += Uint32Array.BYTES_PER_ELEMENT;
            var q = m.createTypedArrayFromArrayBuffer(M, t, l, W);
            l += W * E;
            var j = T.getUint32(l, !0);
            l += Uint32Array.BYTES_PER_ELEMENT;
            var Y = m.createTypedArrayFromArrayBuffer(M, t, l, j);
            l += j * E;
            var X = T.getUint32(l, !0);
            l += Uint32Array.BYTES_PER_ELEMENT;
            var Z = m.createTypedArrayFromArrayBuffer(M, t, l, X);
            l += X * E;
            var K = T.getUint32(l, !0);
            l += Uint32Array.BYTES_PER_ELEMENT;
            var J = m.createTypedArrayFromArrayBuffer(M, t, l, K);
            l += K * E;
            for (var Q, $; l < T.byteLength;) {
                var ee = T.getUint8(l, !0);
                l += Uint8Array.BYTES_PER_ELEMENT;
                var te = T.getUint32(l, e._littleEndianExtensionSize);
                l += Uint32Array.BYTES_PER_ELEMENT, ee === D.OCT_VERTEX_NORMALS && e._requestVertexNormals ? Q = new Uint8Array(t, l, 2 * M) : ee === D.WATER_MASK && e._requestWaterMask && ($ = new Uint8Array(t, l, te)), l += te
            }
            var ie, ne = 5 * e.getLevelMaximumGeometricError(i), re = e._tilingScheme.tileXYToRectangle(o, a, i);
            return re.width < _.PI_OVER_TWO + _.EPSILON5 && (ie = g.fromRectangle(re, w, x, e._tilingScheme.ellipsoid)), new y({
                center: b,
                minimumHeight: w,
                maximumHeight: x,
                boundingSphere: P,
                orientedBoundingBox: ie,
                horizonOcclusionPoint: I,
                quantizedVertices: O,
                encodedNormals: Q,
                indices: k,
                westIndices: q,
                southIndices: Y,
                eastIndices: Z,
                northIndices: J,
                westSkirtHeight: ne,
                southSkirtHeight: ne,
                eastSkirtHeight: ne,
                northSkirtHeight: ne,
                childTileMask: A(e, i, o, s),
                waterMask: $
            })
        }

        function A(e, t, i, n) {
            var r = e._availableTiles;
            if (!r || 0 === r.length)return 15;
            var o = t + 1;
            if (o >= r.length)return 0;
            var a = r[o], s = 0;
            return s |= P(a, 2 * i, 2 * n) ? 1 : 0, s |= P(a, 2 * i + 1, 2 * n) ? 2 : 0, s |= P(a, 2 * i, 2 * n + 1) ? 4 : 0, s |= P(a, 2 * i + 1, 2 * n + 1) ? 8 : 0
        }

        function P(e, t, i) {
            for (var n = 0, r = e.length; r > n; ++n) {
                var o = e[n];
                if (t >= o.startX && t <= o.endX && i >= o.startY && i <= o.endY)return !0
            }
            return !1
        }

        var I = function (n) {
            function r(t) {
                var i;
                if (!t.format)return i = "The tile format is not specified in the layer.json file.", void(p = T.handleError(p, _, _._errorEvent, i, void 0, void 0, void 0, l));
                if (!t.tiles || 0 === t.tiles.length)return i = "The layer.json file does not specify any tile URL templates.", void(p = T.handleError(p, _, _._errorEvent, i, void 0, void 0, void 0, l));
                if ("heightmap-1.0" === t.format)_._heightmapStructure = {
                    heightScale: .2,
                    heightOffset: -1e3,
                    elementsPerHeight: 1,
                    stride: 1,
                    elementMultiplier: 256,
                    isBigEndian: !1
                }, _._hasWaterMask = !0, _._requestWaterMask = !0; else if (0 !== t.format.indexOf("quantized-mesh-1."))return i = 'The tile format "' + t.format + '" is invalid or not supported.', void(p = T.handleError(p, _, _._errorEvent, i, void 0, void 0, void 0, l));
                var n = new e(m);
                _._tileUrlTemplates = t.tiles;
                for (var r = 0; r < _._tileUrlTemplates.length; ++r)_._tileUrlTemplates[r] = new e(_._tileUrlTemplates[r]).resolve(n).toString().replace("{version}", t.version);
                _._availableTiles = t.available, !s(_._credit) && s(t.attribution) && null !== t.attribution && (_._credit = new o(t.attribution)), s(t.extensions) && -1 !== t.extensions.indexOf("octvertexnormals") ? _._hasVertexNormals = !0 : s(t.extensions) && -1 !== t.extensions.indexOf("vertexnormals") && (_._hasVertexNormals = !0, _._littleEndianExtensionSize = !1), s(t.extensions) && -1 !== t.extensions.indexOf("watermask") && (_._hasWaterMask = !0), _._ready = !0
            }

            function u(e) {
                if (s(e) && 404 === e.statusCode)return void r({
                    tilejson: "2.1.0",
                    format: "heightmap-1.0",
                    version: "1.0.0",
                    scheme: "tms",
                    tiles: ["{z}/{x}/{y}.terrain?v={version}"]
                });
                var t = "An error occurred while accessing " + m + ".";
                p = T.handleError(p, _, _._errorEvent, t, void 0, void 0, void 0, l)
            }

            function l() {
                var e = f(m);
                t(e, r, u)
            }

            this._url = i(n.url), this._proxy = n.proxy, this._tilingScheme = new h({
                numberOfLevelZeroTilesX: 2,
                numberOfLevelZeroTilesY: 1,
                ellipsoid: n.ellipsoid
            }), this._heightmapWidth = 65, this._levelZeroMaximumGeometricError = E.getEstimatedLevelZeroGeometricErrorForAHeightmap(this._tilingScheme.ellipsoid, this._heightmapWidth, this._tilingScheme.getNumberOfXTilesAtLevel(0)), this._heightmapStructure = void 0, this._hasWaterMask = !1, this._hasVertexNormals = !1, this._requestVertexNormals = a(n.requestVertexNormals, !1), this._littleEndianExtensionSize = !0, this._requestWaterMask = a(n.requestWaterMask, !1), this._errorEvent = new c;
            var d = n.credit;
            "string" == typeof d && (d = new o(d)), this._credit = d, this._ready = !1;
            var m = this._url + "layer.json";
            s(this._proxy) && (m = this._proxy.getURL(m));
            var p, _ = this;
            l()
        }, D = {OCT_VERTEX_NORMALS: 1, WATER_MASK: 2};
        return I.prototype.requestTileGeometry = function (e, i, n, r) {
            var o = this._tileUrlTemplates;
            if (0 === o.length)return void 0;
            var u = this._tilingScheme.getNumberOfYTilesAtLevel(n), l = u - i - 1, c = o[(e + l + n) % o.length].replace("{z}", n).replace("{x}", e).replace("{y}", l), h = this._proxy;
            s(h) && (c = h.getURL(c));
            var d, m = [];
            this._requestVertexNormals && this._hasVertexNormals && m.push(this._littleEndianExtensionSize ? "octvertexnormals" : "vertexnormals"), this._requestWaterMask && this._hasWaterMask && m.push("watermask");
            var f = function (e) {
                return p(e, b(m))
            };
            if (r = a(r, !0)) {
                if (d = S(c, f), !s(d))return void 0
            } else d = f(c);
            var _ = this;
            return t(d, function (t) {
                return s(_._heightmapStructure) ? w(_, t, n, e, i, l) : x(_, t, n, e, i, l)
            })
        }, u(I.prototype, {
            errorEvent: {
                get: function () {
                    return this._errorEvent
                }
            }, credit: {
                get: function () {
                    return this._credit
                }
            }, tilingScheme: {
                get: function () {
                    return this._tilingScheme
                }
            }, ready: {
                get: function () {
                    return this._ready
                }
            }, hasWaterMask: {
                get: function () {
                    return this._hasWaterMask && this._requestWaterMask
                }
            }, hasVertexNormals: {
                get: function () {
                    return this._hasVertexNormals && this._requestVertexNormals
                }
            }, requestVertexNormals: {
                get: function () {
                    return this._requestVertexNormals
                }
            }, requestWaterMask: {
                get: function () {
                    return this._requestWaterMask
                }
            }
        }), I.prototype.getLevelMaximumGeometricError = function (e) {
            return this._levelZeroMaximumGeometricError / (1 << e)
        }, I.prototype.getTileDataAvailable = function (e, t, i) {
            var n = this._availableTiles;
            if (n && 0 !== n.length) {
                if (i >= n.length)return !1;
                var r = n[i], o = this._tilingScheme.getNumberOfYTilesAtLevel(i), a = o - t - 1;
                return P(r, e, a)
            }
            return void 0
        }, I
    }),define("Cesium/Widgets/BaseLayerPicker/createDefaultTerrainProviderViewModels", ["../../Core/buildModuleUrl", "../../Core/CesiumTerrainProvider", "../../Core/EllipsoidTerrainProvider", "../BaseLayerPicker/ProviderViewModel"], function (e, t, i, n) {
        "use strict";
        function r() {
            var r = [];
            return r.push(new n({
                name: "WGS84 Ellipsoid",
                iconUrl: e("Widgets/Images/TerrainProviders/Ellipsoid.png"),
                tooltip: "WGS84 standard ellipsoid, also known as EPSG:4326",
                creationFunction: function () {
                    return new i
                }
            })), r.push(new n({
                name: "STK World Terrain meshes",
                iconUrl: e("Widgets/Images/TerrainProviders/STK.png"),
                tooltip: "High-resolution, mesh-based terrain for the entire globe. Free for use on the Internet. Closed-network options are available.\nhttp://www.agi.com",
                creationFunction: function () {
                    return new t({
                        url: "//assets.agi.com/stk-terrain/world",
                        requestWaterMask: !0,
                        requestVertexNormals: !0
                    })
                }
            })), r
        }

        return r
    }),define("Cesium/Core/getTimestamp", ["./defined"], function (e) {
        "use strict";
        var t;
        return t = "undefined" != typeof performance && e(performance.now) ? function () {
            return performance.now()
        } : function () {
            return Date.now()
        }
    }),define("Cesium/Core/Clock", ["./ClockRange", "./ClockStep", "./defaultValue", "./defined", "./DeveloperError", "./Event", "./getTimestamp", "./JulianDate"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        var u = function (r) {
            r = i(r, i.EMPTY_OBJECT);
            var u = r.startTime, l = !n(u), c = r.stopTime, h = !n(c), d = r.currentTime, m = !n(d);
            l && h && m ? (d = s.now(), u = s.clone(d), c = s.addDays(d, 1, new s)) : l && h ? (u = s.clone(d), c = s.addDays(d, 1, new s)) : l && m ? (u = s.addDays(c, -1, new s), d = s.clone(u)) : m && h ? (d = s.clone(u), c = s.addDays(u, 1, new s)) : m ? d = s.clone(u) : h ? c = s.addDays(d, 1, new s) : l && (u = s.clone(d)), this.startTime = u, this.stopTime = c, this.currentTime = d, this.multiplier = i(r.multiplier, 1), this.clockStep = i(r.clockStep, t.SYSTEM_CLOCK_MULTIPLIER), this.clockRange = i(r.clockRange, e.UNBOUNDED), this.canAnimate = i(r.canAnimate, !0), this.shouldAnimate = i(r.shouldAnimate, !0), this.onTick = new o, this._lastSystemTime = a()
        };
        return u.prototype.tick = function () {
            var i = a(), n = s.clone(this.currentTime), r = this.startTime, o = this.stopTime, u = this.multiplier;
            if (this.canAnimate && this.shouldAnimate)if (this.clockStep === t.SYSTEM_CLOCK)n = s.now(n); else {
                if (this.clockStep === t.TICK_DEPENDENT)n = s.addSeconds(n, u, n); else {
                    var l = i - this._lastSystemTime;
                    n = s.addSeconds(n, u * (l / 1e3), n)
                }
                if (this.clockRange === e.CLAMPED)s.lessThan(n, r) ? n = s.clone(r, n) : s.greaterThan(n, o) && (n = s.clone(o, n)); else if (this.clockRange === e.LOOP_STOP)for (s.lessThan(n, r) && (n = s.clone(r, n)); s.greaterThan(n, o);)n = s.addSeconds(r, s.secondsDifference(n, o), n)
            }
            return this.currentTime = n, this._lastSystemTime = i, this.onTick.raiseEvent(this), n
        }, u
    }),define("Cesium/Core/requestAnimationFrame", ["./defined", "./getTimestamp"], function (e, t) {
        "use strict";
        var i = window.requestAnimationFrame;
        !function () {
            if (!e(i))for (var n = ["webkit", "moz", "ms", "o"], r = 0, o = n.length; o > r && !e(i);)i = window[n[r] + "RequestAnimationFrame"], ++r;
            if (!e(i)) {
                var a = 1e3 / 60, s = 0;
                i = function (e) {
                    var i = t(), n = Math.max(a - (i - s), 0);
                    return s = i + n, setTimeout(function () {
                        e(s)
                    }, n)
                }
            }
        }();
        var n = function (e) {
            return i(e)
        };
        return n
    }),define("Cesium/Core/KeyboardEventModifier", ["./freezeObject"], function (e) {
        "use strict";
        var t = {SHIFT: 0, CTRL: 1, ALT: 2};
        return e(t)
    }),define("Cesium/Core/ScreenSpaceEventHandler", ["./AssociativeArray", "./Cartesian2", "./defaultValue", "./defined", "./destroyObject", "./DeveloperError", "./FeatureDetection", "./KeyboardEventModifier", "./ScreenSpaceEventType"], function (e, t, i, n, r, o, a, s, u) {
        "use strict";
        function l(e, t, i) {
            var n = e._element;
            if (n === document)return i.x = t.clientX, i.y = t.clientY, i;
            var r = n.getBoundingClientRect();
            return i.x = t.clientX - r.left, i.y = t.clientY - r.top, i
        }

        function c(e, t) {
            var i = e;
            return n(t) && (i += "+" + t), i
        }

        function h(e) {
            return e.shiftKey ? s.SHIFT : e.ctrlKey ? s.CTRL : e.altKey ? s.ALT : void 0
        }

        function d(e, t, i, n) {
            var r = function (t) {
                n(e, t)
            };
            i.addEventListener(t, r, !1), e._removalFunctions.push(function () {
                i.removeEventListener(t, r, !1)
            })
        }

        function m(e) {
            var t = e._element, i = n(t.disableRootEvents) ? t : document;
            a.supportsPointerEvents() ? (d(e, "pointerdown", t, w), d(e, "pointerup", t, x), d(e, "pointermove", t, A)) : (d(e, "mousedown", t, f), d(e, "mouseup", i, _), d(e, "mousemove", i, v), d(e, "touchstart", t, C), d(e, "touchend", i, E), d(e, "touchmove", i, T)), d(e, "dblclick", t, g);
            var r;
            r = "onwheel"in t ? "wheel" : n(document.onmousewheel) ? "mousewheel" : "DOMMouseScroll", d(e, r, t, y)
        }

        function p(e) {
            for (var t = e._removalFunctions, i = 0; i < t.length; ++i)t[i]()
        }

        function f(e, i) {
            if (!e._seenAnyTouchEvents) {
                var r = i.button;
                e._buttonDown = r;
                var o;
                if (r === P.LEFT)o = u.LEFT_DOWN; else if (r === P.MIDDLE)o = u.MIDDLE_DOWN; else {
                    if (r !== P.RIGHT)return;
                    o = u.RIGHT_DOWN
                }
                var a = l(e, i, e._primaryPosition);
                t.clone(a, e._primaryStartPosition), t.clone(a, e._primaryPreviousPosition);
                var s = h(i), c = e.getInputAction(o, s);
                n(c) && (t.clone(a, I.position), c(I), i.preventDefault())
            }
        }

        function _(e, i) {
            if (!e._seenAnyTouchEvents) {
                var r = i.button;
                e._buttonDown = void 0;
                var o, a;
                if (r === P.LEFT)o = u.LEFT_UP, a = u.LEFT_CLICK; else if (r === P.MIDDLE)o = u.MIDDLE_UP, a = u.MIDDLE_CLICK; else {
                    if (r !== P.RIGHT)return;
                    o = u.RIGHT_UP, a = u.RIGHT_CLICK
                }
                var s = h(i), c = e.getInputAction(o, s), d = e.getInputAction(a, s);
                if (n(c) || n(d)) {
                    var m = l(e, i, e._primaryPosition);
                    if (n(c) && (t.clone(m, D.position), c(D)), n(d)) {
                        var p = e._primaryStartPosition, f = p.x - m.x, _ = p.y - m.y, v = Math.sqrt(f * f + _ * _);
                        v < e._clickPixelTolerance && (t.clone(m, M.position), d(M))
                    }
                }
            }
        }

        function v(e, i) {
            if (!e._seenAnyTouchEvents) {
                var r = h(i), o = l(e, i, e._primaryPosition), a = e._primaryPreviousPosition, s = e.getInputAction(u.MOUSE_MOVE, r);
                n(s) && (t.clone(a, O.startPosition), t.clone(o, O.endPosition), s(O)), t.clone(o, a), n(e._buttonDown) && i.preventDefault()
            }
        }

        function g(e, t) {
            var i, r = t.button;
            if (r === P.LEFT)i = u.LEFT_DOUBLE_CLICK; else if (r === P.MIDDLE)i = u.MIDDLE_DOUBLE_CLICK; else {
                if (r !== P.RIGHT)return;
                i = u.RIGHT_DOUBLE_CLICK
            }
            var o = h(t), a = e.getInputAction(i, o);
            n(a) && (l(e, t, R.position), a(R))
        }

        function y(e, t) {
            var i;
            if (n(t.deltaY)) {
                var r = t.deltaMode;
                i = r === t.DOM_DELTA_PIXEL ? -t.deltaY : r === t.DOM_DELTA_LINE ? 40 * -t.deltaY : 120 * -t.deltaY
            } else i = t.detail > 0 ? -120 * t.detail : t.wheelDelta;
            if (n(i)) {
                var o = h(t), a = e.getInputAction(u.WHEEL, o);
                n(a) && (a(i), t.preventDefault())
            }
        }

        function C(e, i) {
            e._seenAnyTouchEvents = !0;
            var n, r, o, a = i.changedTouches, s = a.length, u = e._positions;
            for (n = 0; s > n; ++n)r = a[n], o = r.identifier, u.set(o, l(e, r, new t));
            S(e, i);
            var c = e._previousPositions;
            for (n = 0; s > n; ++n)r = a[n], o = r.identifier, c.set(o, t.clone(u.get(o)))
        }

        function E(e, t) {
            e._seenAnyTouchEvents = !0;
            var i, n, r, o = t.changedTouches, a = o.length, s = e._positions;
            for (i = 0; a > i; ++i)n = o[i], r = n.identifier, s.remove(r);
            S(e, t);
            var u = e._previousPositions;
            for (i = 0; a > i; ++i)n = o[i], r = n.identifier, u.remove(r)
        }

        function S(e, i) {
            var r, o, a = h(i), s = e._positions, l = e._previousPositions, c = s.length;
            if (1 !== c && e._buttonDown === P.LEFT && (e._buttonDown = void 0, r = e.getInputAction(u.LEFT_UP, a), n(r) && (t.clone(e._primaryPosition, F.position), r(F)), 0 === c && (o = e.getInputAction(u.LEFT_CLICK, a), n(o)))) {
                var d = e._primaryStartPosition, m = l.values[0], p = d.x - m.x, f = d.y - m.y, _ = Math.sqrt(p * p + f * f);
                _ < e._clickPixelTolerance && (t.clone(e._primaryPosition, B.position), o(B))
            }
            if (2 !== c && e._isPinching && (e._isPinching = !1, r = e.getInputAction(u.PINCH_END, a), n(r) && r()), 1 === c) {
                var v = s.values[0];
                t.clone(v, e._primaryPosition), t.clone(v, e._primaryStartPosition), t.clone(v, e._primaryPreviousPosition), e._buttonDown = P.LEFT, r = e.getInputAction(u.LEFT_DOWN, a), n(r) && (t.clone(v, N.position), r(N)), i.preventDefault()
            }
            2 === c && (e._isPinching = !0, r = e.getInputAction(u.PINCH_START, a), n(r) && (t.clone(s.values[0], L.position1), t.clone(s.values[1], L.position2), r(L)))
        }

        function T(e, i) {
            e._seenAnyTouchEvents = !0;
            var r, o, a, s = i.changedTouches, u = s.length, c = e._positions;
            for (r = 0; u > r; ++r) {
                o = s[r], a = o.identifier;
                var h = c.get(a);
                n(h) && l(e, o, h)
            }
            b(e, i);
            var d = e._previousPositions;
            for (r = 0; u > r; ++r)o = s[r], a = o.identifier, t.clone(c.get(a), d.get(a))
        }

        function b(e, i) {
            var r, o = h(i), a = e._positions, s = e._previousPositions, l = a.length;
            if (1 === l && e._buttonDown === P.LEFT) {
                var c = a.values[0];
                t.clone(c, e._primaryPosition);
                var d = e._primaryPreviousPosition;
                r = e.getInputAction(u.MOUSE_MOVE, o), n(r) && (t.clone(d, z.startPosition), t.clone(c, z.endPosition), r(z)), t.clone(c, d), i.preventDefault()
            } else if (2 === l && e._isPinching && (r = e.getInputAction(u.PINCH_MOVE, o), n(r))) {
                var m = a.values[0], p = a.values[1], f = s.values[0], _ = s.values[1], v = p.x - m.x, g = p.y - m.y, y = .25 * Math.sqrt(v * v + g * g), C = _.x - f.x, E = _.y - f.y, S = .25 * Math.sqrt(C * C + E * E), T = .125 * (p.y + m.y), b = .125 * (_.y + f.y), w = Math.atan2(g, v), x = Math.atan2(E, C);
                t.fromElements(0, S, V.distance.startPosition), t.fromElements(0, y, V.distance.endPosition), t.fromElements(x, b, V.angleAndHeight.startPosition), t.fromElements(w, T, V.angleAndHeight.endPosition), r(V)
            }
        }

        function w(e, i) {
            if (i.target.setPointerCapture(i.pointerId), "touch" === i.pointerType) {
                var n = e._positions, r = i.pointerId;
                n.set(r, l(e, i, new t)), S(e, i);
                var o = e._previousPositions;
                o.set(r, t.clone(n.get(r)))
            } else f(e, i)
        }

        function x(e, t) {
            if ("touch" === t.pointerType) {
                var i = e._positions, n = t.pointerId;
                i.remove(n), S(e, t);
                var r = e._previousPositions;
                r.remove(n)
            } else _(e, t)
        }

        function A(e, i) {
            if ("touch" === i.pointerType) {
                var n = e._positions, r = i.pointerId;
                l(e, i, n.get(r)), b(e, i);
                var o = e._previousPositions;
                t.clone(n.get(r), o.get(r))
            } else v(e, i)
        }

        var P = {
            LEFT: 0,
            MIDDLE: 1,
            RIGHT: 2
        }, I = {position: new t}, D = {position: new t}, M = {position: new t}, O = {
            startPosition: new t,
            endPosition: new t
        }, R = {position: new t}, N = {position: new t}, L = {
            position1: new t,
            position2: new t
        }, F = {position: new t}, B = {position: new t}, z = {
            startPosition: new t,
            endPosition: new t
        }, V = {
            distance: {startPosition: new t, endPosition: new t},
            angleAndHeight: {startPosition: new t, endPosition: new t}
        }, U = function (n) {
            this._inputEvents = {}, this._buttonDown = void 0, this._isPinching = !1, this._seenAnyTouchEvents = !1, this._primaryStartPosition = new t, this._primaryPosition = new t, this._primaryPreviousPosition = new t, this._positions = new e, this._previousPositions = new e, this._removalFunctions = [], this._clickPixelTolerance = 5, this._element = i(n, document), m(this)
        };
        return U.prototype.setInputAction = function (e, t, i) {
            var n = c(t, i);
            this._inputEvents[n] = e
        }, U.prototype.getInputAction = function (e, t) {
            var i = c(e, t);
            return this._inputEvents[i]
        }, U.prototype.removeInputAction = function (e, t) {
            var i = c(e, t);
            delete this._inputEvents[i]
        }, U.prototype.isDestroyed = function () {
            return !1
        }, U.prototype.destroy = function () {
            return p(this), r(this)
        }, U
    }),define("Cesium/Core/Visibility", ["./freezeObject"], function (e) {
        "use strict";
        var t = {NONE: -1, PARTIAL: 0, FULL: 1};
        return e(t)
    }),define("Cesium/Core/Occluder", ["./BoundingSphere", "./Cartesian3", "./defaultValue", "./defined", "./defineProperties", "./DeveloperError", "./Ellipsoid", "./Math", "./Rectangle", "./Visibility"], function (e, t, i, n, r, o, a, s, u, l) {
        "use strict";
        var c = function (e, i) {
            this._occluderPosition = t.clone(e.center), this._occluderRadius = e.radius, this._horizonDistance = 0, this._horizonPlaneNormal = void 0, this._horizonPlanePosition = void 0, this._cameraPosition = void 0, this.cameraPosition = i
        }, h = new t;
        r(c.prototype, {
            position: {
                get: function () {
                    return this._occluderPosition
                }
            }, radius: {
                get: function () {
                    return this._occluderRadius
                }
            }, cameraPosition: {
                set: function (e) {
                    e = t.clone(e, this._cameraPosition);
                    var i, n, r, o = t.subtract(this._occluderPosition, e, h), a = t.magnitudeSquared(o), s = this._occluderRadius * this._occluderRadius;
                    if (a > s) {
                        i = Math.sqrt(a - s), a = 1 / Math.sqrt(a), n = t.multiplyByScalar(o, a, h);
                        var u = i * i * a;
                        r = t.add(e, t.multiplyByScalar(n, u, h), h)
                    } else i = Number.MAX_VALUE;
                    this._horizonDistance = i, this._horizonPlaneNormal = n, this._horizonPlanePosition = r, this._cameraPosition = e
                }
            }
        }), c.fromBoundingSphere = function (e, i, r) {
            if (!n(e))throw new o("occluderBoundingSphere is required.");
            if (!n(i))throw new o("camera position is required.");
            return n(r) ? (t.clone(e.center, r._occluderPosition), r._occluderRadius = e.radius, r.cameraPosition = i, r) : new c(e, i)
        };
        var d = new t;
        c.prototype.isPointVisible = function (e) {
            if (this._horizonDistance !== Number.MAX_VALUE) {
                var i = t.subtract(e, this._occluderPosition, d), n = this._occluderRadius;
                if (n = t.magnitudeSquared(i) - n * n, n > 0)return n = Math.sqrt(n) + this._horizonDistance, i = t.subtract(e, this._cameraPosition, i), n * n > t.magnitudeSquared(i)
            }
            return !1
        };
        var m = new t;
        c.prototype.isBoundingSphereVisible = function (e) {
            var i = t.clone(e.center, m), n = e.radius;
            if (this._horizonDistance !== Number.MAX_VALUE) {
                var r = t.subtract(i, this._occluderPosition, d), o = this._occluderRadius - n;
                if (o = t.magnitudeSquared(r) - o * o, n < this._occluderRadius)return o > 0 ? (o = Math.sqrt(o) + this._horizonDistance, r = t.subtract(i, this._cameraPosition, r), o * o + n * n > t.magnitudeSquared(r)) : !1;
                if (o > 0) {
                    r = t.subtract(i, this._cameraPosition, r);
                    var a = t.magnitudeSquared(r), s = this._occluderRadius * this._occluderRadius, u = n * n;
                    return (this._horizonDistance * this._horizonDistance + s) * u > a * s ? !0 : (o = Math.sqrt(o) + this._horizonDistance, o * o + u > a)
                }
                return !0
            }
            return !1
        };
        var p = new t;
        c.prototype.computeVisibility = function (e) {
            if (!n(e))throw new o("occludeeBS is required.");
            var i = t.clone(e.center), r = e.radius;
            if (r > this._occluderRadius)return l.FULL;
            if (this._horizonDistance !== Number.MAX_VALUE) {
                var a = t.subtract(i, this._occluderPosition, p), s = this._occluderRadius - r, u = t.magnitudeSquared(a);
                if (s = u - s * s, s > 0) {
                    s = Math.sqrt(s) + this._horizonDistance, a = t.subtract(i, this._cameraPosition, a);
                    var c = t.magnitudeSquared(a);
                    return c > s * s + r * r ? l.NONE : (s = this._occluderRadius + r, s = u - s * s, s > 0 ? (s = Math.sqrt(s) + this._horizonDistance, s * s + r * r > c ? l.FULL : l.PARTIAL) : (a = t.subtract(i, this._horizonPlanePosition, a), t.dot(a, this._horizonPlaneNormal) > -r ? l.PARTIAL : l.FULL))
                }
            }
            return l.NONE
        };
        var f = new t;
        c.computeOccludeePoint = function (e, i, n) {
            var r = t.clone(i), a = t.clone(e.center), s = e.radius, u = n.length;
            if (t.equals(a, i))throw new o("occludeePosition must be different than occluderBoundingSphere.center");
            var l = t.normalize(t.subtract(r, a, f), f), h = -t.dot(l, a), d = c._anyRotationVector(a, l, h), m = c._horizonToPlaneNormalDotProduct(e, l, h, d, n[0]);
            if (!m)return void 0;
            for (var p, _ = 1; u > _; ++_) {
                if (p = c._horizonToPlaneNormalDotProduct(e, l, h, d, n[_]), !p)return void 0;
                m > p && (m = p)
            }
            if (.0017453283658983088 > m)return void 0;
            var v = s / m;
            return t.add(a, t.multiplyByScalar(l, v, f), f)
        };
        var _ = [];
        c.computeOccludeePointFromRectangle = function (n, r) {
            r = i(r, a.WGS84);
            var o = u.subsample(n, r, 0, _), s = e.fromPoints(o), l = t.ZERO;
            return t.equals(l, s.center) ? void 0 : c.computeOccludeePoint(new e(l, r.minimumRadius), s.center, o)
        };
        var v = new t;
        c._anyRotationVector = function (e, i, n) {
            var r = t.abs(i, v), o = r.x > r.y ? 0 : 1;
            (0 === o && r.z > r.x || 1 === o && r.z > r.y) && (o = 2);
            var a, s = new t;
            0 === o ? (r.x = e.x, r.y = e.y + 1, r.z = e.z + 1, a = t.UNIT_X) : 1 === o ? (r.x = e.x + 1, r.y = e.y, r.z = e.z + 1, a = t.UNIT_Y) : (r.x = e.x + 1, r.y = e.y + 1, r.z = e.z, a = t.UNIT_Z);
            var u = (t.dot(i, r) + n) / -t.dot(i, a);
            return t.normalize(t.subtract(t.add(r, t.multiplyByScalar(a, u, s), r), e, r), r)
        };
        var g = new t;
        c._rotationVector = function (e, i, n, r, o) {
            var a = t.subtract(r, e, g);
            if (a = t.normalize(a, a), t.dot(i, a) < .9999999847691291) {
                var u = t.cross(i, a, a), l = t.magnitude(u);
                if (l > s.EPSILON13)return t.normalize(u, new t)
            }
            return o
        };
        var y = new t, C = new t, E = new t, S = new t;
        return c._horizonToPlaneNormalDotProduct = function (e, i, n, r, o) {
            var a = t.clone(o, y), s = t.clone(e.center, C), u = e.radius, l = t.subtract(s, a, E), c = t.magnitudeSquared(l), h = u * u;
            if (h > c)return !1;
            var d = c - h, m = Math.sqrt(d), p = Math.sqrt(c), f = 1 / p, _ = m * f, v = _ * m;
            l = t.normalize(l, l);
            var g = t.add(a, t.multiplyByScalar(l, v, S), S), T = Math.sqrt(d - v * v), b = this._rotationVector(s, i, n, a, r), w = t.fromElements(b.x * b.x * l.x + (b.x * b.y - b.z) * l.y + (b.x * b.z + b.y) * l.z, (b.x * b.y + b.z) * l.x + b.y * b.y * l.y + (b.y * b.z - b.x) * l.z, (b.x * b.z - b.y) * l.x + (b.y * b.z + b.x) * l.y + b.z * b.z * l.z, y);
            w = t.normalize(w, w);
            var x = t.multiplyByScalar(w, T, y);
            b = t.normalize(t.subtract(t.add(g, x, E), s, E), E);
            var A = t.dot(i, b);
            b = t.normalize(t.subtract(t.subtract(g, x, b), s, b), b);
            var P = t.dot(i, b);
            return P > A ? A : P
        }, c
    }),define("Cesium/Shaders/GlobeFS", [], function () {
        "use strict";
        return "//#define SHOW_TILE_BOUNDARIES\n\nuniform vec4 u_initialColor;\n\n#if TEXTURE_UNITS > 0\nuniform sampler2D u_dayTextures[TEXTURE_UNITS];\nuniform vec4 u_dayTextureTranslationAndScale[TEXTURE_UNITS];\n\n#ifdef APPLY_ALPHA\nuniform float u_dayTextureAlpha[TEXTURE_UNITS];\n#endif\n\n#ifdef APPLY_BRIGHTNESS\nuniform float u_dayTextureBrightness[TEXTURE_UNITS];\n#endif\n\n#ifdef APPLY_CONTRAST\nuniform float u_dayTextureContrast[TEXTURE_UNITS];\n#endif\n\n#ifdef APPLY_HUE\nuniform float u_dayTextureHue[TEXTURE_UNITS];\n#endif\n\n#ifdef APPLY_SATURATION\nuniform float u_dayTextureSaturation[TEXTURE_UNITS];\n#endif\n\n#ifdef APPLY_GAMMA\nuniform float u_dayTextureOneOverGamma[TEXTURE_UNITS];\n#endif\n\nuniform vec4 u_dayTextureTexCoordsRectangle[TEXTURE_UNITS];\n#endif\n\n#ifdef SHOW_REFLECTIVE_OCEAN\nuniform sampler2D u_waterMask;\nuniform vec4 u_waterMaskTranslationAndScale;\nuniform float u_zoomedOutOceanSpecularIntensity;\n#endif\n\n#ifdef SHOW_OCEAN_WAVES\nuniform sampler2D u_oceanNormalMap;\n#endif\n\n#ifdef ENABLE_DAYNIGHT_SHADING\nuniform vec2 u_lightingFadeDistance;\n#endif\n\nvarying vec3 v_positionMC;\nvarying vec3 v_positionEC;\nvarying vec2 v_textureCoordinates;\nvarying vec3 v_normalMC;\nvarying vec3 v_normalEC;\n\nvec4 sampleAndBlend(\n    vec4 previousColor,\n    sampler2D texture,\n    vec2 tileTextureCoordinates,\n    vec4 textureCoordinateRectangle,\n    vec4 textureCoordinateTranslationAndScale,\n    float textureAlpha,\n    float textureBrightness,\n    float textureContrast,\n    float textureHue,\n    float textureSaturation,\n    float textureOneOverGamma)\n{\n    // This crazy step stuff sets the alpha to 0.0 if this following condition is true:\n    //    tileTextureCoordinates.s < textureCoordinateRectangle.s ||\n    //    tileTextureCoordinates.s > textureCoordinateRectangle.p ||\n    //    tileTextureCoordinates.t < textureCoordinateRectangle.t ||\n    //    tileTextureCoordinates.t > textureCoordinateRectangle.q\n    // In other words, the alpha is zero if the fragment is outside the rectangle\n    // covered by this texture.  Would an actual 'if' yield better performance?\n    vec2 alphaMultiplier = step(textureCoordinateRectangle.st, tileTextureCoordinates); \n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\n    \n    alphaMultiplier = step(vec2(0.0), textureCoordinateRectangle.pq - tileTextureCoordinates);\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\n    \n    vec2 translation = textureCoordinateTranslationAndScale.xy;\n    vec2 scale = textureCoordinateTranslationAndScale.zw;\n    vec2 textureCoordinates = tileTextureCoordinates * scale + translation;\n    vec4 sample = texture2D(texture, textureCoordinates);\n    vec3 color = sample.rgb;\n    float alpha = sample.a;\n    \n#ifdef APPLY_BRIGHTNESS\n    color = mix(vec3(0.0), color, textureBrightness);\n#endif\n\n#ifdef APPLY_CONTRAST\n    color = mix(vec3(0.5), color, textureContrast);\n#endif\n\n#ifdef APPLY_HUE\n    color = czm_hue(color, textureHue);\n#endif\n\n#ifdef APPLY_SATURATION\n    color = czm_saturation(color, textureSaturation);\n#endif\n\n#ifdef APPLY_GAMMA\n    color = pow(color, vec3(textureOneOverGamma));\n#endif\n\n    float sourceAlpha = alpha * textureAlpha;\n    float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\n    vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\n    return vec4(outColor, outAlpha);\n}\n\nvec4 computeDayColor(vec4 initialColor, vec2 textureCoordinates);\nvec4 computeWaterColor(vec3 positionEyeCoordinates, vec2 textureCoordinates, mat3 enuToEye, vec4 imageryColor, float specularMapValue);\n\nvoid main()\n{\n    // The clamp below works around an apparent bug in Chrome Canary v23.0.1241.0\n    // where the fragment shader sees textures coordinates < 0.0 and > 1.0 for the\n    // fragments on the edges of tiles even though the vertex shader is outputting\n    // coordinates strictly in the 0-1 range.\n    vec4 color = computeDayColor(u_initialColor, clamp(v_textureCoordinates, 0.0, 1.0));\n\n#ifdef SHOW_TILE_BOUNDARIES\n    if (v_textureCoordinates.x < (1.0/256.0) || v_textureCoordinates.x > (255.0/256.0) ||\n        v_textureCoordinates.y < (1.0/256.0) || v_textureCoordinates.y > (255.0/256.0))\n    {\n        color = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n#endif\n\n#if defined(SHOW_REFLECTIVE_OCEAN) || defined(ENABLE_DAYNIGHT_SHADING)\n    vec3 normalMC = normalize(czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)));   // normalized surface normal in model coordinates\n    vec3 normalEC = normalize(czm_normal3D * normalMC);                                         // normalized surface normal in eye coordiantes\n#endif\n\n#ifdef SHOW_REFLECTIVE_OCEAN\n    vec2 waterMaskTranslation = u_waterMaskTranslationAndScale.xy;\n    vec2 waterMaskScale = u_waterMaskTranslationAndScale.zw;\n    vec2 waterMaskTextureCoordinates = v_textureCoordinates * waterMaskScale + waterMaskTranslation;\n\n    float mask = texture2D(u_waterMask, waterMaskTextureCoordinates).r;\n\n    if (mask > 0.0)\n    {\n        mat3 enuToEye = czm_eastNorthUpToEyeCoordinates(v_positionMC, normalEC);\n        \n        vec2 ellipsoidTextureCoordinates = czm_ellipsoidWgs84TextureCoordinates(normalMC);\n        vec2 ellipsoidFlippedTextureCoordinates = czm_ellipsoidWgs84TextureCoordinates(normalMC.zyx);\n\n        vec2 textureCoordinates = mix(ellipsoidTextureCoordinates, ellipsoidFlippedTextureCoordinates, czm_morphTime * smoothstep(0.9, 0.95, normalMC.z));\n\n        color = computeWaterColor(v_positionEC, textureCoordinates, enuToEye, color, mask);\n    }\n#endif\n\n#ifdef ENABLE_VERTEX_LIGHTING\n    float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_sunDirectionEC, normalize(v_normalEC)) * 0.9 + 0.3, 0.0, 1.0);\n    gl_FragColor = vec4(color.rgb * diffuseIntensity, color.a);\n#elif defined(ENABLE_DAYNIGHT_SHADING)\n    float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_sunDirectionEC, normalEC) * 5.0 + 0.3, 0.0, 1.0);\n    float cameraDist = length(czm_view[3]);\n    float fadeOutDist = u_lightingFadeDistance.x;\n    float fadeInDist = u_lightingFadeDistance.y;\n    float t = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);\n    diffuseIntensity = mix(1.0, diffuseIntensity, t);\n    gl_FragColor = vec4(color.rgb * diffuseIntensity, color.a);\n#else\n    gl_FragColor = color;\n#endif\n}\n\n#ifdef SHOW_REFLECTIVE_OCEAN\n\nfloat waveFade(float edge0, float edge1, float x)\n{\n    float y = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return pow(1.0 - y, 5.0);\n}\n\nfloat linearFade(float edge0, float edge1, float x)\n{\n    return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\n\n// Based on water rendering by Jonas Wagner:\n// http://29a.ch/2012/7/19/webgl-terrain-rendering-water-fog\n\n// low altitude wave settings\nconst float oceanFrequencyLowAltitude = 825000.0;\nconst float oceanAnimationSpeedLowAltitude = 0.004;\nconst float oceanOneOverAmplitudeLowAltitude = 1.0 / 2.0;\nconst float oceanSpecularIntensity = 0.5;\n \n// high altitude wave settings\nconst float oceanFrequencyHighAltitude = 125000.0;\nconst float oceanAnimationSpeedHighAltitude = 0.008;\nconst float oceanOneOverAmplitudeHighAltitude = 1.0 / 2.0;\n\nvec4 computeWaterColor(vec3 positionEyeCoordinates, vec2 textureCoordinates, mat3 enuToEye, vec4 imageryColor, float maskValue)\n{\n    vec3 positionToEyeEC = -positionEyeCoordinates;\n    float positionToEyeECLength = length(positionToEyeEC);\n\n    // The double normalize below works around a bug in Firefox on Android devices.\n    vec3 normalizedpositionToEyeEC = normalize(normalize(positionToEyeEC));\n    \n    // Fade out the waves as the camera moves far from the surface.\n    float waveIntensity = waveFade(70000.0, 1000000.0, positionToEyeECLength);\n\n#ifdef SHOW_OCEAN_WAVES\n    // high altitude waves\n    float time = czm_frameNumber * oceanAnimationSpeedHighAltitude;\n    vec4 noise = czm_getWaterNoise(u_oceanNormalMap, textureCoordinates * oceanFrequencyHighAltitude, time, 0.0);\n    vec3 normalTangentSpaceHighAltitude = vec3(noise.xy, noise.z * oceanOneOverAmplitudeHighAltitude);\n    \n    // low altitude waves\n    time = czm_frameNumber * oceanAnimationSpeedLowAltitude;\n    noise = czm_getWaterNoise(u_oceanNormalMap, textureCoordinates * oceanFrequencyLowAltitude, time, 0.0);\n    vec3 normalTangentSpaceLowAltitude = vec3(noise.xy, noise.z * oceanOneOverAmplitudeLowAltitude);\n    \n    // blend the 2 wave layers based on distance to surface\n    float highAltitudeFade = linearFade(0.0, 60000.0, positionToEyeECLength);\n    float lowAltitudeFade = 1.0 - linearFade(20000.0, 60000.0, positionToEyeECLength);\n    vec3 normalTangentSpace = \n        (highAltitudeFade * normalTangentSpaceHighAltitude) + \n        (lowAltitudeFade * normalTangentSpaceLowAltitude);\n    normalTangentSpace = normalize(normalTangentSpace);\n    \n    // fade out the normal perturbation as we move farther from the water surface\n    normalTangentSpace.xy *= waveIntensity;\n    normalTangentSpace = normalize(normalTangentSpace);\n#else\n    vec3 normalTangentSpace = vec3(0.0, 0.0, 1.0);\n#endif\n\n    vec3 normalEC = enuToEye * normalTangentSpace;\n    \n    const vec3 waveHighlightColor = vec3(0.3, 0.45, 0.6);\n    \n    // Use diffuse light to highlight the waves\n    float diffuseIntensity = czm_getLambertDiffuse(czm_sunDirectionEC, normalEC) * maskValue;\n    vec3 diffuseHighlight = waveHighlightColor * diffuseIntensity;\n    \n#ifdef SHOW_OCEAN_WAVES\n    // Where diffuse light is low or non-existent, use wave highlights based solely on\n    // the wave bumpiness and no particular light direction.\n    float tsPerturbationRatio = normalTangentSpace.z;\n    vec3 nonDiffuseHighlight = mix(waveHighlightColor * 5.0 * (1.0 - tsPerturbationRatio), vec3(0.0), diffuseIntensity);\n#else\n    vec3 nonDiffuseHighlight = vec3(0.0);\n#endif\n\n    // Add specular highlights in 3D, and in all modes when zoomed in.\n    float specularIntensity = czm_getSpecular(czm_sunDirectionEC, normalizedpositionToEyeEC, normalEC, 10.0) + 0.25 * czm_getSpecular(czm_moonDirectionEC, normalizedpositionToEyeEC, normalEC, 10.0);\n    float surfaceReflectance = mix(0.0, mix(u_zoomedOutOceanSpecularIntensity, oceanSpecularIntensity, waveIntensity), maskValue);\n    float specular = specularIntensity * surfaceReflectance;\n    \n    return vec4(imageryColor.rgb + diffuseHighlight + nonDiffuseHighlight + specular, imageryColor.a); \n}\n\n#endif // #ifdef SHOW_REFLECTIVE_OCEAN\n";
    }),define("Cesium/Shaders/GlobeFSPole", [], function () {
        "use strict";
        return "uniform vec3 u_color;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main()\n{\n    // TODO: make arbitrary ellipsoid\n    czm_ellipsoid ellipsoid = czm_getWgs84EllipsoidEC();\n    vec3 direction = normalize(czm_windowToEyeCoordinates(gl_FragCoord).xyz);\n    czm_ray ray = czm_ray(vec3(0.0), direction);\n    czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid);\n    \n    if (!czm_isEmpty(intersection))\n    {\n        vec3 positionEC = czm_pointAlongRay(ray, intersection.start);\n        vec3 positionMC = (czm_inverseModelView * vec4(positionEC, 1.0)).xyz;\n        \n        vec3 normalMC = normalize(czm_geodeticSurfaceNormal(positionMC, vec3(0.0), vec3(1.0)));\n        vec3 normalEC = normalize(czm_normal * normalMC);\n        \n        vec3 startDayColor = u_color;\n        \n        gl_FragColor = vec4(startDayColor, 1.0);\n    }\n    else\n    {\n        discard;\n    }\n}"
    }),define("Cesium/Shaders/GlobeVS", [], function () {
        "use strict";
        return "attribute vec4 position3DAndHeight;\nattribute vec3 textureCoordAndEncodedNormals;\n\nuniform vec3 u_center3D;\nuniform mat4 u_modifiedModelView;\nuniform vec4 u_tileRectangle;\n\n// Uniforms for 2D Mercator projection\nuniform vec2 u_southAndNorthLatitude;\nuniform vec3 u_southMercatorYLowAndHighAndOneOverHeight;\n\nvarying vec3 v_positionMC;\nvarying vec3 v_positionEC;\n\nvarying vec2 v_textureCoordinates;\nvarying vec3 v_normalMC;\nvarying vec3 v_normalEC;\n\n// These functions are generated at runtime.\nvec4 getPosition(vec3 position3DWC);\nfloat get2DYPositionFraction();\n\nvec4 getPosition3DMode(vec3 position3DWC)\n{\n    return czm_projection * (u_modifiedModelView * vec4(position3DAndHeight.xyz, 1.0));\n}\n\nfloat get2DMercatorYPositionFraction()\n{\n    // The width of a tile at level 11, in radians and assuming a single root tile, is\n    //   2.0 * czm_pi / pow(2.0, 11.0)\n    // We want to just linearly interpolate the 2D position from the texture coordinates\n    // when we're at this level or higher.  The constant below is the expression\n    // above evaluated and then rounded up at the 4th significant digit.\n    const float maxTileWidth = 0.003068;\n    float positionFraction = textureCoordAndEncodedNormals.y;\n    float southLatitude = u_southAndNorthLatitude.x;\n    float northLatitude = u_southAndNorthLatitude.y;\n    if (northLatitude - southLatitude > maxTileWidth)\n    {\n        float southMercatorYLow = u_southMercatorYLowAndHighAndOneOverHeight.x;\n        float southMercatorYHigh = u_southMercatorYLowAndHighAndOneOverHeight.y;\n        float oneOverMercatorHeight = u_southMercatorYLowAndHighAndOneOverHeight.z;\n\n        float currentLatitude = mix(southLatitude, northLatitude, textureCoordAndEncodedNormals.y);\n        currentLatitude = clamp(currentLatitude, -czm_webMercatorMaxLatitude, czm_webMercatorMaxLatitude);\n        positionFraction = czm_latitudeToWebMercatorFraction(currentLatitude, southMercatorYLow, southMercatorYHigh, oneOverMercatorHeight);\n    }    \n    return positionFraction;\n}\n\nfloat get2DGeographicYPositionFraction()\n{\n    return textureCoordAndEncodedNormals.y;\n}\n\nvec4 getPositionPlanarEarth(vec3 position3DWC, float height2D)\n{\n    float yPositionFraction = get2DYPositionFraction();\n    vec4 rtcPosition2D = vec4(height2D, mix(u_tileRectangle.st, u_tileRectangle.pq, vec2(textureCoordAndEncodedNormals.x, yPositionFraction)), 1.0);  \n    return czm_projection * (u_modifiedModelView * rtcPosition2D);\n}\n\nvec4 getPosition2DMode(vec3 position3DWC)\n{\n    return getPositionPlanarEarth(position3DWC, 0.0);\n}\n\nvec4 getPositionColumbusViewMode(vec3 position3DWC)\n{\n    return getPositionPlanarEarth(position3DWC, position3DAndHeight.w);\n}\n\nvec4 getPositionMorphingMode(vec3 position3DWC)\n{\n    // We do not do RTC while morphing, so there is potential for jitter.\n    // This is unlikely to be noticeable, though.\n    float yPositionFraction = get2DYPositionFraction();\n    vec4 position2DWC = vec4(0.0, mix(u_tileRectangle.st, u_tileRectangle.pq, vec2(textureCoordAndEncodedNormals.x, yPositionFraction)), 1.0);\n    vec4 morphPosition = czm_columbusViewMorph(position2DWC, vec4(position3DWC, 1.0), czm_morphTime);\n    return czm_modelViewProjection * morphPosition;\n}\n\nvoid main() \n{\n    vec3 position3DWC = position3DAndHeight.xyz + u_center3D;\n\n    gl_Position = getPosition(position3DWC);\n\n#if defined(ENABLE_VERTEX_LIGHTING)\n    v_positionEC = (czm_modelView3D * vec4(position3DWC, 1.0)).xyz;\n    v_positionMC = position3DWC;                                 // position in model coordinates\n    float encodedNormal = textureCoordAndEncodedNormals.z;\n    v_normalMC = czm_octDecode(encodedNormal);\n    v_normalEC = czm_normal3D * v_normalMC;\n#elif defined(SHOW_REFLECTIVE_OCEAN) || defined(ENABLE_DAYNIGHT_SHADING)\n    v_positionEC = (czm_modelView3D * vec4(position3DWC, 1.0)).xyz;\n    v_positionMC = position3DWC;                                 // position in model coordinates\n#endif\n\n    v_textureCoordinates = textureCoordAndEncodedNormals.xy;\n}\n"
    }),define("Cesium/Shaders/GlobeVSPole", [], function () {
        "use strict";
        return "attribute vec4 position;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main() \n{\n    float x = (position.x - czm_viewport.x) / czm_viewport.z;\n    float y = (position.y - czm_viewport.y) / czm_viewport.w;\n    v_textureCoordinates = vec2(x, y);\n    \n    gl_Position = czm_viewportOrthographic * position;\n}"
    }),define("Cesium/Scene/terrainAttributeLocations", [], function () {
        "use strict";
        return {position3DAndHeight: 0, textureCoordAndEncodedNormals: 1}
    }),define("Cesium/Scene/GlobeSurfaceShaderSet", ["../Core/defined", "../Core/destroyObject", "../Renderer/ShaderProgram", "../Scene/SceneMode", "../Scene/terrainAttributeLocations"], function (e, t, i, n, r) {
        "use strict";
        function o(e, t, i) {
            this.numberOfDayTextures = e, this.flags = t, this.shaderProgram = i
        }

        function a() {
            this.baseVertexShaderSource = void 0, this.baseFragmentShaderSource = void 0, this._attributeLocations = r, this._shadersByTexturesFlags = [], this._pickShaderPrograms = []
        }

        function s(e) {
            var t, i = "vec4 getPosition(vec3 position3DWC) { return getPosition3DMode(position3DWC); }", r = "vec4 getPosition(vec3 position3DWC) { return getPosition2DMode(position3DWC); }", o = "vec4 getPosition(vec3 position3DWC) { return getPositionColumbusViewMode(position3DWC); }", a = "vec4 getPosition(vec3 position3DWC) { return getPositionMorphingMode(position3DWC); }";
            switch (e) {
                case n.SCENE3D:
                    t = i;
                    break;
                case n.SCENE2D:
                    t = r;
                    break;
                case n.COLUMBUS_VIEW:
                    t = o;
                    break;
                case n.MORPHING:
                    t = a
            }
            return t
        }

        function u(e) {
            var t = "float get2DYPositionFraction() { return get2DGeographicYPositionFraction(); }", i = "float get2DYPositionFraction() { return get2DMercatorYPositionFraction(); }";
            return e ? i : t
        }

        return a.prototype.getShaderProgram = function (t, n, r, a, l, c, h, d, m, p, f, _, v, g, y) {
            var C = n | l << 2 | c << 3 | h << 4 | d << 5 | m << 6 | p << 7 | f << 8 | _ << 9 | v << 10 | g << 11 | y << 12, E = r.surfaceShader;
            if (e(E) && E.numberOfDayTextures === a && E.flags === C)return E.shaderProgram;
            var S = this._shadersByTexturesFlags[a];
            if (e(S) || (S = this._shadersByTexturesFlags[a] = []), E = S[C], !e(E)) {
                var T = this.baseVertexShaderSource.clone(), b = this.baseFragmentShaderSource.clone();
                b.defines.push("TEXTURE_UNITS " + a), l && b.defines.push("APPLY_BRIGHTNESS"), c && b.defines.push("APPLY_CONTRAST"), h && b.defines.push("APPLY_HUE"), d && b.defines.push("APPLY_SATURATION"), m && b.defines.push("APPLY_GAMMA"), p && b.defines.push("APPLY_ALPHA"), f && (b.defines.push("SHOW_REFLECTIVE_OCEAN"), T.defines.push("SHOW_REFLECTIVE_OCEAN")), _ && b.defines.push("SHOW_OCEAN_WAVES"), v && (g ? (T.defines.push("ENABLE_VERTEX_LIGHTING"), b.defines.push("ENABLE_VERTEX_LIGHTING")) : (T.defines.push("ENABLE_DAYNIGHT_SHADING"), b.defines.push("ENABLE_DAYNIGHT_SHADING")));
                for (var w = "    vec4 computeDayColor(vec4 initialColor, vec2 textureCoordinates)\n    {\n        vec4 color = initialColor;\n", x = 0; a > x; ++x)w += "    color = sampleAndBlend(\n        color,\n        u_dayTextures[" + x + "],\n        textureCoordinates,\n        u_dayTextureTexCoordsRectangle[" + x + "],\n        u_dayTextureTranslationAndScale[" + x + "],\n        " + (p ? "u_dayTextureAlpha[" + x + "]" : "1.0") + ",\n        " + (l ? "u_dayTextureBrightness[" + x + "]" : "0.0") + ",\n        " + (c ? "u_dayTextureContrast[" + x + "]" : "0.0") + ",\n        " + (h ? "u_dayTextureHue[" + x + "]" : "0.0") + ",\n        " + (d ? "u_dayTextureSaturation[" + x + "]" : "0.0") + ",\n        " + (m ? "u_dayTextureOneOverGamma[" + x + "]" : "0.0") + "\n    );\n";
                w += "        return color;\n    }", b.sources.push(w), T.sources.push(s(n)), T.sources.push(u(y));
                var A = i.fromCache({
                    context: t,
                    vertexShaderSource: T,
                    fragmentShaderSource: b,
                    attributeLocations: this._attributeLocations
                });
                E = S[C] = new o(a, C, A)
            }
            return r.surfaceShader = E, E.shaderProgram
        }, a.prototype.getPickShaderProgram = function (t, n, r) {
            var o = n | r << 2, a = this._pickShaderPrograms[o];
            if (!e(a)) {
                var l = this.baseVertexShaderSource.clone();
                l.sources.push(s(n)), l.sources.push(u(r));
                var c = "void main()\n{\n    gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n}\n";
                a = this._pickShaderPrograms[o] = i.fromCache({
                    context: t,
                    vertexShaderSource: l,
                    fragmentShaderSource: c,
                    attributeLocations: this._attributeLocations
                })
            }
            return a
        }, a.prototype.destroy = function () {
            var i = this._shadersByTexturesFlags;
            for (var n in i)if (i.hasOwnProperty(n)) {
                var r = i[n];
                if (!e(r))continue;
                for (var o in r)if (r.hasOwnProperty(o)) {
                    var a = r[o];
                    e(a) && a.shaderProgram.destroy()
                }
            }
            return t(this)
        }, a
    }),define("Cesium/Core/SphereOutlineGeometry", ["./Cartesian3", "./defaultValue", "./defined", "./DeveloperError", "./EllipsoidOutlineGeometry"], function (e, t, i, n, r) {
        "use strict";
        var o = function (i) {
            var n = t(i.radius, 1), o = new e(n, n, n), a = {
                radii: o,
                stackPartitions: i.stackPartitions,
                slicePartitions: i.slicePartitions,
                subdivisions: i.subdivisions
            };
            this._ellipsoidGeometry = new r(a), this._workerName = "createSphereOutlineGeometry"
        };
        o.packedLength = r.packedLength, o.pack = function (e, t, i) {
            r.pack(e._ellipsoidGeometry, t, i)
        };
        var a = new r, s = {
            radius: void 0,
            radii: new e,
            stackPartitions: void 0,
            slicePartitions: void 0,
            subdivisions: void 0
        };
        return o.unpack = function (t, n, u) {
            var l = r.unpack(t, n, a);
            return s.stackPartitions = l._stackPartitions, s.slicePartitions = l._slicePartitions, s.subdivisions = l._subdivisions, i(u) ? (e.clone(l._radii, s.radii), u._ellipsoidGeometry = new r(s), u) : (s.radius = l._radii.x, new o(s))
        }, o.createGeometry = function (e) {
            return r.createGeometry(e._ellipsoidGeometry)
        }, o
    }),define("Cesium/Scene/DepthFunction", ["../Core/freezeObject", "../Renderer/WebGLConstants"], function (e, t) {
        "use strict";
        var i = {
            NEVER: t.NEVER,
            LESS: t.LESS,
            EQUAL: t.EQUAL,
            LESS_OR_EQUAL: t.LEQUAL,
            GREATER: t.GREATER,
            NOT_EQUAL: t.NOTEQUAL,
            GREATER_OR_EQUAL: t.GEQUAL,
            ALWAYS: t.ALWAYS
        };
        return e(i)
    }),define("Cesium/Scene/ImageryState", ["../Core/freezeObject"], function (e) {
        "use strict";
        var t = {
            UNLOADED: 0,
            TRANSITIONING: 1,
            RECEIVED: 2,
            TEXTURE_LOADED: 3,
            READY: 4,
            FAILED: 5,
            INVALID: 6,
            PLACEHOLDER: 7
        };
        return e(t)
    }),define("Cesium/Scene/QuadtreeTileLoadState", ["../Core/freezeObject"], function (e) {
        "use strict";
        var t = {START: 0, LOADING: 1, DONE: 2, FAILED: 3};
        return e(t)
    }),define("Cesium/Scene/TerrainState", ["../Core/freezeObject"], function (e) {
        "use strict";
        var t = {FAILED: 0, UNLOADED: 1, RECEIVING: 2, RECEIVED: 3, TRANSFORMING: 4, TRANSFORMED: 5, READY: 6};
        return e(t)
    }),define("Cesium/Scene/TileTerrain", ["../Core/BoundingSphere", "../Core/Cartesian3", "../Core/ComponentDatatype", "../Core/defined", "../Core/DeveloperError", "../Core/IndexDatatype", "../Core/OrientedBoundingBox", "../Core/TileProviderError", "../Renderer/Buffer", "../Renderer/BufferUsage", "../Renderer/VertexArray", "../ThirdParty/when", "./terrainAttributeLocations", "./TerrainState"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m) {
        "use strict";
        function p(e, t, i, r, o) {
            function a(t) {
                e.data = t, e.state = m.RECEIVED
            }

            function u() {
                e.state = m.FAILED;
                var n = "Failed to obtain terrain tile X: " + i + " Y: " + r + " Level: " + o + ".";
                t._requestError = s.handleError(t._requestError, t, t.errorEvent, n, i, r, o, l)
            }

            function l() {
                e.data = t.requestTileGeometry(i, r, o), n(e.data) ? (e.state = m.RECEIVING, h(e.data, a, u)) : e.state = m.UNLOADED
            }

            l()
        }

        function f(e, t, i, r, o, a) {
            var s = i.tilingScheme, u = e.data, l = u.createMesh(s, r, o, a);
            n(l) && (e.state = m.TRANSFORMING, h(l, function (t) {
                e.mesh = t, e.state = m.TRANSFORMED
            }, function () {
                e.state = m.FAILED
            }))
        }

        function _(e, t, r, a, s, h) {
            var p, f, _ = i.FLOAT, v = e.mesh.vertices, g = u.createVertexBuffer({
                context: t,
                typedArray: v,
                usage: l.STATIC_DRAW
            });
            r.hasVertexNormals ? (p = 7 * i.getSizeInBytes(_), f = 3) : (p = 6 * i.getSizeInBytes(_), f = 2);
            var y = 4, C = [{
                index: d.position3DAndHeight,
                vertexBuffer: g,
                componentDatatype: _,
                componentsPerAttribute: y,
                offsetInBytes: 0,
                strideInBytes: p
            }, {
                index: d.textureCoordAndEncodedNormals,
                vertexBuffer: g,
                componentDatatype: _,
                componentsPerAttribute: f,
                offsetInBytes: y * i.getSizeInBytes(_),
                strideInBytes: p
            }], E = e.mesh.indices.indexBuffers || {}, S = E[t.id];
            if (!n(S) || S.isDestroyed()) {
                var T = e.mesh.indices, b = 2 === T.BYTES_PER_ELEMENT ? o.UNSIGNED_SHORT : o.UNSIGNED_INT;
                S = u.createIndexBuffer({
                    context: t,
                    typedArray: T,
                    usage: l.STATIC_DRAW,
                    indexDatatype: b
                }), S.vertexArrayDestroyable = !1, S.referenceCount = 1, E[t.id] = S, e.mesh.indices.indexBuffers = E
            } else++S.referenceCount;
            e.vertexArray = new c({context: t, attributes: C, indexBuffer: S}), e.state = m.READY
        }

        var v = function (e) {
            this.state = m.UNLOADED, this.data = void 0, this.mesh = void 0, this.vertexArray = void 0, this.upsampleDetails = e
        };
        return v.prototype.freeResources = function () {
            if (this.state = m.UNLOADED, this.data = void 0, this.mesh = void 0, n(this.vertexArray)) {
                var e = this.vertexArray.indexBuffer;
                this.vertexArray.destroy(), this.vertexArray = void 0, !e.isDestroyed() && n(e.referenceCount) && (--e.referenceCount, 0 === e.referenceCount && e.destroy())
            }
        }, v.prototype.publishToTile = function (i) {
            var n = i.data, r = this.mesh;
            t.clone(r.center, n.center), n.minimumHeight = r.minimumHeight, n.maximumHeight = r.maximumHeight, n.boundingSphere3D = e.clone(r.boundingSphere3D, n.boundingSphere3D), n.orientedBoundingBox = a.clone(r.orientedBoundingBox, n.orientedBoundingBox), i.data.occludeePointInScaledSpace = t.clone(r.occludeePointInScaledSpace, n.occludeePointInScaledSpace), n.freeVertexArray(), n.vertexArray = this.vertexArray, this.vertexArray = void 0
        }, v.prototype.processLoadStateMachine = function (e, t, i, n, r) {
            this.state === m.UNLOADED && p(this, t, i, n, r), this.state === m.RECEIVED && f(this, e, t, i, n, r), this.state === m.TRANSFORMED && _(this, e, t, i, n, r)
        }, v.prototype.processUpsampleStateMachine = function (e, t, i, r, o) {
            if (this.state === m.UNLOADED) {
                var a = this.upsampleDetails, s = a.data, u = a.x, l = a.y, c = a.level;
                if (this.data = s.upsample(t.tilingScheme, u, l, c, i, r, o), !n(this.data))return;
                this.state = m.RECEIVING;
                var d = this;
                h(this.data, function (e) {
                    d.data = e, d.state = m.RECEIVED
                }, function () {
                    d.state = m.FAILED
                })
            }
            this.state === m.RECEIVED && f(this, e, t, i, r, o), this.state === m.TRANSFORMED && _(this, e, t, i, r, o)
        }, v
    }),define("Cesium/Scene/GlobeSurfaceTile", ["../Core/BoundingSphere", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/Cartographic", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/IntersectionTests", "../Core/PixelFormat", "../Core/Rectangle", "../Renderer/PixelDatatype", "../Renderer/Sampler", "../Renderer/Texture", "../Renderer/TextureMagnificationFilter", "../Renderer/TextureMinificationFilter", "../Renderer/TextureWrap", "./ImageryState", "./QuadtreeTileLoadState", "./SceneMode", "./TerrainState", "./TileTerrain"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C) {
        "use strict";
        function E(e, i, n, r, a, s, u) {
            if (t.unpack(r, s * a, u), t.add(e.center, u, u), o(i) && i !== g.SCENE3D) {
                var l = n.ellipsoid, c = l.cartesianToCartographic(u);
                n.project(c, u), t.fromElements(u.z, u.x, u.y, u)
            }
            return u
        }

        function S(e, i, n) {
            var r = e.data, a = b(e);
            o(a) && (r.upsampledTerrain = new C(a)), A(e, i) && (r.loadedTerrain = new C);
            for (var s = 0, u = n.length; u > s; ++s) {
                var c = n.get(s);
                c.show && c._createTileImagerySkeletons(e, i)
            }
            var h = e.tilingScheme.ellipsoid, d = e.rectangle;
            h.cartographicToCartesian(l.southwest(d), r.southwestCornerCartesian), h.cartographicToCartesian(l.northeast(d), r.northeastCornerCartesian), U.longitude = d.west, U.latitude = .5 * (d.south + d.north), U.height = 0;
            var m = h.cartographicToCartesian(U, z), p = t.cross(m, t.UNIT_Z, F);
            t.normalize(p, r.westNormal), U.longitude = d.east;
            var f = h.cartographicToCartesian(U, V), _ = t.cross(t.UNIT_Z, f, F);
            t.normalize(_, r.eastNormal);
            var v = h.geodeticSurfaceNormalCartographic(l.southeast(d), B), g = t.subtract(m, f, F), y = t.cross(v, g, B);
            t.normalize(y, r.southNormal);
            var E = h.geodeticSurfaceNormalCartographic(l.northwest(d), B), S = t.cross(g, E, B);
            t.normalize(S, r.northNormal)
        }

        function T(e, t, i) {
            var n = e.data, a = n.loadedTerrain, s = n.upsampledTerrain, u = !1;
            o(a) && (a.processLoadStateMachine(t, i, e.x, e.y, e.level), a.state >= y.RECEIVED && (n.terrainData !== a.data && (n.terrainData = a.data, I(t, n), x(e)), u = !0), a.state === y.READY ? (a.publishToTile(e), n.pickTerrain = r(n.loadedTerrain, n.upsampledTerrain), n.loadedTerrain = void 0, n.upsampledTerrain = void 0) : a.state === y.FAILED && (n.loadedTerrain = void 0)), !u && o(s) && (s.processUpsampleStateMachine(t, i, e.x, e.y, e.level), s.state >= y.RECEIVED && n.terrainData !== s.data && (n.terrainData = s.data, i.hasWaterMask && D(e), w(e)), s.state === y.READY ? (s.publishToTile(e), n.pickTerrain = n.upsampledTerrain, n.upsampledTerrain = void 0) : s.state === y.FAILED && (n.upsampledTerrain = void 0))
        }

        function b(e) {
            for (var t = e.parent; o(t) && o(t.data) && !o(t.data.terrainData);)t = t.parent;
            return o(t) && o(t.data) ? {data: t.data.terrainData, x: t.x, y: t.y, level: t.level} : void 0
        }

        function w(e) {
            var t = e.data;
            if (o(e._children))for (var i = 0; 4 > i; ++i) {
                var n = e._children[i];
                if (n.state !== v.START) {
                    var r = n.data;
                    if (o(r.terrainData) && !r.terrainData.wasCreatedByUpsampling())continue;
                    o(r.upsampledTerrain) && r.upsampledTerrain.freeResources(), r.upsampledTerrain = new C({
                        data: t.terrainData,
                        x: e.x,
                        y: e.y,
                        level: e.level
                    }), n.state = v.LOADING
                }
            }
        }

        function x(e) {
            var t = e.data;
            if (o(e.children))for (var i = 0; 4 > i; ++i) {
                var n = e.children[i];
                if (n.state !== v.START) {
                    var r = n.data;
                    if (o(r.terrainData) && !r.terrainData.wasCreatedByUpsampling())continue;
                    o(r.upsampledTerrain) && r.upsampledTerrain.freeResources(), r.upsampledTerrain = new C({
                        data: t.terrainData,
                        x: e.x,
                        y: e.y,
                        level: e.level
                    }), t.terrainData.isChildAvailable(e.x, e.y, n.x, n.y) && (o(r.loadedTerrain) || (r.loadedTerrain = new C)), n.state = v.LOADING
                }
            }
        }

        function A(e, t) {
            var i = t.getTileDataAvailable(e.x, e.y, e.level);
            if (o(i))return i;
            var n = e.parent;
            return o(n) ? o(n.data) && o(n.data.terrainData) ? n.data.terrainData.isChildAvailable(n.x, n.y, e.x, e.y) : !1 : !0
        }

        function P(e) {
            var t = e.cache.tile_waterMaskData;
            if (!o(t)) {
                var i = new d({
                    context: e,
                    pixelFormat: u.LUMINANCE,
                    pixelDatatype: c.UNSIGNED_BYTE,
                    source: {arrayBufferView: new Uint8Array([255]), width: 1, height: 1}
                });
                i.referenceCount = 1;
                var n = new h({
                    wrapS: f.CLAMP_TO_EDGE,
                    wrapT: f.CLAMP_TO_EDGE,
                    minificationFilter: p.LINEAR,
                    magnificationFilter: m.LINEAR
                });
                t = {
                    allWaterTexture: i, sampler: n, destroy: function () {
                        this.allWaterTexture.destroy()
                    }
                }, e.cache.tile_waterMaskData = t
            }
            return t
        }

        function I(e, t) {
            var n = t.waterMaskTexture;
            o(n) && (--n.referenceCount, 0 === n.referenceCount && n.destroy(), t.waterMaskTexture = void 0);
            var r = t.terrainData.waterMask;
            if (o(r)) {
                var a, s = P(e), l = r.length;
                if (1 === l) {
                    if (0 === r[0])return;
                    a = s.allWaterTexture
                } else {
                    var h = Math.sqrt(l);
                    a = new d({
                        context: e,
                        pixelFormat: u.LUMINANCE,
                        pixelDatatype: c.UNSIGNED_BYTE,
                        source: {width: h, height: h, arrayBufferView: r},
                        sampler: s.sampler
                    }), a.referenceCount = 0
                }
                ++a.referenceCount, t.waterMaskTexture = a, i.fromElements(0, 0, 1, 1, t.waterMaskTranslationAndScale)
            }
        }

        function D(e) {
            for (var t = e.data, i = e.parent; o(i) && !o(i.data.terrainData) || i.data.terrainData.wasCreatedByUpsampling();)i = i.parent;
            if (o(i) && o(i.data.waterMaskTexture)) {
                t.waterMaskTexture = i.data.waterMaskTexture, ++t.waterMaskTexture.referenceCount;
                var n = i.rectangle, r = e.rectangle, a = r.width, s = r.height, u = a / n.width, l = s / n.height;
                t.waterMaskTranslationAndScale.x = u * (r.west - n.west) / a, t.waterMaskTranslationAndScale.y = l * (r.south - n.south) / s, t.waterMaskTranslationAndScale.z = u, t.waterMaskTranslationAndScale.w = l
            }
        }

        var M = function () {
            this.imagery = [], this.southwestCornerCartesian = new t, this.northeastCornerCartesian = new t, this.westNormal = new t, this.southNormal = new t, this.eastNormal = new t, this.northNormal = new t, this.waterMaskTexture = void 0, this.waterMaskTranslationAndScale = new i(0, 0, 1, 1), this.terrainData = void 0, this.center = new t, this.vertexArray = void 0, this.minimumHeight = 0, this.maximumHeight = 0, this.boundingSphere3D = new e, this.boundingSphere2D = new e, this.orientedBoundingBox = void 0, this.occludeePointInScaledSpace = new t, this.loadedTerrain = void 0, this.upsampledTerrain = void 0, this.pickBoundingSphere = new e, this.pickTerrain = void 0, this.surfaceShader = void 0
        };
        a(M.prototype, {
            eligibleForUnloading: {
                get: function () {
                    for (var e = this.loadedTerrain, t = o(e) && (e.state === y.RECEIVING || e.state === y.TRANSFORMING), i = this.upsampledTerrain, n = o(i) && (i.state === y.RECEIVING || i.state === y.TRANSFORMING), r = !t && !n, a = this.imagery, s = 0, u = a.length; r && u > s; ++s) {
                        var l = a[s];
                        r = !o(l.loadingImagery) || l.loadingImagery.state !== _.TRANSITIONING
                    }
                    return r
                }
            }
        });
        var O = new t, R = new t, N = new t, L = new t;
        M.prototype.pick = function (e, i, n, r, a) {
            var u = this.pickTerrain;
            if (!o(u))return void 0;
            var l = u.mesh;
            if (!o(l))return void 0;
            for (var c = l.vertices, h = l.stride, d = l.indices, m = d.length, p = 0; m > p; p += 3) {
                var f = d[p], _ = d[p + 1], v = d[p + 2], g = E(this, i, n, c, h, f, O), y = E(this, i, n, c, h, _, R), C = E(this, i, n, c, h, v, N), S = s.rayTriangle(e, g, y, C, r, L);
                if (o(S))return t.clone(S, a)
            }
            return void 0
        }, M.prototype.freeResources = function () {
            o(this.waterMaskTexture) && (--this.waterMaskTexture.referenceCount, 0 === this.waterMaskTexture.referenceCount && this.waterMaskTexture.destroy(), this.waterMaskTexture = void 0), this.terrainData = void 0, o(this.loadedTerrain) && (this.loadedTerrain.freeResources(), this.loadedTerrain = void 0), o(this.upsampledTerrain) && (this.upsampledTerrain.freeResources(), this.upsampledTerrain = void 0), o(this.pickTerrain) && (this.pickTerrain.freeResources(), this.pickTerrain = void 0);
            var e, t, i = this.imagery;
            for (e = 0, t = i.length; t > e; ++e)i[e].freeResources();
            this.imagery.length = 0, this.freeVertexArray()
        }, M.prototype.freeVertexArray = function () {
            var e;
            o(this.vertexArray) && (e = this.vertexArray.indexBuffer, this.vertexArray = this.vertexArray.destroy(), !e.isDestroyed() && o(e.referenceCount) && (--e.referenceCount, 0 === e.referenceCount && e.destroy())), o(this.wireframeVertexArray) && (e = this.wireframeVertexArray.indexBuffer, this.wireframeVertexArray = this.wireframeVertexArray.destroy(), !e.isDestroyed() && o(e.referenceCount) && (--e.referenceCount, 0 === e.referenceCount && e.destroy()))
        }, M.processStateMachine = function (e, t, i, n, r) {
            var a = e.data;
            o(a) || (a = e.data = new M), e.state === v.START && (S(e, n, r), e.state = v.LOADING), e.state === v.LOADING && T(e, t, n);
            for (var s = o(a.vertexArray), u = !o(a.loadedTerrain) && !o(a.upsampledTerrain), l = o(a.terrainData) && a.terrainData.wasCreatedByUpsampling(), c = a.imagery, h = 0, d = c.length; d > h; ++h) {
                var m = c[h];
                if (o(m.loadingImagery)) {
                    if (m.loadingImagery.state === _.PLACEHOLDER) {
                        var p = m.loadingImagery.imageryLayer;
                        if (p.imageryProvider.ready) {
                            m.freeResources(), c.splice(h, 1), p._createTileImagerySkeletons(e, n, h), --h, d = c.length;
                            continue
                        }
                        l = !1
                    }
                    var f = m.processStateMachine(e, t, i);
                    u = u && f, s = s && (f || o(m.readyImagery)), l = l && o(m.loadingImagery) && (m.loadingImagery.state === _.FAILED || m.loadingImagery.state === _.INVALID)
                } else l = !1
            }
            e.upsampledFromParent = l, h === d && (s && (e.renderable = !0), u && (e.state = v.DONE))
        };
        var F = new t, B = new t, z = new t, V = new t, U = new n;
        return M
    }),define("Cesium/Renderer/ComputeCommand", ["../Core/defaultValue", "../Core/PrimitiveType", "../Scene/Pass"], function (e, t, i) {
        "use strict";
        var n = function (t) {
            t = e(t, e.EMPTY_OBJECT), this.vertexArray = t.vertexArray, this.fragmentShaderSource = t.fragmentShaderSource, this.shaderProgram = t.shaderProgram, this.uniformMap = t.uniformMap, this.outputTexture = t.outputTexture, this.preExecute = t.preExecute, this.postExecute = t.postExecute, this.persists = e(t.persists, !1), this.pass = i.COMPUTE, this.owner = t.owner
        };
        return n.prototype.execute = function (e) {
            e.execute(this)
        }, n
    }),define("Cesium/Shaders/ReprojectWebMercatorFS", [], function () {
        "use strict";
        return "uniform sampler2D u_texture;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main()\n{\n    gl_FragColor = texture2D(u_texture, v_textureCoordinates);\n}\n"
    }),define("Cesium/Shaders/ReprojectWebMercatorVS", [], function () {
        "use strict";
        return "attribute vec4 position;\nattribute float webMercatorT;\n\nuniform vec2 u_textureDimensions;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main()\n{\n    v_textureCoordinates = vec2(position.x, webMercatorT);\n    gl_Position = czm_viewportOrthographic * (position * vec4(u_textureDimensions, 1.0, 1.0));\n}\n"
    }),define("Cesium/Scene/Imagery", ["../Core/defined", "../Core/destroyObject", "./ImageryState"], function (e, t, i) {
        "use strict";
        var n = function (t, n, r, o, a) {
            if (this.imageryLayer = t, this.x = n, this.y = r, this.level = o, 0 !== o) {
                var s = n / 2 | 0, u = r / 2 | 0, l = o - 1;
                this.parent = t.getImageryFromCache(s, u, l)
            }
            if (this.state = i.UNLOADED, this.imageUrl = void 0, this.image = void 0, this.texture = void 0, this.credits = void 0, this.referenceCount = 0, !e(a) && t.imageryProvider.ready) {
                var c = t.imageryProvider.tilingScheme;
                a = c.tileXYToRectangle(n, r, o)
            }
            this.rectangle = a
        };
        return n.createPlaceholder = function (e) {
            var t = new n(e, 0, 0, 0);
            return t.addReference(), t.state = i.PLACEHOLDER, t
        }, n.prototype.addReference = function () {
            ++this.referenceCount
        }, n.prototype.releaseReference = function () {
            return --this.referenceCount, 0 === this.referenceCount ? (this.imageryLayer.removeImageryFromCache(this), e(this.parent) && this.parent.releaseReference(), e(this.image) && e(this.image.destroy) && this.image.destroy(), e(this.texture) && this.texture.destroy(), t(this), 0) : this.referenceCount
        }, n.prototype.processStateMachine = function (e, t) {
            this.state === i.UNLOADED && (this.state = i.TRANSITIONING, this.imageryLayer._requestImagery(this)), this.state === i.RECEIVED && (this.state = i.TRANSITIONING, this.imageryLayer._createTexture(e, this)), this.state === i.TEXTURE_LOADED && (this.state = i.TRANSITIONING, this.imageryLayer._reprojectTexture(e, t, this))
        }, n
    }),define("Cesium/Scene/TileImagery", ["../Core/defined", "./ImageryState"], function (e, t) {
        "use strict";
        var i = function (e, t) {
            this.readyImagery = void 0, this.loadingImagery = e, this.textureCoordinateRectangle = t, this.textureTranslationAndScale = void 0
        };
        return i.prototype.freeResources = function () {
            e(this.readyImagery) && this.readyImagery.releaseReference(), e(this.loadingImagery) && this.loadingImagery.releaseReference()
        }, i.prototype.processStateMachine = function (i, n, r) {
            var o = this.loadingImagery, a = o.imageryLayer;
            if (o.processStateMachine(n, r), o.state === t.READY)return e(this.readyImagery) && this.readyImagery.releaseReference(), this.readyImagery = this.loadingImagery, this.loadingImagery = void 0, this.textureTranslationAndScale = a._calculateTextureTranslationAndScale(i, this), !0;
            for (var s, u = o.parent; e(u) && u.state !== t.READY;)u.state !== t.FAILED && u.state !== t.INVALID && (s = s || u), u = u.parent;
            return this.readyImagery !== u && (e(this.readyImagery) && this.readyImagery.releaseReference(), this.readyImagery = u, e(u) && (u.addReference(), this.textureTranslationAndScale = a._calculateTextureTranslationAndScale(i, this))), o.state === t.FAILED || o.state === t.INVALID ? e(s) ? (s.processStateMachine(n, r), !1) : !0 : !1
        }, i
    }),define("Cesium/Scene/ImageryLayer", ["../Core/BoundingRectangle", "../Core/Cartesian2", "../Core/Cartesian4", "../Core/Color", "../Core/ComponentDatatype", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/FeatureDetection", "../Core/GeographicTilingScheme", "../Core/IndexDatatype", "../Core/Math", "../Core/PixelFormat", "../Core/PrimitiveType", "../Core/Rectangle", "../Core/TerrainProvider", "../Core/TileProviderError", "../Renderer/Buffer", "../Renderer/BufferUsage", "../Renderer/ClearCommand", "../Renderer/ComputeCommand", "../Renderer/ContextLimits", "../Renderer/DrawCommand", "../Renderer/Framebuffer", "../Renderer/MipmapHint", "../Renderer/RenderState", "../Renderer/Sampler", "../Renderer/ShaderProgram", "../Renderer/ShaderSource", "../Renderer/Texture", "../Renderer/TextureMagnificationFilter", "../Renderer/TextureMinificationFilter", "../Renderer/TextureWrap", "../Renderer/VertexArray", "../Shaders/ReprojectWebMercatorFS", "../Shaders/ReprojectWebMercatorVS", "../ThirdParty/when", "./Imagery", "./ImageryState", "./TileImagery"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S, T, b, w, x, A, P, I, D, M, O, R, N, L, F, B, z, V, U) {
        "use strict";
        function k(e, t, i, n) {
            if (d.isPowerOfTwo(n.width) && d.isPowerOfTwo(n.height)) {
                var r = t.cache.imageryLayer_mipmapSampler;
                if (!a(r)) {
                    var s = S.maximumTextureFilterAnisotropy;
                    r = t.cache.imageryLayer_mipmapSampler = new A({
                        wrapS: R.CLAMP_TO_EDGE,
                        wrapT: R.CLAMP_TO_EDGE,
                        minificationFilter: O.LINEAR_MIPMAP_LINEAR,
                        magnificationFilter: M.LINEAR,
                        maximumAnisotropy: Math.min(s, o(e._maximumAnisotropy, s))
                    })
                }
                n.generateMipmap(w.NICEST), n.sampler = r
            } else {
                var u = t.cache.imageryLayer_nonMipmapSampler;
                a(u) || (u = t.cache.imageryLayer_nonMipmapSampler = new A({
                    wrapS: R.CLAMP_TO_EDGE,
                    wrapT: R.CLAMP_TO_EDGE,
                    minificationFilter: O.LINEAR,
                    magnificationFilter: M.LINEAR
                })), n.sampler = u
            }
            i.state = V.READY
        }

        function G(e, t, i) {
            return JSON.stringify([e, t, i])
        }

        function H(e, t, i, n) {
            var r = t.cache.imageryLayer_reproject;
            if (!a(r)) {
                r = t.cache.imageryLayer_reproject = {
                    vertexArray: void 0,
                    shaderProgram: void 0,
                    sampler: void 0,
                    destroy: function () {
                        a(this.framebuffer) && this.framebuffer.destroy(), a(this.vertexArray) && this.vertexArray.destroy(), a(this.shaderProgram) && this.shaderProgram.destroy()
                    }
                };
                for (var o = new Float32Array(256), s = 0, u = 0; 64 > u; ++u) {
                    var l = u / 63;
                    o[s++] = 0, o[s++] = l, o[s++] = 1, o[s++] = l
                }
                var c = {
                    position: 0,
                    webMercatorT: 1
                }, m = _.getRegularGridIndices(2, 64), p = g.createIndexBuffer({
                    context: t,
                    typedArray: m,
                    usage: y.STATIC_DRAW,
                    indexDatatype: h.UNSIGNED_SHORT
                });
                r.vertexArray = new N({
                    context: t,
                    attributes: [{
                        index: c.position,
                        vertexBuffer: g.createVertexBuffer({context: t, typedArray: o, usage: y.STATIC_DRAW}),
                        componentsPerAttribute: 2
                    }, {
                        index: c.webMercatorT,
                        vertexBuffer: g.createVertexBuffer({context: t, sizeInBytes: 512, usage: y.STREAM_DRAW}),
                        componentsPerAttribute: 1
                    }],
                    indexBuffer: p
                });
                var f = new I({sources: [F]});
                r.shaderProgram = P.fromCache({
                    context: t,
                    vertexShaderSource: f,
                    fragmentShaderSource: L,
                    attributeLocations: c
                }), r.sampler = new A({
                    wrapS: R.CLAMP_TO_EDGE,
                    wrapT: R.CLAMP_TO_EDGE,
                    minificationFilter: O.LINEAR,
                    magnificationFilter: M.LINEAR
                })
            }
            i.sampler = r.sampler;
            var v = i.width, C = i.height;
            Z.textureDimensions.x = v, Z.textureDimensions.y = C, Z.texture = i;
            var E = Math.sin(n.south), S = .5 * Math.log((1 + E) / (1 - E));
            E = Math.sin(n.north);
            var T = .5 * Math.log((1 + E) / (1 - E)), b = 1 / (T - S), x = new D({
                context: t,
                width: v,
                height: C,
                pixelFormat: i.pixelFormat,
                pixelDatatype: i.pixelDatatype,
                preMultiplyAlpha: i.preMultiplyAlpha
            });
            d.isPowerOfTwo(v) && d.isPowerOfTwo(C) && x.generateMipmap(w.NICEST);
            for (var B = n.south, z = n.north, V = K, U = 0, k = 0; 64 > k; ++k) {
                var G = k / 63, H = d.lerp(B, z, G);
                E = Math.sin(H);
                var W = .5 * Math.log((1 + E) / (1 - E)), q = (W - S) * b;
                V[U++] = q, V[U++] = q
            }
            r.vertexArray.getAttribute(1).vertexBuffer.copyFromArrayView(V), e.shaderProgram = r.shaderProgram, e.outputTexture = x, e.uniformMap = Z, e.vertexArray = r.vertexArray
        }

        function W(e, t, i) {
            var n = e._imageryProvider, r = n.tilingScheme, o = r.ellipsoid, a = e._imageryProvider.tilingScheme instanceof c ? 1 : Math.cos(i), s = r.rectangle, u = o.maximumRadius * s.width * a / (n.tileWidth * r.getNumberOfXTilesAtLevel(0)), l = u / t, h = Math.log(l) / Math.log(2), d = Math.round(h);
            return 0 | d
        }

        var q = function J(e, t) {
            this._imageryProvider = e, t = o(t, {}), this.alpha = o(t.alpha, o(e.defaultAlpha, 1)), this.brightness = o(t.brightness, o(e.defaultBrightness, J.DEFAULT_BRIGHTNESS)), this.contrast = o(t.contrast, o(e.defaultContrast, J.DEFAULT_CONTRAST)), this.hue = o(t.hue, o(e.defaultHue, J.DEFAULT_HUE)), this.saturation = o(t.saturation, o(e.defaultSaturation, J.DEFAULT_SATURATION)), this.gamma = o(t.gamma, o(e.defaultGamma, J.DEFAULT_GAMMA)), this.show = o(t.show, !0), this._minimumTerrainLevel = t.minimumTerrainLevel, this._maximumTerrainLevel = t.maximumTerrainLevel, this._rectangle = o(t.rectangle, f.MAX_VALUE), this._maximumAnisotropy = t.maximumAnisotropy, this._imageryCache = {}, this._skeletonPlaceholder = new U(z.createPlaceholder(this)), this._show = !0, this._layerIndex = -1, this._isBaseLayer = !1, this._requestImageError = void 0
        };
        s(q.prototype, {
            imageryProvider: {
                get: function () {
                    return this._imageryProvider
                }
            }, rectangle: {
                get: function () {
                    return this._rectangle
                }
            }
        }), q.DEFAULT_BRIGHTNESS = 1, q.DEFAULT_CONTRAST = 1, q.DEFAULT_HUE = 0, q.DEFAULT_SATURATION = 1, q.DEFAULT_GAMMA = 1, q.prototype.isBaseLayer = function () {
            return this._isBaseLayer
        }, q.prototype.isDestroyed = function () {
            return !1
        }, q.prototype.destroy = function () {
            return u(this)
        };
        var j = new f, Y = new f, X = new f;
        q.prototype._createTileImagerySkeletons = function (e, t, n) {
            var r = e.data;
            if (a(this._minimumTerrainLevel) && e.level < this._minimumTerrainLevel)return !1;
            if (a(this._maximumTerrainLevel) && e.level > this._maximumTerrainLevel)return !1;
            var o = this._imageryProvider;
            if (a(n) || (n = r.imagery.length), !o.ready)return this._skeletonPlaceholder.loadingImagery.addReference(), r.imagery.splice(n, 0, this._skeletonPlaceholder), !0;
            var s = f.intersection(o.rectangle, this._rectangle, j), u = f.intersection(e.rectangle, s, Y);
            if (!a(u)) {
                if (!this.isBaseLayer())return !1;
                var l = s, c = e.rectangle;
                u = Y, c.south >= l.north ? u.north = u.south = l.north : c.north <= l.south ? u.north = u.south = l.south : (u.south = Math.max(c.south, l.south), u.north = Math.min(c.north, l.north)), c.west >= l.east ? u.west = u.east = l.east : c.east <= l.west ? u.west = u.east = l.west : (u.west = Math.max(c.west, l.west), u.east = Math.min(c.east, l.east))
            }
            var h = 0;
            u.south > 0 ? h = u.south : u.north < 0 && (h = u.north);
            var d = 1, m = d * t.getLevelMaximumGeometricError(e.level), p = W(this, m, h);
            p = Math.max(0, p);
            var _ = o.maximumLevel;
            if (p > _ && (p = _), a(o.minimumLevel)) {
                var v = o.minimumLevel;
                v > p && (p = v)
            }
            var g = o.tilingScheme, y = g.positionToTileXY(f.northwest(u), p), C = g.positionToTileXY(f.southeast(u), p), E = e.rectangle.height / 512, S = e.rectangle.width / 512, T = g.tileXYToRectangle(y.x, y.y, p);
            Math.abs(T.south - e.rectangle.north) < S && y.y < C.y && ++y.y, Math.abs(T.east - e.rectangle.west) < E && y.x < C.x && ++y.x;
            var b = g.tileXYToRectangle(C.x, C.y, p);
            Math.abs(b.north - e.rectangle.south) < S && C.y > y.y && --C.y, Math.abs(b.west - e.rectangle.east) < E && C.x > y.x && --C.x;
            var w, x, A = e.rectangle, P = g.tileXYToRectangle(y.x, y.y, p), I = f.intersection(P, s, X), D = 0, M = 1;
            !this.isBaseLayer() && Math.abs(I.west - e.rectangle.west) >= E && (D = Math.min(1, (I.west - A.west) / A.width)), !this.isBaseLayer() && Math.abs(I.north - e.rectangle.north) >= S && (M = Math.max(0, (I.north - A.south) / A.height));
            for (var O = M, R = y.x; R <= C.x; R++) {
                w = D, P = g.tileXYToRectangle(R, y.y, p), I = f.intersection(P, s, X), D = Math.min(1, (I.east - A.west) / A.width), R === C.x && (this.isBaseLayer() || Math.abs(I.east - e.rectangle.east) < E) && (D = 1), M = O;
                for (var N = y.y; N <= C.y; N++) {
                    x = M, P = g.tileXYToRectangle(R, N, p), I = f.intersection(P, s, X), M = Math.max(0, (I.south - A.south) / A.height), N === C.y && (this.isBaseLayer() || Math.abs(I.south - e.rectangle.south) < S) && (M = 0);
                    var L = new i(w, M, D, x), F = this.getImageryFromCache(R, N, p, P);
                    r.imagery.splice(n, 0, new U(F, L)), ++n
                }
            }
            return !0
        }, q.prototype._calculateTextureTranslationAndScale = function (e, t) {
            var n = t.readyImagery.rectangle, r = e.rectangle, o = r.width, a = r.height, s = o / n.width, u = a / n.height;
            return new i(s * (r.west - n.west) / o, u * (r.south - n.south) / a, s, u)
        }, q.prototype._requestImagery = function (e) {
            function t(t) {
                return a(t) ? (e.image = t, e.state = V.RECEIVED, void v.handleSuccess(o._requestImageError)) : i()
            }

            function i(t) {
                e.state = V.FAILED;
                var i = "Failed to obtain image tile X: " + e.x + " Y: " + e.y + " Level: " + e.level + ".";
                o._requestImageError = v.handleError(o._requestImageError, r, r.errorEvent, i, e.x, e.y, e.level, n, t)
            }

            function n() {
                e.state = V.TRANSITIONING;
                var n = r.requestImage(e.x, e.y, e.level);
                return a(n) ? (a(r.getTileCredits) && (e.credits = r.getTileCredits(e.x, e.y, e.level)), void B(n, t, i)) : void(e.state = V.UNLOADED)
            }

            var r = this._imageryProvider, o = this;
            n()
        }, q.prototype._createTexture = function (e, t) {
            var i = this._imageryProvider;
            if (a(i.tileDiscardPolicy)) {
                var n = i.tileDiscardPolicy;
                if (a(n)) {
                    if (!n.isReady())return void(t.state = V.RECEIVED);
                    if (n.shouldDiscardImage(t.image))return void(t.state = V.INVALID)
                }
            }
            var r = new D({context: e, source: t.image, pixelFormat: i.hasAlphaChannel ? m.RGBA : m.RGB});
            t.texture = r, t.image = void 0, t.state = V.TEXTURE_LOADED
        }, q.prototype._reprojectTexture = function (e, t, i) {
            var n = i.texture, r = i.rectangle;
            if (!(this._imageryProvider.tilingScheme instanceof c) && r.width / n.width > 1e-5) {
                var o = this, a = new E({
                    persists: !0, owner: this, preExecute: function (t) {
                        H(t, e, n, i.rectangle)
                    }, postExecute: function (t) {
                        n.destroy(), i.texture = t, k(o, e, i, t)
                    }
                });
                t.push(a)
            } else k(this, e, i, n)
        }, q.prototype.getImageryFromCache = function (e, t, i, n) {
            var r = G(e, t, i), o = this._imageryCache[r];
            return a(o) || (o = new z(this, e, t, i, n), this._imageryCache[r] = o), o.addReference(), o
        }, q.prototype.removeImageryFromCache = function (e) {
            var t = G(e.x, e.y, e.level);
            delete this._imageryCache[t]
        };
        var Z = {
            u_textureDimensions: function () {
                return this.textureDimensions
            }, u_texture: function () {
                return this.texture
            }, textureDimensions: new t, texture: void 0
        }, K = l.supportsTypedArrays() ? new Float32Array(128) : void 0;
        return q
    }),define("Cesium/Scene/GlobeSurfaceTileProvider", ["../Core/BoundingSphere", "../Core/BoxOutlineGeometry", "../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/Color", "../Core/ColorGeometryInstanceAttribute", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Event", "../Core/FeatureDetection", "../Core/GeometryInstance", "../Core/GeometryPipeline", "../Core/IndexDatatype", "../Core/Intersect", "../Core/Matrix4", "../Core/OrientedBoundingBox", "../Core/PrimitiveType", "../Core/Rectangle", "../Core/SphereOutlineGeometry", "../Core/Visibility", "../Core/WebMercatorProjection", "../Renderer/Buffer", "../Renderer/BufferUsage", "../Renderer/ContextLimits", "../Renderer/DrawCommand", "../Renderer/RenderState", "../Renderer/VertexArray", "../Scene/BlendingState", "../Scene/DepthFunction", "../Scene/Pass", "../Scene/PerInstanceColorAppearance", "../Scene/Primitive", "../ThirdParty/when", "./GlobeSurfaceTile", "./ImageryLayer", "./ImageryState", "./QuadtreeTileLoadState", "./SceneMode"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S, T, b, w, x, A, P, I, D, M, O, R, N, L, F, B, z, V, U, k) {
        "use strict";
        function G(e, t) {
            var i = e.loadingImagery;
            u(i) || (i = e.readyImagery);
            var n = t.loadingImagery;
            return u(n) || (n = t.readyImagery), i.imageryLayer._layerIndex - n.imageryLayer._layerIndex
        }

        function H() {
            var e = {
                u_initialColor: function () {
                    return this.initialColor
                },
                u_zoomedOutOceanSpecularIntensity: function () {
                    return this.zoomedOutOceanSpecularIntensity
                },
                u_oceanNormalMap: function () {
                    return this.oceanNormalMap
                },
                u_lightingFadeDistance: function () {
                    return this.lightingFadeDistance
                },
                u_center3D: function () {
                    return this.center3D
                },
                u_tileRectangle: function () {
                    return this.tileRectangle
                },
                u_modifiedModelView: function () {
                    return this.modifiedModelView
                },
                u_dayTextures: function () {
                    return this.dayTextures
                },
                u_dayTextureTranslationAndScale: function () {
                    return this.dayTextureTranslationAndScale
                },
                u_dayTextureTexCoordsRectangle: function () {
                    return this.dayTextureTexCoordsRectangle
                },
                u_dayTextureAlpha: function () {
                    return this.dayTextureAlpha
                },
                u_dayTextureBrightness: function () {
                    return this.dayTextureBrightness
                },
                u_dayTextureContrast: function () {
                    return this.dayTextureContrast
                },
                u_dayTextureHue: function () {
                    return this.dayTextureHue
                },
                u_dayTextureSaturation: function () {
                    return this.dayTextureSaturation
                },
                u_dayTextureOneOverGamma: function () {
                    return this.dayTextureOneOverGamma
                },
                u_dayIntensity: function () {
                    return this.dayIntensity
                },
                u_southAndNorthLatitude: function () {
                    return this.southAndNorthLatitude
                },
                u_southMercatorYLowAndHighAndOneOverHeight: function () {
                    return this.southMercatorYLowAndHighAndOneOverHeight
                },
                u_waterMask: function () {
                    return this.waterMask
                },
                u_waterMaskTranslationAndScale: function () {
                    return this.waterMaskTranslationAndScale
                },
                initialColor: new r(0, 0, .5, 1),
                zoomedOutOceanSpecularIntensity: .5,
                oceanNormalMap: void 0,
                lightingFadeDistance: new i(65e5, 9e6),
                center3D: void 0,
                modifiedModelView: new g,
                tileRectangle: new r,
                dayTextures: [],
                dayTextureTranslationAndScale: [],
                dayTextureTexCoordsRectangle: [],
                dayTextureAlpha: [],
                dayTextureBrightness: [],
                dayTextureContrast: [],
                dayTextureHue: [],
                dayTextureSaturation: [],
                dayTextureOneOverGamma: [],
                dayIntensity: 0,
                southAndNorthLatitude: new i,
                southMercatorYLowAndHighAndOneOverHeight: new n,
                waterMask: void 0,
                waterMaskTranslationAndScale: new r
            };
            return e
        }

        function W(e, t, i) {
            var n = i.data;
            if (!u(n.wireframeVertexArray) && !u(n.meshForWireframePromise) && (n.meshForWireframePromise = n.terrainData.createMesh(t._terrainProvider.tilingScheme, i.x, i.y, i.level), u(n.meshForWireframePromise))) {
                var r = n.vertexArray;
                F(n.meshForWireframePromise, function (t) {
                    n.vertexArray === r && (n.wireframeVertexArray = q(e, n.vertexArray, t)), n.meshForWireframePromise = void 0
                })
            }
        }

        function q(e, t, i) {
            var n = {indices: i.indices, primitiveType: C.TRIANGLES};
            f.toWireframe(n);
            var r = n.indices, o = w.createIndexBuffer({
                context: e,
                typedArray: r,
                usage: x.STATIC_DRAW,
                indexDatatype: _.UNSIGNED_SHORT
            });
            return new D({context: e, attributes: t._attributes, indexBuffer: o})
        }

        function j(t, i, a, s, l) {
            var c = i.data, h = s.camera.viewMatrix, d = A.maximumTextureImageUnits, m = c.waterMaskTexture, p = t.hasWaterMask && u(m), f = t.oceanNormalMap, _ = p && u(f), v = t.terrainProvider.ready && t.terrainProvider.hasVertexNormals;
            p && --d, _ && --d;
            var S = c.center, T = Q, w = 0, x = 0, I = 0, D = 0, M = 0, O = !1;
            if (s.mode !== k.SCENE3D) {
                var N = s.mapProjection, L = N.project(E.southwest(i.rectangle), te), F = N.project(E.northeast(i.rectangle), ie);
                if (T.x = L.x, T.y = L.y, T.z = F.x, T.w = F.y, s.mode !== k.MORPHING && (S = $, S.x = 0, S.y = .5 * (T.z + T.x), S.z = .5 * (T.w + T.y), T.x -= S.y, T.y -= S.z, T.z -= S.y, T.w -= S.z), N instanceof b) {
                    w = i.rectangle.south, x = i.rectangle.north;
                    var B = b.geodeticLatitudeToMercatorAngle(w), U = b.geodeticLatitudeToMercatorAngle(x);
                    K[0] = B, I = K[0], D = B - K[0], M = 1 / (U - B), O = !0
                }
            }
            var G = g.multiplyByPoint(h, S, ee);
            g.setTranslation(h, G, J);
            var q = c.imagery, j = 0, Y = q.length, X = t._renderState, Z = t._blendRenderState, ne = X, re = t._firstPassInitialColor;
            u(t._debug.boundingSphereTile) || ce();
            do {
                var oe, ae, se = 0;
                t._drawCommands.length <= t._usedDrawCommands ? (oe = new P, oe.owner = i, oe.cull = !1, oe.boundingVolume = new e, oe.orientedBoundingBox = void 0, ae = H(), t._drawCommands.push(oe), t._uniformMaps.push(ae)) : (oe = t._drawCommands[t._usedDrawCommands], ae = t._uniformMaps[t._usedDrawCommands]), oe.owner = i, ++t._usedDrawCommands, i === t._debug.boundingSphereTile && (u(c.orientedBoundingBox) ? ue(c.orientedBoundingBox, o.RED).update(a, s, l) : u(c.boundingSphere3D) && le(c.boundingSphere3D, o.RED).update(a, s, l)), r.clone(re, ae.initialColor), ae.oceanNormalMap = f, ae.lightingFadeDistance.x = t.lightingFadeOutDistance, ae.lightingFadeDistance.y = t.lightingFadeInDistance, ae.zoomedOutOceanSpecularIntensity = t.zoomedOutOceanSpecularIntensity, ae.center3D = c.center, r.clone(T, ae.tileRectangle), ae.southAndNorthLatitude.x = w, ae.southAndNorthLatitude.y = x, ae.southMercatorYLowAndHighAndOneOverHeight.x = D, ae.southMercatorYLowAndHighAndOneOverHeight.y = I, ae.southMercatorYLowAndHighAndOneOverHeight.z = M, g.clone(J, ae.modifiedModelView);
                for (var de = !1, me = !1, pe = !1, fe = !1, _e = !1, ve = !1; d > se && Y > j;) {
                    var ge = q[j], ye = ge.readyImagery;
                    if (++j, u(ye) && ye.state === V.READY && 0 !== ye.imageryLayer.alpha) {
                        var Ce = ye.imageryLayer;
                        if (u(ge.textureTranslationAndScale) || (ge.textureTranslationAndScale = Ce._calculateTextureTranslationAndScale(i, ge)), ae.dayTextures[se] = ye.texture, ae.dayTextureTranslationAndScale[se] = ge.textureTranslationAndScale, ae.dayTextureTexCoordsRectangle[se] = ge.textureCoordinateRectangle, ae.dayTextureAlpha[se] = Ce.alpha, ve = ve || 1 !== ae.dayTextureAlpha[se], ae.dayTextureBrightness[se] = Ce.brightness, de = de || ae.dayTextureBrightness[se] !== z.DEFAULT_BRIGHTNESS, ae.dayTextureContrast[se] = Ce.contrast, me = me || ae.dayTextureContrast[se] !== z.DEFAULT_CONTRAST, ae.dayTextureHue[se] = Ce.hue, pe = pe || ae.dayTextureHue[se] !== z.DEFAULT_HUE, ae.dayTextureSaturation[se] = Ce.saturation, fe = fe || ae.dayTextureSaturation[se] !== z.DEFAULT_SATURATION, ae.dayTextureOneOverGamma[se] = 1 / Ce.gamma, _e = _e || ae.dayTextureOneOverGamma[se] !== 1 / z.DEFAULT_GAMMA, u(ye.credits))for (var Ee = s.creditDisplay, Se = ye.credits, Te = 0, be = Se.length; be > Te; ++Te)Ee.addCredit(Se[Te]);
                        ++se
                    }
                }
                ae.dayTextures.length = se, ae.waterMask = m, r.clone(c.waterMaskTranslationAndScale, ae.waterMaskTranslationAndScale), oe.shaderProgram = t._surfaceShaderSet.getShaderProgram(a, s.mode, c, se, de, me, pe, fe, _e, ve, p, _, t.enableLighting, v, O), oe.renderState = ne, oe.primitiveType = C.TRIANGLES, oe.vertexArray = c.vertexArray, oe.uniformMap = ae, oe.pass = R.GLOBE, t._debug.wireframe && (W(a, t, i), u(c.wireframeVertexArray) && (oe.vertexArray = c.wireframeVertexArray, oe.primitiveType = C.LINES));
                var we = oe.boundingVolume, xe = oe.orientedBoundingBox;
                s.mode !== k.SCENE3D ? (e.fromRectangleWithHeights2D(i.rectangle, s.mapProjection, c.minimumHeight, c.maximumHeight, we), n.fromElements(we.center.z, we.center.x, we.center.y, we.center), s.mode === k.MORPHING && (we = e.union(c.boundingSphere3D, we, we))) : (oe.boundingVolume = e.clone(c.boundingSphere3D, we), oe.orientedBoundingBox = y.clone(c.orientedBoundingBox, xe)), l.push(oe), ne = Z, re = he
            } while (Y > j)
        }

        function Y(e, t, i, n, r) {
            var o;
            e._pickCommands.length <= e._usedPickCommands ? (o = new P, o.cull = !1, e._pickCommands.push(o)) : o = e._pickCommands[e._usedPickCommands], ++e._usedPickCommands;
            var a = n.projection instanceof b;
            o.shaderProgram = e._surfaceShaderSet.getShaderProgram(i, n.mode, a), o.renderState = e._pickRenderState, o.owner = t.owner, o.primitiveType = t.primitiveType, o.vertexArray = t.vertexArray, o.uniformMap = t.uniformMap, o.boundingVolume = t.boundingVolume, o.orientedBoundingBox = o.orientedBoundingBox, o.pass = t.pass, r.push(o)
        }

        var X = function de(e) {
            this.lightingFadeOutDistance = 65e5, this.lightingFadeInDistance = 9e6, this.hasWaterMask = !1, this.oceanNormalMap = void 0, this.zoomedOutOceanSpecularIntensity = .5, this.enableLighting = !1, this._quadtree = void 0, this._terrainProvider = e.terrainProvider, this._imageryLayers = e.imageryLayers, this._surfaceShaderSet = e.surfaceShaderSet, this._renderState = void 0, this._blendRenderState = void 0, this._pickRenderState = void 0, this._errorEvent = new d, this._imageryLayers.layerAdded.addEventListener(de.prototype._onLayerAdded, this), this._imageryLayers.layerRemoved.addEventListener(de.prototype._onLayerRemoved, this), this._imageryLayers.layerMoved.addEventListener(de.prototype._onLayerMoved, this), this._imageryLayers.layerShownOrHidden.addEventListener(de.prototype._onLayerShownOrHidden, this), this._layerOrderChanged = !1, this._tilesToRenderByTextureCount = [], this._drawCommands = [], this._uniformMaps = [], this._pickCommands = [], this._usedDrawCommands = 0, this._usedPickCommands = 0, this._debug = {
                wireframe: !1,
                boundingSphereTile: void 0
            }, this._baseColor = void 0, this._firstPassInitialColor = void 0, this.baseColor = new o(0, 0, .5, 1)
        };
        l(X.prototype, {
            baseColor: {
                get: function () {
                    return this._baseColor
                }, set: function (e) {
                    this._baseColor = e, this._firstPassInitialColor = r.fromColor(e, this._firstPassInitialColor)
                }
            }, quadtree: {
                get: function () {
                    return this._quadtree
                }, set: function (e) {
                    this._quadtree = e
                }
            }, ready: {
                get: function () {
                    return this._terrainProvider.ready && (0 === this._imageryLayers.length || this._imageryLayers.get(0).imageryProvider.ready)
                }
            }, tilingScheme: {
                get: function () {
                    return this._terrainProvider.tilingScheme
                }
            }, errorEvent: {
                get: function () {
                    return this._errorEvent
                }
            }, terrainProvider: {
                get: function () {
                    return this._terrainProvider
                }, set: function (e) {
                    this._terrainProvider !== e && (this._terrainProvider = e, u(this._quadtree) && this._quadtree.invalidateAllTiles())
                }
            }
        }), X.prototype.beginUpdate = function (e, t, i) {
            this._imageryLayers._update(), this._layerOrderChanged && (this._layerOrderChanged = !1, this._quadtree.forEachLoadedTile(function (e) {
                e.data.imagery.sort(G)
            }));
            var n, r, o = this._tilesToRenderByTextureCount;
            for (n = 0, r = o.length; r > n; ++n) {
                var a = o[n];
                u(a) && (a.length = 0)
            }
            this._usedDrawCommands = 0;
            var s = t.creditDisplay;
            this._terrainProvider.ready && u(this._terrainProvider.credit) && s.addCredit(this._terrainProvider.credit);
            var l = this._imageryLayers;
            for (n = 0, r = l.length; r > n; ++n) {
                var c = l.get(n).imageryProvider;
                c.ready && u(c.credit) && s.addCredit(c.credit)
            }
        }, X.prototype.endUpdate = function (e, t, i) {
            u(this._renderState) || (this._renderState = I.fromCache({
                cull: {enabled: !0},
                depthTest: {enabled: !0, func: O.LESS}
            }), this._blendRenderState = I.fromCache({
                cull: {enabled: !0},
                depthTest: {enabled: !0, func: O.LESS_OR_EQUAL},
                blending: M.ALPHA_BLEND
            }));
            for (var n = this._tilesToRenderByTextureCount, r = 0, o = n.length; o > r; ++r) {
                var a = n[r];
                if (u(a))for (var s = 0, l = a.length; l > s; ++s)j(this, a[s], e, t, i)
            }
        }, X.prototype.updateForPick = function (e, t, i) {
            u(this._pickRenderState) || (this._pickRenderState = I.fromCache({
                colorMask: {
                    red: !1,
                    green: !1,
                    blue: !1,
                    alpha: !1
                }, depthTest: {enabled: !0}
            })), this._usedPickCommands = 0;
            for (var n = this._drawCommands, r = (this._tilesToRenderByTextureCount, 0), o = this._usedDrawCommands; o > r; ++r)Y(this, n[r], e, t, i)
        }, X.prototype.getLevelMaximumGeometricError = function (e) {
            return this._terrainProvider.getLevelMaximumGeometricError(e)
        }, X.prototype.loadTile = function (e, t, i, n) {
            B.processStateMachine(n, e, i, this._terrainProvider, this._imageryLayers)
        };
        var Z = new e;
        X.prototype.computeTileVisibility = function (t, i, r) {
            var o = t.data, a = i.cullingVolume, l = s(o.orientedBoundingBox, o.boundingSphere3D);
            i.mode !== k.SCENE3D && (l = Z, e.fromRectangleWithHeights2D(t.rectangle, i.mapProjection, o.minimumHeight, o.maximumHeight, l), n.fromElements(l.center.z, l.center.x, l.center.y, l.center), i.mode === k.MORPHING && (l = e.union(o.boundingSphere3D, l, l)));
            var c = a.computeVisibility(l);
            if (c === v.OUTSIDE)return T.NONE;
            if (i.mode === k.SCENE3D) {
                var h = o.occludeePointInScaledSpace;
                return u(h) ? r.ellipsoid.isScaledSpacePointVisible(h) ? c : T.NONE : c
            }
            return c
        };
        var K = m.supportsTypedArrays() ? new Float32Array(1) : void 0, J = new g, Q = new r, $ = new n, ee = new n, te = new n, ie = new n;
        X.prototype.showTileThisFrame = function (e, t, i, n) {
            for (var r = 0, o = e.data.imagery, a = 0, s = o.length; s > a; ++a) {
                var l = o[a];
                u(l.readyImagery) && 0 !== l.readyImagery.imageryLayer.alpha && ++r
            }
            var c = this._tilesToRenderByTextureCount[r];
            u(c) || (c = [], this._tilesToRenderByTextureCount[r] = c), c.push(e);
            var h = this._debug;
            ++h.tilesRendered, h.texturesRendered += r
        };
        var ne = new n, re = new n, oe = new n(0, -1, 0), ae = new n(0, 0, -1), se = new n;
        X.prototype.computeDistanceToTile = function (e, t) {
            var i = e.data, r = i.southwestCornerCartesian, o = i.northeastCornerCartesian, a = i.westNormal, s = i.southNormal, u = i.eastNormal, l = i.northNormal, c = i.maximumHeight;
            t.mode !== k.SCENE3D && (r = t.mapProjection.project(E.southwest(e.rectangle), ne), r.z = r.y, r.y = r.x, r.x = 0, o = t.mapProjection.project(E.northeast(e.rectangle), re), o.z = o.y, o.y = o.x, o.x = 0, a = oe, u = n.UNIT_Y, s = ae, l = n.UNIT_Z, c = 0);
            var h, d = t.camera.positionWC, m = t.camera.positionCartographic, p = n.subtract(d, r, se), f = n.dot(p, a), _ = n.dot(p, s), v = n.subtract(d, o, se), g = n.dot(v, u), y = n.dot(v, l);
            h = t.mode === k.SCENE3D ? m.height : d.x;
            var C = h - c, S = 0;
            return f > 0 ? S += f * f : g > 0 && (S += g * g), _ > 0 ? S += _ * _ : y > 0 && (S += y * y), C > 0 && (S += C * C), Math.sqrt(S)
        }, X.prototype.isDestroyed = function () {
            return !1
        }, X.prototype.destroy = function () {
            return this._tileProvider = this._tileProvider && this._tileProvider.destroy(), c(this)
        }, X.prototype._onLayerAdded = function (e, t) {
            if (e.show) {
                var i = this._terrainProvider;
                this._quadtree.forEachLoadedTile(function (t) {
                    e._createTileImagerySkeletons(t, i) && (t.state = U.LOADING)
                }), this._layerOrderChanged = !0
            }
        }, X.prototype._onLayerRemoved = function (e, t) {
            this._quadtree.forEachLoadedTile(function (t) {
                for (var i = t.data.imagery, n = -1, r = 0, o = 0, a = i.length; a > o; ++o) {
                    var s = i[o], l = s.loadingImagery;
                    if (u(l) || (l = s.readyImagery), l.imageryLayer === e)-1 === n && (n = o), s.freeResources(), ++r; else if (-1 !== n)break
                }
                -1 !== n && i.splice(n, r)
            })
        }, X.prototype._onLayerMoved = function (e, t, i) {
            this._layerOrderChanged = !0
        }, X.prototype._onLayerShownOrHidden = function (e, t, i) {
            i ? this._onLayerAdded(e, t) : this._onLayerRemoved(e, t)
        };
        var ue, le, ce;
        !function () {
            function e(e) {
                return new L({geometryInstances: e, appearance: new N({translucent: !1, flat: !0}), asynchronous: !1})
            }

            var i, r, o = new p({geometry: t.fromDimensions({dimensions: new n(2, 2, 2)})}), s = new p({geometry: new S({radius: 1})}), l = new g;
            ue = function (t, n) {
                return t === i ? r : (ce(), i = t, l = g.fromRotationTranslation(t.halfAxes, t.center, l), o.modelMatrix = l, o.attributes.color = a.fromColor(n), r = e(o))
            }, le = function (t, n) {
                return t === i ? r : (ce(), i = t, l = g.fromTranslation(t.center, l), l = g.multiplyByUniformScale(l, t.radius, l), s.modelMatrix = l, s.attributes.color = a.fromColor(n), r = e(s))
            }, ce = function () {
                u(r) && (r.destroy(), r = void 0, i = void 0)
            }
        }();
        var he = new r(0, 0, 0, 0);
        return X
    }),define("Cesium/Scene/ImageryLayerCollection", ["../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Event", "../Core/Math", "../Core/Rectangle", "../ThirdParty/when", "./ImageryLayer"], function (e, t, i, n, r, o, a, s, u, l) {
        "use strict";
        function c(e, t) {
            var i = e.indexOf(t);
            return i
        }

        function h(e, t, i) {
            var n = e._layers;
            if (t = a.clamp(t, 0, n.length - 1), i = a.clamp(i, 0, n.length - 1), t !== i) {
                var r = n[t];
                n[t] = n[i], n[i] = r, e._update(), e.layerMoved.raiseEvent(r, i, t)
            }
        }

        var d = function () {
            this._layers = [], this.layerAdded = new o, this.layerRemoved = new o, this.layerMoved = new o, this.layerShownOrHidden = new o
        };
        i(d.prototype, {
            length: {
                get: function () {
                    return this._layers.length
                }
            }
        }), d.prototype.add = function (e, i) {
            var n = t(i);
            n ? this._layers.splice(i, 0, e) : (i = this._layers.length, this._layers.push(e)), this._update(), this.layerAdded.raiseEvent(e, i)
        }, d.prototype.addImageryProvider = function (e, t) {
            var i = new l(e);
            return this.add(i, t), i
        }, d.prototype.remove = function (t, i) {
            i = e(i, !0);
            var n = this._layers.indexOf(t);
            return -1 !== n ? (this._layers.splice(n, 1), this._update(), this.layerRemoved.raiseEvent(t, n), i && t.destroy(), !0) : !1
        }, d.prototype.removeAll = function (t) {
            t = e(t, !0);
            for (var i = this._layers, n = 0, r = i.length; r > n; n++) {
                var o = i[n];
                this.layerRemoved.raiseEvent(o, n), t && o.destroy()
            }
            this._layers = []
        }, d.prototype.contains = function (e) {
            return -1 !== this.indexOf(e)
        }, d.prototype.indexOf = function (e) {
            return this._layers.indexOf(e)
        }, d.prototype.get = function (e) {
            return this._layers[e]
        }, d.prototype.raise = function (e) {
            var t = c(this._layers, e);
            h(this, t, t + 1)
        }, d.prototype.lower = function (e) {
            var t = c(this._layers, e);
            h(this, t, t - 1)
        }, d.prototype.raiseToTop = function (e) {
            var t = c(this._layers, e);
            t !== this._layers.length - 1 && (this._layers.splice(t, 1), this._layers.push(e), this._update(), this.layerMoved.raiseEvent(e, this._layers.length - 1, t))
        }, d.prototype.lowerToBottom = function (e) {
            var t = c(this._layers, e);
            0 !== t && (this._layers.splice(t, 1), this._layers.splice(0, 0, e), this._update(), this.layerMoved.raiseEvent(e, 0, t))
        };
        var m = new s;
        return d.prototype.pickImageryLayerFeatures = function (e, i) {
            var n = i.globe.pick(e, i);
            if (!t(n))return void 0;
            for (var r, o = i.globe.ellipsoid.cartesianToCartographic(n), l = i.globe._surface._tilesToRender, c = (l.length, 0); !t(r) && c < l.length; ++c) {
                var h = l[c];
                s.contains(h.rectangle, o) && (r = h)
            }
            if (!t(r))return void 0;
            for (var d = (r.rectangle, r.data.imagery), p = [], f = d.length - 1; f >= 0; --f) {
                var _ = d[f], v = _.readyImagery;
                if (t(v)) {
                    var g = v.imageryLayer.imageryProvider;
                    if (t(g.pickFeatures) && s.contains(v.rectangle, o)) {
                        var y = m, C = 1 / 1024;
                        if (y.west = a.lerp(r.rectangle.west, r.rectangle.east, _.textureCoordinateRectangle.x - C), y.east = a.lerp(r.rectangle.west, r.rectangle.east, _.textureCoordinateRectangle.z + C), y.south = a.lerp(r.rectangle.south, r.rectangle.north, _.textureCoordinateRectangle.y - C), y.north = a.lerp(r.rectangle.south, r.rectangle.north, _.textureCoordinateRectangle.w + C), s.contains(y, o)) {
                            var E = g.pickFeatures(v.x, v.y, v.level, o.longitude, o.latitude);
                            t(E) && p.push(E)
                        }
                    }
                }
            }
            return 0 === p.length ? void 0 : u.all(p, function (e) {
                for (var i = [], n = 0; n < e.length; ++n) {
                    var r = e[n];
                    if (t(r) && r.length > 0)for (var a = 0; a < r.length; ++a) {
                        var s = r[a];
                        t(s.position) || (s.position = o), i.push(s)
                    }
                }
                return i
            })
        }, d.prototype.isDestroyed = function () {
            return !1
        }, d.prototype.destroy = function () {
            return this.removeAll(!0), n(this)
        }, d.prototype._update = function () {
            for (var e, i, n = !0, r = this._layers, o = 0, a = r.length; a > o; ++o)i = r[o], i._layerIndex = o, i.show ? (i._isBaseLayer = n, n = !1) : i._isBaseLayer = !1, i.show !== i._show && (t(i._show) && (t(e) || (e = []), e.push(i)), i._show = i.show);
            if (t(e))for (o = 0, a = e.length; a > o; ++o)i = e[o], this.layerShownOrHidden.raiseEvent(i, i._layerIndex, i.show)
        }, d
    }),define("Cesium/Core/EllipsoidalOccluder", ["./BoundingSphere", "./Cartesian3", "./defaultValue", "./defined", "./defineProperties", "./DeveloperError", "./Rectangle"], function (e, t, i, n, r, o, a) {
        "use strict";
        function s(e, i, n) {
            var r = e.transformPositionToScaledSpace(i, p), o = t.magnitudeSquared(r), a = Math.sqrt(o), s = t.divideByScalar(r, a, f);
            o = Math.max(1, o), a = Math.max(1, a);
            var u = t.dot(s, n), l = t.magnitude(t.cross(s, n, s)), c = 1 / a, h = Math.sqrt(o - 1) * c;
            return 1 / (u * c - l * h)
        }

        function u(e, i, n) {
            return 0 >= i || i === 1 / 0 || i !== i ? void 0 : t.multiplyByScalar(e, i, n)
        }

        function l(e, i) {
            return e.transformPositionToScaledSpace(i, _), t.normalize(_, _)
        }

        var c = function (e, i) {
            this._ellipsoid = e, this._cameraPosition = new t, this._cameraPositionInScaledSpace = new t, this._distanceToLimbInScaledSpaceSquared = 0, n(i) && (this.cameraPosition = i)
        };
        r(c.prototype, {
            ellipsoid: {
                get: function () {
                    return this._ellipsoid
                }
            }, cameraPosition: {
                get: function () {
                    return this._cameraPosition
                }, set: function (e) {
                    var i = this._ellipsoid, n = i.transformPositionToScaledSpace(e, this._cameraPositionInScaledSpace), r = t.magnitudeSquared(n) - 1;
                    t.clone(e, this._cameraPosition), this._cameraPositionInScaledSpace = n, this._distanceToLimbInScaledSpaceSquared = r
                }
            }
        });
        var h = new t;
        c.prototype.isPointVisible = function (e) {
            var t = this._ellipsoid, i = t.transformPositionToScaledSpace(e, h);
            return this.isScaledSpacePointVisible(i)
        }, c.prototype.isScaledSpacePointVisible = function (e) {
            if (this._distanceToLimbInScaledSpaceSquared < 0)return !0;
            var i = this._cameraPositionInScaledSpace, n = this._distanceToLimbInScaledSpaceSquared, r = t.subtract(e, i, h), o = -t.dot(r, i), a = o > n && o * o / t.magnitudeSquared(r) > n;
            return !a
        }, c.prototype.computeHorizonCullingPoint = function (e, i, r) {
            n(r) || (r = new t);
            for (var o = this._ellipsoid, a = l(o, e), c = 0, h = 0, d = i.length; d > h; ++h) {
                var m = i[h], p = s(o, m, a);
                c = Math.max(c, p)
            }
            return u(a, c, r)
        };
        var d = new t;
        c.prototype.computeHorizonCullingPointFromVertices = function (e, r, o, a, c) {
            n(c) || (c = new t), a = i(a, t.ZERO);
            for (var h = this._ellipsoid, m = l(h, e), p = 0, f = 0, _ = r.length; _ > f; f += o) {
                d.x = r[f] + a.x, d.y = r[f + 1] + a.y, d.z = r[f + 2] + a.z;
                var v = s(h, d, m);
                p = Math.max(p, v)
            }
            return u(m, p, c)
        };
        var m = [];
        c.prototype.computeHorizonCullingPointFromRectangle = function (i, n, r) {
            var o = a.subsample(i, n, 0, m), s = e.fromPoints(o);
            return t.magnitude(s.center) < .1 * n.minimumRadius ? void 0 : this.computeHorizonCullingPoint(s.center, o, r)
        };
        var p = new t, f = new t, _ = new t;
        return c
    }),define("Cesium/Scene/QuadtreeOccluders", ["../Core/Cartesian3", "../Core/defineProperties", "../Core/EllipsoidalOccluder"], function (e, t, i) {
        "use strict";
        var n = function (t) {
            this._ellipsoid = new i(t.ellipsoid, e.ZERO)
        };
        return t(n.prototype, {
            ellipsoid: {
                get: function () {
                    return this._ellipsoid
                }
            }
        }), n
    }),define("Cesium/Scene/QuadtreeTile", ["../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Rectangle", "./QuadtreeTileLoadState"], function (e, t, i, n, r) {
        "use strict";
        var o = function (e) {
            this._tilingScheme = e.tilingScheme, this._x = e.x, this._y = e.y, this._level = e.level, this._parent = e.parent, this._rectangle = this._tilingScheme.tileXYToRectangle(this._x, this._y, this._level), this._children = void 0, this._replacementPrevious = void 0, this._replacementNext = void 0, this._distance = 0, this._customData = [], this._frameUpdated = void 0, this._frameRendered = void 0, this.state = r.START, this.renderable = !1, this.upsampledFromParent = !1, this.data = void 0
        };
        return o.createLevelZeroTiles = function (t) {
            if (!e(t))throw new i("tilingScheme is required.");
            for (var n = t.getNumberOfXTilesAtLevel(0), r = t.getNumberOfYTilesAtLevel(0), a = new Array(n * r), s = 0, u = 0; r > u; ++u)for (var l = 0; n > l; ++l)a[s++] = new o({
                tilingScheme: t,
                x: l,
                y: u,
                level: 0
            });
            return a
        }, o.prototype._updateCustomData = function (t, i, r) {
            var o, a, s, u = this.customData;
            if (e(i) && e(r)) {
                for (o = 0; o < r.length; ++o) {
                    a = r[o];
                    for (var l = 0; l < u.length; ++l)if (u[l] === a) {
                        u.splice(l, 1);
                        break
                    }
                }
                for (s = this._rectangle, o = 0; o < i.length; ++o)a = i[o], n.contains(s, a.positionCartographic) && u.push(a);
                this._frameUpdated = t
            } else {
                var c = this._parent;
                if (e(c) && this._frameUpdated !== c._frameUpdated) {
                    u.length = 0, s = this._rectangle;
                    var h = c.customData;
                    for (o = 0; o < h.length; ++o)a = h[o], n.contains(s, a.positionCartographic) && u.push(a);
                    this._frameUpdated = c._frameUpdated
                }
            }
        }, t(o.prototype, {
            tilingScheme: {
                get: function () {
                    return this._tilingScheme
                }
            }, x: {
                get: function () {
                    return this._x
                }
            }, y: {
                get: function () {
                    return this._y
                }
            }, level: {
                get: function () {
                    return this._level
                }
            }, parent: {
                get: function () {
                    return this._parent
                }
            }, rectangle: {
                get: function () {
                    return this._rectangle
                }
            }, children: {
                get: function () {
                    if (!e(this._children)) {
                        var t = this.tilingScheme, i = this.level + 1, n = 2 * this.x, r = 2 * this.y;
                        this._children = [new o({tilingScheme: t, x: n, y: r, level: i, parent: this}), new o({
                            tilingScheme: t,
                            x: n + 1,
                            y: r,
                            level: i,
                            parent: this
                        }), new o({tilingScheme: t, x: n, y: r + 1, level: i, parent: this}), new o({
                            tilingScheme: t,
                            x: n + 1,
                            y: r + 1,
                            level: i,
                            parent: this
                        })]
                    }
                    return this._children
                }
            }, customData: {
                get: function () {
                    return this._customData
                }
            }, needsLoading: {
                get: function () {
                    return this.state < r.DONE
                }
            }, eligibleForUnloading: {
                get: function () {
                    var t = !0;
                    return e(this.data) && (t = this.data.eligibleForUnloading, e(t) || (t = !0)), t
                }
            }
        }), o.prototype.freeResources = function () {
            if (this.state = r.START, this.renderable = !1, this.upsampledFromParent = !1, e(this.data) && e(this.data.freeResources) && this.data.freeResources(), e(this._children)) {
                for (var t = 0, i = this._children.length; i > t; ++t)this._children[t].freeResources();
                this._children = void 0
            }
        }, o
    }),define("Cesium/Scene/TileReplacementQueue", ["../Core/defined"], function (e) {
        "use strict";
        function t(e, t) {
            var i = t.replacementPrevious, n = t.replacementNext;
            t === e._lastBeforeStartOfFrame && (e._lastBeforeStartOfFrame = n), t === e.head ? e.head = n : i.replacementNext = n, t === e.tail ? e.tail = i : n.replacementPrevious = i, t.replacementPrevious = void 0, t.replacementNext = void 0, --e.count
        }

        var i = function () {
            this.head = void 0, this.tail = void 0, this.count = 0, this._lastBeforeStartOfFrame = void 0
        };
        return i.prototype.markStartOfRenderFrame = function () {
            this._lastBeforeStartOfFrame = this.head
        }, i.prototype.trimTiles = function (i) {
            for (var n = this.tail, r = !0; r && e(this._lastBeforeStartOfFrame) && this.count > i && e(n);) {
                r = n !== this._lastBeforeStartOfFrame;
                var o = n.replacementPrevious;
                n.eligibleForUnloading && (n.freeResources(), t(this, n)), n = o
            }
        }, i.prototype.markTileRendered = function (i) {
            var n = this.head;
            return n === i ? void(i === this._lastBeforeStartOfFrame && (this._lastBeforeStartOfFrame = i.replacementNext)) : (++this.count, e(n) ? ((e(i.replacementPrevious) || e(i.replacementNext)) && t(this, i), i.replacementPrevious = void 0, i.replacementNext = n, n.replacementPrevious = i, void(this.head = i)) : (i.replacementPrevious = void 0, i.replacementNext = void 0, this.head = i, void(this.tail = i)))
        }, i
    }),define("Cesium/Scene/QuadtreePrimitive", ["../Core/Cartesian3", "../Core/Cartographic", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "../Core/getTimestamp", "../Core/Queue", "../Core/Ray", "../Core/Rectangle", "../Core/Visibility", "./QuadtreeOccluders", "./QuadtreeTile", "./QuadtreeTileLoadState", "./SceneMode", "./TileReplacementQueue"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _) {
        "use strict";
        function v(e, t, i) {
            var r = e._debug;
            if (!r.suspendLodUpdate) {
                var o, a, s = e._tilesToRender;
                s.length = 0;
                var u = e._tileTraversalQueue;
                if (u.clear(), r.maxDepth = 0, r.tilesVisited = 0, r.tilesCulled = 0, r.tilesRendered = 0, r.tilesWaitingForChildren = 0, e._tileLoadQueue.length = 0, e._tileReplacementQueue.markStartOfRenderFrame(), !n(e._levelZeroTiles)) {
                    if (!e._tileProvider.ready)return;
                    var l = e._tileProvider.tilingScheme;
                    e._levelZeroTiles = m.createLevelZeroTiles(l)
                }
                e._occluders.ellipsoid.cameraPosition = i.camera.positionWC;
                var c, d = e._tileProvider, p = e._occluders, f = e._levelZeroTiles, _ = e._addHeightCallbacks, v = e._removeHeightCallbacks, y = i.frameNumber;
                if (_.length > 0 || v.length > 0) {
                    for (o = 0, a = f.length; a > o; ++o)c = f[o], c._updateCustomData(y, _, v);
                    _.length = 0, v.length = 0
                }
                for (o = 0, a = f.length; a > o; ++o)c = f[o], e._tileReplacementQueue.markTileRendered(c), c.needsLoading && S(e, c), c.renderable && d.computeTileVisibility(c, i, p) !== h.NONE ? u.enqueue(c) : (++r.tilesCulled, c.renderable || ++r.tilesWaitingForChildren);
                for (; n(c = u.dequeue());)if (++r.tilesVisited, e._tileReplacementQueue.markTileRendered(c), c._updateCustomData(y), c.level > r.maxDepth && (r.maxDepth = c.level), g(e, t, i, c) < e.maximumScreenSpaceError)C(e, c); else if (E(e, c)) {
                    var T = c.children;
                    for (o = 0, a = T.length; a > o; ++o)d.computeTileVisibility(T[o], i, p) !== h.NONE ? u.enqueue(T[o]) : ++r.tilesCulled
                } else C(e, c);
                r.enableDebugOutput && (r.tilesVisited !== r.lastTilesVisited || r.tilesRendered !== r.lastTilesRendered || r.tilesCulled !== r.lastTilesCulled || r.maxDepth !== r.lastMaxDepth || r.tilesWaitingForChildren !== r.lastTilesWaitingForChildren) && (console.log("Visited " + r.tilesVisited + ", Rendered: " + r.tilesRendered + ", Culled: " + r.tilesCulled + ", Max Depth: " + r.maxDepth + ", Waiting for children: " + r.tilesWaitingForChildren), r.lastTilesVisited = r.tilesVisited, r.lastTilesRendered = r.tilesRendered, r.lastTilesCulled = r.tilesCulled, r.lastMaxDepth = r.maxDepth, r.lastTilesWaitingForChildren = r.tilesWaitingForChildren)
            }
        }

        function g(e, t, i, n) {
            if (i.mode === f.SCENE2D)return y(e, t, i, n);
            var r = e._tileProvider.getLevelMaximumGeometricError(n.level), o = e._tileProvider.computeDistanceToTile(n, i);
            n._distance = o;
            var a = t.drawingBufferHeight, s = i.camera.frustum.sseDenominator;
            return r * a / (o * s)
        }

        function y(e, t, i, n) {
            var r = i.camera, o = r.frustum, a = t.drawingBufferWidth, s = t.drawingBufferHeight, u = e._tileProvider.getLevelMaximumGeometricError(n.level), l = Math.max(o.top - o.bottom, o.right - o.left) / Math.max(a, s);
            return u / l
        }

        function C(e, t) {
            e._tilesToRender.push(t), ++e._debug.tilesRendered
        }

        function E(e, t) {
            for (var i = !0, n = !0, r = t.children, o = 0, a = r.length; a > o; ++o) {
                var s = r[o];
                e._tileReplacementQueue.markTileRendered(s), n = n && s.upsampledFromParent, i = i && s.renderable, s.needsLoading && S(e, s)
            }
            return i || ++e._debug.tilesWaitingForChildren, i && !n
        }

        function S(e, t) {
            e._tileLoadQueue.push(t)
        }

        function T(e, t, i, n) {
            var r = e._tileLoadQueue, o = e._tileProvider;
            if (0 !== r.length) {
                e._tileReplacementQueue.trimTiles(e.tileCacheSize);
                for (var a = s(), u = e._loadQueueTimeSlice, l = a + u, c = r.length - 1; c >= 0; --c) {
                    var h = r[c];
                    if (e._tileReplacementQueue.markTileRendered(h), o.loadTile(t, i, n, h), s() >= l)break
                }
            }
        }

        function b(i, r) {
            for (var o = i._tileToUpdateHeights, a = i._tileProvider.terrainProvider, u = s(), l = i._updateHeightsTimeSlice, h = u + l, d = r.mode, m = r.mapProjection, p = m.ellipsoid; o.length > 0;) {
                var _ = o[o.length - 1];
                _ !== i._lastTileUpdated && (i._lastTileIndex = 0);
                for (var v = _.customData, g = v.length, y = !1, C = i._lastTileIndex; g > C; ++C) {
                    var E = v[C];
                    if (_.level > E.level) {
                        n(E.position) || (E.position = p.cartographicToCartesian(E.positionCartographic)), d === f.SCENE3D ? (e.clone(e.ZERO, P.origin), e.normalize(E.position, P.direction)) : (t.clone(E.positionCartographic, I), I.height = -11500, m.project(I, D), e.fromElements(D.z, D.x, D.y, D), e.clone(D, P.origin), e.clone(e.UNIT_X, P.direction));
                        var S = _.data.pick(P, d, m, !1, D);
                        n(S) && E.callback(S), E.level = _.level
                    } else if (_.level === E.level) {
                        for (var T, b = _.children, w = b.length, x = 0; w > x && (T = b[x], !c.contains(T.rectangle, E.positionCartographic)); ++x);
                        var A = a.getTileDataAvailable(T.x, T.y, T.level);
                        (n(A) && !A || n(parent) && n(parent.data) && n(parent.data.terrainData) && !parent.data.terrainData.isChildAvailable(parent.x, parent.y, T.x, T.y)) && E.removeFunc()
                    }
                    if (s() >= h) {
                        y = !0;
                        break
                    }
                }
                if (y) {
                    i._lastTileUpdated = _, i._lastTileIndex = C;
                    break
                }
                o.pop()
            }
        }

        function w(e, t) {
            return e._distance - t._distance
        }

        function x(e, t, i, n) {
            var r = e._tileProvider, o = e._tilesToRender, a = e._tileToUpdateHeights;
            o.sort(w);
            for (var s = 0, u = o.length; u > s; ++s) {
                var l = o[s];
                r.showTileThisFrame(l, t, i, n), l._frameRendered !== i.frameNumber - 1 && a.push(l), l._frameRendered = i.frameNumber
            }
            b(e, i)
        }

        var A = function (e) {
            this._tileProvider = e.tileProvider, this._tileProvider.quadtree = this, this._debug = {
                enableDebugOutput: !1,
                maxDepth: 0,
                tilesVisited: 0,
                tilesCulled: 0,
                tilesRendered: 0,
                tilesWaitingForChildren: 0,
                lastMaxDepth: -1,
                lastTilesVisited: -1,
                lastTilesCulled: -1,
                lastTilesRendered: -1,
                lastTilesWaitingForChildren: -1,
                suspendLodUpdate: !1
            };
            var t = this._tileProvider.tilingScheme, n = t.ellipsoid;
            this._tilesToRender = [], this._tileTraversalQueue = new u, this._tileLoadQueue = [], this._tileReplacementQueue = new _, this._levelZeroTiles = void 0, this._levelZeroTilesReady = !1, this._loadQueueTimeSlice = 5, this._addHeightCallbacks = [], this._removeHeightCallbacks = [], this._tileToUpdateHeights = [], this._lastTileIndex = 0, this._updateHeightsTimeSlice = 2, this.maximumScreenSpaceError = i(e.maximumScreenSpaceError, 2), this.tileCacheSize = i(e.tileCacheSize, 100), this._occluders = new d({ellipsoid: n})
        };
        r(A.prototype, {
            tileProvider: {
                get: function () {
                    return this._tileProvider
                }
            }
        }), A.prototype.invalidateAllTiles = function () {
            var e = this._tileReplacementQueue;
            e.head = void 0, e.tail = void 0, e.count = 0;
            var t = this._levelZeroTiles;
            if (n(t))for (var i = 0; i < t.length; ++i) {
                for (var r = t[i], o = r.customData, a = o.length, s = 0; a > s; ++s) {
                    var u = o[s];
                    u.level = 0, this._addHeightCallbacks.push(u)
                }
                t[i].freeResources()
            }
            this._levelZeroTiles = void 0
        }, A.prototype.forEachLoadedTile = function (e) {
            for (var t = this._tileReplacementQueue.head; n(t);)t.state !== p.START && e(t), t = t.replacementNext
        }, A.prototype.forEachRenderedTile = function (e) {
            for (var t = this._tilesToRender, i = 0, n = t.length; n > i; ++i)e(t[i])
        }, A.prototype.updateHeight = function (e, t) {
            var i = this, n = {position: void 0, positionCartographic: e, level: -1, callback: t};
            return n.removeFunc = function () {
                i._removeHeightCallbacks.push(n)
            }, i._addHeightCallbacks.push(n), n.removeFunc
        }, A.prototype.update = function (e, t, i) {
            var n = t.passes;
            n.render && (this._tileProvider.beginUpdate(e, t, i), v(this, e, t), T(this, e, t, i), x(this, e, t, i), this._tileProvider.endUpdate(e, t, i)), n.pick && this._tilesToRender.length > 0 && this._tileProvider.endUpdate(e, t, i)
        }, A.prototype.isDestroyed = function () {
            return !1
        }, A.prototype.destroy = function () {
            this._tileProvider = this._tileProvider && this._tileProvider.destroy()
        };
        var P = new l, I = new t, D = new e;
        return A
    }),define("Cesium/Scene/Globe", ["../Core/BoundingRectangle", "../Core/BoundingSphere", "../Core/buildModuleUrl", "../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartographic", "../Core/combine", "../Core/ComponentDatatype", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Ellipsoid", "../Core/EllipsoidTerrainProvider", "../Core/FeatureDetection", "../Core/GeographicProjection", "../Core/Geometry", "../Core/GeometryAttribute", "../Core/Intersect", "../Core/IntersectionTests", "../Core/loadImage", "../Core/Math", "../Core/Matrix4", "../Core/Occluder", "../Core/PrimitiveType", "../Core/Ray", "../Core/Rectangle", "../Core/Transforms", "../Renderer/BufferUsage", "../Renderer/DrawCommand", "../Renderer/RenderState", "../Renderer/ShaderProgram", "../Renderer/ShaderSource", "../Renderer/Texture", "../Renderer/VertexArray", "../Shaders/GlobeFS", "../Shaders/GlobeFSPole", "../Shaders/GlobeVS", "../Shaders/GlobeVSPole", "../ThirdParty/when", "./GlobeSurfaceShaderSet", "./GlobeSurfaceTileProvider", "./ImageryLayerCollection", "./Pass", "./QuadtreePrimitive", "./SceneMode", "./terrainAttributeLocations"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S, T, b, w, x, A, P, I, D, M, O, R, N, L, F, B, z, V, U, k, G, H, W, q, j, Y) {
        "use strict";
        function X(e) {
            return function (i, n) {
                var r = t.distanceSquaredTo(i.pickBoundingSphere, e), o = t.distanceSquaredTo(n.pickBoundingSphere, e);
                return r - o
            }
        }

        function Z(t, i, n, o, a, s) {
            se.longitude = 0, se.latitude = o;
            var u = t._ellipsoid.cartographicToCartesian(se, ue);
            se.longitude = Math.PI;
            var l = t._ellipsoid.cartographicToCartesian(se, le), c = .5 * r.magnitude(r.subtract(u, l, re), re);
            se.longitude = 0, se.latitude = n;
            var h, d = t._ellipsoid.cartographicToCartesian(se, ue), m = i.camera.direction;
            h = 1 - r.dot(ae, m) < S.EPSILON6 ? r.UNIT_X : r.normalize(r.cross(m, r.UNIT_Z, re), re);
            var p = r.add(d, r.multiplyByScalar(h, c, re), re), f = r.add(d, r.multiplyByScalar(r.normalize(r.cross(r.UNIT_Z, h, oe), oe), c, oe), oe);
            P.pointToGLWindowCoordinates(a, s, d, d), P.pointToGLWindowCoordinates(a, s, p, p), P.pointToGLWindowCoordinates(a, s, f, f);
            var _ = Math.floor(Math.max(r.distance(f, d), r.distance(p, d))), v = _;
            return new e(Math.floor(d.x) - _, Math.floor(d.y) - v, 2 * _, 2 * v)
        }

        function K(e, i, n) {
            var r = e.terrainProvider;
            if (n.mode === j.SCENE3D && r.ready) {
                var o = r.tilingScheme.rectangle, u = i.uniformState.viewProjection, c = ce;
                c.width = i.drawingBufferWidth, c.height = i.drawingBufferHeight;
                var h, d, m, p, f, _, C, E = T.computeViewportTransformation(c, 0, 1, he), w = .05, x = e._occluder;
                o.north < S.PI_OVER_TWO && (h = new A(-Math.PI, o.north, Math.PI, S.PI_OVER_TWO), d = t.fromRectangle3D(h, e._ellipsoid), m = n.cullingVolume.computeVisibility(d) === y.OUTSIDE, p = b.computeOccludeePointFromRectangle(h, e._ellipsoid), f = p && !x.isPointVisible(p, 0) || !x.isBoundingSphereVisible(d), e._drawNorthPole = !m && !f, e._drawNorthPole && (C = Z(e, n, h.north, h.south - w, u, E), de[0] = C.x, de[1] = C.y, de[2] = C.x + C.width, de[3] = C.y, de[4] = C.x + C.width, de[5] = C.y + C.height, de[6] = C.x, de[7] = C.y + C.height, l(e._northPoleCommand.vertexArray) ? e._northPoleCommand.vertexArray.getAttribute(0).vertexBuffer.copyFromArrayView(de) : (e._northPoleCommand.boundingVolume = t.fromRectangle3D(h, e._ellipsoid), _ = new v({
                    attributes: {
                        position: new g({
                            componentDatatype: s.FLOAT,
                            componentsPerAttribute: 2,
                            values: de
                        })
                    }
                }), e._northPoleCommand.vertexArray = L.fromGeometry({
                    context: i,
                    geometry: _,
                    attributeLocations: {position: 0},
                    bufferUsage: I.STREAM_DRAW
                })))), o.south > -S.PI_OVER_TWO && (h = new A(-Math.PI, -S.PI_OVER_TWO, Math.PI, o.south), d = t.fromRectangle3D(h, e._ellipsoid), m = n.cullingVolume.computeVisibility(d) === y.OUTSIDE, p = b.computeOccludeePointFromRectangle(h, e._ellipsoid), f = p && !x.isPointVisible(p) || !x.isBoundingSphereVisible(d), e._drawSouthPole = !m && !f, e._drawSouthPole && (C = Z(e, n, h.south, h.north + w, u, E), de[0] = C.x, de[1] = C.y, de[2] = C.x + C.width, de[3] = C.y, de[4] = C.x + C.width, de[5] = C.y + C.height, de[6] = C.x, de[7] = C.y + C.height, l(e._southPoleCommand.vertexArray) ? e._southPoleCommand.vertexArray.getAttribute(0).vertexBuffer.copyFromArrayView(de) : (e._southPoleCommand.boundingVolume = t.fromRectangle3D(h, e._ellipsoid), _ = new v({
                    attributes: {
                        position: new g({
                            componentDatatype: s.FLOAT,
                            componentsPerAttribute: 2,
                            values: de
                        })
                    }
                }), e._southPoleCommand.vertexArray = L.fromGeometry({
                    context: i,
                    geometry: _,
                    attributeLocations: {position: 0},
                    bufferUsage: I.STREAM_DRAW
                }))));
                var P = 0, D = e._imageryLayerCollection.length > 0 ? e._imageryLayerCollection.get(0) : void 0;
                l(D) && l(D.imageryProvider) && l(D.imageryProvider.getPoleIntensity) && (P = D.imageryProvider.getPoleIntensity());
                var M = {
                    u_dayIntensity: function () {
                        return P
                    }
                };
                if (!l(e._northPoleCommand.uniformMap)) {
                    var O = a(M, {
                        u_color: function () {
                            return e.northPoleColor
                        }
                    });
                    e._northPoleCommand.uniformMap = a(O, e._drawUniforms)
                }
                if (!l(e._southPoleCommand.uniformMap)) {
                    var R = a(M, {
                        u_color: function () {
                            return e.southPoleColor
                        }
                    });
                    e._southPoleCommand.uniformMap = a(R, e._drawUniforms)
                }
            }
        }

        var J = function (e) {
            e = u(e, m.WGS84);
            var o = new p({ellipsoid: e}), a = new H;
            this._ellipsoid = e, this._imageryLayerCollection = a, this._surfaceShaderSet = new k, this._surfaceShaderSet.baseVertexShaderSource = new R({sources: [z]}), this._surfaceShaderSet.baseFragmentShaderSource = new R({sources: [F]}), this._surface = new q({
                tileProvider: new G({
                    terrainProvider: o,
                    imageryLayers: a,
                    surfaceShaderSet: this._surfaceShaderSet
                })
            }), this._occluder = new b(new t(r.ZERO, e.minimumRadius), r.ZERO), this._rsColor = void 0, this._rsColorWithoutDepthTest = void 0, this._northPoleCommand = new D({
                pass: W.OPAQUE,
                owner: this
            }), this._southPoleCommand = new D({
                pass: W.OPAQUE,
                owner: this
            }), this._drawNorthPole = !1, this._drawSouthPole = !1, this._mode = j.SCENE3D, this.terrainProvider = o, this.northPoleColor = new r(2 / 255, 6 / 255, 18 / 255), this.southPoleColor = new r(1, 1, 1), this.show = !0, this.oceanNormalMapUrl = i("Assets/Textures/waterNormalsSmall.jpg"), this._oceanNormalMapUrl = void 0, this.maximumScreenSpaceError = 2, this.tileCacheSize = 100, this.enableLighting = !1, this.lightingFadeOutDistance = 65e5, this.lightingFadeInDistance = 9e6, this.showWaterEffect = !0, this.depthTestAgainstTerrain = !1, this._oceanNormalMap = void 0, this._zoomedOutOceanSpecularIntensity = .5, this._lightingFadeDistance = new n(this.lightingFadeOutDistance, this.lightingFadeInDistance);
            var s = this;
            this._drawUniforms = {
                u_zoomedOutOceanSpecularIntensity: function () {
                    return s._zoomedOutOceanSpecularIntensity
                }, u_oceanNormalMap: function () {
                    return s._oceanNormalMap
                }, u_lightingFadeDistance: function () {
                    return s._lightingFadeDistance
                }
            }
        };
        c(J.prototype, {
            ellipsoid: {
                get: function () {
                    return this._ellipsoid
                }
            }, imageryLayers: {
                get: function () {
                    return this._imageryLayerCollection
                }
            }, baseColor: {
                get: function () {
                    return this._surface.tileProvider.baseColor
                }, set: function (e) {
                    this._surface.tileProvider.baseColor = e
                }
            }
        });
        var Q = [], $ = {start: 0, stop: 0};
        J.prototype.pick = function (e, i, n) {
            var o = i.mode, a = i.mapProjection, s = Q;
            s.length = 0;
            var u, c, h = this._surface._tilesToRender, d = h.length;
            for (c = 0; d > c; ++c) {
                u = h[c];
                var m = u.data;
                if (l(m)) {
                    var p = m.pickBoundingSphere;
                    o !== j.SCENE3D ? (t.fromRectangleWithHeights2D(u.rectangle, a, m.minimumHeight, m.maximumHeight, p), r.fromElements(p.center.z, p.center.x, p.center.y, p.center)) : t.clone(m.boundingSphere3D, p);
                    var f = C.raySphere(e, p, $);
                    l(f) && s.push(m)
                }
            }
            s.sort(X(e.origin));
            var _;
            for (d = s.length, c = 0; d > c && (_ = s[c].pick(e, i.mode, i.mapProjection, !0, n), !l(_)); ++c);
            return _
        };
        var ee = new r, te = new r, ie = new o, ne = new x;
        J.prototype.getHeight = function (e) {
            var t = this._surface._levelZeroTiles;
            if (l(t)) {
                var i, n, o = t.length;
                for (n = 0; o > n && (i = t[n], !A.contains(i.rectangle, e)); ++n);
                if (!l(i) || !A.contains(i.rectangle, e))return void 0;
                for (; i.renderable;) {
                    var a = i.children;
                    for (o = a.length, n = 0; o > n && (i = a[n], !A.contains(i.rectangle, e)); ++n);
                }
                for (; l(i) && (!l(i.data) || !l(i.data.pickTerrain));)i = i.parent;
                if (!l(i))return void 0;
                var s = this._surface._tileProvider.tilingScheme.ellipsoid, u = s.cartographicToCartesian(e, ee), c = ne;
                r.normalize(u, c.direction);
                var h = i.data.pick(c, void 0, void 0, !1, te);
                return l(h) ? s.cartesianToCartographic(h, ie).height : void 0
            }
        };
        var re = new r, oe = new r, ae = r.negate(r.UNIT_Z, new r), se = new o(0, 0), ue = new r, le = new r, ce = new e, he = new T, de = f.supportsTypedArrays() ? new Float32Array(8) : [];
        return J.prototype.update = function (e, t, i) {
            if (this.show) {
                var n = e.drawingBufferWidth, r = e.drawingBufferHeight;
                if (0 !== n && 0 !== r) {
                    var o = t.mode, a = (t.mapProjection, !1);
                    this._mode === o && l(this._rsColor) || (a = !0, o === j.SCENE3D || o === j.COLUMBUS_VIEW ? (this._rsColor = M.fromCache({
                        cull: {enabled: !0},
                        depthTest: {enabled: !0}
                    }), this._rsColorWithoutDepthTest = M.fromCache({cull: {enabled: !0}})) : (this._rsColor = M.fromCache({cull: {enabled: !0}}), this._rsColorWithoutDepthTest = M.fromCache({cull: {enabled: !0}}))), this._mode = o;
                    var s = this._northPoleCommand, u = this._southPoleCommand;
                    s.renderState = this._rsColorWithoutDepthTest, u.renderState = this._rsColorWithoutDepthTest;
                    var c = this._surface, h = c.tileProvider, d = this.terrainProvider, m = this.showWaterEffect && d.ready && d.hasWaterMask;
                    if (m && this.oceanNormalMapUrl !== this._oceanNormalMapUrl) {
                        var p = this.oceanNormalMapUrl;
                        if (this._oceanNormalMapUrl = p, l(p)) {
                            var f = this;
                            U(E(p), function (t) {
                                p === f.oceanNormalMapUrl && (f._oceanNormalMap = f._oceanNormalMap && f._oceanNormalMap.destroy(), f._oceanNormalMap = new N({
                                    context: e,
                                    source: t
                                }))
                            })
                        } else this._oceanNormalMap = this._oceanNormalMap && this._oceanNormalMap.destroy()
                    }
                    if (!l(s.shaderProgram) || !l(u.shaderProgram)) {
                        var _ = O.replaceCache({
                            context: e,
                            shaderProgram: s.shaderProgram,
                            vertexShaderSource: V,
                            fragmentShaderSource: B,
                            attributeLocations: Y
                        });
                        s.shaderProgram = _, u.shaderProgram = _
                    }
                    this._occluder.cameraPosition = t.camera.positionWC, K(this, e, t);
                    var v = t.passes;
                    v.render && (o === j.SCENE3D && (this._drawNorthPole && i.push(s), this._drawSouthPole && i.push(u)), o === j.SCENE3D ? this._zoomedOutOceanSpecularIntensity = .5 : this._zoomedOutOceanSpecularIntensity = 0, c.maximumScreenSpaceError = this.maximumScreenSpaceError, c.tileCacheSize = this.tileCacheSize, h.terrainProvider = this.terrainProvider, h.lightingFadeOutDistance = this.lightingFadeOutDistance, h.lightingFadeInDistance = this.lightingFadeInDistance, h.zoomedOutOceanSpecularIntensity = this._zoomedOutOceanSpecularIntensity, h.hasWaterMask = m, h.oceanNormalMap = this._oceanNormalMap, h.enableLighting = this.enableLighting, c.update(e, t, i)), v.pick && c.update(e, t, i)
                }
            }
        }, J.prototype.isDestroyed = function () {
            return !1
        }, J.prototype.destroy = function () {
            return this._northPoleCommand.vertexArray = this._northPoleCommand.vertexArray && this._northPoleCommand.vertexArray.destroy(), this._southPoleCommand.vertexArray = this._southPoleCommand.vertexArray && this._southPoleCommand.vertexArray.destroy(), this._surfaceShaderSet = this._surfaceShaderSet && this._surfaceShaderSet.destroy(), this._northPoleCommand.shaderProgram = this._northPoleCommand.shaderProgram && this._northPoleCommand.shaderProgram.destroy(), this._southPoleCommand.shaderProgram = this._northPoleCommand.shaderProgram, this._surface = this._surface && this._surface.destroy(), this._oceanNormalMap = this._oceanNormalMap && this._oceanNormalMap.destroy(), h(this)
        }, J
    }),define("Cesium/Core/IauOrientationParameters", [], function () {
        "use strict";
        var e = function (e, t, i, n) {
            this.rightAscension = e, this.declination = t, this.rotation = i, this.rotationRate = n
        };
        return e
    }),define("Cesium/Core/Iau2000Orientation", ["./defined", "./IauOrientationParameters", "./JulianDate", "./Math", "./TimeConstants"], function (e, t, i, n, r) {
        "use strict";
        var o = {}, a = 32.184, s = 2451545, u = -.0529921, l = -.1059842, c = 13.0120009, h = 13.3407154, d = .9856003, m = 26.4057084, p = 13.064993, f = .3287146, _ = 1.7484877, v = -.1589763, g = .0036096, y = .1643573, C = 12.9590088, E = new i;
        return o.ComputeMoon = function (o, S) {
            e(o) || (o = i.now()), E = i.addSeconds(o, a, E);
            var T = i.totalDays(E) - s, b = T / r.DAYS_PER_JULIAN_CENTURY, w = (125.045 + u * T) * n.RADIANS_PER_DEGREE, x = (250.089 + l * T) * n.RADIANS_PER_DEGREE, A = (260.008 + c * T) * n.RADIANS_PER_DEGREE, P = (176.625 + h * T) * n.RADIANS_PER_DEGREE, I = (357.529 + d * T) * n.RADIANS_PER_DEGREE, D = (311.589 + m * T) * n.RADIANS_PER_DEGREE, M = (134.963 + p * T) * n.RADIANS_PER_DEGREE, O = (276.617 + f * T) * n.RADIANS_PER_DEGREE, R = (34.226 + _ * T) * n.RADIANS_PER_DEGREE, N = (15.134 + v * T) * n.RADIANS_PER_DEGREE, L = (119.743 + g * T) * n.RADIANS_PER_DEGREE, F = (239.961 + y * T) * n.RADIANS_PER_DEGREE, B = (25.053 + C * T) * n.RADIANS_PER_DEGREE, z = Math.sin(w), V = Math.sin(x), U = Math.sin(A), k = Math.sin(P), G = Math.sin(I), H = Math.sin(D), W = Math.sin(M), q = Math.sin(O), j = Math.sin(R), Y = Math.sin(N), X = Math.sin(L), Z = Math.sin(F), K = Math.sin(B), J = Math.cos(w), Q = Math.cos(x), $ = Math.cos(A), ee = Math.cos(P), te = Math.cos(I), ie = Math.cos(D), ne = Math.cos(M), re = Math.cos(O), oe = Math.cos(R), ae = Math.cos(N), se = Math.cos(L), ue = Math.cos(F), le = Math.cos(B), ce = (269.9949 + .0031 * b - 3.8787 * z - .1204 * V + .07 * U - .0172 * k + .0072 * H - .0052 * Y + .0043 * K) * n.RADIANS_PER_DEGREE, he = (66.5392 + .013 * b + 1.5419 * J + .0239 * Q - .0278 * $ + .0068 * ee - .0029 * ie + 9e-4 * ne + 8e-4 * ae - 9e-4 * le) * n.RADIANS_PER_DEGREE, de = (38.3213 + 13.17635815 * T - 1.4e-12 * T * T + 3.561 * z + .1208 * V - .0642 * U + .0158 * k + .0252 * G - .0066 * H - .0047 * W - .0046 * q + .0028 * j + .0052 * Y + .004 * X + .0019 * Z - .0044 * K) * n.RADIANS_PER_DEGREE, me = (13.17635815 - 2.8e-12 * T + 3.561 * J * u + .1208 * Q * l - .0642 * $ * c + .0158 * ee * h + .0252 * te * d - .0066 * ie * m - .0047 * ne * p - .0046 * re * f + .0028 * oe * _ + .0052 * ae * v + .004 * se * g + .0019 * ue * y - .0044 * le * C) / 86400 * n.RADIANS_PER_DEGREE;
            return e(S) || (S = new t), S.rightAscension = ce, S.declination = he, S.rotation = de, S.rotationRate = me, S
        }, o
    }),define("Cesium/Core/IauOrientationAxes", ["./Cartesian3", "./defined", "./Iau2000Orientation", "./JulianDate", "./Math", "./Matrix3", "./Quaternion"], function (e, t, i, n, r, o, a) {
        "use strict";
        function s(i, n, a) {
            var s = l;
            s.x = Math.cos(i + r.PI_OVER_TWO), s.y = Math.sin(i + r.PI_OVER_TWO), s.z = 0;
            var u = Math.cos(n), d = h;
            d.x = u * Math.cos(i), d.y = u * Math.sin(i), d.z = Math.sin(n);
            var m = e.cross(d, s, c);
            return t(a) || (a = new o), a[0] = s.x, a[1] = m.x, a[2] = d.x, a[3] = s.y, a[4] = m.y, a[5] = d.y, a[6] = s.z, a[7] = m.z, a[8] = d.z, a
        }

        var u = function (e) {
            t(e) && "function" == typeof e || (e = i.ComputeMoon), this._computeFunction = e
        }, l = new e, c = new e, h = new e, d = new o, m = new a;
        return u.prototype.evaluate = function (i, u) {
            t(i) || (i = n.now());
            var l = this._computeFunction(i), c = s(l.rightAscension, l.declination, u), h = r.zeroToTwoPi(l.rotation), p = a.fromAxisAngle(e.UNIT_Z, h, m), f = o.fromQuaternion(a.conjugate(p, p), d), _ = o.multiply(f, c, c);
            return _
        }, u
    }),define("Cesium/Shaders/EllipsoidFS", [], function () {
        "use strict";
        return "#ifdef WRITE_DEPTH\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n#endif\n#endif\n\nuniform vec3 u_radii;\nuniform vec3 u_oneOverEllipsoidRadiiSquared;\n\nvarying vec3 v_positionEC;\n\nvec4 computeEllipsoidColor(czm_ray ray, float intersection, float side)\n{\n    vec3 positionEC = czm_pointAlongRay(ray, intersection);\n    vec3 positionMC = (czm_inverseModelView * vec4(positionEC, 1.0)).xyz;\n    vec3 geodeticNormal = normalize(czm_geodeticSurfaceNormal(positionMC, vec3(0.0), u_oneOverEllipsoidRadiiSquared));\n    vec3 sphericalNormal = normalize(positionMC / u_radii);\n    vec3 normalMC = geodeticNormal * side;              // normalized surface normal (always facing the viewer) in model coordinates\n    vec3 normalEC = normalize(czm_normal * normalMC);   // normalized surface normal in eye coordiantes\n\n    vec2 st = czm_ellipsoidWgs84TextureCoordinates(sphericalNormal);\n    vec3 positionToEyeEC = -positionEC;\n\n    czm_materialInput materialInput;\n    materialInput.s = st.s;\n    materialInput.st = st;\n    materialInput.str = (positionMC + u_radii) / u_radii;\n    materialInput.normalEC = normalEC;\n    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(positionMC, normalEC);\n    materialInput.positionToEyeEC = positionToEyeEC;\n    czm_material material = czm_getMaterial(materialInput);\n\n#ifdef ONLY_SUN_LIGHTING\n    return czm_private_phong(normalize(positionToEyeEC), material);\n#else\n    return czm_phong(normalize(positionToEyeEC), material);\n#endif\n}\n\nvoid main()\n{\n    // PERFORMANCE_TODO: When dynamic branching is available, compute ratio of maximum and minimum radii\n    // in the vertex shader. Only when it is larger than some constant, march along the ray.\n    // Otherwise perform one intersection test which will be the common case.\n    \n    // Test if the ray intersects a sphere with the ellipsoid's maximum radius.\n    // For very oblate ellipsoids, using the ellipsoid's radii for an intersection test\n    // may cause false negatives. This will discard fragments before marching the ray forward.\n    float maxRadius = max(u_radii.x, max(u_radii.y, u_radii.z)) * 1.5;\n    vec3 direction = normalize(v_positionEC);\n    vec3 ellipsoidCenter = czm_modelView[3].xyz;\n    \n    float t1 = -1.0;\n    float t2 = -1.0;\n    \n    float b = -2.0 * dot(direction, ellipsoidCenter);\n    float c = dot(ellipsoidCenter, ellipsoidCenter) - maxRadius * maxRadius;\n\n    float discriminant = b * b - 4.0 * c;\n    if (discriminant >= 0.0) {\n        t1 = (-b - sqrt(discriminant)) * 0.5;\n        t2 = (-b + sqrt(discriminant)) * 0.5;\n    }\n    \n    if (t1 < 0.0 && t2 < 0.0) {\n        discard;\n    }\n    \n    float t = min(t1, t2);\n    if (t < 0.0) {\n        t = 0.0;\n    }\n    \n    // March ray forward to intersection with larger sphere and find\n    // actual intersection point with ellipsoid.\n    czm_ellipsoid ellipsoid = czm_ellipsoidNew(ellipsoidCenter, u_radii);\n    czm_ray ray = czm_ray(t * direction, direction);\n    czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid);\n    \n    if (czm_isEmpty(intersection))\n    {\n        discard;\n    }\n\n    // If the viewer is outside, compute outsideFaceColor, with normals facing outward.\n    vec4 outsideFaceColor = (intersection.start != 0.0) ? computeEllipsoidColor(ray, intersection.start, 1.0) : vec4(0.0);\n\n    // If the viewer either is inside or can see inside, compute insideFaceColor, with normals facing inward.\n    vec4 insideFaceColor = (outsideFaceColor.a < 1.0) ? computeEllipsoidColor(ray, intersection.stop, -1.0) : vec4(0.0);\n\n    gl_FragColor = mix(insideFaceColor, outsideFaceColor, outsideFaceColor.a);\n    gl_FragColor.a = 1.0 - (1.0 - insideFaceColor.a) * (1.0 - outsideFaceColor.a);\n    \n#ifdef WRITE_DEPTH\n#ifdef GL_EXT_frag_depth\n    t = (intersection.start != 0.0) ? intersection.start : intersection.stop;\n    vec3 positionEC = czm_pointAlongRay(ray, t);\n    vec4 positionCC = czm_projection * vec4(positionEC, 1.0);\n    float z = positionCC.z / positionCC.w;\n    \n    float n = czm_depthRange.near;\n    float f = czm_depthRange.far;\n    \n    gl_FragDepthEXT = (z * (f - n) + f + n) * 0.5;\n#endif\n#endif\n}\n"
    }),define("Cesium/Shaders/EllipsoidVS", [], function () {
        "use strict";
        return "attribute vec3 position;\n\nuniform vec3 u_radii;\n\nvarying vec3 v_positionEC;\n\nvoid main() \n{\n    // In the vertex data, the cube goes from (-1.0, -1.0, -1.0) to (1.0, 1.0, 1.0) in model coordinates.\n    // Scale to consider the radii.  We could also do this once on the CPU when using the BoxGeometry,\n    // but doing it here allows us to change the radii without rewriting the vertex data, and\n    // allows all ellipsoids to reuse the same vertex data.\n    vec4 p = vec4(u_radii * position, 1.0);\n\n    v_positionEC = (czm_modelView * p).xyz;     // position in eye coordinates\n    gl_Position = czm_modelViewProjection * p;  // position in clip coordinates\n\n    // With multi-frustum, when the ellipsoid primitive is positioned on the intersection of two frustums \n    // and close to terrain, the terrain (writes depth) in the closest frustum can overwrite part of the \n    // ellipsoid (does not write depth) that was rendered in the farther frustum.\n    //\n    // Here, we clamp the depth in the vertex shader to avoid being overwritten; however, this creates\n    // artifacts since some fragments can be alpha blended twice.  This is solved by only rendering\n    // the ellipsoid in the closest frustum to the viewer.\n    gl_Position.z = clamp(gl_Position.z, czm_depthRange.near, czm_depthRange.far);\n}\n"
    }),define("Cesium/Scene/EllipsoidPrimitive", ["../Core/BoundingSphere", "../Core/BoxGeometry", "../Core/Cartesian3", "../Core/combine", "../Core/defaultValue", "../Core/defined", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Matrix4", "../Core/VertexFormat", "../Renderer/BufferUsage", "../Renderer/DrawCommand", "../Renderer/RenderState", "../Renderer/ShaderProgram", "../Renderer/ShaderSource", "../Renderer/VertexArray", "../Shaders/EllipsoidFS", "../Shaders/EllipsoidVS", "./BlendingState", "./CullFace", "./Material", "./Pass", "./SceneMode"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S) {
        "use strict";
        function T(e) {
            var n = e.cache.ellipsoidPrimitive_vertexArray;
            if (o(n))return n;
            var r = t.createGeometry(t.fromDimensions({dimensions: new i(2, 2, 2), vertexFormat: l.POSITION_ONLY}));
            return n = f.fromGeometry({
                context: e,
                geometry: r,
                attributeLocations: b,
                bufferUsage: c.STATIC_DRAW,
                interleave: !0
            }), e.cache.ellipsoidPrimitive_vertexArray = n, n
        }

        var b = {position: 0}, w = function (t) {
            t = r(t, r.EMPTY_OBJECT), this.center = i.clone(r(t.center, i.ZERO)), this._center = new i, this.radii = i.clone(t.radii), this._radii = new i, this._oneOverEllipsoidRadiiSquared = new i, this._boundingSphere = new e, this.modelMatrix = u.clone(r(t.modelMatrix, u.IDENTITY)), this._modelMatrix = new u, this._computedModelMatrix = new u, this.show = r(t.show, !0), this.material = r(t.material, C.fromType(C.ColorType)), this._material = void 0, this._translucent = void 0, this.id = t.id, this._id = void 0, this.debugShowBoundingVolume = r(t.debugShowBoundingVolume, !1), this.onlySunLighting = r(t.onlySunLighting, !1), this._onlySunLighting = !1, this._depthTestEnabled = r(t.depthTestEnabled, !0), this._sp = void 0, this._rs = void 0, this._va = void 0, this._pickSP = void 0, this._pickId = void 0, this._colorCommand = new h({owner: r(t._owner, this)}), this._pickCommand = new h({owner: r(t._owner, this)});
            var n = this;
            this._uniforms = {
                u_radii: function () {
                    return n.radii
                }, u_oneOverEllipsoidRadiiSquared: function () {
                    return n._oneOverEllipsoidRadiiSquared
                }
            }, this._pickUniforms = {
                czm_pickColor: function () {
                    return n._pickId.color
                }
            }
        };
        return w.prototype.update = function (t, r, a) {
            if (this.show && r.mode === S.SCENE3D && o(this.center) && o(this.radii)) {
                var s = this.material.isTranslucent(), l = this._translucent !== s;
                (!o(this._rs) || l) && (this._translucent = s, this._rs = d.fromCache({
                    cull: {
                        enabled: !0,
                        face: y.FRONT
                    },
                    depthTest: {enabled: this._depthTestEnabled},
                    depthMask: !s && t.fragmentDepth,
                    blending: s ? g.ALPHA_BLEND : void 0
                })), o(this._va) || (this._va = T(t));
                var c = !1, h = this.radii;
                if (!i.equals(this._radii, h)) {
                    i.clone(h, this._radii);
                    var f = this._oneOverEllipsoidRadiiSquared;
                    f.x = 1 / (h.x * h.x), f.y = 1 / (h.y * h.y), f.z = 1 / (h.z * h.z), c = !0
                }
                u.equals(this.modelMatrix, this._modelMatrix) && i.equals(this.center, this._center) || (u.clone(this.modelMatrix, this._modelMatrix), i.clone(this.center, this._center), u.multiplyByTranslation(this.modelMatrix, this.center, this._computedModelMatrix), c = !0), c && (i.clone(i.ZERO, this._boundingSphere.center), this._boundingSphere.radius = i.maximumComponent(h), e.transform(this._boundingSphere, this._computedModelMatrix, this._boundingSphere));
                var C = this._material !== this.material;
                this._material = this.material, this._material.update(t);
                var w = this.onlySunLighting !== this._onlySunLighting;
                this._onlySunLighting = this.onlySunLighting;
                var x, A = this._colorCommand;
                (C || w || l) && (x = new p({sources: [this.material.shaderSource, _]}), this.onlySunLighting && x.defines.push("ONLY_SUN_LIGHTING"), !s && t.fragmentDepth && x.defines.push("WRITE_DEPTH"), this._sp = m.replaceCache({
                    context: t,
                    shaderProgram: this._sp,
                    vertexShaderSource: v,
                    fragmentShaderSource: x,
                    attributeLocations: b
                }), A.vertexArray = this._va, A.renderState = this._rs, A.shaderProgram = this._sp, A.uniformMap = n(this._uniforms, this.material._uniforms), A.executeInClosestFrustum = s);
                var P = r.passes;
                if (P.render && (A.boundingVolume = this._boundingSphere, A.debugShowBoundingVolume = this.debugShowBoundingVolume, A.modelMatrix = this._computedModelMatrix, A.pass = s ? E.TRANSLUCENT : E.OPAQUE, a.push(A)), P.pick) {
                    var I = this._pickCommand;
                    o(this._pickId) && this._id === this.id || (this._id = this.id, this._pickId = this._pickId && this._pickId.destroy(), this._pickId = t.createPickId({
                        primitive: this,
                        id: this.id
                    })), (C || w || !o(this._pickSP)) && (x = new p({
                        sources: [this.material.shaderSource, _],
                        pickColorQualifier: "uniform"
                    }), this.onlySunLighting && x.defines.push("ONLY_SUN_LIGHTING"), !s && t.fragmentDepth && x.defines.push("WRITE_DEPTH"), this._pickSP = m.replaceCache({
                        context: t,
                        shaderProgram: this._pickSP,
                        vertexShaderSource: v,
                        fragmentShaderSource: x,
                        attributeLocations: b
                    }), I.vertexArray = this._va, I.renderState = this._rs, I.shaderProgram = this._pickSP, I.uniformMap = n(n(this._uniforms, this._pickUniforms), this.material._uniforms), I.executeInClosestFrustum = s), I.boundingVolume = this._boundingSphere, I.modelMatrix = this._computedModelMatrix, I.pass = s ? E.TRANSLUCENT : E.OPAQUE, a.push(I)
                }
            }
        }, w.prototype.isDestroyed = function () {
            return !1
        }, w.prototype.destroy = function () {
            return this._sp = this._sp && this._sp.destroy(), this._pickSP = this._pickSP && this._pickSP.destroy(), this._pickId = this._pickId && this._pickId.destroy(), a(this)
        }, w
    }),define("Cesium/Scene/Moon", ["../Core/buildModuleUrl", "../Core/Cartesian3", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/Ellipsoid", "../Core/IauOrientationAxes", "../Core/Matrix3", "../Core/Matrix4", "../Core/Simon1994PlanetaryPositions", "../Core/Transforms", "./EllipsoidPrimitive", "./Material"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m) {
        "use strict";
        var p = function (t) {
            t = i(t, i.EMPTY_OBJECT);
            var r = t.textureUrl;
            n(r) || (r = e("Assets/Textures/moonSmall.jpg")), this.show = i(t.show, !0), this.textureUrl = r, this._ellipsoid = i(t.ellipsoid, a.MOON), this.onlySunLighting = i(t.onlySunLighting, !0), this._ellipsoidPrimitive = new d({
                radii: this.ellipsoid.radii,
                material: m.fromType(m.ImageType),
                depthTestEnabled: !1,
                _owner: this
            }), this._ellipsoidPrimitive.material.translucent = !1, this._axes = new s
        };
        r(p.prototype, {
            ellipsoid: {
                get: function () {
                    return this._ellipsoid
                }
            }
        });
        var f = new u, _ = new u, v = new t, g = [];
        return p.prototype.update = function (e, t) {
            if (this.show) {
                var i = this._ellipsoidPrimitive;
                i.material.uniforms.image = this.textureUrl, i.onlySunLighting = this.onlySunLighting;
                var r = t.time;
                n(h.computeIcrfToFixedMatrix(r, f)) || h.computeTemeToPseudoFixedMatrix(r, f);
                var o = this._axes.evaluate(r, _);
                u.transpose(o, o), u.multiply(f, o, o);
                var a = c.computeMoonPositionInEarthInertialFrame(r, v);
                return u.multiplyByVector(f, a, a), l.fromRotationTranslation(o, a, i.modelMatrix), g.length = 0, i.update(e, t, g), 1 === g.length ? g[0] : void 0
            }
        }, p.prototype.isDestroyed = function () {
            return !1
        }, p.prototype.destroy = function () {
            return this._ellipsoidPrimitive = this._ellipsoidPrimitive && this._ellipsoidPrimitive.destroy(), o(this)
        }, p
    }),define("Cesium/Core/mergeSort", ["./defined", "./DeveloperError"], function (e, t) {
        "use strict";
        function i(e, t, i, n, a, s) {
            var u, l, c = a - n + 1, h = s - a, d = r, m = o;
            for (u = 0; c > u; ++u)d[u] = e[n + u];
            for (l = 0; h > l; ++l)m[l] = e[a + l + 1];
            u = 0, l = 0;
            for (var p = n; s >= p; ++p) {
                var f = d[u], _ = m[l];
                c > u && (l >= h || t(f, _, i) <= 0) ? (e[p] = f, ++u) : h > l && (e[p] = _, ++l)
            }
        }

        function n(e, t, r, o, a) {
            if (!(o >= a)) {
                var s = Math.floor(.5 * (o + a));
                n(e, t, r, o, s), n(e, t, r, s + 1, a), i(e, t, r, o, s, a)
            }
        }

        var r = [], o = [], a = function (e, t, i) {
            var a = e.length, s = Math.ceil(.5 * a);
            r.length = s, o.length = s, n(e, t, i, 0, a - 1), r.length = 0, o.length = 0
        };
        return a
    }),define("Cesium/Renderer/ComputeEngine", ["../Core/BoundingRectangle", "../Core/Color", "../Core/ComponentDatatype", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Geometry", "../Core/GeometryAttribute", "../Core/PrimitiveType", "../Shaders/ViewportQuadVS", "./BufferUsage", "./ClearCommand", "./DrawCommand", "./Framebuffer", "./RenderState", "./ShaderProgram"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v) {
        "use strict";
        function g(e, t) {
            return new f({context: e, colorTextures: [t], destroyAttachments: !1})
        }

        function y(e, t) {
            return v.fromCache({
                context: e,
                vertexShaderSource: h,
                fragmentShaderSource: t,
                attributeLocations: {position: 0, textureCoordinates: 1}
            })
        }

        function C(t, i) {
            return r(E) && E.viewport.width === t && E.viewport.height === i || (E = _.fromCache({viewport: new e(0, 0, t, i)})), E
        }

        var E, S = function (e) {
            this._context = e
        }, T = new p({primitiveType: c.TRIANGLES}), b = new m({color: new t(0, 0, 0, 0)});
        return S.prototype.execute = function (e) {
            r(e.preExecute) && e.preExecute(e);
            var t = e.outputTexture, i = t.width, n = t.height, o = this._context, a = r(e.vertexArray) ? e.vertexArray : o.getViewportQuadVertexArray(), s = r(e.shaderProgram) ? e.shaderProgram : y(o, e.fragmentShaderSource), u = g(o, t), l = C(i, n), c = e.uniformMap, h = b;
            h.framebuffer = u, h.renderState = l, h.execute(o);
            var d = T;
            d.vertexArray = a, d.renderState = l, d.shaderProgram = s, d.uniformMap = c, d.framebuffer = u, d.execute(o),
                u.destroy(), e.persists || (s.destroy(), r(e.vertexArray) && a.destroy()), r(e.postExecute) && e.postExecute(t)
        }, S.prototype.isDestroyed = function () {
            return !1
        }, S.prototype.destroy = function () {
            return a(this)
        }, S
    }),define("Cesium/ThirdParty/Tween", [], function () {
        void 0 === Date.now && (Date.now = function () {
            return (new Date).valueOf()
        });
        var e = e || function () {
                var e = [];
                return {
                    REVISION: "13", getAll: function () {
                        return e
                    }, removeAll: function () {
                        e = []
                    }, add: function (t) {
                        e.push(t)
                    }, remove: function (t) {
                        var i = e.indexOf(t);
                        -1 !== i && e.splice(i, 1)
                    }, update: function (t) {
                        if (0 === e.length)return !1;
                        var i = 0;
                        for (t = void 0 !== t ? t : "undefined" != typeof window && void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now() : Date.now(); i < e.length;)e[i].update(t) ? i++ : e.splice(i, 1);
                        return !0
                    }
                }
            }();
        return e.Tween = function (t) {
            var i = t, n = {}, r = {}, o = {}, a = 1e3, s = 0, u = !1, l = !1, c = !1, h = 0, d = null, m = e.Easing.Linear.None, p = e.Interpolation.Linear, f = [], _ = null, v = !1, g = null, y = null, C = null;
            for (var E in t)n[E] = parseFloat(t[E], 10);
            this.to = function (e, t) {
                return void 0 !== t && (a = t), r = e, this
            }, this.start = function (t) {
                e.add(this), l = !0, v = !1, d = void 0 !== t ? t : "undefined" != typeof window && void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now() : Date.now(), d += h;
                for (var a in r) {
                    if (r[a]instanceof Array) {
                        if (0 === r[a].length)continue;
                        r[a] = [i[a]].concat(r[a])
                    }
                    n[a] = i[a], n[a]instanceof Array == !1 && (n[a] *= 1), o[a] = n[a] || 0
                }
                return this
            }, this.stop = function () {
                return l ? (e.remove(this), l = !1, null !== C && C.call(i), this.stopChainedTweens(), this) : this
            }, this.stopChainedTweens = function () {
                for (var e = 0, t = f.length; t > e; e++)f[e].stop()
            }, this.delay = function (e) {
                return h = e, this
            }, this.repeat = function (e) {
                return s = e, this
            }, this.yoyo = function (e) {
                return u = e, this
            }, this.easing = function (e) {
                return m = e, this
            }, this.interpolation = function (e) {
                return p = e, this
            }, this.chain = function () {
                return f = arguments, this
            }, this.onStart = function (e) {
                return _ = e, this
            }, this.onUpdate = function (e) {
                return g = e, this
            }, this.onComplete = function (e) {
                return y = e, this
            }, this.onStop = function (e) {
                return C = e, this
            }, this.update = function (e) {
                var t;
                if (d > e)return !0;
                v === !1 && (null !== _ && _.call(i), v = !0);
                var l = (e - d) / a;
                l = l > 1 ? 1 : l;
                var C = m(l);
                for (t in r) {
                    var E = n[t] || 0, S = r[t];
                    S instanceof Array ? i[t] = p(S, C) : ("string" == typeof S && (S = E + parseFloat(S, 10)), "number" == typeof S && (i[t] = E + (S - E) * C))
                }
                if (null !== g && g.call(i, C), 1 == l) {
                    if (s > 0) {
                        isFinite(s) && s--;
                        for (t in o) {
                            if ("string" == typeof r[t] && (o[t] = o[t] + parseFloat(r[t], 10)), u) {
                                var T = o[t];
                                o[t] = r[t], r[t] = T
                            }
                            n[t] = o[t]
                        }
                        return u && (c = !c), d = e + h, !0
                    }
                    null !== y && y.call(i);
                    for (var b = 0, w = f.length; w > b; b++)f[b].start(e);
                    return !1
                }
                return !0
            }
        }, e.Easing = {
            Linear: {
                None: function (e) {
                    return e
                }
            }, Quadratic: {
                In: function (e) {
                    return e * e
                }, Out: function (e) {
                    return e * (2 - e)
                }, InOut: function (e) {
                    return (e *= 2) < 1 ? .5 * e * e : -.5 * (--e * (e - 2) - 1)
                }
            }, Cubic: {
                In: function (e) {
                    return e * e * e
                }, Out: function (e) {
                    return --e * e * e + 1
                }, InOut: function (e) {
                    return (e *= 2) < 1 ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2)
                }
            }, Quartic: {
                In: function (e) {
                    return e * e * e * e
                }, Out: function (e) {
                    return 1 - --e * e * e * e
                }, InOut: function (e) {
                    return (e *= 2) < 1 ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2)
                }
            }, Quintic: {
                In: function (e) {
                    return e * e * e * e * e
                }, Out: function (e) {
                    return --e * e * e * e * e + 1
                }, InOut: function (e) {
                    return (e *= 2) < 1 ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2)
                }
            }, Sinusoidal: {
                In: function (e) {
                    return 1 - Math.cos(e * Math.PI / 2)
                }, Out: function (e) {
                    return Math.sin(e * Math.PI / 2)
                }, InOut: function (e) {
                    return .5 * (1 - Math.cos(Math.PI * e))
                }
            }, Exponential: {
                In: function (e) {
                    return 0 === e ? 0 : Math.pow(1024, e - 1)
                }, Out: function (e) {
                    return 1 === e ? 1 : 1 - Math.pow(2, -10 * e)
                }, InOut: function (e) {
                    return 0 === e ? 0 : 1 === e ? 1 : (e *= 2) < 1 ? .5 * Math.pow(1024, e - 1) : .5 * (-Math.pow(2, -10 * (e - 1)) + 2)
                }
            }, Circular: {
                In: function (e) {
                    return 1 - Math.sqrt(1 - e * e)
                }, Out: function (e) {
                    return Math.sqrt(1 - --e * e)
                }, InOut: function (e) {
                    return (e *= 2) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
                }
            }, Elastic: {
                In: function (e) {
                    var t, i = .1, n = .4;
                    return 0 === e ? 0 : 1 === e ? 1 : (!i || 1 > i ? (i = 1, t = n / 4) : t = n * Math.asin(1 / i) / (2 * Math.PI), -(i * Math.pow(2, 10 * (e -= 1)) * Math.sin(2 * (e - t) * Math.PI / n)))
                }, Out: function (e) {
                    var t, i = .1, n = .4;
                    return 0 === e ? 0 : 1 === e ? 1 : (!i || 1 > i ? (i = 1, t = n / 4) : t = n * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * e) * Math.sin(2 * (e - t) * Math.PI / n) + 1)
                }, InOut: function (e) {
                    var t, i = .1, n = .4;
                    return 0 === e ? 0 : 1 === e ? 1 : (!i || 1 > i ? (i = 1, t = n / 4) : t = n * Math.asin(1 / i) / (2 * Math.PI), (e *= 2) < 1 ? -.5 * i * Math.pow(2, 10 * (e -= 1)) * Math.sin(2 * (e - t) * Math.PI / n) : i * Math.pow(2, -10 * (e -= 1)) * Math.sin(2 * (e - t) * Math.PI / n) * .5 + 1)
                }
            }, Back: {
                In: function (e) {
                    var t = 1.70158;
                    return e * e * ((t + 1) * e - t)
                }, Out: function (e) {
                    var t = 1.70158;
                    return --e * e * ((t + 1) * e + t) + 1
                }, InOut: function (e) {
                    var t = 2.5949095;
                    return (e *= 2) < 1 ? .5 * e * e * ((t + 1) * e - t) : .5 * ((e -= 2) * e * ((t + 1) * e + t) + 2)
                }
            }, Bounce: {
                In: function (t) {
                    return 1 - e.Easing.Bounce.Out(1 - t)
                }, Out: function (e) {
                    return 1 / 2.75 > e ? 7.5625 * e * e : 2 / 2.75 > e ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : 2.5 / 2.75 > e ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
                }, InOut: function (t) {
                    return .5 > t ? .5 * e.Easing.Bounce.In(2 * t) : .5 * e.Easing.Bounce.Out(2 * t - 1) + .5
                }
            }
        }, e.Interpolation = {
            Linear: function (t, i) {
                var n = t.length - 1, r = n * i, o = Math.floor(r), a = e.Interpolation.Utils.Linear;
                return 0 > i ? a(t[0], t[1], r) : i > 1 ? a(t[n], t[n - 1], n - r) : a(t[o], t[o + 1 > n ? n : o + 1], r - o)
            }, Bezier: function (t, i) {
                var n, r = 0, o = t.length - 1, a = Math.pow, s = e.Interpolation.Utils.Bernstein;
                for (n = 0; o >= n; n++)r += a(1 - i, o - n) * a(i, n) * t[n] * s(o, n);
                return r
            }, CatmullRom: function (t, i) {
                var n = t.length - 1, r = n * i, o = Math.floor(r), a = e.Interpolation.Utils.CatmullRom;
                return t[0] === t[n] ? (0 > i && (o = Math.floor(r = n * (1 + i))), a(t[(o - 1 + n) % n], t[o], t[(o + 1) % n], t[(o + 2) % n], r - o)) : 0 > i ? t[0] - (a(t[0], t[0], t[1], t[1], -r) - t[0]) : i > 1 ? t[n] - (a(t[n], t[n], t[n - 1], t[n - 1], r - n) - t[n]) : a(t[o ? o - 1 : 0], t[o], t[o + 1 > n ? n : o + 1], t[o + 2 > n ? n : o + 2], r - o)
            }, Utils: {
                Linear: function (e, t, i) {
                    return (t - e) * i + e
                }, Bernstein: function (t, i) {
                    var n = e.Interpolation.Utils.Factorial;
                    return n(t) / n(i) / n(t - i)
                }, Factorial: function () {
                    var e = [1];
                    return function (t) {
                        var i, n = 1;
                        if (e[t])return e[t];
                        for (i = t; i > 1; i--)n *= i;
                        return e[t] = n
                    }
                }(), CatmullRom: function (e, t, i, n, r) {
                    var o = .5 * (i - e), a = .5 * (n - t), s = r * r, u = r * s;
                    return (2 * t - 2 * i + o + a) * u + (-3 * t + 3 * i - 2 * o - a) * s + o * r + t
                }
            }
        }, e
    }),define("Cesium/Core/EasingFunction", ["../ThirdParty/Tween", "./freezeObject"], function (e, t) {
        "use strict";
        var i = {
            LINEAR_NONE: e.Easing.Linear.None,
            QUADRACTIC_IN: e.Easing.Quadratic.In,
            QUADRACTIC_OUT: e.Easing.Quadratic.Out,
            QUADRACTIC_IN_OUT: e.Easing.Quadratic.InOut,
            CUBIC_IN: e.Easing.Cubic.In,
            CUBIC_OUT: e.Easing.Cubic.Out,
            CUBIC_IN_OUT: e.Easing.Cubic.InOut,
            QUARTIC_IN: e.Easing.Quartic.In,
            QUARTIC_OUT: e.Easing.Quartic.Out,
            QUARTIC_IN_OUT: e.Easing.Quartic.InOut,
            QUINTIC_IN: e.Easing.Quintic.In,
            QUINTIC_OUT: e.Easing.Quintic.Out,
            QUINTIC_IN_OUT: e.Easing.Quintic.InOut,
            SINUSOIDAL_IN: e.Easing.Sinusoidal.In,
            SINUSOIDAL_OUT: e.Easing.Sinusoidal.Out,
            SINUSOIDAL_IN_OUT: e.Easing.Sinusoidal.InOut,
            EXPONENTIAL_IN: e.Easing.Exponential.In,
            EXPONENTIAL_OUT: e.Easing.Exponential.Out,
            EXPONENTIAL_IN_OUT: e.Easing.Exponential.InOut,
            CIRCULAR_IN: e.Easing.Circular.In,
            CIRCULAR_OUT: e.Easing.Circular.Out,
            CIRCULAR_IN_OUT: e.Easing.Circular.InOut,
            ELASTIC_IN: e.Easing.Elastic.In,
            ELASTIC_OUT: e.Easing.Elastic.Out,
            ELASTIC_IN_OUT: e.Easing.Elastic.InOut,
            BACK_IN: e.Easing.Back.In,
            BACK_OUT: e.Easing.Back.Out,
            BACK_IN_OUT: e.Easing.Back.InOut,
            BOUNCE_IN: e.Easing.Bounce.In,
            BOUNCE_OUT: e.Easing.Bounce.Out,
            BOUNCE_IN_OUT: e.Easing.Bounce.InOut
        };
        return t(i)
    }),define("Cesium/Scene/PerspectiveOffCenterFrustum", ["../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Matrix4", "./CullingVolume"], function (e, t, i, n, r, o, a, s, u) {
        "use strict";
        function l(e) {
            var t = e.top, i = e.bottom, n = e.right, r = e.left, o = e.near, a = e.far;
            (t !== e._top || i !== e._bottom || r !== e._left || n !== e._right || o !== e._near || a !== e._far) && (e._left = r, e._right = n, e._top = t, e._bottom = i, e._near = o, e._far = a, e._perspectiveMatrix = s.computePerspectiveOffCenter(r, n, i, t, o, a, e._perspectiveMatrix), e._infinitePerspective = s.computeInfinitePerspectiveOffCenter(r, n, i, t, o, e._infinitePerspective))
        }

        var c = function () {
            this.left = void 0, this._left = void 0, this.right = void 0, this._right = void 0, this.top = void 0, this._top = void 0, this.bottom = void 0, this._bottom = void 0, this.near = 1, this._near = this.near, this.far = 5e8, this._far = this.far, this._cullingVolume = new u, this._perspectiveMatrix = new s, this._infinitePerspective = new s
        };
        o(c.prototype, {
            projectionMatrix: {
                get: function () {
                    return l(this), this._perspectiveMatrix
                }
            }, infiniteProjectionMatrix: {
                get: function () {
                    return l(this), this._infinitePerspective
                }
            }
        });
        var h = new t, d = new t, m = new t, p = new t;
        return c.prototype.computeCullingVolume = function (e, n, o) {
            var a = this._cullingVolume.planes, s = this.top, u = this.bottom, l = this.right, c = this.left, f = this.near, _ = this.far, v = t.cross(n, o, h), g = d;
            t.multiplyByScalar(n, f, g), t.add(e, g, g);
            var y = m;
            t.multiplyByScalar(n, _, y), t.add(e, y, y);
            var C = p;
            t.multiplyByScalar(v, c, C), t.add(g, C, C), t.subtract(C, e, C), t.normalize(C, C), t.cross(C, o, C);
            var E = a[0];
            return r(E) || (E = a[0] = new i), E.x = C.x, E.y = C.y, E.z = C.z, E.w = -t.dot(C, e), t.multiplyByScalar(v, l, C), t.add(g, C, C), t.subtract(C, e, C), t.normalize(C, C), t.cross(o, C, C), E = a[1], r(E) || (E = a[1] = new i), E.x = C.x, E.y = C.y, E.z = C.z, E.w = -t.dot(C, e), t.multiplyByScalar(o, u, C), t.add(g, C, C), t.subtract(C, e, C), t.normalize(C, C), t.cross(v, C, C), E = a[2], r(E) || (E = a[2] = new i), E.x = C.x, E.y = C.y, E.z = C.z, E.w = -t.dot(C, e), t.multiplyByScalar(o, s, C), t.add(g, C, C), t.subtract(C, e, C), t.normalize(C, C), t.cross(C, v, C), E = a[3], r(E) || (E = a[3] = new i), E.x = C.x, E.y = C.y, E.z = C.z, E.w = -t.dot(C, e), E = a[4], r(E) || (E = a[4] = new i), E.x = n.x, E.y = n.y, E.z = n.z, E.w = -t.dot(n, g), t.negate(n, C), E = a[5], r(E) || (E = a[5] = new i), E.x = C.x, E.y = C.y, E.z = C.z, E.w = -t.dot(C, y), this._cullingVolume
        }, c.prototype.getPixelSize = function (t, i, o) {
            l(this);
            var a = t.x, s = t.y;
            i = n(i, this.near);
            var u = 1 / this.near, c = this.top * u, h = 2 * i * c / s;
            c = this.right * u;
            var d = 2 * i * c / a;
            return r(o) ? (o.x = d, o.y = h, o) : new e(d, h)
        }, c.prototype.clone = function (e) {
            return r(e) || (e = new c), e.right = this.right, e.left = this.left, e.top = this.top, e.bottom = this.bottom, e.near = this.near, e.far = this.far, e._left = void 0, e._right = void 0, e._top = void 0, e._bottom = void 0, e._near = void 0, e._far = void 0, e
        }, c.prototype.equals = function (e) {
            return r(e) && this.right === e.right && this.left === e.left && this.top === e.top && this.bottom === e.bottom && this.near === e.near && this.far === e.far
        }, c
    }),define("Cesium/Scene/PerspectiveFrustum", ["../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "./PerspectiveOffCenterFrustum"], function (e, t, i, n) {
        "use strict";
        function r(e) {
            var t = e._offCenterFrustum;
            (e.fov !== e._fov || e.aspectRatio !== e._aspectRatio || e.near !== e._near || e.far !== e._far) && (e._aspectRatio = e.aspectRatio, e._fov = e.fov, e._fovy = e.aspectRatio <= 1 ? e.fov : 2 * Math.atan(Math.tan(.5 * e.fov) / e.aspectRatio), e._near = e.near, e._far = e.far, e._sseDenominator = 2 * Math.tan(.5 * e._fovy), t.top = e.near * Math.tan(.5 * e._fovy), t.bottom = -t.top, t.right = e.aspectRatio * t.top, t.left = -t.right, t.near = e.near, t.far = e.far)
        }

        var o = function () {
            this._offCenterFrustum = new n, this.fov = void 0, this._fov = void 0, this._fovy = void 0, this._sseDenominator = void 0, this.aspectRatio = void 0, this._aspectRatio = void 0, this.near = 1, this._near = this.near, this.far = 5e8, this._far = this.far
        };
        return t(o.prototype, {
            projectionMatrix: {
                get: function () {
                    return r(this), this._offCenterFrustum.projectionMatrix
                }
            }, infiniteProjectionMatrix: {
                get: function () {
                    return r(this), this._offCenterFrustum.infiniteProjectionMatrix
                }
            }, fovy: {
                get: function () {
                    return r(this), this._fovy
                }
            }, sseDenominator: {
                get: function () {
                    return r(this), this._sseDenominator
                }
            }
        }), o.prototype.computeCullingVolume = function (e, t, i) {
            return r(this), this._offCenterFrustum.computeCullingVolume(e, t, i)
        }, o.prototype.getPixelSize = function (e, t, i) {
            return r(this), this._offCenterFrustum.getPixelSize(e, t, i)
        }, o.prototype.clone = function (t) {
            return e(t) || (t = new o), t.aspectRatio = this.aspectRatio, t.fov = this.fov, t.near = this.near, t.far = this.far, t._aspectRatio = void 0, t._fov = void 0, t._near = void 0, t._far = void 0, this._offCenterFrustum.clone(t._offCenterFrustum), t
        }, o.prototype.equals = function (t) {
            return e(t) ? (r(this), r(t), this.fov === t.fov && this.aspectRatio === t.aspectRatio && this.near === t.near && this.far === t.far && this._offCenterFrustum.equals(t._offCenterFrustum)) : !1
        }, o
    }),define("Cesium/Scene/CameraFlightPath", ["../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartographic", "../Core/defaultValue", "../Core/defined", "../Core/DeveloperError", "../Core/EasingFunction", "../Core/Math", "./PerspectiveFrustum", "./PerspectiveOffCenterFrustum", "./SceneMode"], function (e, t, i, n, r, o, a, s, u, l, c) {
        "use strict";
        function h(e, t, i) {
            var n, r, o;
            if (e instanceof u) {
                var a = Math.tan(.5 * e.fovy);
                return n = e.near, r = e.near * a, o = e.aspectRatio * r, Math.max(t * n / o, i * n / r)
            }
            return e instanceof l ? (n = e.near, r = e.top, o = e.right, Math.max(t * n / o, i * n / r)) : Math.max(t, i)
        }

        function d(e, i, n, o, a) {
            var u, l = a;
            if (!r(a)) {
                var c = e.position, d = i, m = e.up, p = e.right, f = e.frustum, _ = t.subtract(c, d, C), v = t.magnitude(t.multiplyByScalar(m, t.dot(_, m), E)), g = t.magnitude(t.multiplyByScalar(p, t.dot(_, p), E));
                u = Math.max(n, o), l = Math.min(.2 * h(f, v, g), 1e9)
            }
            if (r(a) && l > a || l > u) {
                var y = 8, S = 1e6, T = -Math.pow((l - n) * S, 1 / y), b = Math.pow((l - o) * S, 1 / y);
                return function (e) {
                    var t = e * (b - T) + T;
                    return -Math.pow(t, y) / S + l
                }
            }
            return function (e) {
                return s.lerp(n, o, e)
            }
        }

        function m(e, t) {
            return s.equalsEpsilon(e, s.TWO_PI, s.EPSILON11) && (e = 0), t > e + Math.PI ? e += s.TWO_PI : t < e - Math.PI && (e -= s.TWO_PI), e
        }

        function p(i, n, r, o, a, u, l) {
            var c = i.camera, h = t.clone(c.position, S), p = c.pitch, f = m(c.heading, o), _ = m(c.roll, u), v = d(c, r, h.z, r.z, l), g = function (t) {
                var i = t.time / n;
                c.setView({
                    heading: s.lerp(f, o, i),
                    pitch: s.lerp(p, a, i),
                    roll: s.lerp(_, u, i)
                }), e.lerp(h, r, i, c.position), c.position.z = v(i)
            };
            return g
        }

        function f(e, t, n, r, o, a, u) {
            var l = e.camera, c = e.mapProjection, h = c.ellipsoid, p = i.clone(l.positionCartographic, T), f = l.pitch, _ = m(l.heading, r), v = m(l.roll, a), g = h.cartesianToCartographic(n, b);
            g.height <= 0 && (g.height = p.height), p.longitude = s.zeroToTwoPi(p.longitude), g.longitude = s.zeroToTwoPi(g.longitude);
            var y = p.longitude - g.longitude;
            y < -s.PI ? p.longitude += s.TWO_PI : y > s.PI && (g.longitude += s.TWO_PI);
            var C = d(l, n, p.height, g.height, u), E = function (e) {
                var i = e.time / t, n = w;
                n.longitude = s.lerp(p.longitude, g.longitude, i), n.latitude = s.lerp(p.latitude, g.latitude, i), n.height = C(i), l.setView({
                    positionCartographic: n,
                    heading: s.lerp(_, r, i),
                    pitch: s.lerp(f, o, i),
                    roll: s.lerp(v, a, i)
                })
            };
            return E
        }

        function _(i, n, r, o, a, u, l) {
            var c = i.camera, h = t.clone(c.position, S), p = c.pitch, f = m(c.heading, o), _ = m(c.roll, u), v = c.frustum.right - c.frustum.left, g = d(c, r, v, r.z, l), y = function (t) {
                var i = t.time / n;
                c.setView({
                    heading: s.lerp(f, o, i),
                    pitch: s.lerp(p, a, i),
                    roll: s.lerp(_, u, i)
                }), e.lerp(h, r, i, c.position);
                var l = g(i), d = c.frustum, m = d.top / d.right, v = .5 * (l - (d.right - d.left));
                d.right += v, d.left -= v, d.top = m * d.right, d.bottom = -d.top
            };
            return y
        }

        function v(e, t) {
            return {startObject: {}, stopObject: {}, duration: 0, complete: e, cancel: t}
        }

        function g(e, t) {
            var i = function () {
                "function" == typeof t && t(), e.enableInputs = !0
            };
            return i
        }

        var y = {}, C = new t, E = new t, S = new t, T = new i, b = new i, w = new i, x = (new t, new t, new t, new i), A = new t;
        return y.createTween = function (i, o) {
            o = n(o, n.EMPTY_OBJECT);
            var u = o.destination, l = i.mapProjection, h = l.ellipsoid, d = o.maximumHeight, m = o.easingFunction;
            if (i.mode === c.MORPHING)return v();
            var y = n(o.convert, !0);
            y && i.mode !== c.SCENE3D && (h.cartesianToCartographic(u, x), u = l.project(x, A));
            var C = i.camera, E = o.endTransform;
            r(E) && C._setTransform(E);
            var S = o.duration;
            r(S) || (S = Math.ceil(t.distance(C.position, u) / 1e6) + 2, S = Math.min(S, 3));
            var T = i.mode, b = n(o.heading, 0), w = i.mode !== c.SCENE2D ? n(o.pitch, -s.PI_OVER_TWO) : -s.PI_OVER_TWO, P = n(o.roll, 0), I = i.screenSpaceCameraController;
            I.enableInputs = !1;
            var D = g(I, o.complete), M = g(I, o.cancel), O = C.frustum, R = i.mode === c.SCENE2D;
            if (R = R && e.equalsEpsilon(C.position, u, s.EPSILON6), R = R && s.equalsEpsilon(Math.max(O.right - O.left, O.top - O.bottom), u.z, s.EPSILON6), R = R || i.mode !== c.SCENE2D && t.equalsEpsilon(u, C.position, s.EPSILON6))return v(D, M);
            var N = new Array(4);
            if (N[c.SCENE2D] = _, N[c.SCENE3D] = f, N[c.COLUMBUS_VIEW] = p, 0 >= S) {
                var L = function () {
                    var e = N[T](i, 1, u, b, w, P, d);
                    e({time: 1}), "function" == typeof D && D()
                };
                return v(L, M)
            }
            var F = N[T](i, S, u, b, w, P, d);
            if (!r(m)) {
                var B = C.positionCartographic.height, z = T === c.SCENE3D ? h.cartesianToCartographic(u).height : u.z;
                m = B > z && B > 11500 ? a.CUBIC_OUT : a.QUINTIC_IN_OUT
            }
            return {
                duration: S,
                easingFunction: m,
                startObject: {time: 0},
                stopObject: {time: S},
                update: F,
                complete: D,
                cancel: M
            }
        }, y
    }),define("Cesium/Scene/Camera", ["../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/Cartographic", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/EasingFunction", "../Core/Ellipsoid", "../Core/EllipsoidGeodesic", "../Core/Event", "../Core/IntersectionTests", "../Core/Math", "../Core/Matrix3", "../Core/Matrix4", "../Core/Quaternion", "../Core/Ray", "../Core/Rectangle", "../Core/Transforms", "./CameraFlightPath", "./HeadingPitchRange", "./PerspectiveFrustum", "./SceneMode"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S, T) {
        "use strict";
        function b(e) {
            var i = e._right, n = e._up, r = e._direction, o = e._position, a = e._viewMatrix;
            a[0] = i.x, a[1] = n.x, a[2] = -r.x, a[3] = 0, a[4] = i.y, a[5] = n.y, a[6] = -r.y, a[7] = 0, a[8] = i.z, a[9] = n.z, a[10] = -r.z, a[11] = 0, a[12] = -t.dot(i, o), a[13] = -t.dot(n, o), a[14] = t.dot(r, o), a[15] = 1, f.multiply(a, e._actualInvTransform, e._viewMatrix), f.inverseTransformation(e._viewMatrix, e._invViewMatrix)
        }

        function w(e) {
            var n = e._projection, r = n.ellipsoid, o = f.getColumn(e._transform, 3, re), a = r.cartesianToCartographic(o, te), s = n.project(a, ie), u = oe;
            u.x = s.z, u.y = s.x, u.z = s.y, u.w = 1;
            var l = i.add(f.getColumn(e._transform, 0, ne), o, ne);
            r.cartesianToCartographic(l, a), n.project(a, s);
            var c = ae;
            c.x = s.z, c.y = s.x, c.z = s.y, c.w = 0, t.subtract(c, u, c);
            var h = i.add(f.getColumn(e._transform, 1, ne), o, ne);
            r.cartesianToCartographic(h, a), n.project(a, s);
            var d = se;
            d.x = s.z, d.y = s.x, d.z = s.y, d.w = 0, t.subtract(d, u, d);
            var m = ue;
            t.cross(c, d, m), t.normalize(m, m), t.cross(d, m, c), t.normalize(c, c), t.cross(m, c, d), t.normalize(d, d), f.setColumn(e._actualTransform, 0, c, e._actualTransform), f.setColumn(e._actualTransform, 1, d, e._actualTransform), f.setColumn(e._actualTransform, 2, m, e._actualTransform), f.setColumn(e._actualTransform, 3, u, e._actualTransform)
        }

        function x(e) {
            var n = e._projection, r = n.ellipsoid, o = f.getColumn(e._transform, 3, re), a = r.cartesianToCartographic(o, te), s = n.project(a, ie), u = oe;
            u.x = s.z, u.y = s.x, u.z = s.y, u.w = 1;
            var l = i.clone(i.UNIT_X, ue), c = i.add(f.getColumn(e._transform, 0, ne), o, ne);
            r.cartesianToCartographic(c, a), n.project(a, s);
            var h = ae;
            h.x = s.z, h.y = s.x, h.z = s.y, h.w = 0, t.subtract(h, u, h), h.x = 0;
            var d = se;
            if (t.magnitudeSquared(h) > m.EPSILON10)t.cross(l, h, d); else {
                var p = i.add(f.getColumn(e._transform, 1, ne), o, ne);
                r.cartesianToCartographic(p, a), n.project(a, s), d.x = s.z, d.y = s.x, d.z = s.y, d.w = 0, t.subtract(d, u, d), d.x = 0, t.magnitudeSquared(d) < m.EPSILON10 && (i.clone(i.UNIT_Y, h), i.clone(i.UNIT_Z, d))
            }
            t.cross(d, l, h), t.normalize(h, h), t.cross(l, h, d), t.normalize(d, d), f.setColumn(e._actualTransform, 0, h, e._actualTransform), f.setColumn(e._actualTransform, 1, d, e._actualTransform), f.setColumn(e._actualTransform, 2, l, e._actualTransform), f.setColumn(e._actualTransform, 3, u, e._actualTransform)
        }

        function A(e) {
            var i = e._mode, n = !1, r = 0;
            i === T.SCENE2D && (r = e.frustum.right - e.frustum.left, n = r !== e._positionCartographic.height);
            var o = e._position, a = !t.equals(o, e.position) || n;
            a && (o = t.clone(e.position, e._position));
            var s = e._direction, u = !t.equals(s, e.direction);
            u && (s = t.clone(e.direction, e._direction));
            var l = e._up, c = !t.equals(l, e.up);
            c && (l = t.clone(e.up, e._up));
            var h = e._right, d = !t.equals(h, e.right);
            d && (h = t.clone(e.right, e._right));
            var p = e._transformChanged || e._modeChanged;
            e._transformChanged = !1, p && (f.inverseTransformation(e._transform, e._invTransform), e._mode === T.COLUMBUS_VIEW || e._mode === T.SCENE2D ? f.equals(f.IDENTITY, e._transform) ? f.clone(ee.TRANSFORM_2D, e._actualTransform) : e._mode === T.COLUMBUS_VIEW ? w(e) : x(e) : f.clone(e._transform, e._actualTransform), f.inverseTransformation(e._actualTransform, e._actualInvTransform), e._modeChanged = !1);
            var _ = e._actualTransform;
            if (a || p)if (e._positionWC = f.multiplyByPoint(_, o, e._positionWC), i === T.SCENE3D || i === T.MORPHING)e._positionCartographic = e._projection.ellipsoid.cartesianToCartographic(e._positionWC, e._positionCartographic); else {
                var v = le;
                v.x = e._positionWC.y, v.y = e._positionWC.z, v.z = e._positionWC.x, i === T.SCENE2D && (v.z = r), e._projection.unproject(v, e._positionCartographic)
            }
            if (u || c || d) {
                var g = t.dot(s, t.cross(l, h, le));
                if (Math.abs(1 - g) > m.EPSILON2) {
                    s = t.normalize(s, e._direction), t.clone(s, e.direction);
                    var y = 1 / t.magnitudeSquared(l), C = t.dot(l, s) * y, E = t.multiplyByScalar(s, C, le);
                    l = t.normalize(t.subtract(l, E, e._up), e._up), t.clone(l, e.up), h = t.cross(s, l, e._right), t.clone(h, e.right)
                }
            }
            (u || p) && (e._directionWC = f.multiplyByPointAsVector(_, s, e._directionWC)), (c || p) && (e._upWC = f.multiplyByPointAsVector(_, l, e._upWC)), (d || p) && (e._rightWC = f.multiplyByPointAsVector(_, h, e._rightWC)), (a || u || c || d || p) && b(e)
        }

        function P(e, t) {
            var i;
            return i = m.equalsEpsilon(Math.abs(e.z), 1, m.EPSILON3) ? Math.atan2(t.y, t.x) - m.PI_OVER_TWO : Math.atan2(e.y, e.x) - m.PI_OVER_TWO, m.TWO_PI - m.zeroToTwoPi(i)
        }

        function I(e) {
            return m.PI_OVER_TWO - m.acosClamped(e.z)
        }

        function D(e, t, i) {
            var n = 0;
            return m.equalsEpsilon(Math.abs(e.z), 1, m.EPSILON3) || (n = Math.atan2(-i.z, t.z), n = m.zeroToTwoPi(n + m.TWO_PI)), n
        }

        function M(e, i, n, r, a, s, u) {
            o(i) || (i = o(n) ? u.cartographicToCartesian(n, fe) : t.clone(e.positionWC, fe));
            var l = f.clone(e.transform, _e), c = y.eastNorthUpToFixedFrame(i, u, ve);
            e._setTransform(c), t.clone(t.ZERO, e.position);
            var h = _.fromHeadingPitchRoll(r - m.PI_OVER_TWO, a, s, ge), d = p.fromQuaternion(h, ye);
            p.getColumn(d, 0, e.direction), p.getColumn(d, 2, e.up), t.cross(e.direction, e.up, e.right), e._setTransform(l)
        }

        function O(e, i, n, r, a, s, u, l) {
            var c = f.clone(e.transform, _e);
            e._setTransform(f.IDENTITY), o(i) && !t.equals(i, e.positionWC) && (n = u.cartesianToCartographic(i)), o(n) && (i = l.project(n, fe), t.clone(i, e.position));
            var h = _.fromHeadingPitchRoll(r - m.PI_OVER_TWO, a, s, ge), d = p.fromQuaternion(h, ye);
            p.getColumn(d, 0, e.direction), p.getColumn(d, 2, e.up), t.cross(e.direction, e.up, e.right), e._setTransform(c)
        }

        function R(i, n, r, a, s, u, l, c) {
            s = -m.PI_OVER_TWO, u = 0;
            var h = f.clone(i.transform, _e);
            if (i._setTransform(f.IDENTITY), o(n) && !t.equals(n, i.positionWC) && (r = l.cartesianToCartographic(n)), o(r)) {
                n = c.project(r, fe), e.clone(n, i.position);
                var d = .5 * -r.height, v = -d, g = i.frustum;
                if (v > d) {
                    var y = g.top / g.right;
                    g.right = v, g.left = d, g.top = g.right * y, g.bottom = -g.top
                }
            }
            var C = _.fromHeadingPitchRoll(a - m.PI_OVER_TWO, s, u, ge), E = p.fromQuaternion(C, ye);
            p.getColumn(E, 2, i.up), t.cross(i.direction, i.up, i.right), i._setTransform(h)
        }

        function N(e, t) {
            var i = e._maxCoord.x * e.maximumTranslateFactor;
            t.x > i && (t.x = i), t.x < -i && (t.x = -i);
            var n = e._maxCoord.y * e.maximumTranslateFactor;
            t.y > n && (t.y = n), t.y < -n && (t.y = -n)
        }

        function L(e, i) {
            var n = e.position, r = t.normalize(n, we);
            if (o(e.constrainedAxis)) {
                var a = t.equalsEpsilon(r, e.constrainedAxis, m.EPSILON2), s = t.equalsEpsilon(r, t.negate(e.constrainedAxis, Pe), m.EPSILON2);
                if (a || s)(a && 0 > i || s && i > 0) && e.rotate(e.right, i); else {
                    var u = t.normalize(e.constrainedAxis, xe), l = t.dot(r, u), c = m.acosClamped(l);
                    i > 0 && i > c && (i = c - m.EPSILON4), l = t.dot(r, t.negate(u, Pe)), c = m.acosClamped(l), 0 > i && -i > c && (i = -c + m.EPSILON4);
                    var h = t.cross(u, r, Ae);
                    e.rotate(h, i)
                }
            } else e.rotate(e.right, i)
        }

        function F(e, t) {
            o(e.constrainedAxis) ? e.rotate(e.constrainedAxis, t) : e.rotate(e.up, t)
        }

        function B(e, t) {
            var i = e.frustum;
            t = .5 * t;
            var n = i.right - t, r = i.left + t, o = e._maxCoord.x * e.maximumZoomFactor;
            n > o && (n = o, r = -o), r >= n && (n = 1, r = -1);
            var a = i.top / i.right;
            i.right = n, i.left = r, i.top = i.right * a, i.bottom = -i.top
        }

        function z(e, t) {
            e.move(e.direction, t)
        }

        function V(e, i, n) {
            i = m.clamp(i, -m.PI_OVER_TWO, m.PI_OVER_TWO), e = m.zeroToTwoPi(e) - m.PI_OVER_TWO;
            var r = _.fromAxisAngle(t.UNIT_Y, -i, Me), o = _.fromAxisAngle(t.UNIT_Z, -e, Oe), a = _.multiply(o, r, o), s = p.fromQuaternion(a, Re), u = t.clone(t.UNIT_X, De);
            return p.multiplyByVector(s, u, u), t.negate(u, u), t.multiplyByScalar(u, n, u), u
        }

        function U(e, i, n, r, a) {
            function s(e, i, n, r) {
                var o = Math.abs(t.dot(i, n));
                return o / r - t.dot(e, n)
            }

            o(r) || (r = new t);
            var u = e;
            a && (u = qe);
            var l = i.north, h = i.south, d = i.east, p = i.west;
            p > d && (d += m.TWO_PI);
            var f, _ = .5 * (p + d);
            if (h < -m.PI_OVER_TWO + m.RADIANS_PER_DEGREE && l > m.PI_OVER_TWO - m.RADIANS_PER_DEGREE)f = 0; else {
                var v = Le;
                v.longitude = _, v.latitude = l, v.height = 0;
                var g = Fe;
                g.longitude = _, g.latitude = h, g.height = 0;
                var y = Ne;
                o(y) && y.ellipsoid === n || (Ne = y = new c(void 0, void 0, n)), y.setEndPoints(v, g), f = y.interpolateUsingFraction(.5, Le).latitude
            }
            var C = Le;
            C.longitude = _, C.latitude = f, C.height = 0;
            var E = n.cartographicToCartesian(C, He), S = Le;
            S.longitude = d, S.latitude = l;
            var T = n.cartographicToCartesian(S, Be);
            S.longitude = p;
            var b = n.cartographicToCartesian(S, Ve);
            S.longitude = _;
            var w = n.cartographicToCartesian(S, ke);
            S.latitude = h;
            var x = n.cartographicToCartesian(S, Ge);
            S.longitude = d;
            var A = n.cartographicToCartesian(S, Ue);
            S.longitude = p;
            var P = n.cartographicToCartesian(S, ze);
            t.subtract(b, E, b), t.subtract(A, E, A), t.subtract(T, E, T), t.subtract(P, E, P), t.subtract(w, E, w), t.subtract(x, E, x);
            var I = n.geodeticSurfaceNormal(E, u.direction);
            t.negate(I, I);
            var D = t.cross(I, t.UNIT_Z, u.right);
            t.normalize(D, D);
            var M = t.cross(D, I, u.up), O = Math.tan(.5 * e.frustum.fovy), R = e.frustum.aspectRatio * O, N = Math.max(s(I, M, b, O), s(I, M, A, O), s(I, M, T, O), s(I, M, P, O), s(I, M, w, O), s(I, M, x, O), s(I, D, b, R), s(I, D, A, R), s(I, D, T, R), s(I, D, P, R), s(I, D, w, R), s(I, D, x, R));
            if (0 > h && l > 0) {
                var L = Le;
                L.longitude = p, L.latitude = 0, L.height = 0;
                var F = n.cartographicToCartesian(L, We);
                t.subtract(F, E, F), N = Math.max(N, s(I, M, F, O), s(I, D, F, R)), L.longitude = d, F = n.cartographicToCartesian(L, We), t.subtract(F, E, F), N = Math.max(N, s(I, M, F, O), s(I, D, F, R))
            }
            return t.add(E, t.multiplyByScalar(I, -N, We), r)
        }

        function k(e, i, n, r, a) {
            var s = i.north, u = i.south, l = i.east, c = i.west, h = e._actualTransform, d = e._actualInvTransform, m = je;
            m.longitude = l, m.latitude = s;
            var p = n.project(m, Ye);
            f.multiplyByPoint(h, p, p), f.multiplyByPoint(d, p, p), m.longitude = c, m.latitude = u;
            var _ = n.project(m, Xe);
            f.multiplyByPoint(h, _, _), f.multiplyByPoint(d, _, _);
            var v = Math.tan(.5 * e.frustum.fovy), g = e.frustum.aspectRatio * v;
            if (o(r) || (r = new t), r.x = .5 * (p.x - _.x) + _.x, r.y = .5 * (p.y - _.y) + _.y, r.z = .5 * Math.max((p.x - _.x) / g, (p.y - _.y) / v), !a) {
                var y = t.clone(t.UNIT_Z, e.direction);
                t.negate(y, y), t.clone(t.UNIT_X, e.right), t.clone(t.UNIT_Y, e.up)
            }
            return r
        }

        function G(e, i, n, r, a) {
            var s = i.north, u = i.south, l = i.east, c = i.west, h = Ze;
            h.longitude = l, h.latitude = s;
            var d = n.project(h, Ke);
            h.longitude = c, h.latitude = u;
            var m, p, f = n.project(h, Je), _ = .5 * Math.abs(d.x - f.x), v = .5 * Math.abs(d.y - f.y), g = e.frustum.right / e.frustum.top, y = v * g;
            if (_ > y ? (m = _, p = m / g) : (p = v, m = y), v = Math.max(2 * m, 2 * p), o(r) || (r = new t), r.x = .5 * (d.x - f.x) + f.x, r.y = .5 * (d.y - f.y) + f.y, a)h = n.unproject(r, h), h.height = v, r = n.project(h, r); else {
                var C = e.frustum;
                C.right = m, C.left = -m, C.top = p, C.bottom = -p;
                var E = t.clone(t.UNIT_Z, e.direction);
                t.negate(E, E), t.clone(t.UNIT_X, e.right), t.clone(t.UNIT_Y, e.up)
            }
            return r
        }

        function H(e, t, i, n) {
            i = r(i, l.WGS84);
            var o = e.getPickRay(t, Qe), a = d.rayEllipsoid(o, i);
            if (!a)return void 0;
            var s = a.start > 0 ? a.start : a.stop;
            return v.getPoint(o, s, n)
        }

        function W(e, t, i, n) {
            var r = e.getPickRay(t, $e), o = r.origin;
            o.z = 0;
            var a = i.unproject(o);
            return a.latitude < -m.PI_OVER_TWO || a.latitude > m.PI_OVER_TWO || a.longitude < -Math.PI || a.longitude > Math.PI ? void 0 : i.ellipsoid.cartographicToCartesian(a, n)
        }

        function q(e, i, n, r) {
            var o = e.getPickRay(i, et), a = -o.origin.x / o.direction.x;
            v.getPoint(o, a, r);
            var s = n.unproject(new t(r.y, r.z, 0));
            return s.latitude < -m.PI_OVER_TWO || s.latitude > m.PI_OVER_TWO || s.longitude < -Math.PI || s.longitude > Math.PI ? void 0 : n.ellipsoid.cartographicToCartesian(s, r)
        }

        function j(e, i, n) {
            var r = e._scene.canvas, o = r.clientWidth, a = r.clientHeight, s = Math.tan(.5 * e.frustum.fovy), u = e.frustum.aspectRatio * s, l = e.frustum.near, c = 2 / o * i.x - 1, h = 2 / a * (a - i.y) - 1, d = e.positionWC;
            t.clone(d, n.origin);
            var m = t.multiplyByScalar(e.directionWC, l, tt);
            t.add(d, m, m);
            var p = t.multiplyByScalar(e.rightWC, c * l * u, it), f = t.multiplyByScalar(e.upWC, h * l * s, nt), _ = t.add(m, p, n.direction);
            return t.add(_, f, _), t.subtract(_, d, _), t.normalize(_, _), n
        }

        function Y(e, i, n) {
            var r = e._scene.canvas, o = r.clientWidth, a = r.clientHeight, s = 2 / o * i.x - 1;
            s *= .5 * (e.frustum.right - e.frustum.left);
            var u = 2 / a * (a - i.y) - 1;
            u *= .5 * (e.frustum.top - e.frustum.bottom);
            var l = n.origin;
            return t.clone(e.position, l), t.multiplyByScalar(e.right, s, rt), t.add(rt, l, l), t.multiplyByScalar(e.up, u, rt), t.add(rt, l, l), t.clone(e.directionWC, n.direction), n
        }

        function X(e, i) {
            var n = e.position, r = n.x < -e._maxCoord.x || n.x > e._maxCoord.x, o = n.y < -e._maxCoord.y || n.y > e._maxCoord.y, a = r || o, s = e.frustum, l = s.top, c = s.bottom, h = s.right, d = s.left, p = e._max2Dfrustum, f = h > e._max2Dfrustum.right;
            if (a || f) {
                var _ = t.clone(n);
                _.x > e._maxCoord.x ? _.x = e._maxCoord.x : _.x < -e._maxCoord.x && (_.x = -e._maxCoord.x), _.y > e._maxCoord.y ? _.y = e._maxCoord.y : _.y < -e._maxCoord.y && (_.y = -e._maxCoord.y);
                var v = function (i) {
                    a && (e.position = t.lerp(n, _, i.time, e.position)), f && (e.frustum.top = m.lerp(l, p.top, i.time), e.frustum.bottom = m.lerp(c, p.bottom, i.time), e.frustum.right = m.lerp(h, p.right, i.time), e.frustum.left = m.lerp(d, p.left, i.time))
                };
                return {
                    easingFunction: u.EXPONENTIAL_OUT,
                    startObject: {time: 0},
                    stopObject: {time: 1},
                    duration: i,
                    update: v
                }
            }
            return void 0
        }

        function Z(e, i, n, r, o, a) {
            var s = t.clone(i);
            n.y > r ? s.y -= n.y - r : n.y < -r && (s.y += -r - n.y), n.z > o ? s.z -= n.z - o : n.z < -o && (s.z += -o - n.z);
            var l = function (n) {
                var r = t.lerp(i, s, n.time, new t);
                e.worldToCameraCoordinatesPoint(r, e.position)
            };
            return {
                easingFunction: u.EXPONENTIAL_OUT,
                startObject: {time: 0},
                stopObject: {time: 1},
                duration: a,
                update: l
            }
        }

        function K(e, i) {
            var n = e.position, r = e.direction, o = e.worldToCameraCoordinatesVector(t.UNIT_X, st), a = -t.dot(o, n) / t.dot(o, r), s = t.add(n, t.multiplyByScalar(r, a, ut), ut);
            e.cameraToWorldCoordinatesPoint(s, s), n = e.cameraToWorldCoordinatesPoint(e.position, lt);
            var u = Math.tan(.5 * e.frustum.fovy), l = e.frustum.aspectRatio * u, c = t.magnitude(t.subtract(n, s, ct)), h = l * c, d = u * c, m = e._maxCoord.x, p = e._maxCoord.y, f = Math.max(h - m, m), _ = Math.max(d - p, p);
            if (n.z < -f || n.z > f || n.y < -_ || n.y > _) {
                var v = s.y < -f || s.y > f, g = s.z < -_ || s.z > _;
                if (v || g)return Z(e, n, s, f, _, i)
            }
            return void 0
        }

        function J(e, t) {
            var i = e.frustum, n = Math.tan(.5 * i.fovy), r = i.aspectRatio * n;
            return Math.max(t / r, t / n)
        }

        function Q(e, t) {
            var i, n, r = e.frustum, o = r.right / r.top, a = t * o;
            return t > a ? (i = t, n = i / o) : (n = t, i = a), 1.5 * Math.max(i, n)
        }

        function $(e, t, i) {
            o(i) || (i = E.clone(_t));
            var n = i.range;
            if (!o(n) || 0 === n) {
                var r = t.radius;
                0 === r ? i.range = vt : i.range = e._mode === T.SCENE2D ? Q(e, r) : J(e, r)
            }
            return i
        }

        var ee = function (e) {
            this._scene = e, this._transform = f.clone(f.IDENTITY), this._invTransform = f.clone(f.IDENTITY), this._actualTransform = f.clone(f.IDENTITY), this._actualInvTransform = f.clone(f.IDENTITY), this._transformChanged = !1, this.position = new t, this._position = new t, this._positionWC = new t, this._positionCartographic = new n, this.direction = new t, this._direction = new t, this._directionWC = new t, this.up = new t, this._up = new t, this._upWC = new t, this.right = new t, this._right = new t, this._rightWC = new t, this.frustum = new S, this.frustum.aspectRatio = e.drawingBufferWidth / e.drawingBufferHeight, this.frustum.fov = m.toRadians(60), this.defaultMoveAmount = 1e5, this.defaultLookAmount = Math.PI / 60, this.defaultRotateAmount = Math.PI / 3600, this.defaultZoomAmount = 1e5, this.constrainedAxis = void 0, this.maximumTranslateFactor = 1.5, this.maximumZoomFactor = 2.5, this._moveStart = new h, this._moveEnd = new h, this._viewMatrix = new f, this._invViewMatrix = new f, b(this), this._mode = T.SCENE3D, this._modeChanged = !0;
            var i = e.mapProjection;
            this._projection = i, this._maxCoord = i.project(new n(Math.PI, m.PI_OVER_TWO)), this._max2Dfrustum = void 0, this.viewRectangle(ee.DEFAULT_VIEW_RECTANGLE, e.mapProjection.ellipsoid);
            var r = t.magnitude(this.position);
            r += r * ee.DEFAULT_VIEW_FACTOR, t.normalize(this.position, this.position), t.multiplyByScalar(this.position, r, this.position)
        };
        ee.TRANSFORM_2D = new f(0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1), ee.TRANSFORM_2D_INVERSE = f.inverseTransformation(ee.TRANSFORM_2D, new f), ee.DEFAULT_VIEW_RECTANGLE = g.fromDegrees(-95, -20, -70, 90), ee.DEFAULT_VIEW_FACTOR = .5;
        var te = new n, ie = new t, ne = new t, re = new i, oe = new i, ae = new i, se = new i, ue = new i, le = new t, ce = new f, he = new f;
        a(ee.prototype, {
            transform: {
                get: function () {
                    return this._transform
                }
            }, inverseTransform: {
                get: function () {
                    return A(this), this._invTransform
                }
            }, viewMatrix: {
                get: function () {
                    return A(this), this._viewMatrix
                }
            }, inverseViewMatrix: {
                get: function () {
                    return A(this), this._invViewMatrix
                }
            }, positionCartographic: {
                get: function () {
                    return A(this), this._positionCartographic
                }
            }, positionWC: {
                get: function () {
                    return A(this), this._positionWC
                }
            }, directionWC: {
                get: function () {
                    return A(this), this._directionWC
                }
            }, upWC: {
                get: function () {
                    return A(this), this._upWC
                }
            }, rightWC: {
                get: function () {
                    return A(this), this._rightWC
                }
            }, heading: {
                get: function () {
                    if (this._mode !== T.MORPHING) {
                        var e = (this.positionWC, this._projection.ellipsoid), t = f.clone(this._transform, ce), i = y.eastNorthUpToFixedFrame(this.positionWC, e, he);
                        this._setTransform(i);
                        var n = P(this.direction, this.up);
                        return this._setTransform(t), n
                    }
                    return void 0
                }
            }, pitch: {
                get: function () {
                    if (this._mode !== T.MORPHING) {
                        var e = (this.positionWC, this._projection.ellipsoid), t = f.clone(this._transform, ce), i = y.eastNorthUpToFixedFrame(this.positionWC, e, he);
                        this._setTransform(i);
                        var n = I(this.direction);
                        return this._setTransform(t), n
                    }
                    return void 0
                }
            }, roll: {
                get: function () {
                    if (this._mode !== T.MORPHING) {
                        var e = (this.positionWC, this._projection.ellipsoid), t = f.clone(this._transform, ce), i = y.eastNorthUpToFixedFrame(this.positionWC, e, he);
                        this._setTransform(i);
                        var n = D(this.direction, this.up, this.right);
                        return this._setTransform(t), n
                    }
                    return void 0
                }
            }, moveStart: {
                get: function () {
                    return this._moveStart
                }
            }, moveEnd: {
                get: function () {
                    return this._moveEnd
                }
            }
        }), ee.prototype.update = function (e) {
            var t = !1;
            if (e !== this._mode && (this._mode = e, this._modeChanged = e !== T.MORPHING, t = this._mode === T.SCENE2D), t) {
                var i = this._max2Dfrustum = this.frustum.clone(), n = 2, r = i.top / i.right;
                i.right = this._maxCoord.x * n, i.left = -i.right, i.top = r * i.right, i.bottom = -i.top
            }
        };
        var de = new t, me = new t, pe = new t;
        ee.prototype._setTransform = function (e) {
            var i = t.clone(this.positionWC, de), n = t.clone(this.upWC, me), r = t.clone(this.directionWC, pe);
            f.clone(e, this._transform), this._transformChanged = !0, A(this);
            var o = this._actualInvTransform;
            f.multiplyByPoint(o, i, this.position), f.multiplyByPointAsVector(o, r, this.direction), f.multiplyByPointAsVector(o, n, this.up), t.cross(this.direction, this.up, this.right), A(this)
        };
        var fe = new t, _e = new f, ve = new f, ge = new _, ye = new p;
        new n;
        ee.prototype.setView = function (e) {
            if (this._mode !== T.MORPHING) {
                e = r(e, r.EMPTY_OBJECT);
                var t = r(e.heading, this.heading), i = r(e.pitch, this.pitch), n = r(e.roll, this.roll), o = e.position, a = e.positionCartographic, s = this._projection, u = s.ellipsoid;
                this._mode === T.SCENE3D ? M(this, o, a, t, i, n, u) : this._mode === T.SCENE2D ? R(this, o, a, t, i, n, u, s) : O(this, o, a, t, i, n, u, s)
            }
        }, ee.prototype.worldToCameraCoordinates = function (e, t) {
            return o(t) || (t = new i), A(this), f.multiplyByVector(this._actualInvTransform, e, t)
        }, ee.prototype.worldToCameraCoordinatesPoint = function (e, i) {
            return o(i) || (i = new t), A(this), f.multiplyByPoint(this._actualInvTransform, e, i)
        }, ee.prototype.worldToCameraCoordinatesVector = function (e, i) {
            return o(i) || (i = new t), A(this), f.multiplyByPointAsVector(this._actualInvTransform, e, i)
        }, ee.prototype.cameraToWorldCoordinates = function (e, t) {
            return o(t) || (t = new i), A(this), f.multiplyByVector(this._actualTransform, e, t)
        }, ee.prototype.cameraToWorldCoordinatesPoint = function (e, i) {
            return o(i) || (i = new t), A(this), f.multiplyByPoint(this._actualTransform, e, i)
        }, ee.prototype.cameraToWorldCoordinatesVector = function (e, i) {
            return o(i) || (i = new t), A(this), f.multiplyByPointAsVector(this._actualTransform, e, i)
        };
        var Ce = new t;
        ee.prototype.move = function (e, i) {
            var n = this.position;
            t.multiplyByScalar(e, i, Ce), t.add(n, Ce, n), this._mode === T.SCENE2D && N(this, n)
        }, ee.prototype.moveForward = function (e) {
            e = r(e, this.defaultMoveAmount), this.move(this.direction, e)
        }, ee.prototype.moveBackward = function (e) {
            e = r(e, this.defaultMoveAmount), this.move(this.direction, -e)
        }, ee.prototype.moveUp = function (e) {
            e = r(e, this.defaultMoveAmount), this.move(this.up, e)
        }, ee.prototype.moveDown = function (e) {
            e = r(e, this.defaultMoveAmount), this.move(this.up, -e)
        }, ee.prototype.moveRight = function (e) {
            e = r(e, this.defaultMoveAmount), this.move(this.right, e)
        }, ee.prototype.moveLeft = function (e) {
            e = r(e, this.defaultMoveAmount), this.move(this.right, -e)
        }, ee.prototype.lookLeft = function (e) {
            e = r(e, this.defaultLookAmount), this.look(this.up, -e)
        }, ee.prototype.lookRight = function (e) {
            e = r(e, this.defaultLookAmount), this.look(this.up, e)
        }, ee.prototype.lookUp = function (e) {
            e = r(e, this.defaultLookAmount), this.look(this.right, -e)
        }, ee.prototype.lookDown = function (e) {
            e = r(e, this.defaultLookAmount), this.look(this.right, e)
        };
        var Ee = new _, Se = new p;
        ee.prototype.look = function (e, t) {
            var i = r(t, this.defaultLookAmount), n = _.fromAxisAngle(e, -i, Ee), o = p.fromQuaternion(n, Se), a = this.direction, s = this.up, u = this.right;
            p.multiplyByVector(o, a, a), p.multiplyByVector(o, s, s), p.multiplyByVector(o, u, u)
        }, ee.prototype.twistLeft = function (e) {
            e = r(e, this.defaultLookAmount), this.look(this.direction, e)
        }, ee.prototype.twistRight = function (e) {
            e = r(e, this.defaultLookAmount), this.look(this.direction, -e)
        };
        var Te = new _, be = new p;
        ee.prototype.rotate = function (e, i) {
            var n = r(i, this.defaultRotateAmount), o = _.fromAxisAngle(e, -n, Te), a = p.fromQuaternion(o, be);
            p.multiplyByVector(a, this.position, this.position), p.multiplyByVector(a, this.direction, this.direction), p.multiplyByVector(a, this.up, this.up), t.cross(this.direction, this.up, this.right), t.cross(this.right, this.direction, this.up)
        }, ee.prototype.rotateDown = function (e) {
            e = r(e, this.defaultRotateAmount), L(this, e)
        }, ee.prototype.rotateUp = function (e) {
            e = r(e, this.defaultRotateAmount), L(this, -e)
        };
        var we = new t, xe = new t, Ae = new t, Pe = new t;
        ee.prototype.rotateRight = function (e) {
            e = r(e, this.defaultRotateAmount), F(this, -e)
        }, ee.prototype.rotateLeft = function (e) {
            e = r(e, this.defaultRotateAmount), F(this, e)
        }, ee.prototype.zoomIn = function (e) {
            e = r(e, this.defaultZoomAmount), this._mode === T.SCENE2D ? B(this, e) : z(this, e)
        }, ee.prototype.zoomOut = function (e) {
            e = r(e, this.defaultZoomAmount), this._mode === T.SCENE2D ? B(this, -e) : z(this, -e)
        }, ee.prototype.getMagnitude = function () {
            return this._mode === T.SCENE3D ? t.magnitude(this.position) : this._mode === T.COLUMBUS_VIEW ? Math.abs(this.position.z) : this._mode === T.SCENE2D ? Math.max(this.frustum.right - this.frustum.left, this.frustum.top - this.frustum.bottom) : void 0
        };
        var Ie = new f;
        new f;
        ee.prototype.lookAt = function (e, t) {
            var i = y.eastNorthUpToFixedFrame(e, l.WGS84, Ie);
            this.lookAtTransform(i, t)
        };
        var De = new t, Me = new _, Oe = new _, Re = new p;
        ee.prototype.lookAtTransform = function (i, n) {
            if (this._setTransform(i), o(n)) {
                var r;
                if (r = o(n.heading) ? V(n.heading, n.pitch, n.range) : n, this._mode === T.SCENE2D) {
                    e.clone(e.ZERO, this.position), t.negate(r, this.up), this.up.z = 0, t.magnitudeSquared(this.up) < m.EPSILON10 && t.clone(t.UNIT_Y, this.up), t.normalize(this.up, this.up), this._setTransform(f.IDENTITY), t.negate(t.UNIT_Z, this.direction), t.cross(this.direction, this.up, this.right), t.normalize(this.right, this.right);
                    var a = this.frustum, s = a.top / a.right;
                    return a.right = .5 * t.magnitude(r), a.left = -a.right, a.top = s * a.right, a.bottom = -a.top, void this._setTransform(i)
                }
                t.clone(r, this.position), t.negate(this.position, this.direction), t.normalize(this.direction, this.direction), t.cross(this.direction, t.UNIT_Z, this.right), t.magnitudeSquared(this.right) < m.EPSILON10 && t.clone(t.UNIT_X, this.right), t.normalize(this.right, this.right), t.cross(this.right, this.direction, this.up), t.normalize(this.up, this.up)
            }
        };
        var Ne, Le = new n, Fe = new n, Be = new t, ze = new t, Ve = new t, Ue = new t, ke = new t, Ge = new t, He = new t, We = new t, qe = {
            direction: new t,
            right: new t,
            up: new t
        }, je = new n, Ye = new t, Xe = new t, Ze = new n, Ke = new t, Je = new t;
        ee.prototype.getRectangleCameraCoordinates = function (e, t) {
            return this._mode === T.SCENE3D ? U(this, e, this._projection.ellipsoid, t, !0) : this._mode === T.COLUMBUS_VIEW ? k(this, e, this._projection, t, !0) : this._mode === T.SCENE2D ? G(this, e, this._projection, t, !0) : void 0
        }, ee.prototype.viewRectangle = function (e, t) {
            t = r(t, l.WGS84), this._mode === T.SCENE3D ? U(this, e, t, this.position) : this._mode === T.COLUMBUS_VIEW ? k(this, e, this._projection, this.position) : this._mode === T.SCENE2D && G(this, e, this._projection, this.position)
        };
        var Qe = new v, $e = new v, et = new v;
        ee.prototype.pickEllipsoid = function (e, i, n) {
            if (o(n) || (n = new t), i = r(i, l.WGS84), this._mode === T.SCENE3D)n = H(this, e, i, n); else if (this._mode === T.SCENE2D)n = W(this, e, this._projection, n); else {
                if (this._mode !== T.COLUMBUS_VIEW)return void 0;
                n = q(this, e, this._projection, n)
            }
            return n
        };
        var tt = new t, it = new t, nt = new t, rt = new t;
        ee.prototype.getPickRay = function (e, t) {
            o(t) || (t = new v);
            var i = this.frustum;
            return o(i.aspectRatio) && o(i.fov) && o(i.near) ? j(this, e, t) : Y(this, e, t)
        };
        var ot = new t, at = new t;
        ee.prototype.distanceToBoundingSphere = function (e) {
            var i = t.subtract(this.positionWC, e.center, ot), n = t.multiplyByScalar(this.directionWC, t.dot(i, this.directionWC), at);
            return Math.max(this.frustum.near, t.magnitude(n) - e.radius)
        };
        var st = new t, ut = new t, lt = new t, ct = new t;
        ee.prototype.createCorrectPositionTween = function (e) {
            return this._mode === T.SCENE2D ? X(this, e) : this._mode === T.COLUMBUS_VIEW ? K(this, e) : void 0
        };
        var ht = new t, dt = (new _, new p, new t, new t, new f, {
            destination: void 0,
            heading: void 0,
            pitch: void 0,
            roll: void 0,
            duration: void 0,
            complete: void 0,
            cancel: void 0,
            endTransform: void 0,
            maximumHeight: void 0,
            easingFunction: void 0
        }), mt = new t, pt = new t, ft = new t;
        ee.prototype.flyTo = function (e) {
            e = r(e, r.EMPTY_OBJECT);
            var i = e.destination, n = this._scene, a = o(i.west);
            a && (n.mode !== T.SCENE3D && i.west > i.east && (i = g.MAX_VALUE), i = n.camera.getRectangleCameraCoordinates(i, ht));
            var s, u, l, c = r(e.orientation, r.EMPTY_OBJECT);
            if (o(c.heading))s = c.heading, u = c.pitch, l = c.roll; else if (o(c.direction)) {
                var h = t.clone(c.direction, mt), d = t.clone(c.up, pt);
                if (n.mode === T.SCENE3D) {
                    var m = this._projection.ellipsoid, p = y.eastNorthUpToFixedFrame(i, m, ce), _ = f.inverseTransformation(p, he);
                    f.multiplyByPointAsVector(_, h, h), f.multiplyByPointAsVector(_, d, d)
                }
                var v = t.cross(h, d, ft);
                s = P(h, d), u = I(h), l = D(h, d, v)
            }
            dt.destination = i, dt.heading = s, dt.pitch = u, dt.roll = l, dt.duration = e.duration, dt.complete = e.complete, dt.cancel = e.cancel, dt.endTransform = e.endTransform, dt.convert = a ? !1 : e.convert, dt.maximumHeight = e.maximumHeight, dt.easingFunction = e.easingFunction, n.tweens.add(C.createTween(n, dt))
        };
        var _t = new E(0, -m.PI_OVER_FOUR, 0), vt = 100;
        ee.prototype.viewBoundingSphere = function (e, t) {
            if (this._mode === T.MORPHING)throw new s("viewBoundingSphere is not supported while morphing.");
            t = $(this, e, t), this.lookAt(e.center, t)
        };
        var gt = new f, yt = new t, Ct = new t, Et = new t, St = new t, Tt = new i, bt = new _, wt = new p;
        return ee.prototype.flyToBoundingSphere = function (e, i) {
            i = r(i, r.EMPTY_OBJECT);
            var n = this._mode === T.SCENE2D || this._mode === T.COLUMBUS_VIEW;
            this._setTransform(f.IDENTITY);
            var o, a = $(this, e, i.offset);
            o = n ? t.multiplyByScalar(t.UNIT_Z, a.range, yt) : V(a.heading, a.pitch, a.range);
            var s = y.eastNorthUpToFixedFrame(e.center, l.WGS84, gt);
            f.multiplyByPoint(s, o, o);
            var u, c;
            if (!n) {
                if (u = t.subtract(e.center, o, Ct), t.normalize(u, u), c = f.multiplyByPointAsVector(s, t.UNIT_Z, Et), 1 - Math.abs(t.dot(u, c)) < m.EPSILON6) {
                    var h = _.fromAxisAngle(u, a.heading, bt), d = p.fromQuaternion(h, wt);
                    t.fromCartesian4(f.getColumn(s, 1, Tt), c), p.multiplyByVector(d, c, c)
                }
                var v = t.cross(u, c, St);
                t.cross(v, u, c), t.normalize(c, c)
            }
            this.flyTo({
                destination: o,
                orientation: {direction: u, up: c},
                duration: i.duration,
                complete: i.complete,
                cancel: i.cancel,
                endTransform: i.endTransform,
                maximumHeight: i.maximumHeight,
                easingFunction: i.easingFunction
            })
        }, ee.clone = function (e, i) {
            return o(i) || (i = new ee(e._scene)), t.clone(e.position, i.position), t.clone(e.direction, i.direction), t.clone(e.up, i.up), t.clone(e.right, i.right), f.clone(e._transform, i.transform), i
        }, ee
    }),define("Cesium/Scene/CreditDisplay", ["../Core/Credit", "../Core/defaultValue", "../Core/defined", "../Core/destroyObject", "../Core/DeveloperError"], function (e, t, i, n, r) {
        "use strict";
        function o(e, t, n) {
            if (!i(e.element)) {
                var r = e.text, o = e.link, a = document.createElement("span");
                if (e.hasLink()) {
                    var s = document.createElement("a");
                    s.textContent = r, s.href = o, s.target = "_blank", a.appendChild(s)
                } else a.textContent = r;
                a.className = "cesium-credit-text", e.element = a
            }
            if (t.hasChildNodes()) {
                var u = document.createElement("span");
                u.textContent = n, u.className = "cesium-credit-delimiter", t.appendChild(u)
            }
            t.appendChild(e.element)
        }

        function a(e, t) {
            if (!i(e.element)) {
                var n = e.text, r = e.link, o = document.createElement("span"), a = document.createElement("img");
                if (a.src = e.imageUrl, a.style["vertical-align"] = "bottom", i(n) && (a.alt = n, a.title = n), e.hasLink()) {
                    var s = document.createElement("a");
                    s.appendChild(a), s.href = r, s.target = "_blank", o.appendChild(s)
                } else o.appendChild(a);
                o.className = "cesium-credit-image", e.element = o
            }
            t.appendChild(e.element)
        }

        function s(t, i) {
            for (var n = t.length, r = 0; n > r; r++) {
                var o = t[r];
                if (e.equals(o, i))return !0
            }
            return !1
        }

        function u(e) {
            var t = e.element;
            if (i(t)) {
                var n = t.parentNode;
                if (!e.hasImage()) {
                    var r = t.previousSibling;
                    null === r && (r = t.nextSibling), null !== r && n.removeChild(r)
                }
                n.removeChild(t)
            }
        }

        function l(e, t) {
            var n, r, a, s = e._displayedCredits.textCredits;
            for (n = 0; n < t.length; n++)a = t[n], i(a) && (r = s.indexOf(a), -1 === r ? o(a, e._textContainer, e._delimiter) : s.splice(r, 1));
            for (n = 0; n < s.length; n++)a = s[n], i(a) && u(a)
        }

        function c(e, t) {
            var n, r, o, s = e._displayedCredits.imageCredits;
            for (n = 0; n < t.length; n++)o = t[n], i(o) && (r = s.indexOf(o), -1 === r ? a(o, e._imageContainer) : s.splice(r, 1));
            for (n = 0; n < s.length; n++)o = s[n], i(o) && u(o)
        }

        var h = function (e, i) {
            var n = document.createElement("span");
            n.className = "cesium-credit-imageContainer";
            var r = document.createElement("span");
            r.className = "cesium-credit-textContainer", e.appendChild(n), e.appendChild(r), this._delimiter = t(i, " • "), this._container = e, this._textContainer = r, this._imageContainer = n, this._defaultImageCredits = [], this._defaultTextCredits = [], this._displayedCredits = {
                imageCredits: [],
                textCredits: []
            }, this._currentFrameCredits = {imageCredits: [], textCredits: []}
        };
        return h.prototype.addCredit = function (e) {
            if (e.hasImage()) {
                var t = this._currentFrameCredits.imageCredits;
                s(this._defaultImageCredits, e) || (t[e.id] = e)
            } else {
                var i = this._currentFrameCredits.textCredits;
                s(this._defaultTextCredits, e) || (i[e.id] = e)
            }
        }, h.prototype.addDefaultCredit = function (e) {
            if (e.hasImage()) {
                var t = this._defaultImageCredits;
                s(t, e) || t.push(e)
            } else {
                var i = this._defaultTextCredits;
                s(i, e) || i.push(e)
            }
        }, h.prototype.removeDefaultCredit = function (e) {
            var t;
            e.hasImage() ? (t = this._defaultImageCredits.indexOf(e), -1 !== t && this._defaultImageCredits.splice(t, 1)) : (t = this._defaultTextCredits.indexOf(e), -1 !== t && this._defaultTextCredits.splice(t, 1))
        }, h.prototype.beginFrame = function () {
            this._currentFrameCredits.imageCredits.length = 0, this._currentFrameCredits.textCredits.length = 0
        }, h.prototype.endFrame = function () {
            var e = this._defaultTextCredits.concat(this._currentFrameCredits.textCredits), t = this._defaultImageCredits.concat(this._currentFrameCredits.imageCredits);
            l(this, e), c(this, t), this._displayedCredits.textCredits = e, this._displayedCredits.imageCredits = t
        }, h.prototype.destroy = function () {
            return this._container.removeChild(this._textContainer), this._container.removeChild(this._imageContainer), n(this)
        }, h.prototype.isDestroyed = function () {
            return !1
        }, h
    }),define("Cesium/Shaders/DepthPlaneFS", [], function () {
        "use strict";
        return "varying vec4 positionEC;\n\nvoid main()\n{\n    // TODO: make arbitrary ellipsoid\n    czm_ellipsoid ellipsoid = czm_getWgs84EllipsoidEC();\n    \n    vec3 direction = normalize(positionEC.xyz);\n    czm_ray ray = czm_ray(vec3(0.0), direction);\n    \n    czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid);\n    if (!czm_isEmpty(intersection))\n    {\n        gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n    }\n    else\n    {\n        discard;\n    }\n}"
    }),define("Cesium/Shaders/DepthPlaneVS", [], function () {
        "use strict";
        return "attribute vec4 position;\n\nvarying vec4 positionEC;\n\nvoid main()\n{\n    positionEC = czm_modelView * position;\n    gl_Position = czm_projection * positionEC;\n}"
    }),define("Cesium/Scene/DepthPlane", ["../Core/BoundingSphere", "../Core/Cartesian3", "../Core/ComponentDatatype", "../Core/defined", "../Core/FeatureDetection", "../Core/Geometry", "../Core/GeometryAttribute", "../Core/PrimitiveType", "../Renderer/BufferUsage", "../Renderer/DrawCommand", "../Renderer/RenderState", "../Renderer/ShaderProgram", "../Renderer/VertexArray", "../Shaders/DepthPlaneFS", "../Shaders/DepthPlaneVS", "./DepthFunction", "./Pass", "./SceneMode"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v) {
        "use strict";
        function g(e, i) {
            var n = e.radii, r = i.camera.positionWC, o = t.multiplyComponents(e.oneOverRadii, r, E), a = t.magnitude(o), s = t.normalize(o, S), u = t.normalize(t.cross(t.UNIT_Z, o, T), T), l = t.normalize(t.cross(s, u, b), b), c = Math.sqrt(t.magnitudeSquared(o) - 1), h = t.multiplyByScalar(s, 1 / a, E), d = c / a, m = t.multiplyByScalar(u, d, S), p = t.multiplyByScalar(l, d, T), f = t.add(h, p, b);
            t.subtract(f, m, f), t.multiplyComponents(n, f, f), t.pack(f, C, 0);
            var _ = t.subtract(h, p, b);
            t.subtract(_, m, _), t.multiplyComponents(n, _, _), t.pack(_, C, 3);
            var v = t.add(h, p, b);
            t.add(v, m, v), t.multiplyComponents(n, v, v), t.pack(v, C, 6);
            var g = t.subtract(h, p, b);
            return t.add(g, m, g), t.multiplyComponents(n, g, g), t.pack(g, C, 9), C
        }

        var y = function () {
            this._rs = void 0, this._sp = void 0, this._va = void 0, this._command = void 0, this._mode = void 0
        }, C = r.supportsTypedArrays() ? new Float32Array(12) : [], E = new t, S = new t, T = new t, b = new t;
        return y.prototype.update = function (r, y) {
            if (this._mode = y.mode, y.mode === v.SCENE3D) {
                var C = y.mapProjection.ellipsoid;
                n(this._command) || (this._rs = c.fromCache({
                    cull: {enabled: !0},
                    depthTest: {enabled: !0, func: f.ALWAYS},
                    colorMask: {red: !1, green: !1, blue: !1, alpha: !1}
                }), this._sp = h.fromCache({
                    context: r,
                    vertexShaderSource: p,
                    fragmentShaderSource: m,
                    attributeLocations: {position: 0}
                }), this._command = new l({
                    renderState: this._rs,
                    shaderProgram: this._sp,
                    boundingVolume: new e(t.ZERO, C.maximumRadius),
                    pass: _.OPAQUE,
                    owner: this
                }));
                var E = g(C, y);
                if (n(this._va))this._va.getAttribute(0).vertexBuffer.copyFromArrayView(E); else {
                    var S = new o({
                        attributes: {
                            position: new a({
                                componentDatatype: i.FLOAT,
                                componentsPerAttribute: 3,
                                values: E
                            })
                        }, indices: [0, 1, 2, 2, 1, 3], primitiveType: s.TRIANGLES
                    });
                    this._va = d.fromGeometry({
                        context: r,
                        geometry: S,
                        attributeLocations: {position: 0},
                        bufferUsage: u.DYNAMIC_DRAW
                    }), this._command.vertexArray = this._va
                }
            }
        }, y.prototype.execute = function (e, t) {
            this._mode === v.SCENE3D && this._command.execute(e, t)
        }, y.prototype.isDestroyed = function () {
            return !1
        }, y.prototype.destroy = function () {
            this._sp = this._sp && this._sp.destroy(), this._va = this._va && this._va.destroy()
        }, y
    }),define("Cesium/Scene/FrameState", ["./SceneMode"], function (e) {
        "use strict";
        var t = function (t, i) {
            this.mode = e.SCENE3D, this.morphTime = e.getMorphTime(e.SCENE3D), this.frameNumber = 0, this.time = void 0, this.jobScheduler = i, this.mapProjection = void 0, this.camera = void 0, this.cullingVolume = void 0, this.occluder = void 0, this.passes = {
                render: !1,
                pick: !1
            }, this.creditDisplay = t, this.afterRender = [], this.scene3DOnly = !1
        };
        return t
    }),define("Cesium/Scene/FrustumCommands", ["../Core/defaultValue", "./Pass"], function (e, t) {
        "use strict";
        var i = function (i, n) {
            this.near = e(i, 0), this.far = e(n, 0);
            for (var r = t.NUMBER_OF_PASSES, o = new Array(r), a = new Array(r), s = 0; r > s; ++s)o[s] = [], a[s] = 0;
            this.commands = o, this.indices = a
        };
        return i
    }),define("Cesium/Shaders/PostProcessFilters/FXAA", [], function () {
        "use strict";
        return "/**\n * @license\n * Copyright (c) 2011 NVIDIA Corporation. All rights reserved.\n *\n * TO  THE MAXIMUM  EXTENT PERMITTED  BY APPLICABLE  LAW, THIS SOFTWARE  IS PROVIDED\n * *AS IS*  AND NVIDIA AND  ITS SUPPLIERS DISCLAIM  ALL WARRANTIES,  EITHER  EXPRESS\n * OR IMPLIED, INCLUDING, BUT NOT LIMITED  TO, NONINFRINGEMENT,IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL  NVIDIA \n * OR ITS SUPPLIERS BE  LIABLE  FOR  ANY  DIRECT, SPECIAL,  INCIDENTAL,  INDIRECT,  OR  \n * CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION,  DAMAGES FOR LOSS \n * OF BUSINESS PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY \n * OTHER PECUNIARY LOSS) ARISING OUT OF THE  USE OF OR INABILITY  TO USE THIS SOFTWARE, \n * EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\n */\n\n/*\nFXAA_PRESET - Choose compile-in knob preset 0-5.\n------------------------------------------------------------------------------\nFXAA_EDGE_THRESHOLD - The minimum amount of local contrast required \n                      to apply algorithm.\n                      1.0/3.0  - too little\n                      1.0/4.0  - good start\n                      1.0/8.0  - applies to more edges\n                      1.0/16.0 - overkill\n------------------------------------------------------------------------------\nFXAA_EDGE_THRESHOLD_MIN - Trims the algorithm from processing darks.\n                          Perf optimization.\n                          1.0/32.0 - visible limit (smaller isn't visible)\n                          1.0/16.0 - good compromise\n                          1.0/12.0 - upper limit (seeing artifacts)\n------------------------------------------------------------------------------\nFXAA_SEARCH_STEPS - Maximum number of search steps for end of span.\n------------------------------------------------------------------------------\nFXAA_SEARCH_THRESHOLD - Controls when to stop searching.\n                        1.0/4.0 - seems to be the best quality wise\n------------------------------------------------------------------------------\nFXAA_SUBPIX_TRIM - Controls sub-pixel aliasing removal.\n                   1.0/2.0 - low removal\n                   1.0/3.0 - medium removal\n                   1.0/4.0 - default removal\n                   1.0/8.0 - high removal\n                   0.0 - complete removal\n------------------------------------------------------------------------------\nFXAA_SUBPIX_CAP - Insures fine detail is not completely removed.\n                  This is important for the transition of sub-pixel detail,\n                  like fences and wires.\n                  3.0/4.0 - default (medium amount of filtering)\n                  7.0/8.0 - high amount of filtering\n                  1.0 - no capping of sub-pixel aliasing removal\n*/\n\n#ifndef FXAA_PRESET\n    #define FXAA_PRESET 3\n#endif\n#if (FXAA_PRESET == 3)\n    #define FXAA_EDGE_THRESHOLD      (1.0/8.0)\n    #define FXAA_EDGE_THRESHOLD_MIN  (1.0/24.0)\n    #define FXAA_SEARCH_STEPS        16\n    #define FXAA_SEARCH_THRESHOLD    (1.0/4.0)\n    #define FXAA_SUBPIX_CAP          (3.0/4.0)\n    #define FXAA_SUBPIX_TRIM         (1.0/4.0)\n#endif\n#if (FXAA_PRESET == 4)\n    #define FXAA_EDGE_THRESHOLD      (1.0/8.0)\n    #define FXAA_EDGE_THRESHOLD_MIN  (1.0/24.0)\n    #define FXAA_SEARCH_STEPS        24\n    #define FXAA_SEARCH_THRESHOLD    (1.0/4.0)\n    #define FXAA_SUBPIX_CAP          (3.0/4.0)\n    #define FXAA_SUBPIX_TRIM         (1.0/4.0)\n#endif\n#if (FXAA_PRESET == 5)\n    #define FXAA_EDGE_THRESHOLD      (1.0/8.0)\n    #define FXAA_EDGE_THRESHOLD_MIN  (1.0/24.0)\n    #define FXAA_SEARCH_STEPS        32\n    #define FXAA_SEARCH_THRESHOLD    (1.0/4.0)\n    #define FXAA_SUBPIX_CAP          (3.0/4.0)\n    #define FXAA_SUBPIX_TRIM         (1.0/4.0)\n#endif\n\n#define FXAA_SUBPIX_TRIM_SCALE (1.0/(1.0 - FXAA_SUBPIX_TRIM))\n\n// Return the luma, the estimation of luminance from rgb inputs.\n// This approximates luma using one FMA instruction,\n// skipping normalization and tossing out blue.\n// FxaaLuma() will range 0.0 to 2.963210702.\nfloat FxaaLuma(vec3 rgb) {\n    return rgb.y * (0.587/0.299) + rgb.x;\n}\n\nvec3 FxaaLerp3(vec3 a, vec3 b, float amountOfA) {\n    return (vec3(-amountOfA) * b) + ((a * vec3(amountOfA)) + b);\n}\n\nvec4 FxaaTexOff(sampler2D tex, vec2 pos, ivec2 off, vec2 rcpFrame) {\n    float x = pos.x + float(off.x) * rcpFrame.x;\n    float y = pos.y + float(off.y) * rcpFrame.y;\n    return texture2D(tex, vec2(x, y));\n}\n\n// pos is the output of FxaaVertexShader interpolated across screen.\n// xy -> actual texture position {0.0 to 1.0}\n// rcpFrame should be a uniform equal to  {1.0/frameWidth, 1.0/frameHeight}\nvec3 FxaaPixelShader(vec2 pos, sampler2D tex, vec2 rcpFrame)\n{\n    vec3 rgbN = FxaaTexOff(tex, pos.xy, ivec2( 0,-1), rcpFrame).xyz;\n    vec3 rgbW = FxaaTexOff(tex, pos.xy, ivec2(-1, 0), rcpFrame).xyz;\n    vec3 rgbM = FxaaTexOff(tex, pos.xy, ivec2( 0, 0), rcpFrame).xyz;\n    vec3 rgbE = FxaaTexOff(tex, pos.xy, ivec2( 1, 0), rcpFrame).xyz;\n    vec3 rgbS = FxaaTexOff(tex, pos.xy, ivec2( 0, 1), rcpFrame).xyz;\n    \n    float lumaN = FxaaLuma(rgbN);\n    float lumaW = FxaaLuma(rgbW);\n    float lumaM = FxaaLuma(rgbM);\n    float lumaE = FxaaLuma(rgbE);\n    float lumaS = FxaaLuma(rgbS);\n    float rangeMin = min(lumaM, min(min(lumaN, lumaW), min(lumaS, lumaE)));\n    float rangeMax = max(lumaM, max(max(lumaN, lumaW), max(lumaS, lumaE)));\n    \n    float range = rangeMax - rangeMin;\n    if(range < max(FXAA_EDGE_THRESHOLD_MIN, rangeMax * FXAA_EDGE_THRESHOLD))\n    {\n        return rgbM;\n    }\n    \n    vec3 rgbL = rgbN + rgbW + rgbM + rgbE + rgbS;\n    \n    float lumaL = (lumaN + lumaW + lumaE + lumaS) * 0.25;\n    float rangeL = abs(lumaL - lumaM);\n    float blendL = max(0.0, (rangeL / range) - FXAA_SUBPIX_TRIM) * FXAA_SUBPIX_TRIM_SCALE; \n    blendL = min(FXAA_SUBPIX_CAP, blendL);\n    \n    vec3 rgbNW = FxaaTexOff(tex, pos.xy, ivec2(-1,-1), rcpFrame).xyz;\n    vec3 rgbNE = FxaaTexOff(tex, pos.xy, ivec2( 1,-1), rcpFrame).xyz;\n    vec3 rgbSW = FxaaTexOff(tex, pos.xy, ivec2(-1, 1), rcpFrame).xyz;\n    vec3 rgbSE = FxaaTexOff(tex, pos.xy, ivec2( 1, 1), rcpFrame).xyz;\n    rgbL += (rgbNW + rgbNE + rgbSW + rgbSE);\n    rgbL *= vec3(1.0/9.0);\n    \n    float lumaNW = FxaaLuma(rgbNW);\n    float lumaNE = FxaaLuma(rgbNE);\n    float lumaSW = FxaaLuma(rgbSW);\n    float lumaSE = FxaaLuma(rgbSE);\n    \n    float edgeVert = \n        abs((0.25 * lumaNW) + (-0.5 * lumaN) + (0.25 * lumaNE)) +\n        abs((0.50 * lumaW ) + (-1.0 * lumaM) + (0.50 * lumaE )) +\n        abs((0.25 * lumaSW) + (-0.5 * lumaS) + (0.25 * lumaSE));\n    float edgeHorz = \n        abs((0.25 * lumaNW) + (-0.5 * lumaW) + (0.25 * lumaSW)) +\n        abs((0.50 * lumaN ) + (-1.0 * lumaM) + (0.50 * lumaS )) +\n        abs((0.25 * lumaNE) + (-0.5 * lumaE) + (0.25 * lumaSE));\n        \n    bool horzSpan = edgeHorz >= edgeVert;\n    float lengthSign = horzSpan ? -rcpFrame.y : -rcpFrame.x;\n    \n    if(!horzSpan)\n    {\n        lumaN = lumaW;\n        lumaS = lumaE;\n    }\n    \n    float gradientN = abs(lumaN - lumaM);\n    float gradientS = abs(lumaS - lumaM);\n    lumaN = (lumaN + lumaM) * 0.5;\n    lumaS = (lumaS + lumaM) * 0.5;\n    \n    if (gradientN < gradientS)\n    {\n        lumaN = lumaS;\n        lumaN = lumaS;\n        gradientN = gradientS;\n        lengthSign *= -1.0;\n    }\n    \n    vec2 posN;\n    posN.x = pos.x + (horzSpan ? 0.0 : lengthSign * 0.5);\n    posN.y = pos.y + (horzSpan ? lengthSign * 0.5 : 0.0);\n    \n    gradientN *= FXAA_SEARCH_THRESHOLD;\n    \n    vec2 posP = posN;\n    vec2 offNP = horzSpan ? vec2(rcpFrame.x, 0.0) : vec2(0.0, rcpFrame.y); \n    float lumaEndN = lumaN;\n    float lumaEndP = lumaN;\n    bool doneN = false;\n    bool doneP = false;\n    posN += offNP * vec2(-1.0, -1.0);\n    posP += offNP * vec2( 1.0,  1.0);\n    \n    for(int i = 0; i < FXAA_SEARCH_STEPS; i++) {\n        if(!doneN)\n        {\n            lumaEndN = FxaaLuma(texture2D(tex, posN.xy).xyz);\n        }\n        if(!doneP)\n        {\n            lumaEndP = FxaaLuma(texture2D(tex, posP.xy).xyz);\n        }\n        \n        doneN = doneN || (abs(lumaEndN - lumaN) >= gradientN);\n        doneP = doneP || (abs(lumaEndP - lumaN) >= gradientN);\n        \n        if(doneN && doneP)\n        {\n            break;\n        }\n        if(!doneN)\n        {\n            posN -= offNP;\n        }\n        if(!doneP)\n        {\n            posP += offNP;\n        }\n    }\n    \n    float dstN = horzSpan ? pos.x - posN.x : pos.y - posN.y;\n    float dstP = horzSpan ? posP.x - pos.x : posP.y - pos.y;\n    bool directionN = dstN < dstP;\n    lumaEndN = directionN ? lumaEndN : lumaEndP;\n    \n    if(((lumaM - lumaN) < 0.0) == ((lumaEndN - lumaN) < 0.0))\n    {\n        lengthSign = 0.0;\n    }\n \n\n    float spanLength = (dstP + dstN);\n    dstN = directionN ? dstN : dstP;\n    float subPixelOffset = (0.5 + (dstN * (-1.0/spanLength))) * lengthSign;\n    vec3 rgbF = texture2D(tex, vec2(\n        pos.x + (horzSpan ? 0.0 : subPixelOffset),\n        pos.y + (horzSpan ? subPixelOffset : 0.0))).xyz;\n    return FxaaLerp3(rgbL, rgbF, blendL); \n}\n\nuniform sampler2D u_texture;\nuniform vec2 u_step;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main()\n{\n    gl_FragColor = vec4(FxaaPixelShader(v_textureCoordinates, u_texture, u_step), 1.0);\n}\n"
    }),define("Cesium/Scene/FXAA", ["../Core/Cartesian2", "../Core/Color", "../Core/defined", "../Core/destroyObject", "../Core/PixelFormat", "../Renderer/ClearCommand", "../Renderer/Framebuffer", "../Renderer/PixelDatatype", "../Renderer/Renderbuffer", "../Renderer/RenderbufferFormat", "../Renderer/RenderState", "../Renderer/Texture", "../Shaders/PostProcessFilters/FXAA"], function (e, t, i, n, r, o, a, s, u, l, c, h, d) {
        "use strict";
        function m(e) {
            e._fbo = e._fbo && e._fbo.destroy(), e._texture = e._texture && e._texture.destroy(), e._depthTexture = e._depthTexture && e._depthTexture.destroy(), e._depthRenderbuffer = e._depthRenderbuffer && e._depthRenderbuffer.destroy(), e._fbo = void 0, e._texture = void 0, e._depthTexture = void 0, e._depthRenderbuffer = void 0, i(e._command) && (e._command.shaderProgram = e._command.shaderProgram && e._command.shaderProgram.destroy(), e._command = void 0)
        }

        var p = function (e) {
            this._texture = void 0, this._depthTexture = void 0, this._depthRenderbuffer = void 0, this._fbo = void 0, this._command = void 0;
            var i = new o({color: new t(0, 0, 0, 0), depth: 1, owner: this});
            this._clearCommand = i
        };
        return p.prototype.update = function (t) {
            var n = t.drawingBufferWidth, o = t.drawingBufferHeight, m = this._texture, p = !i(m) || m.width !== n || m.height !== o;
            if (p && (this._texture = this._texture && this._texture.destroy(), this._depthTexture = this._depthTexture && this._depthTexture.destroy(), this._depthRenderbuffer = this._depthRenderbuffer && this._depthRenderbuffer.destroy(), this._texture = new h({
                    context: t,
                    width: n,
                    height: o,
                    pixelFormat: r.RGBA,
                    pixelDatatype: s.UNSIGNED_BYTE
                }), t.depthTexture ? this._depthTexture = new h({
                    context: t,
                    width: n,
                    height: o,
                    pixelFormat: r.DEPTH_COMPONENT,
                    pixelDatatype: s.UNSIGNED_SHORT
                }) : this._depthRenderbuffer = new u({
                    context: t,
                    width: n,
                    height: o,
                    format: l.DEPTH_COMPONENT16
                })), (!i(this._fbo) || p) && (this._fbo = this._fbo && this._fbo.destroy(), this._fbo = new a({
                    context: t,
                    colorTextures: [this._texture],
                    depthTexture: this._depthTexture,
                    depthRenderbuffer: this._depthRenderbuffer,
                    destroyAttachments: !1
                })), i(this._command) || (this._command = t.createViewportQuadCommand(d, {
                    renderState: c.fromCache(),
                    owner: this
                })), p) {
                var f = this, _ = new e(1 / this._texture.width, 1 / this._texture.height);
                this._command.uniformMap = {
                    u_texture: function () {
                        return f._texture
                    }, u_step: function () {
                        return _
                    }
                }
            }
        }, p.prototype.execute = function (e, t) {
            this._command.execute(e, t)
        }, p.prototype.clear = function (e, i, n) {
            var r = i.framebuffer;
            i.framebuffer = this._fbo, t.clone(n, this._clearCommand.color), this._clearCommand.execute(e, i), i.framebuffer = r
        }, p.prototype.getColorFramebuffer = function () {
            return this._fbo
        }, p.prototype.isDestroyed = function () {
            return !1
        }, p.prototype.destroy = function () {
            return m(this), n(this)
        }, p
    }),define("Cesium/Shaders/PostProcessFilters/PassThrough", [], function () {
        "use strict";
        return "uniform sampler2D u_texture;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main() \n{\n    gl_FragColor = texture2D(u_texture, v_textureCoordinates);\n}\n"
    }),define("Cesium/Scene/GlobeDepth", ["../Core/Color", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/PixelFormat", "../Renderer/ClearCommand", "../Renderer/Framebuffer", "../Renderer/PixelDatatype", "../Renderer/RenderState", "../Renderer/Texture", "../Shaders/PostProcessFilters/PassThrough"], function (e, t, i, n, r, o, a, s, u, l, c) {
        "use strict";
        function h(e, i, n) {
            if (!t(e._debugGlobeDepthViewportCommand)) {
                var r = "uniform sampler2D u_texture;\nvarying vec2 v_textureCoordinates;\nvoid main()\n{\n    float z_window = czm_unpackDepth(texture2D(u_texture, v_textureCoordinates));\n    float n_range = czm_depthRange.near;\n    float f_range = czm_depthRange.far;\n    float z_ndc = (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n    float scale = pow(z_ndc * 0.5 + 0.5, 8.0);\n    gl_FragColor = vec4(mix(vec3(0.0), vec3(1.0), scale), 1.0);\n}\n";
                e._debugGlobeDepthViewportCommand = i.createViewportQuadCommand(r, {
                    uniformMap: {
                        u_texture: function () {
                            return e._globeDepthTexture
                        }
                    }, owner: e
                })
            }
            e._debugGlobeDepthViewportCommand.execute(i, n)
        }

        function d(e) {
            e._colorTexture = e._colorTexture && !e._colorTexture.isDestroyed() && e._colorTexture.destroy(), e._depthStencilTexture = e._depthStencilTexture && !e._depthStencilTexture.isDestroyed() && e._depthStencilTexture.destroy(), e._globeDepthTexture = e._globeDepthTexture && !e._globeDepthTexture.isDestroyed() && e._globeDepthTexture.destroy()
        }

        function m(e) {
            e.framebuffer = e.framebuffer && !e.framebuffer.isDestroyed() && e.framebuffer.destroy(), e._copyDepthFramebuffer = e._copyDepthFramebuffer && !e._copyDepthFramebuffer.isDestroyed() && e._copyDepthFramebuffer.destroy()
        }

        function p(e, t, i, n) {
            e._colorTexture = new l({
                context: t,
                width: i,
                height: n,
                pixelFormat: r.RGBA,
                pixelDatatype: s.UNSIGNED_BYTE
            }), e._depthStencilTexture = new l({
                context: t,
                width: i,
                height: n,
                pixelFormat: r.DEPTH_STENCIL,
                pixelDatatype: s.UNSIGNED_INT_24_8_WEBGL
            }), e._globeDepthTexture = new l({
                context: t, width: i, height: n, pixelFormat: r.RGBA, pixelDatatype: s.UNSIGNED_BYTE
            })
        }

        function f(e, t, i, n) {
            d(e), m(e), p(e, t, i, n), e.framebuffer = new a({
                context: t,
                colorTextures: [e._colorTexture],
                depthStencilTexture: e._depthStencilTexture,
                destroyAttachments: !1
            }), e._copyDepthFramebuffer = new a({
                context: t,
                colorTextures: [e._globeDepthTexture],
                destroyAttachments: !1
            })
        }

        function _(e, i) {
            var n = i.drawingBufferWidth, r = i.drawingBufferHeight, o = e._colorTexture, a = !t(o) || o.width !== n || o.height !== r;
            (!t(e.framebuffer) || a) && f(e, i, n, r)
        }

        function v(i, n) {
            if (!t(i._copyDepthCommand)) {
                var r = "uniform sampler2D u_texture;\nvarying vec2 v_textureCoordinates;\nvoid main()\n{\n    gl_FragColor = czm_packDepth(texture2D(u_texture, v_textureCoordinates).r);\n}\n";
                i._copyDepthCommand = n.createViewportQuadCommand(r, {
                    renderState: u.fromCache(),
                    uniformMap: {
                        u_texture: function () {
                            return i._depthStencilTexture
                        }
                    },
                    owner: i
                })
            }
            i._copyDepthCommand.framebuffer = i._copyDepthFramebuffer, t(i._copyColorCommand) || (i._copyColorCommand = n.createViewportQuadCommand(c, {
                renderState: u.fromCache(),
                uniformMap: {
                    u_texture: function () {
                        return i._colorTexture
                    }
                },
                owner: i
            })), t(i._clearColorCommand) || (i._clearColorCommand = new o({
                color: new e(0, 0, 0, 0),
                stencil: 0,
                owner: i
            })), i._clearColorCommand.framebuffer = i.framebuffer
        }

        var g = function () {
            this._colorTexture = void 0, this._depthStencilTexture = void 0, this._globeDepthTexture = void 0, this.framebuffer = void 0, this._copyDepthFramebuffer = void 0, this._clearColorCommand = void 0, this._copyColorCommand = void 0, this._copyDepthCommand = void 0, this._debugGlobeDepthViewportCommand = void 0
        };
        return g.prototype.executeDebugGlobeDepth = function (e, t) {
            h(this, e, t)
        }, g.prototype.update = function (e) {
            _(this, e), v(this, e), e.uniformState.globeDepthTexture = void 0
        }, g.prototype.executeCopyDepth = function (e, i) {
            t(this._copyDepthCommand) && (this._copyDepthCommand.execute(e, i), e.uniformState.globeDepthTexture = this._globeDepthTexture)
        }, g.prototype.executeCopyColor = function (e, i) {
            t(this._copyColorCommand) && this._copyColorCommand.execute(e, i)
        }, g.prototype.clear = function (i, n, r) {
            var o = this._clearColorCommand;
            t(o) && (e.clone(r, o.color), o.execute(i, n))
        }, g.prototype.isDestroyed = function () {
            return !1
        }, g.prototype.destroy = function () {
            d(this), m(this), t(this._copyColorCommand) && (this._copyColorCommand.shaderProgram = this._copyColorCommand.shaderProgram.destroy()), t(this._copyDepthCommand) && (this._copyDepthCommand.shaderProgram = this._copyDepthCommand.shaderProgram.destroy());
            var e = this._debugGlobeDepthViewportCommand;
            return t(e) && (e.shaderProgram = e.shaderProgram.destroy()), n(this)
        }, g
    }),define("Cesium/Scene/JobScheduler", ["../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/getTimestamp", "./JobType"], function (e, t, i, n, r) {
        "use strict";
        var o = function (e) {
            this._total = e, this.usedThisFrame = 0, this.stolenFromMeThisFrame = 0, this.starvedThisFrame = !1, this.starvedLastFrame = !1
        };
        t(o.prototype, {
            total: {
                get: function () {
                    return this._total
                }
            }
        });
        var a = function (t) {
            if (e(t) && t.length !== r.NUMBER_OF_JOB_TYPES)throw new i("A budget must be specified for each job type; budgets.length should equal JobType.NUMBER_OF_JOB_TYPES.");
            var n = new Array(r.NUMBER_OF_JOB_TYPES);
            n[r.TEXTURE] = new o(e(t) ? t[r.TEXTURE] : 10), n[r.PROGRAM] = new o(e(t) ? t[r.PROGRAM] : 10), n[r.BUFFER] = new o(e(t) ? t[r.BUFFER] : 30);
            var a, s = n.length, u = 0;
            for (a = 0; s > a; ++a)u += n[a].total;
            var l = new Array(s);
            for (a = 0; s > a; ++a)l[a] = !1;
            this._totalBudget = u, this._totalUsedThisFrame = 0, this._budgets = n, this._executedThisFrame = l
        };
        return a.getTimestamp = n, t(a.prototype, {
            totalBudget: {
                get: function () {
                    return this._totalBudget
                }
            }
        }), a.prototype.disableThisFrame = function () {
            this._totalUsedThisFrame = this._totalBudget
        }, a.prototype.resetBudgets = function () {
            for (var e = this._budgets, t = e.length, i = 0; t > i; ++i) {
                var n = e[i];
                n.starvedLastFrame = n.starvedThisFrame, n.starvedThisFrame = !1, n.usedThisFrame = 0, n.stolenFromMeThisFrame = 0
            }
            this._totalUsedThisFrame = 0
        }, a.prototype.execute = function (e, t) {
            var i = this._budgets, n = i[t], r = this._executedThisFrame[t];
            if (this._totalUsedThisFrame >= this._totalBudget && r)return n.starvedThisFrame = !0, !1;
            var o;
            if (n.usedThisFrame + n.stolenFromMeThisFrame >= n.total) {
                for (var s = i.length, u = 0; s > u && (o = i[u], !(o.usedThisFrame + o.stolenFromMeThisFrame < o.total) || o.starvedLastFrame); ++u);
                if (u === s && r)return !1;
                r && (n.starvedThisFrame = !0)
            }
            var l = a.getTimestamp();
            e.execute();
            var c = a.getTimestamp() - l;
            return this._totalUsedThisFrame += c, o ? o.stolenFromMeThisFrame += c : n.usedThisFrame += c, this._executedThisFrame[t] = !0, !0
        }, a
    }),define("Cesium/Shaders/AdjustTranslucentFS", [], function () {
        "use strict";
        return "#ifdef MRT\n#extension GL_EXT_draw_buffers : enable\n#endif\n\nuniform vec4 u_bgColor;\nuniform sampler2D u_depthTexture;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main()\n{\n    if (texture2D(u_depthTexture, v_textureCoordinates).r < 1.0)\n    {\n#ifdef MRT\n        gl_FragData[0] = u_bgColor;\n        gl_FragData[1] = vec4(u_bgColor.a);\n#else\n        gl_FragColor = u_bgColor;\n#endif\n        return;\n    }\n    \n    discard;\n}"
    }),define("Cesium/Shaders/CompositeOITFS", [], function () {
        "use strict";
        return "/**\n * Compositing for Weighted Blended Order-Independent Transparency. See:\n * - http://jcgt.org/published/0002/02/09/\n * - http://casual-effects.blogspot.com/2014/03/weighted-blended-order-independent.html\n */\n \nuniform sampler2D u_opaque;\nuniform sampler2D u_accumulation;\nuniform sampler2D u_revealage;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main()\n{\n    vec4 opaque = texture2D(u_opaque, v_textureCoordinates);\n    vec4 accum = texture2D(u_accumulation, v_textureCoordinates);\n    float r = texture2D(u_revealage, v_textureCoordinates).r;\n    \n#ifdef MRT\n    vec4 transparent = vec4(accum.rgb / clamp(r, 1e-4, 5e4), accum.a);\n#else\n    vec4 transparent = vec4(accum.rgb / clamp(accum.a, 1e-4, 5e4), r);\n#endif\n    \n    gl_FragColor = (1.0 - transparent.a) * transparent + transparent.a * opaque;\n}\n"
    }),define("Cesium/Scene/OIT", ["../Core/Color", "../Core/defined", "../Core/destroyObject", "../Core/PixelFormat", "../Renderer/ClearCommand", "../Renderer/Framebuffer", "../Renderer/PixelDatatype", "../Renderer/RenderState", "../Renderer/ShaderProgram", "../Renderer/ShaderSource", "../Renderer/Texture", "../Renderer/WebGLConstants", "../Shaders/AdjustTranslucentFS", "../Shaders/CompositeOITFS", "./BlendEquation", "./BlendFunction"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f) {
        "use strict";
        function _(e) {
            e._accumulationTexture = e._accumulationTexture && !e._accumulationTexture.isDestroyed() && e._accumulationTexture.destroy(), e._revealageTexture = e._revealageTexture && !e._revealageTexture.isDestroyed() && e._revealageTexture.destroy()
        }

        function v(e) {
            e._translucentFBO = e._translucentFBO && !e._translucentFBO.isDestroyed() && e._translucentFBO.destroy(), e._alphaFBO = e._alphaFBO && !e._alphaFBO.isDestroyed() && e._alphaFBO.destroy(), e._adjustTranslucentFBO = e._adjustTranslucentFBO && !e._adjustTranslucentFBO.isDestroyed() && e._adjustTranslucentFBO.destroy(), e._adjustAlphaFBO = e._adjustAlphaFBO && !e._adjustAlphaFBO.isDestroyed() && e._adjustAlphaFBO.destroy()
        }

        function g(e) {
            _(e), v(e)
        }

        function y(e, t, i, r) {
            _(e), e._accumulationTexture = new c({
                context: t,
                width: i,
                height: r,
                pixelFormat: n.RGBA,
                pixelDatatype: a.FLOAT
            }), e._revealageTexture = new c({
                context: t,
                width: i,
                height: r,
                pixelFormat: n.RGBA,
                pixelDatatype: a.FLOAT
            })
        }

        function C(e, t) {
            v(e);
            var i = h.FRAMEBUFFER_COMPLETE, n = !0;
            if (e._translucentMRTSupport && (e._translucentFBO = new o({
                    context: t,
                    colorTextures: [e._accumulationTexture, e._revealageTexture],
                    depthStencilTexture: e._depthStencilTexture,
                    destroyAttachments: !1
                }), e._adjustTranslucentFBO = new o({
                    context: t,
                    colorTextures: [e._accumulationTexture, e._revealageTexture],
                    destroyAttachments: !1
                }), (e._translucentFBO.status !== i || e._adjustTranslucentFBO.status !== i) && (v(e), e._translucentMRTSupport = !1)), !e._translucentMRTSupport) {
                e._translucentFBO = new o({
                    context: t,
                    colorTextures: [e._accumulationTexture],
                    depthStencilTexture: e._depthStencilTexture,
                    destroyAttachments: !1
                }), e._alphaFBO = new o({
                    context: t,
                    colorTextures: [e._revealageTexture],
                    depthStencilTexture: e._depthStencilTexture,
                    destroyAttachments: !1
                }), e._adjustTranslucentFBO = new o({
                    context: t,
                    colorTextures: [e._accumulationTexture],
                    destroyAttachments: !1
                }), e._adjustAlphaFBO = new o({
                    context: t,
                    colorTextures: [e._revealageTexture],
                    destroyAttachments: !1
                });
                var r = e._translucentFBO.status === i, a = e._alphaFBO.status === i, s = e._adjustTranslucentFBO.status === i, u = e._adjustAlphaFBO.status === i;
                r && a && s && u || (g(e), e._translucentMultipassSupport = !1, n = !1)
            }
            return n
        }

        function E(e, i, n, r) {
            var o = n[r.id];
            if (!t(o)) {
                var a = s.getState(r);
                a.depthMask = !1, a.blending = i, o = s.fromCache(a), n[r.id] = o
            }
            return o
        }

        function S(e, t, i) {
            return E(t, O, e._translucentRenderStateCache, i)
        }

        function T(e, t, i) {
            return E(t, R, e._translucentRenderStateCache, i)
        }

        function b(e, t, i) {
            return E(t, N, e._alphaRenderStateCache, i)
        }

        function w(e, i, n, r) {
            var o = i.id, a = n[o];
            if (!t(a)) {
                var s = i._attributeLocations, c = i.fragmentShaderSource.clone();
                c.sources = c.sources.map(function (e) {
                    return e = l.replaceMain(e, "czm_translucent_main"), e = e.replace(/gl_FragColor/g, "czm_gl_FragColor"), e = e.replace(/\bdiscard\b/g, "czm_discard = true"), e = e.replace(/czm_phong/g, "czm_translucentPhong")
                }), c.sources.splice(0, 0, (-1 !== r.indexOf("gl_FragData") ? "#extension GL_EXT_draw_buffers : enable \n" : "") + "vec4 czm_gl_FragColor;\nbool czm_discard = false;\n"), c.sources.push("void main()\n{\n    czm_translucent_main();\n    if (czm_discard)\n    {\n        discard;\n    }\n" + r + "}\n"), a = u.fromCache({
                    context: e,
                    vertexShaderSource: i.vertexShaderSource,
                    fragmentShaderSource: c,
                    attributeLocations: s
                }), n[o] = a
            }
            return a
        }

        function x(e, t, i) {
            return w(t, i, e._translucentShaderCache, L)
        }

        function A(e, t, i) {
            return w(t, i, e._translucentShaderCache, F)
        }

        function P(e, t, i) {
            return w(t, i, e._alphaShaderCache, B)
        }

        function I(e, i, n, r, o) {
            var a, s, u, l, c = i.context, h = r.framebuffer, d = o.length;
            r.framebuffer = e._adjustTranslucentFBO, e._adjustTranslucentCommand.execute(c, r), r.framebuffer = e._adjustAlphaFBO, e._adjustAlphaCommand.execute(c, r);
            var m = e._opaqueFBO;
            for (r.framebuffer = e._translucentFBO, l = 0; d > l; ++l)a = o[l], t(a.oit) && a.shaderProgram.id === a.oit.shaderProgramId || (a.oit = {
                colorRenderState: T(e, c, a.renderState),
                alphaRenderState: b(e, c, a.renderState),
                colorShaderProgram: A(e, c, a.shaderProgram),
                alphaShaderProgram: P(e, c, a.shaderProgram),
                shaderProgramId: a.shaderProgram.id
            }), s = a.oit.colorRenderState, u = a.oit.colorShaderProgram, n(a, i, c, r, s, u, m);
            for (r.framebuffer = e._alphaFBO, l = 0; d > l; ++l)a = o[l], s = a.oit.alphaRenderState, u = a.oit.alphaShaderProgram, n(a, i, c, r, s, u, m);
            r.framebuffer = h
        }

        function D(e, i, n, r, o) {
            var a = i.context, s = r.framebuffer, u = o.length;
            r.framebuffer = e._adjustTranslucentFBO, e._adjustTranslucentCommand.execute(a, r);
            var l = e._opaqueFBO;
            r.framebuffer = e._translucentFBO;
            for (var c = 0; u > c; ++c) {
                var h = o[c];
                t(h.oit) && h.shaderProgram.id === h.oit.shaderProgramId || (h.oit = {
                    translucentRenderState: S(e, a, h.renderState),
                    translucentShaderProgram: x(e, a, h.shaderProgram),
                    shaderProgramId: h.shaderProgram.id
                });
                var d = h.oit.translucentRenderState, m = h.oit.translucentShaderProgram;
                n(h, i, a, r, d, m, l)
            }
            r.framebuffer = s
        }

        var M = function (t) {
            this._translucentMultipassSupport = !1, this._translucentMRTSupport = !1;
            var i = t.floatingPointTexture && t.depthTexture;
            this._translucentMRTSupport = t.drawBuffers && i, this._translucentMultipassSupport = !this._translucentMRTSupport && i, this._opaqueFBO = void 0, this._opaqueTexture = void 0, this._depthStencilTexture = void 0, this._accumulationTexture = void 0, this._translucentFBO = void 0, this._alphaFBO = void 0, this._adjustTranslucentFBO = void 0, this._adjustAlphaFBO = void 0, this._opaqueClearCommand = new r({
                color: new e(0, 0, 0, 0),
                owner: this
            }), this._translucentMRTClearCommand = new r({
                color: new e(0, 0, 0, 1),
                owner: this
            }), this._translucentMultipassClearCommand = new r({
                color: new e(0, 0, 0, 0),
                owner: this
            }), this._alphaClearCommand = new r({
                color: new e(1, 1, 1, 1),
                owner: this
            }), this._translucentRenderStateCache = {}, this._alphaRenderStateCache = {}, this._translucentShaderCache = {}, this._alphaShaderCache = {}, this._compositeCommand = void 0, this._adjustTranslucentCommand = void 0, this._adjustAlphaCommand = void 0
        };
        M.prototype.update = function (e, i) {
            if (this.isSupported()) {
                this._opaqueFBO = i, this._opaqueTexture = i.getColorTexture(0), this._depthStencilTexture = i.depthStencilTexture;
                var n = this._opaqueTexture.width, r = this._opaqueTexture.height, o = this._accumulationTexture, a = !t(o) || o.width !== n || o.height !== r;
                if (a && y(this, e, n, r), t(this._translucentFBO) && !a || C(this, e)) {
                    var u, c, h = this;
                    t(this._compositeCommand) || (u = new l({sources: [m]}), this._translucentMRTSupport && u.defines.push("MRT"), c = {
                        u_opaque: function () {
                            return h._opaqueTexture
                        }, u_accumulation: function () {
                            return h._accumulationTexture
                        }, u_revealage: function () {
                            return h._revealageTexture
                        }
                    }, this._compositeCommand = e.createViewportQuadCommand(u, {
                        renderState: s.fromCache(),
                        uniformMap: c,
                        owner: this
                    })), t(this._adjustTranslucentCommand) || (this._translucentMRTSupport ? (u = new l({
                        defines: ["MRT"],
                        sources: [d]
                    }), c = {
                        u_bgColor: function () {
                            return h._translucentMRTClearCommand.color
                        }, u_depthTexture: function () {
                            return h._depthStencilTexture
                        }
                    }, this._adjustTranslucentCommand = e.createViewportQuadCommand(u, {
                        renderState: s.fromCache(),
                        uniformMap: c,
                        owner: this
                    })) : this._translucentMultipassSupport && (u = new l({sources: [d]}), c = {
                        u_bgColor: function () {
                            return h._translucentMultipassClearCommand.color
                        }, u_depthTexture: function () {
                            return h._depthStencilTexture
                        }
                    }, this._adjustTranslucentCommand = e.createViewportQuadCommand(u, {
                        renderState: s.fromCache(),
                        uniformMap: c,
                        owner: this
                    }), c = {
                        u_bgColor: function () {
                            return h._alphaClearCommand.color
                        }, u_depthTexture: function () {
                            return h._depthStencilTexture
                        }
                    }, this._adjustAlphaCommand = e.createViewportQuadCommand(u, {
                        renderState: s.fromCache(),
                        uniformMap: c,
                        owner: this
                    })))
                }
            }
        };
        var O = {
            enabled: !0,
            color: new e(0, 0, 0, 0),
            equationRgb: p.ADD,
            equationAlpha: p.ADD,
            functionSourceRgb: f.ONE,
            functionDestinationRgb: f.ONE,
            functionSourceAlpha: f.ZERO,
            functionDestinationAlpha: f.ONE_MINUS_SOURCE_ALPHA
        }, R = {
            enabled: !0,
            color: new e(0, 0, 0, 0),
            equationRgb: p.ADD,
            equationAlpha: p.ADD,
            functionSourceRgb: f.ONE,
            functionDestinationRgb: f.ONE,
            functionSourceAlpha: f.ONE,
            functionDestinationAlpha: f.ONE
        }, N = {
            enabled: !0,
            color: new e(0, 0, 0, 0),
            equationRgb: p.ADD,
            equationAlpha: p.ADD,
            functionSourceRgb: f.ZERO,
            functionDestinationRgb: f.ONE_MINUS_SOURCE_ALPHA,
            functionSourceAlpha: f.ZERO,
            functionDestinationAlpha: f.ONE_MINUS_SOURCE_ALPHA
        }, L = "    vec3 Ci = czm_gl_FragColor.rgb * czm_gl_FragColor.a;\n    float ai = czm_gl_FragColor.a;\n    float wzi = czm_alphaWeight(ai);\n    gl_FragData[0] = vec4(Ci * wzi, ai);\n    gl_FragData[1] = vec4(ai * wzi);\n", F = "    vec3 Ci = czm_gl_FragColor.rgb * czm_gl_FragColor.a;\n    float ai = czm_gl_FragColor.a;\n    float wzi = czm_alphaWeight(ai);\n    gl_FragColor = vec4(Ci, ai) * wzi;\n", B = "    float ai = czm_gl_FragColor.a;\n    gl_FragColor = vec4(ai);\n";
        return M.prototype.executeCommands = function (e, t, i, n) {
            return this._translucentMRTSupport ? void D(this, e, t, i, n) : void I(this, e, t, i, n)
        }, M.prototype.execute = function (e, t) {
            this._compositeCommand.execute(e, t)
        }, M.prototype.clear = function (t, i, n) {
            var r = i.framebuffer;
            i.framebuffer = this._opaqueFBO, e.clone(n, this._opaqueClearCommand.color), this._opaqueClearCommand.execute(t, i), i.framebuffer = this._translucentFBO;
            var o = this._translucentMRTSupport ? this._translucentMRTClearCommand : this._translucentMultipassClearCommand;
            o.execute(t, i), this._translucentMultipassSupport && (i.framebuffer = this._alphaFBO, this._alphaClearCommand.execute(t, i)), i.framebuffer = r
        }, M.prototype.isSupported = function () {
            return this._translucentMRTSupport || this._translucentMultipassSupport
        }, M.prototype.isDestroyed = function () {
            return !1
        }, M.prototype.destroy = function () {
            g(this), t(this._compositeCommand) && (this._compositeCommand.shaderProgram = this._compositeCommand.shaderProgram && this._compositeCommand.shaderProgram.destroy()), t(this._adjustTranslucentCommand) && (this._adjustTranslucentCommand.shaderProgram = this._adjustTranslucentCommand.shaderProgram && this._adjustTranslucentCommand.shaderProgram.destroy()), t(this._adjustAlphaCommand) && (this._adjustAlphaCommand.shaderProgram = this._adjustAlphaCommand.shaderProgram && this._adjustAlphaCommand.shaderProgram.destroy());
            var e, n = this._translucentShaderCache;
            for (e in n)n.hasOwnProperty(e) && t(n[e]) && n[e].destroy();
            this._translucentShaderCache = {}, n = this._alphaShaderCache;
            for (e in n)n.hasOwnProperty(e) && t(n[e]) && n[e].destroy();
            return this._alphaShaderCache = {}, i(this)
        }, M
    }),define("Cesium/Scene/OrthographicFrustum", ["../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Matrix4", "./CullingVolume"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        function u(e) {
            (e.top !== e._top || e.bottom !== e._bottom || e.left !== e._left || e.right !== e._right || e.near !== e._near || e.far !== e._far) && (e._left = e.left, e._right = e.right, e._top = e.top, e._bottom = e.bottom, e._near = e.near, e._far = e.far, e._orthographicMatrix = a.computeOrthographicOffCenter(e.left, e.right, e.bottom, e.top, e.near, e.far, e._orthographicMatrix))
        }

        var l = function () {
            this.left = void 0, this._left = void 0, this.right = void 0, this._right = void 0, this.top = void 0, this._top = void 0, this.bottom = void 0, this._bottom = void 0, this.near = 1, this._near = this.near, this.far = 5e8, this._far = this.far, this._cullingVolume = new s, this._orthographicMatrix = new a
        };
        r(l.prototype, {
            projectionMatrix: {
                get: function () {
                    return u(this), this._orthographicMatrix
                }
            }
        });
        var c = new t, h = new t, d = new t, m = new t;
        return l.prototype.computeCullingVolume = function (e, r, o) {
            var a = this._cullingVolume.planes, s = this.top, u = this.bottom, l = this.right, p = this.left, f = this.near, _ = this.far, v = t.cross(r, o, c), g = h;
            t.multiplyByScalar(r, f, g), t.add(e, g, g);
            var y = d;
            t.multiplyByScalar(v, p, y), t.add(g, y, y);
            var C = a[0];
            return n(C) || (C = a[0] = new i), C.x = v.x, C.y = v.y, C.z = v.z, C.w = -t.dot(v, y), t.multiplyByScalar(v, l, y), t.add(g, y, y), C = a[1], n(C) || (C = a[1] = new i), C.x = -v.x, C.y = -v.y, C.z = -v.z, C.w = -t.dot(t.negate(v, m), y), t.multiplyByScalar(o, u, y), t.add(g, y, y), C = a[2], n(C) || (C = a[2] = new i), C.x = o.x, C.y = o.y, C.z = o.z, C.w = -t.dot(o, y), t.multiplyByScalar(o, s, y), t.add(g, y, y), C = a[3], n(C) || (C = a[3] = new i), C.x = -o.x, C.y = -o.y, C.z = -o.z, C.w = -t.dot(t.negate(o, m), y), C = a[4], n(C) || (C = a[4] = new i), C.x = r.x, C.y = r.y, C.z = r.z, C.w = -t.dot(r, g), t.multiplyByScalar(r, _, y), t.add(e, y, y), C = a[5], n(C) || (C = a[5] = new i), C.x = -r.x, C.y = -r.y, C.z = -r.z, C.w = -t.dot(t.negate(r, m), y), this._cullingVolume
        }, l.prototype.getPixelSize = function (t, i, r) {
            u(this);
            var o = this.right - this.left, a = this.top - this.bottom, s = o / t.x, l = a / t.y;
            return n(r) ? (r.x = s, r.y = l, r) : new e(s, l)
        }, l.prototype.clone = function (e) {
            return n(e) || (e = new l), e.left = this.left, e.right = this.right, e.top = this.top, e.bottom = this.bottom, e.near = this.near, e.far = this.far, e._left = void 0, e._right = void 0, e._top = void 0, e._bottom = void 0, e._near = void 0, e._far = void 0, e
        }, l.prototype.equals = function (e) {
            return n(e) && this.right === e.right && this.left === e.left && this.top === e.top && this.bottom === e.bottom && this.near === e.near && this.far === e.far
        }, l
    }),define("Cesium/Scene/PerformanceDisplay", ["../Core/Color", "../Core/defaultValue", "../Core/defined", "../Core/destroyObject", "../Core/DeveloperError", "../Core/getTimestamp", "../Widgets/getElement"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = function (e) {
            e = t(e, t.EMPTY_OBJECT);
            var n = a(e.container);
            if (!i(n))throw new r("container is required");
            this._container = n;
            var o = document.createElement("div");
            o.className = "cesium-performanceDisplay";
            var s = document.createElement("div");
            s.className = "cesium-performanceDisplay-fps", this._fpsText = document.createTextNode(""), s.appendChild(this._fpsText);
            var u = document.createElement("div");
            u.className = "cesium-performanceDisplay-ms", this._msText = document.createTextNode(""), u.appendChild(this._msText), o.appendChild(u), o.appendChild(s), this._container.appendChild(o), this._lastFpsSampleTime = void 0, this._frameCount = 0, this._time = void 0, this._fps = 0, this._frameTime = 0
        };
        return s.prototype.update = function () {
            if (!i(this._time))return this._lastFpsSampleTime = o(), void(this._time = o());
            var e = this._time, t = o();
            this._time = t;
            var n = t - e;
            this._frameCount++;
            var r = this._fps, a = t - this._lastFpsSampleTime;
            a > 1e3 && (r = 1e3 * this._frameCount / a | 0, this._lastFpsSampleTime = t, this._frameCount = 0), r !== this._fps && (this._fpsText.nodeValue = r + " FPS", this._fps = r), n !== this._frameTime && (this._msText.nodeValue = n.toFixed(2) + " MS", this._frameTime = n)
        }, s.prototype.destroy = function () {
            return n(this)
        }, s
    }),define("Cesium/Scene/PickDepth", ["../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/PixelFormat", "../Renderer/Framebuffer", "../Renderer/PixelDatatype", "../Renderer/RenderState", "../Renderer/Texture", "../Shaders/PostProcessFilters/PassThrough"], function (e, t, i, n, r, o, a, s, u) {
        "use strict";
        function l(t, i, n) {
            if (!e(t._debugPickDepthViewportCommand)) {
                var r = "uniform sampler2D u_texture;\nvarying vec2 v_textureCoordinates;\nvoid main()\n{\n    float z_window = czm_unpackDepth(texture2D(u_texture, v_textureCoordinates));\n    float n_range = czm_depthRange.near;\n    float f_range = czm_depthRange.far;\n    float z_ndc = (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n    float scale = pow(z_ndc * 0.5 + 0.5, 8.0);\n    gl_FragColor = vec4(mix(vec3(0.0), vec3(1.0), scale), 1.0);\n}\n";
                t._debugPickDepthViewportCommand = i.createViewportQuadCommand(r, {
                    uniformMap: {
                        u_texture: function () {
                            return t._depthTexture
                        }
                    }, owner: t
                })
            }
            t._debugPickDepthViewportCommand.execute(i, n)
        }

        function c(e) {
            e._depthTexture = e._depthTexture && !e._depthTexture.isDestroyed() && e._depthTexture.destroy()
        }

        function h(e) {
            e.framebuffer = e.framebuffer && !e.framebuffer.isDestroyed() && e.framebuffer.destroy()
        }

        function d(e, t, i, r) {
            e._depthTexture = new s({
                context: t,
                width: i,
                height: r,
                pixelFormat: n.RGBA,
                pixelDatatype: o.UNSIGNED_BYTE
            })
        }

        function m(e, t, i, n) {
            c(e), h(e), d(e, t, i, n), e.framebuffer = new r({
                context: t,
                colorTextures: [e._depthTexture],
                destroyAttachments: !1
            })
        }

        function p(t, i, n) {
            var r = n.width, o = n.height, a = t._depthTexture, s = !e(a) || a.width !== r || a.height !== o;
            (!e(t.framebuffer) || s) && m(t, i, r, o)
        }

        function f(t, i, n) {
            if (!e(t._copyDepthCommand)) {
                var r = "uniform sampler2D u_texture;\nvarying vec2 v_textureCoordinates;\nvoid main()\n{\n    gl_FragColor = czm_packDepth(texture2D(u_texture, v_textureCoordinates).r);\n}\n";
                t._copyDepthCommand = i.createViewportQuadCommand(r, {
                    renderState: a.fromCache(),
                    uniformMap: {
                        u_texture: function () {
                            return t._textureToCopy
                        }
                    },
                    owner: t
                })
            }
            t._textureToCopy = n, t._copyDepthCommand.framebuffer = t.framebuffer
        }

        var _ = function () {
            this.framebuffer = void 0, this._depthTexture = void 0, this._textureToCopy = void 0, this._copyDepthCommand = void 0, this._debugPickDepthViewportCommand = void 0
        };
        return _.prototype.executeDebugPickDepth = function (e, t) {
            l(this, e, t)
        }, _.prototype.update = function (e, t) {
            p(this, e, t), f(this, e, t)
        }, _.prototype.executeCopyDepth = function (e, t) {
            this._copyDepthCommand.execute(e, t)
        }, _.prototype.isDestroyed = function () {
            return !1
        }, _.prototype.destroy = function () {
            return c(this), h(this), this._copyDepthCommand.shaderProgram = e(this._copyDepthCommand.shaderProgram) && this._copyDepthCommand.shaderProgram.destroy(), i(this)
        }, _
    }),define("Cesium/Scene/PrimitiveCollection", ["../Core/createGuid", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError"], function (e, t, i, n, r, o) {
        "use strict";
        function a(e, t) {
            return e._primitives.indexOf(t)
        }

        var s = function (i) {
            i = t(i, t.EMPTY_OBJECT), this._primitives = [], this._guid = e(), this.show = t(i.show, !0), this.destroyPrimitives = t(i.destroyPrimitives, !0)
        };
        return n(s.prototype, {
            length: {
                get: function () {
                    return this._primitives.length
                }
            }
        }), s.prototype.add = function (e) {
            var t = e._external = e._external || {}, i = t._composites = t._composites || {};
            return i[this._guid] = {collection: this}, this._primitives.push(e), e
        }, s.prototype.remove = function (e) {
            if (this.contains(e)) {
                var t = this._primitives.indexOf(e);
                if (-1 !== t)return this._primitives.splice(t, 1), delete e._external._composites[this._guid], this.destroyPrimitives && e.destroy(), !0
            }
            return !1
        }, s.prototype.removeAndDestroy = function (e) {
            var t = this.remove(e);
            return t && !this.destroyPrimitives && e.destroy(), t
        }, s.prototype.removeAll = function () {
            if (this.destroyPrimitives)for (var e = this._primitives, t = e.length, i = 0; t > i; ++i)e[i].destroy();
            this._primitives = []
        }, s.prototype.contains = function (e) {
            return !!(i(e) && e._external && e._external._composites && e._external._composites[this._guid])
        }, s.prototype.raise = function (e) {
            if (i(e)) {
                var t = a(this, e), n = this._primitives;
                if (t !== n.length - 1) {
                    var r = n[t];
                    n[t] = n[t + 1], n[t + 1] = r
                }
            }
        }, s.prototype.raiseToTop = function (e) {
            if (i(e)) {
                var t = a(this, e), n = this._primitives;
                t !== n.length - 1 && (n.splice(t, 1), n.push(e))
            }
        }, s.prototype.lower = function (e) {
            if (i(e)) {
                var t = a(this, e), n = this._primitives;
                if (0 !== t) {
                    var r = n[t];
                    n[t] = n[t - 1], n[t - 1] = r
                }
            }
        }, s.prototype.lowerToBottom = function (e) {
            if (i(e)) {
                var t = a(this, e), n = this._primitives;
                0 !== t && (n.splice(t, 1), n.unshift(e))
            }
        }, s.prototype.get = function (e) {
            return this._primitives[e]
        }, s.prototype.update = function (e, t, i) {
            if (this.show)for (var n = this._primitives, r = 0; r < n.length; ++r)n[r].update(e, t, i)
        }, s.prototype.isDestroyed = function () {
            return !1
        }, s.prototype.destroy = function () {
            return this.removeAll(), r(this)
        }, s
    }),define("Cesium/Scene/SceneTransitioner", ["../Core/Cartesian3", "../Core/defaultValue", "../Core/defined", "../Core/destroyObject", "../Core/DeveloperError", "../Core/EasingFunction", "../Core/Ellipsoid", "../Core/Math", "../Core/Matrix4", "../Core/ScreenSpaceEventHandler", "../Core/ScreenSpaceEventType", "./Camera", "./OrthographicFrustum", "./PerspectiveFrustum", "./SceneMode"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p) {
        "use strict";
        function f(e, t) {
            if (e._scene.completeMorphOnUserInput) {
                e._morphHandler = new l(e._scene.canvas, !1);
                var i = function () {
                    e._morphCancelled = !0, t(e)
                };
                e._completeMorph = i, e._morphHandler.setInputAction(i, c.LEFT_DOWN), e._morphHandler.setInputAction(i, c.MIDDLE_DOWN), e._morphHandler.setInputAction(i, c.RIGHT_DOWN), e._morphHandler.setInputAction(i, c.WHEEL)
            }
        }

        function _(e) {
            for (var t = e._currentTweens, i = 0; i < t.length; ++i)t[i].cancelTween();
            e._currentTweens.length = 0, e._morphHandler = e._morphHandler && e._morphHandler.destroy()
        }

        function v(t, i, n, r) {
            var a = t._scene, s = a.camera;
            s._setTransform(u.IDENTITY);
            var l = s.position, c = s.direction, h = s.up, d = e.clone(t._camera2D.position), m = e.clone(t._camera2D.direction), p = e.clone(t._camera2D.up), f = function (t) {
                s.position = y(l, d, t.time), s.direction = y(c, m, t.time), s.up = y(h, p, t.time), s.right = e.cross(s.direction, s.up, s.right), e.normalize(s.right, s.right)
            }, _ = a.tweens.add({
                duration: i,
                easingFunction: o.QUARTIC_OUT,
                startObject: {time: 0},
                stopObject: {time: 1},
                update: f
            });
            t._currentTweens.push(_), x(t, a, 0, 1, i, r)
        }

        function g(e, t, i, n) {
            t *= .5;
            var r = e._scene.camera;
            r._setTransform(u.IDENTITY), T(e, t, i, function () {
                r.frustum = e._cameraCV.frustum.clone(), v(e, t, i, n)
            })
        }

        function y(t, i, n) {
            return e.lerp(t, i, n, new e)
        }

        function C(t, i, n) {
            var r = t._scene, a = r.camera, u = a.position, l = a.frustum.fov, c = .5 * s.RADIANS_PER_DEGREE, h = e.magnitude(u) * Math.tan(.5 * l);
            a.frustum.far = h / Math.tan(.5 * c) + 1e7;
            var d = function (t) {
                a.frustum.fov = s.lerp(l, c, t.time);
                var i = h / Math.tan(.5 * a.frustum.fov), n = new e;
                a.position = e.multiplyByScalar(e.normalize(a.position, n), i, n)
            }, m = r.tweens.add({
                duration: i,
                easingFunction: o.QUARTIC_OUT,
                startObject: {time: 0},
                stopObject: {time: 1},
                update: d,
                complete: function () {
                    a.frustum = t._camera2D.frustum.clone(), n(t)
                }
            });
            t._currentTweens.push(m)
        }

        function E(t, i, n, r) {
            var a = t._scene, s = a.camera;
            s._setTransform(u.IDENTITY);
            var l = n.maximumRadius, c = e.clone(s.position), h = e.clone(s.direction), d = e.clone(s.up), m = Math.tan(.5 * t._cameraCV.frustum.fovy), p = t._cameraCV.frustum.aspectRatio * m, f = l * Math.PI / p, _ = new e;
            _ = e.multiplyByScalar(e.normalize(t._camera2D.position, _), f, _);
            var v = e.clone(t._camera2D.direction), g = e.clone(t._camera2D.up), E = function (t) {
                s.position = y(c, _, t.time), s.direction = y(h, v, t.time), s.up = y(d, g, t.time), s.right = e.cross(s.direction, s.up, s.right), e.normalize(s.right, s.right)
            };
            i *= .5;
            var S = a.tweens.add({
                duration: i,
                easingFunction: o.QUARTIC_OUT,
                startObject: {time: 0},
                stopObject: {time: 1},
                update: E,
                complete: function () {
                    C(t, i, r)
                }
            });
            t._currentTweens.push(S)
        }

        function S(t, i, n, r) {
            i *= .5;
            var o = n.maximumRadius, a = Math.tan(.5 * t._camera3D.frustum.fovy), s = t._camera3D.frustum.aspectRatio * a, u = o * Math.PI / s, l = {}, c = new e;
            l.position2D = e.multiplyByScalar(e.normalize(t._camera2D.position2D, c), u, c), l.direction2D = e.clone(t._camera2D.direction2D), l.up2D = e.clone(t._camera2D.up2D);
            var h = function () {
                C(t, i, r)
            };
            w(t, i, l, h)
        }

        function T(t, i, n, r) {
            var a = t._scene, u = a.camera, l = n.maximumRadius, c = Math.tan(.5 * t._cameraCV.frustum.fovy), h = t._cameraCV.frustum.aspectRatio * c, d = l * Math.PI / h, m = new e;
            m = e.multiplyByScalar(e.normalize(t._camera2D.position, m), d, m);
            var p = u.frustum.top, f = u.frustum.bottom, _ = u.frustum.right, v = u.frustum.left, g = t._camera2D.frustum, C = t._cameraCV.frustum, E = e.clone(u.position), S = function (e) {
                u.position = y(E, m, e.time), u.frustum.top = s.lerp(p, g.top, e.time), u.frustum.bottom = s.lerp(f, g.bottom, e.time), u.frustum.right = s.lerp(_, g.right, e.time), u.frustum.left = s.lerp(v, g.left, e.time)
            }, T = (_ - v) / (2 * l * Math.PI), b = 1;
            T > b && (T = 0);
            var w = (b - T) * i;
            if (w < s.EPSILON6) {
                if (e.equalsEpsilon(E, m, s.EPSILON6))return u.position = m, u.frustum = C.clone(), void r(t);
                w = i, T = 0, b = 1
            }
            var x = a.tweens.add({
                easingFunction: o.QUARTIC_OUT,
                duration: w,
                startObject: {time: T},
                stopObject: {time: b},
                update: S,
                complete: function () {
                    u.frustum = C.clone(), r(t)
                }
            });
            t._currentTweens.push(x)
        }

        function b(t, i, n, r) {
            var a = t._scene, s = a.camera;
            s._setTransform(u.IDENTITY), i *= .5;
            var l = function () {
                var n = e.clone(s.position), u = e.clone(s.direction), l = e.clone(s.up), c = e.clone(t._cameraCV.position), h = e.clone(t._cameraCV.direction), d = e.clone(t._cameraCV.up), m = function (t) {
                    s.position = y(n, c, t.time), s.direction = y(u, h, t.time), s.up = y(l, d, t.time), s.right = e.cross(s.direction, s.up, s.right), e.normalize(s.right, s.right)
                }, p = a.tweens.add({
                    duration: i,
                    easingFunction: o.QUARTIC_OUT,
                    startObject: {time: 0},
                    stopObject: {time: 1},
                    update: m,
                    complete: function () {
                        r(t)
                    }
                });
                t._currentTweens.push(p)
            };
            T(t, i, n, l)
        }

        function w(t, i, n, r) {
            var a = t._scene, s = a.camera;
            s._setTransform(u.IDENTITY);
            var l = e.clone(s.position), c = e.clone(s.direction), h = e.clone(s.up), d = e.clone(n.position2D), m = e.clone(n.direction2D), p = e.clone(n.up2D), f = function (t) {
                s.position = y(l, d, t.time), s.direction = y(c, m, t.time), s.up = y(h, p, t.time), s.right = e.cross(s.direction, s.up, s.right), e.normalize(s.right, s.right)
            }, _ = a.tweens.add({
                duration: i,
                easingFunction: o.QUARTIC_OUT,
                startObject: {time: 0},
                stopObject: {time: 1},
                update: f,
                complete: function () {
                    s.position = d, s.direction = m, s.up = p, s.right = e.cross(m, p, s.right), e.normalize(s.right, s.right)
                }
            });
            t._currentTweens.push(_), x(t, a, 1, 0, i, r)
        }

        function x(e, t, n, r, a, s) {
            var u = {
                object: t,
                property: "morphTime",
                startValue: n,
                stopValue: r,
                duration: a,
                easingFunction: o.QUARTIC_OUT
            };
            i(s) && (u.complete = function () {
                s(e)
            });
            var l = t.tweens.addProperty(u);
            e._currentTweens.push(l)
        }

        function A(e) {
            var t = e._scene, i = t.drawingBufferHeight / t.drawingBufferWidth, n = e._camera2D.frustum;
            n.top = n.right * i, n.bottom = -n.top, i = 1 / i, n = e._cameraCV.frustum, n.aspectRatio = i, n = e._camera3D.frustum, n.aspectRatio = i;
            var r = t.camera;
            switch (t.mode) {
                case p.SCENE3D:
                    r.frustum = e._camera3D.frustum.clone();
                    break;
                case p.COLUMBUS_VIEW:
                    r.frustum = e._cameraCV.frustum.clone();
                    break;
                case p.SCENE2D:
                    r.frustum = e._camera2D.frustum.clone()
            }
        }

        function P(t) {
            var n = t._scene;
            if (n.mode = p.SCENE3D, n.morphTime = p.getMorphTime(p.SCENE3D), _(t), A(t), t._previousMode !== p.MORPHING || t._morphCancelled) {
                t._morphCancelled = !1;
                var r = n.camera;
                r.position = e.clone(t._camera3D.position), r.direction = e.clone(t._camera3D.direction), r.up = e.clone(t._camera3D.up), r.right = e.cross(r.direction, r.up, r.right), e.normalize(r.right, r.right)
            }
            var o = i(t._completeMorph);
            t._completeMorph = void 0, n.camera.update(n.mode), t._scene.morphComplete.raiseEvent(t, t._previousMode, p.SCENE3D, o)
        }

        function I(t) {
            var n = t._scene;
            n.mode = p.SCENE2D, n.morphTime = p.getMorphTime(p.SCENE2D), _(t), A(t);
            var r = n.camera;
            e.clone(t._camera2D.position, r.position), e.clone(t._camera2D.direction, r.direction), e.clone(t._camera2D.up, r.up), e.cross(r.direction, r.up, r.right), e.normalize(r.right, r.right);
            var o = i(t._completeMorph);
            t._completeMorph = void 0, n.camera.update(n.mode), t._scene.morphComplete.raiseEvent(t, t._previousMode, p.SCENE2D, o)
        }

        function D(t) {
            var n = t._scene;
            if (n.mode = p.COLUMBUS_VIEW, n.morphTime = p.getMorphTime(p.COLUMBUS_VIEW), _(t), A(t), t._previousModeMode !== p.MORPHING || t._morphCancelled) {
                t._morphCancelled = !1;
                var r = n.camera;
                e.clone(t._cameraCV.position, r.position), e.clone(t._cameraCV.direction, r.direction), e.clone(t._cameraCV.up, r.up), e.cross(r.direction, r.up, r.right), e.normalize(r.right, r.right)
            }
            var o = i(t._completeMorph);
            t._completeMorph = void 0, n.camera.update(n.mode), t._scene.morphComplete.raiseEvent(t, t._previousMode, p.COLUMBUS_VIEW, o)
        }

        var M = function (i, n) {
            this._scene = i, n = t(n, a.WGS84);
            var r = n.maximumRadius, o = new e(0, 0, 2 * r), l = new e;
            l = e.normalize(e.negate(o, l), l);
            var c = e.clone(e.UNIT_Y), p = u.multiplyByPoint(h.TRANSFORM_2D, o, new e), f = u.multiplyByPointAsVector(h.TRANSFORM_2D, l, new e), _ = u.multiplyByPointAsVector(h.TRANSFORM_2D, c, new e), v = new d;
            v.right = r * Math.PI, v.left = -v.right, v.top = v.right * (i.drawingBufferHeight / i.drawingBufferWidth), v.bottom = -v.top, this._camera2D = {
                position: o,
                direction: l,
                up: c,
                position2D: p,
                direction2D: f,
                up2D: _,
                frustum: v
            }, o = new e(0, -1, 1), o = e.multiplyByScalar(e.normalize(o, o), 5 * r, o), l = new e, l = e.normalize(e.subtract(e.ZERO, o, l), l);
            var g = new e;
            g = e.normalize(e.cross(l, e.UNIT_Z, g), g), c = new e, c = e.normalize(e.cross(g, l, c), c), p = u.multiplyByPoint(h.TRANSFORM_2D, o, new e), f = u.multiplyByPointAsVector(h.TRANSFORM_2D, l, new e);
            var y = u.multiplyByPointAsVector(h.TRANSFORM_2D, g, new e);
            _ = new e, _ = e.normalize(e.cross(y, f, _), _), v = new m, v.aspectRatio = i.drawingBufferWidth / i.drawingBufferHeight, v.fov = s.toRadians(60), this._cameraCV = {
                position: o,
                direction: l,
                up: c,
                position2D: p,
                direction2D: f,
                up2D: _,
                frustum: v
            }, o = new e, o = e.multiplyByScalar(e.normalize(new e(0, -2, 1), o), 2 * r, o), l = new e, l = e.normalize(e.subtract(e.ZERO, o, l), l), g = new e, g = e.normalize(e.cross(l, e.UNIT_Z, g), g), c = new e, c = e.normalize(e.cross(g, l, c), c), this._camera3D = {
                position: o,
                direction: l,
                up: c,
                frustum: v
            }, this._currentTweens = [], this._morphHandler = void 0, this._morphCancelled = !1, this._completeMorph = void 0
        };
        return M.prototype.completeMorph = function () {
            i(this._completeMorph) && this._completeMorph()
        }, M.prototype.morphTo2D = function (e, t) {
            i(this._completeMorph) && this._completeMorph();
            var n = this._scene;
            this._previousMode = n.mode, this._previousMode !== p.SCENE2D && this._previousMode !== p.MORPHING && (this._scene.morphStart.raiseEvent(this, this._previousMode, p.SCENE2D, !0), A(this), n.mode = p.MORPHING, f(this, I), this._previousMode === p.COLUMBUS_VIEW ? E(this, e, t, I) : S(this, e, t, I), 0 === e && i(this._completeMorph) && this._completeMorph())
        }, M.prototype.morphToColumbusView = function (e, t) {
            i(this._completeMorph) && this._completeMorph();
            var n = this._scene;
            this._previousMode = n.mode, this._previousMode !== p.COLUMBUS_VIEW && this._previousMode !== p.MORPHING && (this._scene.morphStart.raiseEvent(this, this._previousMode, p.COLUMBUS_VIEW, !0), A(this), n.mode = p.MORPHING, f(this, D), this._previousMode === p.SCENE2D ? b(this, e, t, D) : w(this, e, this._cameraCV, D), 0 === e && i(this._completeMorph) && this._completeMorph())
        }, M.prototype.morphTo3D = function (e, t) {
            i(this._completeMorph) && this._completeMorph();
            var n = this._scene;
            this._previousMode = n.mode, this._previousMode !== p.SCENE3D && this._previousMode !== p.MORPHING && (this._scene.morphStart.raiseEvent(this, this._previousMode, p.SCENE3D, !0), A(this), n.mode = p.MORPHING, f(this, P), this._previousMode === p.SCENE2D ? g(this, e, t, P) : v(this, e, t, P), 0 === e && i(this._completeMorph) && this._completeMorph())
        }, M.prototype.isDestroyed = function () {
            return !1
        }, M.prototype.destroy = function () {
            return _(this), n(this)
        }, M
    }),define("Cesium/Scene/CameraEventType", ["../Core/freezeObject"], function (e) {
        "use strict";
        var t = {LEFT_DRAG: 0, RIGHT_DRAG: 1, MIDDLE_DRAG: 2, WHEEL: 3, PINCH: 4};
        return e(t)
    }),define("Cesium/Scene/CameraEventAggregator", ["../Core/Cartesian2", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/KeyboardEventModifier", "../Core/Math", "../Core/ScreenSpaceEventHandler", "../Core/ScreenSpaceEventType", "./CameraEventType"], function (e, t, i, n, r, o, a, s, u, l) {
        "use strict";
        function c(e, i) {
            var n = e;
            return t(i) && (n += "+" + i), n
        }

        function h(t, i) {
            e.clone(t.distance.startPosition, i.distance.startPosition), e.clone(t.distance.endPosition, i.distance.endPosition), e.clone(t.angleAndHeight.startPosition, i.angleAndHeight.startPosition), e.clone(t.angleAndHeight.endPosition, i.angleAndHeight.endPosition)
        }

        function d(i, n, r) {
            var o = c(l.PINCH, n), a = i._update, s = i._isDown, d = i._eventStartPosition, m = i._pressTime, p = i._releaseTime;
            a[o] = !0, s[o] = !1, d[o] = new e;
            var f = i._movement[o];
            t(f) || (f = i._movement[o] = {}), f.distance = {
                startPosition: new e,
                endPosition: new e
            }, f.angleAndHeight = {
                startPosition: new e,
                endPosition: new e
            }, f.prevAngle = 0, i._eventHandler.setInputAction(function (e) {
                i._buttonsDown++, s[o] = !0, m[o] = new Date
            }, u.PINCH_START, n), i._eventHandler.setInputAction(function () {
                i._buttonsDown = Math.max(i._buttonsDown - 1, 0), s[o] = !1, p[o] = new Date
            }, u.PINCH_END, n), i._eventHandler.setInputAction(function (t) {
                if (s[o]) {
                    a[o] ? (h(t, f), a[o] = !1, f.prevAngle = f.angleAndHeight.startPosition.x) : (e.clone(t.distance.endPosition, f.distance.endPosition), e.clone(t.angleAndHeight.endPosition, f.angleAndHeight.endPosition));
                    for (var i = f.angleAndHeight.endPosition.x, n = f.prevAngle, u = 2 * Math.PI; i >= n + Math.PI;)i -= u;
                    for (; i < n - Math.PI;)i += u;
                    f.angleAndHeight.endPosition.x = -i * r.clientWidth / 12, f.angleAndHeight.startPosition.x = -n * r.clientWidth / 12
                }
            }, u.PINCH_MOVE, n)
        }

        function m(i, n) {
            var r = c(l.WHEEL, n), o = i._update;
            o[r] = !0;
            var s = i._movement[r];
            t(s) || (s = i._movement[r] = {}), s.startPosition = new e, s.endPosition = new e, i._eventHandler.setInputAction(function (t) {
                var i = 15 * a.toRadians(t);
                o[r] ? (e.clone(e.ZERO, s.startPosition), s.endPosition.x = 0, s.endPosition.y = i, o[r] = !1) : s.endPosition.y = s.endPosition.y + i
            }, u.WHEEL, n)
        }

        function p(i, n, r) {
            var o = c(r, n), a = i._isDown, s = i._eventStartPosition, h = i._pressTime, d = i._releaseTime;
            a[o] = !1, s[o] = new e;
            var m = i._lastMovement[o];
            t(m) || (m = i._lastMovement[o] = {startPosition: new e, endPosition: new e, valid: !1});
            var p, f;
            r === l.LEFT_DRAG ? (p = u.LEFT_DOWN, f = u.LEFT_UP) : r === l.RIGHT_DRAG ? (p = u.RIGHT_DOWN, f = u.RIGHT_UP) : r === l.MIDDLE_DRAG && (p = u.MIDDLE_DOWN, f = u.MIDDLE_UP), i._eventHandler.setInputAction(function (t) {
                i._buttonsDown++, m.valid = !1, a[o] = !0, h[o] = new Date, e.clone(t.position, s[o])
            }, p, n), i._eventHandler.setInputAction(function () {
                i._buttonsDown = Math.max(i._buttonsDown - 1, 0), a[o] = !1, d[o] = new Date
            }, f, n)
        }

        function f(t, i) {
            e.clone(t.startPosition, i.startPosition), e.clone(t.endPosition, i.endPosition)
        }

        function _(i, n) {
            var r = i._update, o = i._movement, a = i._lastMovement, s = i._isDown;
            for (var h in l)if (l.hasOwnProperty(h)) {
                var d = l[h];
                if (t(d)) {
                    var m = c(d, n);
                    r[m] = !0, t(i._lastMovement[m]) || (i._lastMovement[m] = {
                        startPosition: new e,
                        endPosition: new e,
                        valid: !1
                    }), t(i._movement[m]) || (i._movement[m] = {startPosition: new e, endPosition: new e})
                }
            }
            i._eventHandler.setInputAction(function (u) {
                for (var h in l)if (l.hasOwnProperty(h)) {
                    var d = l[h];
                    if (t(d)) {
                        var m = c(d, n);
                        s[m] && (r[m] ? (f(o[m], a[m]), a[m].valid = !0, f(u, o[m]), r[m] = !1) : e.clone(u.endPosition, o[m].endPosition))
                    }
                }
                e.clone(u.endPosition, i._currentMousePosition)
            }, u.MOUSE_MOVE, n)
        }

        var v = function (i) {
            this._eventHandler = new s(i, !0), this._update = {}, this._movement = {}, this._lastMovement = {}, this._isDown = {}, this._eventStartPosition = {}, this._pressTime = {}, this._releaseTime = {}, this._buttonsDown = 0, this._currentMousePosition = new e, m(this, void 0), d(this, void 0, i), p(this, void 0, l.LEFT_DRAG), p(this, void 0, l.RIGHT_DRAG), p(this, void 0, l.MIDDLE_DRAG), _(this, void 0);
            for (var n in o)if (o.hasOwnProperty(n)) {
                var r = o[n];
                t(r) && (m(this, r), d(this, r, i), p(this, r, l.LEFT_DRAG), p(this, r, l.RIGHT_DRAG), p(this, r, l.MIDDLE_DRAG), _(this, r))
            }
        };
        return i(v.prototype, {
            currentMousePosition: {
                get: function () {
                    return this._currentMousePosition
                }
            }, anyButtonDown: {
                get: function () {
                    var e = !(this._update[c(l.WHEEL)] && this._update[c(l.WHEEL, o.SHIFT)] && this._update[c(l.WHEEL, o.CTRL)] && this._update[c(l.WHEEL, o.ALT)]);
                    return this._buttonsDown > 0 || e
                }
            }
        }), v.prototype.isMoving = function (e, t) {
            var i = c(e, t);
            return !this._update[i]
        }, v.prototype.getMovement = function (e, t) {
            var i = c(e, t), n = this._movement[i];
            return n
        }, v.prototype.getLastMovement = function (e, t) {
            var i = c(e, t), n = this._lastMovement[i];
            return n.valid ? n : void 0
        }, v.prototype.isButtonDown = function (e, t) {
            var i = c(e, t);
            return this._isDown[i]
        }, v.prototype.getStartMousePosition = function (e, t) {
            if (e === l.WHEEL || e === l.PINCH)return this._currentMousePosition;
            var i = c(e, t);
            return this._eventStartPosition[i]
        }, v.prototype.getButtonPressTime = function (e, t) {
            var i = c(e, t);
            return this._pressTime[i]
        }, v.prototype.getButtonReleaseTime = function (e, t) {
            var i = c(e, t);
            return this._releaseTime[i]
        }, v.prototype.reset = function () {
            for (var e in this._update)this._update.hasOwnProperty(e) && (this._update[e] = !0)
        }, v.prototype.isDestroyed = function () {
            return !1
        }, v.prototype.destroy = function () {
            return this._eventHandler = this._eventHandler && this._eventHandler.destroy(), n(this)
        }, v
    }),define("Cesium/Scene/TweenCollection", ["../Core/clone", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/DeveloperError", "../Core/EasingFunction", "../Core/getTimestamp", "../Core/TimeConstants", "../ThirdParty/Tween"], function (e, t, i, n, r, o, a, s, u) {
        "use strict";
        var l = function (t, i, n, r, o, a, s, u, l, c) {
            this._tweens = t, this._tweenjs = i, this._startObject = e(n), this._stopObject = e(r), this._duration = o, this._delay = a, this._easingFunction = s, this._update = u, this._complete = l, this.cancel = c, this.needsStart = !0
        };
        n(l.prototype, {
            startObject: {
                get: function () {
                    return this._startObject
                }
            }, stopObject: {
                get: function () {
                    return this._stopObject
                }
            }, duration: {
                get: function () {
                    return this._duration
                }
            }, delay: {
                get: function () {
                    return this._delay
                }
            }, easingFunction: {
                get: function () {
                    return this._easingFunction
                }
            }, update: {
                get: function () {
                    return this._update
                }
            }, complete: {
                get: function () {
                    return this._complete
                }
            }, tweenjs: {
                get: function () {
                    return this._tweenjs
                }
            }
        }), l.prototype.cancelTween = function () {
            this._tweens.remove(this)
        };
        var c = function () {
            this._tweens = []
        };
        return n(c.prototype, {
            length: {
                get: function () {
                    return this._tweens.length
                }
            }
        }), c.prototype.add = function (n) {
            if (n = t(n, t.EMPTY_OBJECT), 0 === n.duration)return i(n.complete) && n.complete(), new l(this);
            var r = n.duration / s.SECONDS_PER_MILLISECOND, a = t(n.delay, 0), c = a / s.SECONDS_PER_MILLISECOND, h = t(n.easingFunction, o.LINEAR_NONE), d = n.startObject, m = new u.Tween(d);
            m.to(e(n.stopObject), r), m.delay(c), m.easing(h), i(n.update) && m.onUpdate(function () {
                n.update(d)
            }), m.onComplete(t(n.complete, null)), m.repeat(t(n._repeat, 0));
            var p = new l(this, m, n.startObject, n.stopObject, n.duration, a, h, n.update, n.complete, n.cancel);
            return this._tweens.push(p), p
        }, c.prototype.addProperty = function (e) {
            function i(e) {
                n[r] = e.value
            }

            e = t(e, t.EMPTY_OBJECT);
            var n = e.object, r = e.property, o = e.startValue, a = e.stopValue;
            return this.add({
                startObject: {value: o},
                stopObject: {value: a},
                duration: t(e.duration, 3),
                delay: e.delay,
                easingFunction: e.easingFunction,
                update: i,
                complete: e.complete,
                cancel: e.cancel,
                _repeat: e._repeat
            })
        }, c.prototype.addAlpha = function (e) {
            function n(e) {
                for (var t = o.length, i = 0; t > i; ++i)r.uniforms[o[i]].alpha = e.alpha
            }

            e = t(e, t.EMPTY_OBJECT);
            var r = e.material, o = [];
            for (var a in r.uniforms)r.uniforms.hasOwnProperty(a) && i(r.uniforms[a]) && i(r.uniforms[a].alpha) && o.push(a);
            return this.add({
                startObject: {alpha: t(e.startValue, 0)},
                stopObject: {alpha: t(e.stopValue, 1)},
                duration: t(e.duration, 3),
                delay: e.delay,
                easingFunction: e.easingFunction,
                update: n,
                complete: e.complete,
                cancel: e.cancel
            })
        }, c.prototype.addOffsetIncrement = function (e) {
            e = t(e, t.EMPTY_OBJECT);
            var i = e.material, n = i.uniforms;
            return this.addProperty({
                object: n,
                property: "offset",
                startValue: n.offset,
                stopValue: n.offset + 1,
                duration: e.duration,
                delay: e.delay,
                easingFunction: e.easingFunction,
                update: e.update,
                cancel: e.cancel,
                _repeat: 1 / 0
            })
        }, c.prototype.remove = function (e) {
            if (!i(e))return !1;
            var t = this._tweens.indexOf(e);
            return -1 !== t ? (e.tweenjs.stop(), i(e.cancel) && e.cancel(), this._tweens.splice(t, 1), !0) : !1
        }, c.prototype.removeAll = function () {
            for (var e = this._tweens, t = 0; t < e.length; ++t) {
                var n = e[t];
                n.tweenjs.stop(), i(n.cancel) && n.cancel()
            }
            e.length = 0
        }, c.prototype.contains = function (e) {
            return i(e) && -1 !== this._tweens.indexOf(e)
        }, c.prototype.get = function (e) {
            return this._tweens[e]
        }, c.prototype.update = function (e) {
            var t = this._tweens, n = 0;
            for (e = i(e) ? e / s.SECONDS_PER_MILLISECOND : a(); n < t.length;) {
                var r = t[n], o = r.tweenjs;
                r.needsStart ? (r.needsStart = !1, o.start(e)) : o.update(e) ? n++ : (o.stop(), t.splice(n, 1))
            }
        }, c
    }),define("Cesium/Scene/ScreenSpaceCameraController", ["../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/Cartographic", "../Core/defaultValue", "../Core/defined", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Ellipsoid", "../Core/IntersectionTests", "../Core/isArray", "../Core/KeyboardEventModifier", "../Core/Math", "../Core/Matrix3", "../Core/Matrix4", "../Core/Plane", "../Core/Quaternion", "../Core/Ray", "../Core/Transforms", "./CameraEventAggregator", "./CameraEventType", "./SceneMode", "./SceneTransforms", "./TweenCollection"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S, T) {
        "use strict";
        function b(e, t) {
            if (0 > e)return 0;
            var i = 25 * (1 - t);
            return Math.exp(-i * e)
        }

        function w(t) {
            return e.equalsEpsilon(t.startPosition, t.endPosition, d.EPSILON14)
        }

        function x(t, i, n, r, a, s, u) {
            var l = s[u];
            o(l) || (l = s[u] = {startPosition: new e, endPosition: new e, motion: new e, active: !1});
            var c = t.getButtonPressTime(i, n), h = t.getButtonReleaseTime(i, n), d = c && h && (h.getTime() - c.getTime()) / 1e3, m = new Date, p = h && (m.getTime() - h.getTime()) / 1e3;
            if (c && h && $ > d) {
                var f = b(p, r);
                if (l.active)l.startPosition = e.clone(l.endPosition, l.startPosition), l.endPosition = e.multiplyByScalar(l.motion, f, l.endPosition), l.endPosition = e.add(l.startPosition, l.endPosition, l.endPosition), l.motion = e.clone(e.ZERO, l.motion); else {
                    var _ = t.getLastMovement(i, n);
                    if (!o(_) || w(_))return;
                    l.motion.x = .5 * (_.endPosition.x - _.startPosition.x), l.motion.y = .5 * (_.endPosition.y - _.startPosition.y), l.startPosition = e.clone(_.startPosition, l.startPosition), l.endPosition = e.multiplyByScalar(l.motion, f, l.endPosition), l.endPosition = e.add(l.startPosition, l.endPosition, l.endPosition), l.active = !0
                }
                if (isNaN(l.endPosition.x) || isNaN(l.endPosition.y) || w(l))return void(l.active = !1);
                if (!t.isButtonDown(i, n)) {
                    var v = t.getStartMousePosition(i, n);
                    a(s, v, l)
                }
            } else l.active = !1
        }

        function A(e, t, i, n, r, a) {
            if (o(i)) {
                var s = e._aggregator;
                c(i) || (ee[0] = i, i = ee);
                for (var u = i.length, l = 0; u > l; ++l) {
                    var h = i[l], d = o(h.eventType) ? h.eventType : h, m = h.modifier, p = s.isMoving(d, m) && s.getMovement(d, m), f = s.getStartMousePosition(d, m);
                    e.enableInputs && t && (p ? n(e, f, p) : 1 > r && x(s, d, m, r, n, e, a))
                }
            }
        }

        function P(i, n, r, a, s, u) {
            var l = 1;
            o(u) && (l = d.clamp(Math.abs(u), .25, 1));
            var c = i.minimumZoomDistance * l, h = i.maximumZoomDistance, m = s - c, p = a * m;
            p = d.clamp(p, i._minimumZoomRate, i._maximumZoomRate);
            var f = r.endPosition.y - r.startPosition.y, _ = f / i._scene.canvas.clientHeight;
            _ = Math.min(_, i.maximumMovementRatio);
            var v = p * _;
            if (!(v > 0 && Math.abs(s - c) < 1 || 0 > v && Math.abs(s - h) < 1)) {
                c > s - v ? v = s - c - 1 : s - v > h && (v = s - h);
                var g, y = i._scene, C = y.camera, T = y.mode;
                if (o(i._globe) && (g = T !== E.SCENE2D ? N(i, n, ie) : C.getPickRay(n, te).origin), !o(g))return void C.zoomIn(v);
                var b = e.equals(n, i._zoomMouseStart), w = i._zoomingOnVector, x = i._rotatingZoom;
                b || (i._zoomMouseStart = e.clone(n, i._zoomMouseStart), i._zoomWorldPosition = t.clone(g, i._zoomWorldPosition), w = i._zoomingOnVector = !1, x = i._rotatingZoom = !1);
                var A = T === E.COLUMBUS_VIEW;
                if (!b || x) {
                    if (T === E.SCENE2D) {
                        var P = i._zoomWorldPosition, I = C.position;
                        if (!t.equals(P, I)) {
                            var D = t.subtract(P, I, re);
                            t.normalize(D, D);
                            var M = t.distance(P, I) * v / (.5 * C.getMagnitude());
                            C.move(D, .5 * M)
                        }
                    } else if (T === E.SCENE3D) {
                        var O = t.normalize(C.position, ce);
                        if (C.positionCartographic.height < 3e3 && Math.abs(t.dot(C.direction, O)) < .6)A = !0; else {
                            var R = y.canvas, L = oe;
                            L.x = R.clientWidth / 2, L.y = R.clientHeight / 2;
                            var F = N(i, L, ae);
                            if (o(F)) {
                                var B = t.normalize(F, se), z = t.normalize(i._zoomWorldPosition, ue), V = t.dot(z, B);
                                if (V > 0) {
                                    var U = d.acosClamped(V), k = t.cross(z, B, le), G = Math.abs(U) > d.toRadians(20) ? .75 * C.positionCartographic.height : C.positionCartographic.height - v, H = v / G;
                                    C.rotate(k, U * H)
                                }
                            } else A = !0
                        }
                    }
                    i._rotatingZoom = !A
                }
                if (!b && A || w) {
                    var W, q = S.wgs84ToWindowCoordinates(y, i._zoomWorldPosition, ne);
                    W = T !== E.COLUMBUS_VIEW && e.equals(n, i._zoomMouseStart) && o(q) ? C.getPickRay(q, te) : C.getPickRay(n, te);
                    var j = W.direction;
                    T === E.COLUMBUS_VIEW && t.fromElements(j.y, j.z, j.x, j), C.move(j, v), i._zoomingOnVector = !0
                } else C.zoomIn(v)
            }
        }

        function I(e, i, n) {
            var r = e._scene, o = r.camera, a = o.getPickRay(n.startPosition, he).origin, s = o.getPickRay(n.endPosition, de).origin, u = t.subtract(a, s, me), l = t.magnitude(u);
            l > 0 && (t.normalize(u, u), o.move(u, l))
        }

        function D(e, t, i) {
            o(i.distance) && (i = i.distance);
            var n = e._scene, r = n.camera;
            P(e, t, i, e._zoomFactor, r.getMagnitude())
        }

        function M(t, i, n) {
            if (o(n.angleAndHeight))return void O(t, i, n.angleAndHeight);
            var r = t._scene, a = r.camera, s = r.canvas, u = s.clientWidth, l = s.clientHeight, c = pe;
            c.x = 2 / u * n.startPosition.x - 1, c.y = 2 / l * (l - n.startPosition.y) - 1, c = e.normalize(c, c);
            var h = fe;
            h.x = 2 / u * n.endPosition.x - 1, h.y = 2 / l * (l - n.endPosition.y) - 1, h = e.normalize(h, h);
            var m = d.acosClamped(c.x);
            c.y < 0 && (m = d.TWO_PI - m);
            var p = d.acosClamped(h.x);
            h.y < 0 && (p = d.TWO_PI - p);
            var f = p - m;
            a.twistRight(f)
        }

        function O(e, t, i) {
            var n = e._rotateFactor * e._rotateRateRangeAdjustment;
            n > e._maximumRotateRate && (n = e._maximumRotateRate), n < e._minimumRotateRate && (n = e._minimumRotateRate);
            var r = e._scene, o = r.camera, a = r.canvas, s = (i.endPosition.x - i.startPosition.x) / a.clientWidth;
            s = Math.min(s, e.maximumMovementRatio);
            var u = n * s * Math.PI * 4;
            o.twistRight(u)
        }

        function R(e) {
            var t = e._tweens;
            e._aggregator.anyButtonDown && t.removeAll();
            var i = e._scene, n = i.camera;
            if (t.contains(e._tween) || (p.equals(p.IDENTITY, n.transform) ? (A(e, e.enableTranslate, e.translateEventTypes, I, e.inertiaTranslate, "_lastInertiaTranslateMovement"), A(e, e.enableZoom, e.zoomEventTypes, D, e.inertiaZoom, "_lastInertiaZoomMovement"), A(e, e.enableRotate, e.tiltEventTypes, M, e.inertiaSpin, "_lastInertiaTiltMovement")) : (A(e, e.enableRotate, e.translateEventTypes, M, e.inertiaSpin, "_lastInertiaSpinMovement"), A(e, e.enableZoom, e.zoomEventTypes, D, e.inertiaZoom, "_lastInertiaZoomMovement"))), !(e._aggregator.anyButtonDown || o(e._lastInertiaZoomMovement) && e._lastInertiaZoomMovement.active || o(e._lastInertiaTranslateMovement) && e._lastInertiaTranslateMovement.active || t.contains(e._tween))) {
                var r = n.createCorrectPositionTween(e.bounceAnimationTime);
                o(r) && (e._tween = t.add(r))
            }
            t.update()
        }

        function N(e, i, n) {
            var r = e._scene, a = e._globe, s = r.camera;
            if (!o(a))return void 0;
            var u;
            r.pickPositionSupported && (u = r.pickPosition(i, ve));
            var l = s.getPickRay(i, _e), c = a.pick(l, r, ge), h = o(u) ? t.distance(u, s.positionWC) : Number.POSITIVE_INFINITY, d = o(c) ? t.distance(c, s.positionWC) : Number.POSITIVE_INFINITY;
            return d > h ? t.clone(u, n) : t.clone(c, n)
        }

        function L(i, n, r) {
            if (t.equals(n, i._translateMousePosition) || (i._looking = !1), t.equals(n, i._strafeMousePosition) || (i._strafing = !1), i._looking)return void Z(i, n, r);
            if (i._strafing)return void k(i, n, r);
            var a, s = i._scene, u = s.camera, c = e.clone(r.startPosition, xe), h = e.clone(r.endPosition, Ae), m = u.getPickRay(c, ye), p = t.clone(t.ZERO, be), _ = t.UNIT_X;
            if (u.position.z < i.minimumPickingTerrainHeight && (a = N(i, c, Ee), o(a) && (p.x = a.x)), p.x > u.position.z && o(a))return t.clone(a, i._strafeStartPosition), i._strafing = !0, k(i, n, r), void(i._strafeMousePosition = e.clone(n, i._strafeMousePosition));
            var v = f.fromPointNormal(p, _, we);
            m = u.getPickRay(c, ye);
            var g = l.rayPlane(m, v, Ee), y = u.getPickRay(h, Ce), C = l.rayPlane(y, v, Se);
            if (!o(g) || !o(C))return i._looking = !0, Z(i, n, r), void e.clone(n, i._translateMousePosition);
            var E = t.subtract(g, C, Te), S = E.x;
            E.x = E.y, E.y = E.z, E.z = S;
            var T = t.magnitude(E);
            T > d.EPSILON6 && (t.normalize(E, E), u.move(E, T))
        }

        function F(t, i, n) {
            if (o(n.angleAndHeight) && (n = n.angleAndHeight), e.equals(i, t._tiltCenterMousePosition) || (t._tiltCVOffMap = !1, t._looking = !1), t._looking)return void Z(t, i, n);
            var r = t._scene, a = r.camera, s = t._maxCoord, u = Math.abs(a.position.x) - s.x < 0 && Math.abs(a.position.y) - s.y < 0;
            t._tiltCVOffMap || !u || a.position.z > t.minimumPickingTerrainHeight ? (t._tiltCVOffMap = !0, B(t, i, n)) : z(t, i, n)
        }

        function B(i, n, r) {
            var a = i._scene, s = a.camera, l = a.canvas, c = Pe;
            c.x = l.clientWidth / 2, c.y = l.clientHeight / 2;
            var h, m = s.getPickRay(c, Ie), f = t.UNIT_X, _ = m.origin, v = m.direction, y = t.dot(f, v);
            if (Math.abs(y) > d.EPSILON6 && (h = -t.dot(f, _) / y), !o(h) || 0 >= h)return i._looking = !0, Z(i, n, r), void e.clone(n, i._tiltCenterMousePosition);
            var C = t.multiplyByScalar(v, h, De);
            t.add(_, C, C);
            var E = a.mapProjection, S = E.ellipsoid;
            t.fromElements(C.y, C.z, C.x, C);
            var T = E.unproject(C, Be);
            S.cartographicToCartesian(T, C);
            var b = g.eastNorthUpToFixedFrame(C, S, Oe), w = i._globe, x = i._ellipsoid;
            i._globe = void 0, i._ellipsoid = u.UNIT_SPHERE, i._rotateFactor = 1, i._rotateRateRangeAdjustment = 1;
            var A = p.clone(s.transform, ze);
            s._setTransform(b), H(i, n, r, t.UNIT_Z), s._setTransform(A), i._globe = w, i._ellipsoid = x;
            var P = x.maximumRadius;
            i._rotateFactor = 1 / P, i._rotateRateRangeAdjustment = P
        }

        function z(i, n, r) {
            var a, s, c = i._ellipsoid, h = i._scene, v = h.camera, y = t.UNIT_X;
            if (e.equals(n, i._tiltCenterMousePosition))a = t.clone(i._tiltCenter, De); else {
                if (v.position.z < i.minimumPickingTerrainHeight && (a = N(i, n, De)), !o(a)) {
                    s = v.getPickRay(n, Ie);
                    var C, E = s.origin, S = s.direction, T = t.dot(y, S);
                    if (Math.abs(T) > d.EPSILON6 && (C = -t.dot(y, E) / T), !o(C) || 0 >= C)return i._looking = !0, Z(i, n, r), void e.clone(n, i._tiltCenterMousePosition);
                    a = t.multiplyByScalar(S, C, De), t.add(E, a, a)
                }
                e.clone(n, i._tiltCenterMousePosition), t.clone(a, i._tiltCenter)
            }
            var b = h.canvas, w = Pe;
            w.x = b.clientWidth / 2, w.y = i._tiltCenterMousePosition.y, s = v.getPickRay(w, Ie);
            var x = t.clone(t.ZERO, Ne);
            x.x = a.x;
            var A = f.fromPointNormal(x, y, Le), P = l.rayPlane(s, A, Me), I = v._projection;
            c = I.ellipsoid, t.fromElements(a.y, a.z, a.x, a);
            var D = I.unproject(a, Be);
            c.cartographicToCartesian(D, a);
            var M, O = g.eastNorthUpToFixedFrame(a, c, Oe);
            o(P) ? (t.fromElements(P.y, P.z, P.x, P), D = I.unproject(P, Be), c.cartographicToCartesian(D, P), M = g.eastNorthUpToFixedFrame(P, c, Re)) : M = O;
            var R = i._globe, L = i._ellipsoid;
            i._globe = void 0, i._ellipsoid = u.UNIT_SPHERE, i._rotateFactor = 1, i._rotateRateRangeAdjustment = 1;
            var F = t.UNIT_Z, B = p.clone(v.transform, ze);
            v._setTransform(O);
            var z = t.cross(t.UNIT_Z, t.normalize(v.position, Fe), Fe), V = t.dot(v.right, z);
            if (H(i, n, r, F, !1, !0), v._setTransform(M), 0 > V) {
                r.startPosition.y > r.endPosition.y && (F = void 0);
                var U = v.constrainedAxis;
                v.constrainedAxis = void 0, H(i, n, r, F, !0, !1), v.constrainedAxis = U
            } else H(i, n, r, F, !0, !1);
            if (o(v.constrainedAxis)) {
                var k = t.cross(v.direction, v.constrainedAxis, _t);
                t.equalsEpsilon(k, t.ZERO, d.EPSILON6) || (t.dot(k, v.right) < 0 && t.negate(k, k), t.cross(k, v.direction, v.up), t.cross(v.direction, v.up, v.right), t.normalize(v.up, v.up), t.normalize(v.right, v.right))
            }
            v._setTransform(B), i._globe = R, i._ellipsoid = L;
            var G = L.maximumRadius;
            i._rotateFactor = 1 / G, i._rotateRateRangeAdjustment = G;
            var W = t.clone(v.positionWC, Fe);
            if (J(i), !t.equals(v.positionWC, W)) {
                v._setTransform(M), v.worldToCameraCoordinatesPoint(W, W);
                var q = t.magnitudeSquared(W);
                t.magnitudeSquared(v.position) > q && (t.normalize(v.position, v.position), t.multiplyByScalar(v.position, Math.sqrt(q), v.position));
                var j = t.angleBetween(W, v.position), Y = t.cross(W, v.position, W);
                t.normalize(Y, Y);
                var X = _.fromAxisAngle(Y, j, Ve), K = m.fromQuaternion(X, Ue);
                m.multiplyByVector(K, v.direction, v.direction), m.multiplyByVector(K, v.up, v.up), t.cross(v.direction, v.up, v.right), t.cross(v.right, v.direction, v.up), v._setTransform(B)
            }
        }

        function V(e, i, n) {
            o(n.distance) && (n = n.distance);
            var r = e._scene, a = r.camera, s = r.canvas, u = ke;
            u.x = s.clientWidth / 2, u.y = s.clientHeight / 2;
            var l, c = a.getPickRay(u, Ge);
            a.position.z < e.minimumPickingTerrainHeight && (l = N(e, u, He));
            var h;
            if (o(l))h = t.distance(c.origin, l); else {
                var d = t.UNIT_X, m = c.origin, p = c.direction;
                h = -t.dot(d, m) / t.dot(d, p)
            }
            P(e, i, n, e._zoomFactor, h)
        }

        function U(e) {
            var t = e._scene, i = t.camera;
            if (p.equals(p.IDENTITY, i.transform)) {
                var n = e._tweens;
                if (e._aggregator.anyButtonDown && n.removeAll(), A(e, e.enableTilt, e.tiltEventTypes, F, e.inertiaSpin, "_lastInertiaTiltMovement"), A(e, e.enableTranslate, e.translateEventTypes, L, e.inertiaTranslate, "_lastInertiaTranslateMovement"), A(e, e.enableZoom, e.zoomEventTypes, V, e.inertiaZoom, "_lastInertiaZoomMovement"), A(e, e.enableLook, e.lookEventTypes, Z), !(e._aggregator.anyButtonDown || o(e._lastInertiaZoomMovement) && e._lastInertiaZoomMovement.active || o(e._lastInertiaTranslateMovement) && e._lastInertiaTranslateMovement.active || n.contains(e._tween))) {
                    var r = i.createCorrectPositionTween(e.bounceAnimationTime);
                    o(r) && (e._tween = n.add(r))
                }
                n.update()
            } else A(e, e.enableRotate, e.rotateEventTypes, H, e.inertiaSpin, "_lastInertiaSpinMovement"), A(e, e.enableZoom, e.zoomEventTypes, q, e.inertiaZoom, "_lastInertiaZoomMovement")
        }

        function k(e, i, n) {
            var r = e._scene, a = r.camera, s = N(e, n.startPosition, Ke);
            if (o(s)) {
                var u = n.endPosition, c = a.getPickRay(u, We), h = t.clone(a.direction, Ye);
                r.mode === E.COLUMBUS_VIEW && t.fromElements(h.z, h.x, h.y, h);
                var d = f.fromPointNormal(s, h, qe), m = l.rayPlane(c, d, je);
                o(m) && (h = t.subtract(s, m, h), r.mode === E.COLUMBUS_VIEW && t.fromElements(h.y, h.z, h.x, h), t.add(a.position, h, a.position))
            }
        }

        function G(i, n, r) {
            var a = i._scene, s = a.camera;
            if (!p.equals(s.transform, p.IDENTITY))return void H(i, n, r);
            var l, c, h, d, m = i._ellipsoid.geodeticSurfaceNormal(s.position, $e), f = i._ellipsoid.cartesianToCartographic(s.positionWC, Ze).height, _ = i._globe, v = !1;
            if (o(_) && f < i.minimumPickingTerrainHeight && (d = N(i, r.startPosition, Ke), o(d))) {
                var g = s.getPickRay(r.startPosition, _e), y = i._ellipsoid.geodeticSurfaceNormal(d);
                v = Math.abs(t.dot(g.direction, y)) < .05, v && !i._looking && (i._rotating = !1, i._strafing = !0)
            }
            return e.equals(n, i._rotateMousePosition) ? void(i._looking ? Z(i, n, r, m) : i._rotating ? H(i, n, r) : i._strafing ? (t.clone(d, i._strafeStartPosition), k(i, n, r)) : (l = t.magnitude(i._rotateStartPosition), c = Je, c.x = c.y = c.z = l, h = u.fromCartesian3(c, Qe), W(i, n, r, h))) : (i._looking = !1, i._rotating = !1, i._strafing = !1, o(_) && f < i.minimumPickingTerrainHeight ? o(d) ? t.magnitude(s.position) < t.magnitude(d) ? (t.clone(d, i._strafeStartPosition), i._strafing = !0, k(i, n, r)) : (l = t.magnitude(d), c = Je, c.x = c.y = c.z = l, h = u.fromCartesian3(c, Qe), W(i, n, r, h), t.clone(d, i._rotateStartPosition)) : (i._looking = !0, Z(i, n, r, m)) : o(s.pickEllipsoid(r.startPosition, i._ellipsoid, Xe)) ? (W(i, n, r, i._ellipsoid), t.clone(Xe, i._rotateStartPosition)) : f > i.minimumTrackBallHeight ? (i._rotating = !0, H(i, n, r)) : (i._looking = !0, Z(i, n, r, m)), void e.clone(n, i._rotateMousePosition))
        }

        function H(e, i, n, a, s, u) {
            s = r(s, !1), u = r(u, !1);
            var l = e._scene, c = l.camera, h = l.canvas, d = c.constrainedAxis;
            o(a) && (c.constrainedAxis = a);
            var m = t.magnitude(c.position), p = e._rotateFactor * (m - e._rotateRateRangeAdjustment);
            p > e._maximumRotateRate && (p = e._maximumRotateRate), p < e._minimumRotateRate && (p = e._minimumRotateRate);
            var f = (n.startPosition.x - n.endPosition.x) / h.clientWidth, _ = (n.startPosition.y - n.endPosition.y) / h.clientHeight;
            f = Math.min(f, e.maximumMovementRatio), _ = Math.min(_, e.maximumMovementRatio);
            var v = p * f * Math.PI * 2, g = p * _ * Math.PI;
            s || c.rotateRight(v), u || c.rotateUp(g), c.constrainedAxis = d
        }

        function W(i, n, r, a) {
            var s = i._scene, u = s.camera, l = e.clone(r.startPosition, at), c = e.clone(r.endPosition, st), h = u.pickEllipsoid(l, a, et), m = u.pickEllipsoid(c, a, tt);
            if (!o(h) || !o(m))return i._rotating = !0, void H(i, n, r);
            if (h = u.worldToCameraCoordinates(h, h), m = u.worldToCameraCoordinates(m, m), o(u.constrainedAxis)) {
                var p = u.constrainedAxis, f = t.mostOrthogonalAxis(p, it);
                t.cross(f, p, f), t.normalize(f, f);
                var _ = t.cross(p, f, nt), v = t.magnitude(h), g = t.dot(p, h), y = Math.acos(g / v), C = t.multiplyByScalar(p, g, rt);
                t.subtract(h, C, C), t.normalize(C, C);
                var E = t.magnitude(m), S = t.dot(p, m), T = Math.acos(S / E), b = t.multiplyByScalar(p, S, ot);
                t.subtract(m, b, b), t.normalize(b, b);
                var w = Math.acos(t.dot(C, f));
                t.dot(C, _) < 0 && (w = d.TWO_PI - w);
                var x = Math.acos(t.dot(b, f));
                t.dot(b, _) < 0 && (x = d.TWO_PI - x);
                var A, P = w - x;
                A = t.equalsEpsilon(p, u.position, d.EPSILON2) ? u.right : t.cross(p, u.position, it);
                var I, D = t.cross(p, A, it), M = t.dot(D, t.subtract(h, p, nt)), O = t.dot(D, t.subtract(m, p, nt));
                I = M > 0 && O > 0 ? T - y : M > 0 && 0 >= O ? t.dot(u.position, p) > 0 ? -y - T : y + T : y - T, u.rotateRight(P), u.rotateUp(I)
            } else {
                t.normalize(h, h), t.normalize(m, m);
                var R = t.dot(h, m), N = t.cross(h, m, it);
                if (1 > R && !t.equalsEpsilon(N, t.ZERO, d.EPSILON14)) {
                    var L = Math.acos(R);
                    u.rotate(N, L)
                }
            }
        }

        function q(e, i, n) {
            o(n.distance) && (n = n.distance);
            var r = e._ellipsoid, a = e._scene, s = a.camera, u = a.canvas, l = ke;
            l.x = u.clientWidth / 2, l.y = u.clientHeight / 2;
            var c, h = s.getPickRay(l, Ge), d = r.cartesianToCartographic(s.position, lt).height;
            d < e.minimumPickingTerrainHeight && (c = N(e, l, He));
            var m;
            m = o(c) ? t.distance(h.origin, c) : d;
            var p = t.normalize(s.position, ut);
            P(e, i, n, e._zoomFactor, m, t.dot(p, s.direction))
        }

        function j(t, i, n) {
            var r = t._scene, a = r.camera;
            if (p.equals(a.transform, p.IDENTITY)) {
                if (o(n.angleAndHeight) && (n = n.angleAndHeight), e.equals(i, t._tiltCenterMousePosition) || (t._tiltOnEllipsoid = !1, t._looking = !1), t._looking) {
                    var s = t._ellipsoid.geodeticSurfaceNormal(a.position, Et);
                    return void Z(t, i, n, s)
                }
                var u = t._ellipsoid, l = u.cartesianToCartographic(a.position, Ct);
                t._tiltOnEllipsoid || l.height > t.minimumCollisionTerrainHeight ? (t._tiltOnEllipsoid = !0, Y(t, i, n)) : X(t, i, n)
            }
        }

        function Y(i, n, r) {
            var a = i._ellipsoid, s = i._scene, c = s.camera, h = .25 * i.minimumZoomDistance, m = a.cartesianToCartographic(c.positionWC, St).height;
            if (!(m - h - 1 < d.EPSILON3 && r.endPosition.y - r.startPosition.y < 0)) {
                var f = s.canvas, _ = ct;
                _.x = f.clientWidth / 2, _.y = f.clientHeight / 2;
                var y, C = c.getPickRay(_, ht), E = l.rayEllipsoid(C, a);
                if (o(E))y = v.getPoint(C, E.start, dt); else {
                    if (!(m > i.minimumTrackBallHeight)) {
                        i._looking = !0;
                        var S = i._ellipsoid.geodeticSurfaceNormal(c.position, Et);
                        return Z(i, n, r, S), void e.clone(n, i._tiltCenterMousePosition)
                    }
                    var T = l.grazingAltitudeLocation(C, a);
                    if (!o(T))return;
                    var b = a.cartesianToCartographic(T, Ct);
                    b.height = 0, y = a.cartographicToCartesian(b, dt)
                }
                var w = g.eastNorthUpToFixedFrame(y, a, pt), x = i._globe, A = i._ellipsoid;
                i._globe = void 0, i._ellipsoid = u.UNIT_SPHERE, i._rotateFactor = 1, i._rotateRateRangeAdjustment = 1;
                var P = p.clone(c.transform, vt);
                c._setTransform(w), H(i, n, r, t.UNIT_Z), c._setTransform(P), i._globe = x, i._ellipsoid = A;
                var I = A.maximumRadius;
                i._rotateFactor = 1 / I, i._rotateRateRangeAdjustment = I
            }
        }

        function X(i, n, r) {
            var a, s, c, h = i._ellipsoid, f = i._scene, y = f.camera;
            if (e.equals(n, i._tiltCenterMousePosition))a = t.clone(i._tiltCenter, dt); else {
                if (a = N(i, n, dt), !o(a)) {
                    if (s = y.getPickRay(n, ht), c = l.rayEllipsoid(s, h), !o(c)) {
                        var C = h.cartesianToCartographic(y.position, Ct);
                        if (C.height <= i.minimumTrackBallHeight) {
                            i._looking = !0;
                            var E = i._ellipsoid.geodeticSurfaceNormal(y.position, Et);
                            Z(i, n, r, E), e.clone(n, i._tiltCenterMousePosition)
                        }
                        return
                    }
                    a = v.getPoint(s, c.start, dt)
                }
                e.clone(n, i._tiltCenterMousePosition), t.clone(a, i._tiltCenter)
            }
            var S = f.canvas, T = ct;
            T.x = S.clientWidth / 2, T.y = i._tiltCenterMousePosition.y, s = y.getPickRay(T, ht);
            var b = t.magnitude(a), w = t.fromElements(b, b, b, Je), x = u.fromCartesian3(w, Qe);
            if (c = l.rayEllipsoid(s, x), o(c)) {
                var A = t.magnitude(s.origin) > b ? c.start : c.stop, P = v.getPoint(s, A, mt), I = g.eastNorthUpToFixedFrame(a, h, pt), D = g.eastNorthUpToFixedFrame(P, x, ft), M = i._globe, O = i._ellipsoid;
                i._globe = void 0, i._ellipsoid = u.UNIT_SPHERE, i._rotateFactor = 1, i._rotateRateRangeAdjustment = 1;
                var R = t.UNIT_Z, L = p.clone(y.transform, vt);
                y._setTransform(I);
                var F = t.cross(P, y.positionWC, _t), B = t.dot(y.rightWC, F);
                if (H(i, n, r, R, !1, !0), y._setTransform(D), 0 > B) {
                    r.startPosition.y > r.endPosition.y && (R = void 0);
                    var z = y.constrainedAxis;
                    y.constrainedAxis = void 0, H(i, n, r, R, !0, !1), y.constrainedAxis = z
                } else H(i, n, r, R, !0, !1);
                if (o(y.constrainedAxis)) {
                    var V = t.cross(y.direction, y.constrainedAxis, _t);
                    t.equalsEpsilon(V, t.ZERO, d.EPSILON6) || (t.dot(V, y.right) < 0 && t.negate(V, V), t.cross(V, y.direction, y.up), t.cross(y.direction, y.up, y.right), t.normalize(y.up, y.up), t.normalize(y.right, y.right))
                }
                y._setTransform(L), i._globe = M, i._ellipsoid = O;
                var U = O.maximumRadius;
                i._rotateFactor = 1 / U, i._rotateRateRangeAdjustment = U;
                var k = t.clone(y.positionWC, _t);
                if (J(i), !t.equals(y.positionWC, k)) {
                    y._setTransform(D), y.worldToCameraCoordinatesPoint(k, k);
                    var G = t.magnitudeSquared(k);
                    t.magnitudeSquared(y.position) > G && (t.normalize(y.position, y.position), t.multiplyByScalar(y.position, Math.sqrt(G), y.position));
                    var W = t.angleBetween(k, y.position), q = t.cross(k, y.position, k);
                    t.normalize(q, q);
                    var j = _.fromAxisAngle(q, W, gt), Y = m.fromQuaternion(j, yt);
                    m.multiplyByVector(Y, y.direction, y.direction), m.multiplyByVector(Y, y.up, y.up), t.cross(y.direction, y.up, y.right), t.cross(y.right, y.direction, y.up), y._setTransform(L)
                }
            }
        }

        function Z(e, i, n, a) {
            var s = e._scene, u = s.camera, l = Tt;
            l.x = n.startPosition.x, l.y = 0;
            var c = bt;
            c.x = n.endPosition.x, c.y = 0;
            var h = u.getPickRay(l, wt).direction, m = u.getPickRay(c, xt).direction, p = 0, f = t.dot(h, m);
            1 > f && (p = Math.acos(f)), p = n.startPosition.x > n.endPosition.x ? -p : p;
            var _ = e._horizontalRotationAxis;
            if (o(a) ? u.look(a, -p) : o(_) ? u.look(_, -p) : u.lookLeft(p), l.x = 0, l.y = n.startPosition.y, c.x = 0, c.y = n.endPosition.y, h = u.getPickRay(l, wt).direction, m = u.getPickRay(c, xt).direction, p = 0, f = t.dot(h, m), 1 > f && (p = Math.acos(f)), p = n.startPosition.y > n.endPosition.y ? -p : p, a = r(a, _), o(a)) {
                var v = u.direction, g = t.negate(a, At), y = t.equalsEpsilon(v, a, d.EPSILON2), C = t.equalsEpsilon(v, g, d.EPSILON2);
                if (y || C)(y && 0 > p || C && p > 0) && u.look(u.right, -p); else {
                    f = t.dot(v, a);
                    var E = d.acosClamped(f);
                    p > 0 && p > E && (p = E - d.EPSILON4), f = t.dot(v, g), E = d.acosClamped(f), 0 > p && -p > E && (p = -E + d.EPSILON4);
                    var S = t.cross(a, v, Pt);
                    u.look(S, p)
                }
            } else u.lookUp(p)
        }

        function K(e) {
            A(e, e.enableRotate, e.rotateEventTypes, G, e.inertiaSpin, "_lastInertiaSpinMovement"), A(e, e.enableZoom, e.zoomEventTypes, q, e.inertiaZoom, "_lastInertiaZoomMovement"), A(e, e.enableTilt, e.tiltEventTypes, j, e.inertiaSpin, "_lastInertiaTiltMovement"),
                A(e, e.enableLook, e.lookEventTypes, Z)
        }

        function J(e) {
            if (e.enableCollisionDetection) {
                var i = e._scene, n = i.mode, r = i.globe;
                if (o(r) && n !== E.SCENE2D && n !== E.MORPHING) {
                    var a, s, u = i.camera, l = r.ellipsoid, c = i.mapProjection;
                    p.equals(u.transform, p.IDENTITY) || (a = p.clone(u.transform), s = t.magnitude(u.position), u._setTransform(p.IDENTITY));
                    var h = It;
                    n === E.SCENE3D ? l.cartesianToCartographic(u.position, h) : c.unproject(u.position, h);
                    var d = !1;
                    if (h.height < e.minimumCollisionTerrainHeight) {
                        var m = r.getHeight(h);
                        o(m) && (m += e.minimumZoomDistance, h.height < m && (h.height = m, n === E.SCENE3D ? l.cartographicToCartesian(h, u.position) : c.project(h, u.position), d = !0))
                    }
                    o(a) && (u._setTransform(a), d && (t.normalize(u.position, u.position), t.negate(u.position, u.direction), t.multiplyByScalar(u.position, Math.max(s, e.minimumZoomDistance), u.position), t.normalize(u.direction, u.direction), t.cross(u.direction, u.up, u.right), t.cross(u.right, u.direction, u.up)))
                }
            }
        }

        var Q = function (i) {
            this.enableInputs = !0, this.enableTranslate = !0, this.enableZoom = !0, this.enableRotate = !0, this.enableTilt = !0, this.enableLook = !0, this.inertiaSpin = .9, this.inertiaTranslate = .9, this.inertiaZoom = .8, this.maximumMovementRatio = .1, this.bounceAnimationTime = 3, this.minimumZoomDistance = 1, this.maximumZoomDistance = Number.POSITIVE_INFINITY, this.translateEventTypes = C.LEFT_DRAG, this.zoomEventTypes = [C.RIGHT_DRAG, C.WHEEL, C.PINCH], this.rotateEventTypes = C.LEFT_DRAG, this.tiltEventTypes = [C.MIDDLE_DRAG, C.PINCH, {
                eventType: C.LEFT_DRAG,
                modifier: h.CTRL
            }, {eventType: C.RIGHT_DRAG, modifier: h.CTRL}], this.lookEventTypes = {
                eventType: C.LEFT_DRAG,
                modifier: h.SHIFT
            }, this.minimumPickingTerrainHeight = 15e4, this.minimumCollisionTerrainHeight = 15e3, this.minimumTrackBallHeight = 75e5, this.enableCollisionDetection = !0, this._scene = i, this._globe = void 0, this._ellipsoid = void 0, this._aggregator = new y(i.canvas), this._lastInertiaSpinMovement = void 0, this._lastInertiaZoomMovement = void 0, this._lastInertiaTranslateMovement = void 0, this._lastInertiaWheelZoomMovement = void 0, this._lastInertiaTiltMovement = void 0, this._tweens = new T, this._tween = void 0, this._horizontalRotationAxis = void 0, this._tiltCenterMousePosition = new e(-1, -1), this._tiltCenter = new t, this._rotateMousePosition = new e(-1, -1), this._rotateStartPosition = new t, this._strafeStartPosition = new t, this._zoomMouseStart = new e, this._zoomWorldPosition = new t, this._tiltCVOffMap = !1, this._looking = !1, this._rotating = !1, this._strafing = !1, this._zoomingOnVector = !1, this._rotatingZoom = !1;
            var r = i.mapProjection;
            this._maxCoord = r.project(new n(Math.PI, d.PI_OVER_TWO)), this._zoomFactor = 5, this._rotateFactor = void 0, this._rotateRateRangeAdjustment = void 0, this._maximumRotateRate = 1.77, this._minimumRotateRate = 2e-4, this._translateFactor = 1, this._minimumZoomRate = 20, this._maximumZoomRate = 5906376272e3
        }, $ = .4, ee = [], te = new v, ie = new t, ne = new e, re = new t, oe = new e, ae = new t, se = new t, ue = new t, le = new t, ce = new t, he = new v, de = new v, me = new t, pe = new e, fe = new e, _e = new v, ve = new t, ge = new t, ye = new v, Ce = new v, Ee = new t, Se = new t, Te = new t, be = new t, we = new f(t.ZERO, 0), xe = new e, Ae = new e, Pe = new e, Ie = new v, De = new t, Me = new t, Oe = new p, Re = new p, Ne = new t, Le = new f(t.ZERO, 0), Fe = new t, Be = new n, ze = new p, Ve = new _, Ue = new m, ke = new e, Ge = new v, He = new t, We = new v, qe = new f(t.ZERO, 0), je = new t, Ye = new t, Xe = new t, Ze = (new v, new n), Ke = new t, Je = new t, Qe = new u, $e = new t, et = i.clone(i.UNIT_W), tt = i.clone(i.UNIT_W), it = new t, nt = new t, rt = new t, ot = new t, at = new e, st = new e, ut = new t, lt = new n, ct = new e, ht = new v, dt = new t, mt = new t, pt = new p, ft = new p, _t = new t, vt = new p, gt = new _, yt = new m, Ct = new n, Et = new t, St = new n, Tt = new e, bt = new e, wt = new v, xt = new v, At = new t, Pt = new t, It = new n;
        return Q.prototype.update = function () {
            p.equals(this._scene.camera.transform, p.IDENTITY) ? (this._globe = this._scene.globe, this._ellipsoid = o(this._globe) ? this._globe.ellipsoid : this._scene.mapProjection.ellipsoid) : (this._globe = void 0, this._ellipsoid = u.UNIT_SPHERE);
            var e = this._ellipsoid.maximumRadius;
            this._rotateFactor = 1 / e, this._rotateRateRangeAdjustment = e;
            var i = this._scene, n = i.mode;
            n === E.SCENE2D ? R(this) : n === E.COLUMBUS_VIEW ? (this._horizontalRotationAxis = t.UNIT_Z, U(this)) : n === E.SCENE3D && (this._horizontalRotationAxis = void 0, K(this)), J(this), this._aggregator.reset()
        }, Q.prototype.isDestroyed = function () {
            return !1
        }, Q.prototype.destroy = function () {
            return this._tweens.removeAll(), this._aggregator = this._aggregator && this._aggregator.destroy(), a(this)
        }, Q
    }),define("Cesium/Shaders/PostProcessFilters/AdditiveBlend", [], function () {
        "use strict";
        return "uniform sampler2D u_texture0;\nuniform sampler2D u_texture1;\n\nuniform vec2 u_center;\nuniform float u_radius;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main()\n{\n    vec4 color0 = texture2D(u_texture0, v_textureCoordinates);\n    vec4 color1 = texture2D(u_texture1, v_textureCoordinates);\n    \n    float x = length(gl_FragCoord.xy - u_center) / u_radius;\n    float t = smoothstep(0.5, 0.8, x);\n    gl_FragColor = mix(color0 + color1, color0, t);\n}\n"
    }),define("Cesium/Shaders/PostProcessFilters/BrightPass", [], function () {
        "use strict";
        return 'uniform sampler2D u_texture;\n\nuniform float u_avgLuminance;\nuniform float u_threshold;\nuniform float u_offset;\n\nvarying vec2 v_textureCoordinates;\n\nfloat key(float avg)\n{\n    float guess = 1.5 - (1.5 / (avg * 0.1 + 1.0));\n    return max(0.0, guess) + 0.1;\n}\n\n// See section 9. "The bright-pass filter" of Realtime HDR Rendering\n// http://www.cg.tuwien.ac.at/research/publications/2007/Luksch_2007_RHR/Luksch_2007_RHR-RealtimeHDR%20.pdf\n\nvoid main()\n{\n    vec4 color = texture2D(u_texture, v_textureCoordinates);\n    vec3 xyz = czm_RGBToXYZ(color.rgb);\n    float luminance = xyz.r;\n    \n    float scaledLum = key(u_avgLuminance) * luminance / u_avgLuminance;\n    float brightLum = max(scaledLum - u_threshold, 0.0);\n    float brightness = brightLum / (u_offset + brightLum);\n    \n    xyz.r = brightness;\n    gl_FragColor = vec4(czm_XYZToRGB(xyz), 1.0);\n}\n'
    }),define("Cesium/Shaders/PostProcessFilters/GaussianBlur1D", [], function () {
        "use strict";
        return "#define SAMPLES 8\n\nuniform float delta;\nuniform float sigma;\nuniform float direction; // 0.0 for x direction, 1.0 for y direction\n\nuniform sampler2D u_texture;\nuniform vec2 u_step;\n\nvarying vec2 v_textureCoordinates;\n\n//  Incremental Computation of the Gaussian:\n//  http://http.developer.nvidia.com/GPUGems3/gpugems3_ch40.html\n\nvoid main()\n{\n    vec2 st = v_textureCoordinates;\n    \n    vec2 dir = vec2(1.0 - direction, direction);\n    \n    vec3 g;\n    g.x = 1.0 / (sqrt(czm_twoPi) * sigma);\n    g.y = exp((-0.5 * delta * delta) / (sigma * sigma));\n    g.z = g.y * g.y;\n    \n    vec4 result = texture2D(u_texture, st) * g.x;\n    for (int i = 1; i < SAMPLES; ++i)\n    {\n        g.xy *= g.yz;\n        \n        vec2 offset = float(i) * dir * u_step;\n        result += texture2D(u_texture, st - offset) * g.x;\n        result += texture2D(u_texture, st + offset) * g.x;\n    }\n    \n    gl_FragColor = result;\n}\n"
    }),define("Cesium/Scene/SunPostProcess", ["../Core/BoundingRectangle", "../Core/Cartesian2", "../Core/Cartesian4", "../Core/Color", "../Core/defaultValue", "../Core/defined", "../Core/destroyObject", "../Core/Math", "../Core/Matrix4", "../Core/PixelFormat", "../Core/Transforms", "../Renderer/ClearCommand", "../Renderer/Framebuffer", "../Renderer/PassState", "../Renderer/PixelDatatype", "../Renderer/Renderbuffer", "../Renderer/RenderbufferFormat", "../Renderer/RenderState", "../Renderer/Texture", "../Shaders/PostProcessFilters/AdditiveBlend", "../Shaders/PostProcessFilters/BrightPass", "../Shaders/PostProcessFilters/GaussianBlur1D", "../Shaders/PostProcessFilters/PassThrough"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S) {
        "use strict";
        var T = function () {
            this._fbo = void 0, this._downSampleFBO1 = void 0, this._downSampleFBO2 = void 0, this._clearFBO1Command = void 0, this._clearFBO2Command = void 0, this._downSampleCommand = void 0, this._brightPassCommand = void 0, this._blurXCommand = void 0, this._blurYCommand = void 0, this._blendCommand = void 0, this._fullScreenCommand = void 0, this._downSamplePassState = new m, this._downSamplePassState.scissorTest = {
                enable: !0,
                rectangle: new e
            }, this._upSamplePassState = new m, this._upSamplePassState.scissorTest = {
                enabled: !0,
                rectangle: new e
            }, this._uCenter = new t, this._uRadius = void 0, this._blurStep = new t
        };
        T.prototype.clear = function (e, t) {
            var i = this._clearFBO1Command;
            n.clone(r(t, n.BLACK), i.color), i.execute(e), i = this._clearFBO2Command, n.clone(r(t, n.BLACK), i.color), i.execute(e)
        }, T.prototype.execute = function (e, t) {
            this._downSampleCommand.execute(e, this._downSamplePassState), this._brightPassCommand.execute(e, this._downSamplePassState), this._blurXCommand.execute(e, this._downSamplePassState), this._blurYCommand.execute(e, this._downSamplePassState), this._fullScreenCommand.framebuffer = t, this._blendCommand.framebuffer = t, this._fullScreenCommand.execute(e), this._blendCommand.execute(e, this._upSamplePassState)
        };
        var b = new e, w = new e, x = new i, A = new t, P = new t, I = new u;
        return T.prototype.update = function (e) {
            var i = e.drawingBufferWidth, r = e.drawingBufferHeight, a = this;
            if (!o(this._downSampleCommand)) {
                this._clearFBO1Command = new h({color: new n}), this._clearFBO2Command = new h({color: new n});
                var m, T = {};
                this._downSampleCommand = e.createViewportQuadCommand(S, {
                    renderState: m,
                    uniformMap: T,
                    owner: this
                }), T = {
                    u_avgLuminance: function () {
                        return .5
                    }, u_threshold: function () {
                        return .25
                    }, u_offset: function () {
                        return .1
                    }
                }, this._brightPassCommand = e.createViewportQuadCommand(C, {
                    renderState: m,
                    uniformMap: T,
                    owner: this
                });
                var D = 1, M = 2;
                T = {
                    delta: function () {
                        return D
                    }, sigma: function () {
                        return M
                    }, direction: function () {
                        return 0
                    }
                }, this._blurXCommand = e.createViewportQuadCommand(E, {
                    renderState: m,
                    uniformMap: T,
                    owner: this
                }), T = {
                    delta: function () {
                        return D
                    }, sigma: function () {
                        return M
                    }, direction: function () {
                        return 1
                    }
                }, this._blurYCommand = e.createViewportQuadCommand(E, {
                    renderState: m,
                    uniformMap: T,
                    owner: this
                }), T = {
                    u_center: function () {
                        return a._uCenter
                    }, u_radius: function () {
                        return a._uRadius
                    }
                }, this._blendCommand = e.createViewportQuadCommand(y, {
                    renderState: m,
                    uniformMap: T,
                    owner: this
                }), T = {}, this._fullScreenCommand = e.createViewportQuadCommand(S, {
                    renderState: m,
                    uniformMap: T,
                    owner: this
                })
            }
            var O = Math.pow(2, Math.ceil(Math.log(i) / Math.log(2)) - 2), R = Math.pow(2, Math.ceil(Math.log(r) / Math.log(2)) - 2), N = Math.max(O, R), L = b;
            L.width = i, L.height = r;
            var F = w;
            F.width = N, F.height = N;
            var B = this._fbo, z = o(B) && B.getColorTexture(0) || void 0;
            if (!o(z) || z.width !== i || z.height !== r) {
                B = B && B.destroy(), this._downSampleFBO1 = this._downSampleFBO1 && this._downSampleFBO1.destroy(), this._downSampleFBO2 = this._downSampleFBO2 && this._downSampleFBO2.destroy(), this._blurStep.x = this._blurStep.y = 1 / N;
                var V = [new g({context: e, width: i, height: r})];
                B = e.depthTexture ? this._fbo = new d({
                    context: e,
                    colorTextures: V,
                    depthTexture: new g({
                        context: e,
                        width: i,
                        height: r,
                        pixelFormat: l.DEPTH_COMPONENT,
                        pixelDatatype: p.UNSIGNED_SHORT
                    })
                }) : this._fbo = new d({
                    context: e,
                    colorTextures: V,
                    depthRenderbuffer: new f({context: e, format: _.DEPTH_COMPONENT16})
                }), this._downSampleFBO1 = new d({
                    context: e,
                    colorTextures: [new g({context: e, width: N, height: N})]
                }), this._downSampleFBO2 = new d({
                    context: e,
                    colorTextures: [new g({context: e, width: N, height: N})]
                }), this._clearFBO1Command.framebuffer = this._downSampleFBO1, this._clearFBO2Command.framebuffer = this._downSampleFBO2, this._downSampleCommand.framebuffer = this._downSampleFBO1, this._brightPassCommand.framebuffer = this._downSampleFBO2, this._blurXCommand.framebuffer = this._downSampleFBO1, this._blurYCommand.framebuffer = this._downSampleFBO2;
                var U = v.fromCache({viewport: F}), k = v.fromCache();
                this._downSampleCommand.uniformMap.u_texture = function () {
                    return B.getColorTexture(0)
                }, this._downSampleCommand.renderState = U, this._brightPassCommand.uniformMap.u_texture = function () {
                    return a._downSampleFBO1.getColorTexture(0)
                }, this._brightPassCommand.renderState = U, this._blurXCommand.uniformMap.u_texture = function () {
                    return a._downSampleFBO2.getColorTexture(0)
                }, this._blurXCommand.uniformMap.u_step = function () {
                    return a._blurStep
                }, this._blurXCommand.renderState = U, this._blurYCommand.uniformMap.u_texture = function () {
                    return a._downSampleFBO1.getColorTexture(0)
                }, this._blurYCommand.uniformMap.u_step = function () {
                    return a._blurStep
                }, this._blurYCommand.renderState = U, this._blendCommand.uniformMap.u_texture0 = function () {
                    return B.getColorTexture(0)
                }, this._blendCommand.uniformMap.u_texture1 = function () {
                    return a._downSampleFBO2.getColorTexture(0)
                }, this._blendCommand.renderState = k, this._fullScreenCommand.uniformMap.u_texture = function () {
                    return B.getColorTexture(0)
                }, this._fullScreenCommand.renderState = k
            }
            var G = e.uniformState, H = G.sunPositionWC, W = G.view, q = G.viewProjection, j = G.projection, Y = u.computeViewportTransformation(L, 0, 1, I), X = u.multiplyByPoint(W, H, x), Z = c.pointToGLWindowCoordinates(q, Y, H, A);
            X.x += s.SOLAR_RADIUS;
            var K = c.pointToGLWindowCoordinates(j, Y, X, X), J = 30 * t.magnitude(t.subtract(K, Z, K)) * 2, Q = P;
            Q.x = J, Q.y = J;
            var $ = this._upSamplePassState.scissorTest.rectangle;
            return $.x = Math.max(Z.x - .5 * Q.x, 0), $.y = Math.max(Z.y - .5 * Q.y, 0), $.width = Math.min(Q.x, i), $.height = Math.min(Q.y, r), this._uCenter = t.clone(Z, this._uCenter), this._uRadius = .5 * Math.max(Q.x, Q.y), Y = u.computeViewportTransformation(F, 0, 1, I), Z = c.pointToGLWindowCoordinates(q, Y, H, A), Q.x *= O / i, Q.y *= R / r, $ = this._downSamplePassState.scissorTest.rectangle, $.x = Math.max(Z.x - .5 * Q.x, 0), $.y = Math.max(Z.y - .5 * Q.y, 0), $.width = Math.min(Q.x, i), $.height = Math.min(Q.y, r), this._downSamplePassState.context = e, this._upSamplePassState.context = e, this._fbo
        }, T.prototype.isDestroyed = function () {
            return !1
        }, T.prototype.destroy = function () {
            return this._fbo = this._fbo && this._fbo.destroy(), this._downSampleFBO1 = this._downSampleFBO1 && this._downSampleFBO1.destroy(), this._downSampleFBO2 = this._downSampleFBO2 && this._downSampleFBO2.destroy(), this._downSampleCommand = this._downSampleCommand && this._downSampleCommand.shaderProgram && this._downSampleCommand.shaderProgram.destroy(), this._brightPassCommand = this._brightPassCommand && this._brightPassCommand.shaderProgram && this._brightPassCommand.shaderProgram.destroy(), this._blurXCommand = this._blurXCommand && this._blurXCommand.shaderProgram && this._blurXCommand.shaderProgram.destroy(), this._blurYCommand = this._blurYCommand && this._blurYCommand.shaderProgram && this._blurYCommand.shaderProgram.destroy(), this._blendCommand = this._blendCommand && this._blendCommand.shaderProgram && this._blendCommand.shaderProgram.destroy(), this._fullScreenCommand = this._fullScreenCommand && this._fullScreenCommand.shaderProgram && this._fullScreenCommand.shaderProgram.destroy(), a(this)
        }, T
    }),define("Cesium/Scene/Scene", ["../Core/BoundingRectangle", "../Core/BoundingSphere", "../Core/BoxGeometry", "../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/Color", "../Core/ColorGeometryInstanceAttribute", "../Core/createGuid", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/DeveloperError", "../Core/EllipsoidGeometry", "../Core/Event", "../Core/GeographicProjection", "../Core/GeometryInstance", "../Core/GeometryPipeline", "../Core/getTimestamp", "../Core/Intersect", "../Core/Interval", "../Core/JulianDate", "../Core/Math", "../Core/Matrix4", "../Core/mergeSort", "../Core/Occluder", "../Core/ShowGeometryInstanceAttribute", "../Renderer/ClearCommand", "../Renderer/ComputeEngine", "../Renderer/Context", "../Renderer/ContextLimits", "../Renderer/PassState", "../Renderer/ShaderSource", "../Renderer/ShaderProgram", "./Camera", "./CreditDisplay", "./CullingVolume", "./DepthPlane", "./FrameState", "./FrustumCommands", "./FXAA", "./GlobeDepth", "./JobScheduler", "./OIT", "./OrthographicFrustum", "./Pass", "./PerformanceDisplay", "./PerInstanceColorAppearance", "./PerspectiveFrustum", "./PerspectiveOffCenterFrustum", "./PickDepth", "./Primitive", "./PrimitiveCollection", "./SceneMode", "./SceneTransforms", "./SceneTransitioner", "./ScreenSpaceCameraController", "./SunPostProcess", "./TweenCollection"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S, T, b, w, x, A, P, I, D, M, O, R, N, L, F, B, z, V, U, k, G, H, W, q, j, Y, X, Z, K, J, Q, $, ee, te, ie, ne, re, oe) {
        "use strict";
        function ae(e, t) {
            var i = Math.max(Math.abs(e.x), Math.abs(t.x)), n = Math.max(Math.abs(e.y), Math.abs(t.y)), r = Math.max(Math.abs(e.z), Math.abs(t.z));
            return Math.max(Math.max(i, n), r)
        }

        function se(e, t, i) {
            var n = 1 / Math.max(1, ae(e.position, t.position));
            return r.multiplyByScalar(e.position, n, Le), r.multiplyByScalar(t.position, n, Fe), r.equalsEpsilon(Le, Fe, i) && r.equalsEpsilon(e.direction, t.direction, i) && r.equalsEpsilon(e.up, t.up, i) && r.equalsEpsilon(e.right, t.right, i) && b.equalsEpsilon(e.transform, t.transform, i)
        }

        function ue(e) {
            var t = e.globe;
            if (e._mode === ee.SCENE3D && c(t)) {
                var i = t.ellipsoid;
                return Be.radius = i.minimumRadius, Ne = x.fromBoundingSphere(Be, e._camera.positionWC, Ne)
            }
            return void 0
        }

        function le(e) {
            e.render = !1, e.pick = !1
        }

        function ce(e, t, i) {
            var n = e._camera, r = e._frameState;
            r.mode = e._mode, r.morphTime = e.morphTime, r.mapProjection = e.mapProjection, r.frameNumber = t, r.time = S.clone(i, r.time), r.camera = n, r.cullingVolume = n.frustum.computeCullingVolume(n.positionWC, n.directionWC, n.upWC), r.occluder = ue(e), le(r.passes)
        }

        function he(e, t, i, n, r) {
            r.length = n;
            for (var o = 0; n > o; ++o) {
                var a = Math.max(e, Math.pow(i, o) * e), s = Math.min(t, i * a), u = r[o];
                c(u) ? (u.near = a, u.far = s) : u = r[o] = new U(a, s)
            }
        }

        function de(e, t, i) {
            e.debugShowFrustums && (t.debugOverlappingFrustums = 0);
            for (var n = e._frustumCommandsList, r = n.length, o = 0; r > o; ++o) {
                var a = n[o], s = a.near, u = a.far;
                if (!(i.start > u)) {
                    if (i.stop < s)break;
                    var l = t instanceof P ? j.OPAQUE : t.pass, h = a.indices[l]++;
                    if (a.commands[l][h] = t, e.debugShowFrustums && (t.debugOverlappingFrustums |= 1 << o), t.executeInClosestFrustum)break
                }
            }
            if (e.debugShowFrustums) {
                var d = e._debugFrustumStatistics.commandsInFrustums;
                d[t.debugOverlappingFrustums] = c(d[t.debugOverlappingFrustums]) ? d[t.debugOverlappingFrustums] + 1 : 1, ++e._debugFrustumStatistics.totalCommands
            }
        }

        function me(e) {
            var t = e._computeCommandList, i = e._commandList, n = e._overlayCommandList, r = e._frameState.cullingVolume, o = e._camera, a = o.directionWC, s = o.positionWC;
            e.debugShowFrustums && (e._debugFrustumStatistics = {totalCommands: 0, commandsInFrustums: {}});
            for (var u = e._frustumCommandsList, l = u.length, h = j.NUMBER_OF_PASSES, d = 0; l > d; ++d)for (var m = 0; h > m; ++m)u[d].indices[m] = 0;
            t.length = 0, n.length = 0;
            var p, f = Number.MAX_VALUE, _ = Number.MIN_VALUE, v = !1;
            e._frameState.mode === ee.SCENE3D && (p = e._frameState.occluder);
            for (var g = ze.planes, y = 0; 5 > y; ++y)g[y] = r.planes[y];
            r = ze;
            for (var E = i.length, S = 0; E > S; ++S) {
                var T = i[S], b = T.pass;
                if (b === j.COMPUTE)t.push(T); else if (b === j.OVERLAY)n.push(T); else {
                    var w = T.boundingVolume;
                    if (c(w)) {
                        if (T.cull && (r.computeVisibility(w) === C.OUTSIDE || c(p) && w.isOccluded(p)))continue;
                        Ve = w.computePlaneDistances(s, a, Ve), f = Math.min(f, Ve.start), _ = Math.max(_, Ve.stop)
                    } else Ve.start = o.frustum.near, Ve.stop = o.frustum.far, v = !(T instanceof P);
                    de(e, T, Ve)
                }
            }
            v ? (f = o.frustum.near, _ = o.frustum.far) : (f = Math.min(Math.max(f, o.frustum.near), o.frustum.far), _ = Math.max(Math.min(_, o.frustum.far), f));
            var x = e.farToNearRatio, A = Math.ceil(Math.log(_ / f) / Math.log(x));
            f !== Number.MAX_VALUE && (A !== l || 0 !== u.length && (f < u[0].near || _ > u[l - 1].far)) && (he(f, _, x, A, u), me(e))
        }

        function pe(e) {
            var t = {}, i = e.vertexAttributes;
            for (var n in i)i.hasOwnProperty(n) && (t[n] = i[n].index);
            return t
        }

        function fe(e, t, i) {
            var n = t.context, r = l(i, e.shaderProgram), o = r.fragmentShaderSource.clone();
            o.sources = o.sources.map(function (e) {
                return R.replaceMain(e, "czm_Debug_main")
            });
            var s = "void main() \n{ \n    czm_Debug_main(); \n";
            if (t.debugShowCommands) {
                c(e._debugColor) || (e._debugColor = a.fromRandom());
                var u = e._debugColor;
                s += "    gl_FragColor.rgb *= vec3(" + u.red + ", " + u.green + ", " + u.blue + "); \n"
            }
            if (t.debugShowFrustums) {
                var h = 1 & e.debugOverlappingFrustums ? "1.0" : "0.0", d = 2 & e.debugOverlappingFrustums ? "1.0" : "0.0", m = 4 & e.debugOverlappingFrustums ? "1.0" : "0.0";
                s += "    gl_FragColor.rgb *= vec3(" + h + ", " + d + ", " + m + "); \n"
            }
            s += "}", o.sources.push(s);
            var p = pe(r);
            return N.fromCache({
                context: n,
                vertexShaderSource: r.vertexShaderSource,
                fragmentShaderSource: o,
                attributeLocations: p
            })
        }

        function _e(e, t, i, n, r) {
            if (c(e.shaderProgram) || c(r)) {
                var o = fe(e, t, r);
                e.execute(t.context, i, n, o), o.destroy()
            }
        }

        function ve(e, t, n, o, a, u, l) {
            if ((!c(t.debugCommandFilter) || t.debugCommandFilter(e)) && (t.debugShowCommands || t.debugShowFrustums ? _e(e, t, o, a, u) : e.execute(n, o, a, u), e.debugShowBoundingVolume && c(e.boundingVolume))) {
                var h = t._frameState, d = e.boundingVolume;
                c(t._debugVolume) && t._debugVolume.destroy();
                var m, f = r.clone(d.center);
                if (h.mode !== ee.SCENE3D) {
                    f = b.multiplyByPoint(Ue, f, f);
                    var _ = h.mapProjection, y = _.unproject(f);
                    f = _.ellipsoid.cartographicToCartesian(y)
                }
                if (c(d.radius)) {
                    var C = d.radius;
                    m = g.toWireframe(p.createGeometry(new p({
                        radii: new r(C, C, C),
                        vertexFormat: X.FLAT_VERTEX_FORMAT
                    }))), t._debugVolume = new Q({
                        geometryInstances: new v({
                            geometry: m,
                            modelMatrix: b.fromTranslation(f),
                            attributes: {color: new s(1, 0, 0, 1)}
                        }), appearance: new X({flat: !0, translucent: !1}), asynchronous: !1
                    })
                } else {
                    var E = d.halfAxes;
                    m = g.toWireframe(i.createGeometry(i.fromDimensions({
                        dimensions: new r(2, 2, 2),
                        vertexFormat: X.FLAT_VERTEX_FORMAT
                    }))), t._debugVolume = new Q({
                        geometryInstances: new v({
                            geometry: m,
                            modelMatrix: b.fromRotationTranslation(E, f, new b),
                            attributes: {color: new s(1, 0, 0, 1)}
                        }), appearance: new X({flat: !0, translucent: !1}), asynchronous: !1
                    })
                }
                var S = [];
                t._debugVolume.update(n, h, S);
                var T;
                c(l) && (T = o.framebuffer, o.framebuffer = l), S[0].execute(n, o), c(T) && (o.framebuffer = T)
            }
        }

        function ge(e, t) {
            if (c(e)) {
                for (var i = t.mode === ee.SCENE3D ? t.occluder : void 0, n = t.cullingVolume, r = ze.planes, o = 0; 5 > o; ++o)r[o] = n.planes[o];
                n = ze;
                var a = e.boundingVolume;
                return !(!c(e) || c(e.boundingVolume) && e.cull && (n.computeVisibility(a) === C.OUTSIDE || c(i) && a.isOccluded(i)))
            }
        }

        function ye(e, t, i) {
            return t.boundingVolume.distanceSquaredTo(i) - e.boundingVolume.distanceSquaredTo(i)
        }

        function Ce(e, t, i, n) {
            var r = e.context;
            w(n, ye, e._camera.positionWC);
            for (var o = n.length, a = 0; o > a; ++a)t(n[a], e, r, i)
        }

        function Ee(e, t) {
            var i = e._debugGlobeDepths[t];
            return !c(i) && e.context.depthTexture && (i = new G, e._debugGlobeDepths[t] = i), i
        }

        function Se(e, t) {
            var i = e._pickDepths[t];
            return c(i) || (i = new J, e._pickDepths[t] = i), i
        }

        function Te(e, t, i, n) {
            var r, o, s = e._frameState, u = e._camera, l = e.context, h = l.uniformState;
            c(e.sun) && e.sunBloom !== e._sunBloom ? (e.sunBloom ? e._sunPostProcess = new re : c(e._sunPostProcess) && (e._sunPostProcess = e._sunPostProcess.destroy()), e._sunBloom = e.sunBloom) : !c(e.sun) && c(e._sunPostProcess) && (e._sunPostProcess = e._sunPostProcess.destroy(), e._sunBloom = !1);
            var d, m = s.passes.render, p = m && c(e.skyBox) ? e.skyBox.update(l, s) : void 0, f = m && c(e.skyAtmosphere) ? e.skyAtmosphere.update(l, s) : void 0, _ = m && c(e.sun) ? e.sun.update(e) : void 0, v = c(_) ? _.drawCommand : void 0, g = c(_) ? _.computeCommand : void 0, y = ge(v, s), C = m && c(e.moon) ? e.moon.update(l, s) : void 0, E = ge(C, s), S = t.framebuffer;
            d = c(u.frustum.fov) ? u.frustum.clone(ke) : c(u.frustum.infiniteProjectionMatrix) ? u.frustum.clone(Ge) : u.frustum.clone(He);
            var T = e._clearColorCommand;
            a.clone(i, T.color), T.execute(l, t);
            var b = !n && c(e._globeDepth);
            b && (e._globeDepth.update(l), e._globeDepth.clear(l, t, i));
            var w = !1, x = e._frustumCommandsList, A = x.length;
            for (r = 0; A > r; ++r)if (x[r].indices[j.TRANSLUCENT] > 0) {
                w = !0;
                break
            }
            var P = c(e.globe) && (!e.globe.depthTestAgainstTerrain || e.mode === ee.SCENE2D), I = P && e.mode === ee.SCENE3D;
            I && e._depthPlane.update(l, s);
            var D = !n && w && c(e._oit) && e._oit.isSupported();
            D && (e._oit.update(l, e._globeDepth.framebuffer), e._oit.clear(l, t, i), D = D && e._oit.isSupported());
            var M = !n && e.fxaa;
            if (M && (e._fxaa.update(l), e._fxaa.clear(l, t, i)), y && e.sunBloom ? t.framebuffer = e._sunPostProcess.update(l) : b ? t.framebuffer = e._globeDepth.framebuffer : M && (t.framebuffer = e._fxaa.getColorFramebuffer()), c(t.framebuffer) && T.execute(l, t), d.near = u.frustum.near, d.far = u.frustum.far, h.updateFrustum(d), c(p) && ve(p, e, l, t), c(f) && ve(f, e, l, t), y && (c(g) && g.execute(e._computeEngine), v.execute(l, t), e.sunBloom)) {
                var O;
                O = b ? e._globeDepth.framebuffer : M ? e._fxaa.getColorFramebuffer() : S, e._sunPostProcess.execute(l, O), t.framebuffer = O
            }
            E && C.execute(l, t);
            var R;
            D ? (c(e._executeOITFunction) || (e._executeOITFunction = function (e, t, i, n) {
                e._oit.executeCommands(e, t, i, n)
            }), R = e._executeOITFunction) : R = Ce;
            var N = e._depthClearCommand;
            for (r = 0; A > r; ++r) {
                var L = A - r - 1, F = x[L];
                d.near = 0 !== L ? F.near * Re : F.near, d.far = F.far;
                var B, z = e.debugShowGlobeDepth ? Ee(e, L) : e._globeDepth;
                e.debugShowGlobeDepth && c(z) && b && (B = t.framebuffer, t.framebuffer = z.framebuffer), h.updateFrustum(d), N.execute(l, t);
                var V = F.commands[j.GLOBE], U = F.indices[j.GLOBE];
                for (o = 0; U > o; ++o)ve(V[o], e, l, t);
                for (c(z) && b && (e.copyGlobeDepth || e.debugShowGlobeDepth) && (z.update(l), z.executeCopyDepth(l, t)), e.debugShowGlobeDepth && c(z) && b && (t.framebuffer = B), V = F.commands[j.GROUND], U = F.indices[j.GROUND], o = 0; U > o; ++o)ve(V[o], e, l, t);
                P && (N.execute(l, t), I && e._depthPlane.execute(l, t));
                for (var k = j.GROUND + 1, G = j.TRANSLUCENT, H = k; G > H; ++H)for (V = F.commands[H], U = F.indices[H], o = 0; U > o; ++o)ve(V[o], e, l, t);
                if (0 !== L && (d.near = F.near, h.updateFrustum(d)), V = F.commands[j.TRANSLUCENT], V.length = F.indices[j.TRANSLUCENT], R(e, ve, t, V), c(z) && b && e.useDepthPicking) {
                    var W = Se(e, L);
                    W.update(l, z.framebuffer.depthStencilTexture), W.executeCopyDepth(l, t)
                }
            }
            if (e.debugShowGlobeDepth && b) {
                var q = Ee(e, e.debugShowDepthFrustum - 1);
                q.executeDebugGlobeDepth(l, t)
            }
            if (e.debugShowPickDepth && b) {
                var Y = Se(e, e.debugShowDepthFrustum - 1);
                Y.executeDebugPickDepth(l, t)
            }
            D && (t.framebuffer = M ? e._fxaa.getColorFramebuffer() : void 0, e._oit.execute(l, t)), M && (!D && b && (t.framebuffer = e._fxaa.getColorFramebuffer(), e._globeDepth.executeCopyColor(l, t)), t.framebuffer = S, e._fxaa.execute(l, t)), D || M || !b || (t.framebuffer = S, e._globeDepth.executeCopyColor(l, t))
        }

        function be(e) {
            for (var t = e._computeCommandList, i = t.length, n = 0; i > n; ++n)t[n].execute(e._computeEngine)
        }

        function we(e, t) {
            for (var i = e.context, n = e._overlayCommandList, r = n.length, o = 0; r > o; ++o)n[o].execute(i, t)
        }

        function xe(e) {
            var t = e.context, i = e._frameState, n = e._commandList;
            e._globe && e._globe.update(t, i, n), e._groundPrimitives.update(t, i, n), e._primitives.update(t, i, n)
        }

        function Ae(e) {
            for (var t = e.afterRender, i = 0, n = t.length; n > i; ++i)t[i]();
            t.length = 0
        }

        function Pe(e, t) {
            c(t) || (t = S.now());
            var i = e._camera;
            se(i, e._cameraClone, T.EPSILON6) ? e._cameraStartFired && y() - e._cameraMovedTime > e.cameraEventWaitTime && (i.moveEnd.raiseEvent(), e._cameraStartFired = !1) : (e._cameraStartFired || (i.moveStart.raiseEvent(), e._cameraStartFired = !0), e._cameraMovedTime = y(), L.clone(i, e._cameraClone)), e._preRender.raiseEvent(e, t), e._jobScheduler.resetBudgets();
            var n = e.context.uniformState, r = e._frameState, o = T.incrementWrap(r.frameNumber, 15e6, 1);
            ce(e, o, t), r.passes.render = !0, r.creditDisplay.beginFrame();
            var s = e.context;
            n.update(s, r), e._computeCommandList.length = 0, e._commandList.length = 0, e._overlayCommandList.length = 0, xe(e), me(e);
            var u = e._passState;
            if (u.framebuffer = void 0, u.blendingEnabled = void 0, u.scissorTest = void 0, be(e), Te(e, u, l(e.backgroundColor, a.BLACK)), we(e, u), r.creditDisplay.endFrame(), e.debugShowFramesPerSecond) {
                if (!c(e._performanceDisplay)) {
                    var h = document.createElement("div");
                    h.className = "cesium-performanceDisplay-defaultContainer";
                    var d = e._canvas.parentNode;
                    d.appendChild(h);
                    var m = new Y({container: h});
                    e._performanceDisplay = m, e._performanceContainer = h
                }
                e._performanceDisplay.update()
            } else c(e._performanceDisplay) && (e._performanceDisplay = e._performanceDisplay && e._performanceDisplay.destroy(), e._performanceContainer.parentNode.removeChild(e._performanceContainer));
            s.endFrame(), Ae(r), e._postRender.raiseEvent(e, t)
        }

        function Ie(e, t, i, n) {
            var o = e._camera, a = o.frustum, s = e.drawingBufferWidth, u = e.drawingBufferHeight, l = 2 / s * t.x - 1;
            l *= .5 * (a.right - a.left);
            var c = 2 / u * (u - t.y) - 1;
            c *= .5 * (a.top - a.bottom);
            var h = b.clone(o.transform, Ze);
            o._setTransform(b.IDENTITY);
            var d = r.clone(o.position, qe);
            r.multiplyByScalar(o.right, l, je), r.add(je, d, d), r.multiplyByScalar(o.up, c, je), r.add(je, d, d), o._setTransform(h), r.fromElements(d.z, d.x, d.y, d), Ye.x = s, Ye.y = u;
            var m = a.getPixelSize(Ye, void 0, Xe), p = We;
            return p.right = .5 * m.x, p.left = -p.right, p.top = .5 * m.y, p.bottom = -p.top, p.near = a.near, p.far = a.far, p.computeCullingVolume(d, o.directionWC, o.upWC)
        }

        function De(e, t, i, n) {
            var r = e._camera, o = r.frustum, a = o.near, s = e.drawingBufferWidth, u = e.drawingBufferHeight, l = Math.tan(.5 * o.fovy), c = o.aspectRatio * l, h = 2 / s * t.x - 1, d = 2 / u * (u - t.y) - 1, m = h * a * c, p = d * a * l;
            Ye.x = s, Ye.y = u;
            var f = o.getPixelSize(Ye, void 0, Xe), _ = f.x * i * .5, v = f.y * n * .5, g = Ke;
            return g.top = p + v, g.bottom = p - v, g.right = m + _, g.left = m - _, g.near = a, g.far = o.far, g.computeCullingVolume(r.positionWC, r.directionWC, r.upWC)
        }

        function Me(e, t, i, n) {
            return e._mode === ee.SCENE2D ? Ie(e, t, i, n) : De(e, t, i, n)
        }

        var Oe = function (e) {
            e = l(e, l.EMPTY_OBJECT);
            var t = e.canvas, i = e.contextOptions, n = e.creditContainer, r = new D(t, i);
            c(n) || (n = document.createElement("div"), n.style.position = "absolute", n.style.bottom = "0", n.style["text-shadow"] = "0px 0px 2px #000000", n.style.color = "#ffffff", n.style["font-size"] = "10px", n.style["padding-right"] = "5px", t.parentNode.appendChild(n)), this._id = u(), this._jobScheduler = new H, this._frameState = new V(new F(n), this._jobScheduler), this._frameState.scene3DOnly = l(e.scene3DOnly, !1), this._passState = new O(r), this._canvas = t, this._context = r, this._computeEngine = new I(r), this._globe = void 0, this._primitives = new $, this._groundPrimitives = new $, this._tweens = new oe, this._shaderFrameCount = 0, this._sunPostProcess = void 0, this._computeCommandList = [], this._commandList = [], this._frustumCommandsList = [], this._overlayCommandList = [], this._pickFramebuffer = void 0, this._useOIT = l(e.orderIndependentTranslucency, !0), this._executeOITFunction = void 0;
            var o;
            r.depthTexture && (o = new G);
            var s;
            this._useOIT && c(o) && (s = new W(r)), this._globeDepth = o, this._depthPlane = new z, this._oit = s, this._fxaa = new k, this._clearColorCommand = new P({
                color: new a,
                stencil: 0,
                owner: this
            }), this._depthClearCommand = new P({
                depth: 1,
                owner: this
            }), this._pickDepths = [], this._debugGlobeDepths = [], this._transitioner = new ie(this), this._renderError = new f, this._preRender = new f, this._postRender = new f, this._cameraStartFired = !1, this._cameraMovedTime = void 0, this.rethrowRenderErrors = !1, this.completeMorphOnUserInput = !0, this.morphStart = new f, this.morphComplete = new f, this.skyBox = void 0, this.skyAtmosphere = void 0, this.sun = void 0, this.sunBloom = !0, this._sunBloom = void 0, this.moon = void 0, this.backgroundColor = a.clone(a.BLACK), this._mode = ee.SCENE3D, this._mapProjection = c(e.mapProjection) ? e.mapProjection : new _, this._transitioner = new ie(this, this._mapProjection.ellipsoid), this.morphTime = 1, this.farToNearRatio = 1e3, this.debugCommandFilter = void 0, this.debugShowCommands = !1, this.debugShowFrustums = !1, this._debugFrustumStatistics = void 0, this.debugShowFramesPerSecond = !1, this.debugShowGlobeDepth = !1, this.debugShowDepthFrustum = 1, this.fxaa = !0, this.useDepthPicking = !0, this.cameraEventWaitTime = 500, this.copyGlobeDepth = !1, this._performanceDisplay = void 0, this._debugVolume = void 0;
            var h = new L(this);
            this._camera = h, this._cameraClone = L.clone(h), this._screenSpaceCameraController = new ne(this);
            var d = h.frustum.near, m = h.frustum.far, p = Math.ceil(Math.log(m / d) / Math.log(this.farToNearRatio));
            he(d, m, this.farToNearRatio, p, this._frustumCommandsList), ce(this, 0, S.now()), this.initializeFrame()
        }, Re = .99;
        h(Oe.prototype, {
            canvas: {
                get: function () {
                    return this._canvas
                }
            }, drawingBufferHeight: {
                get: function () {
                    return this._context.drawingBufferHeight
                }
            }, drawingBufferWidth: {
                get: function () {
                    return this._context.drawingBufferWidth
                }
            }, maximumAliasedLineWidth: {
                get: function () {
                    return M.maximumAliasedLineWidth
                }
            }, maximumCubeMapSize: {
                get: function () {
                    return M.maximumCubeMapSize
                }
            }, pickPositionSupported: {
                get: function () {
                    return this._context.depthTexture
                }
            }, globe: {
                get: function () {
                    return this._globe
                }, set: function (e) {
                    this._globe = this._globe && this._globe.destroy(), this._globe = e
                }
            }, primitives: {
                get: function () {
                    return this._primitives
                }
            }, groundPrimitives: {
                get: function () {
                    return this._groundPrimitives
                }
            }, camera: {
                get: function () {
                    return this._camera
                }
            }, screenSpaceCameraController: {
                get: function () {
                    return this._screenSpaceCameraController
                }
            }, mapProjection: {
                get: function () {
                    return this._mapProjection
                }
            }, frameState: {
                get: function () {
                    return this._frameState
                }
            }, tweens: {
                get: function () {
                    return this._tweens
                }
            }, imageryLayers: {
                get: function () {
                    return this.globe.imageryLayers
                }
            }, terrainProvider: {
                get: function () {
                    return this.globe.terrainProvider
                }, set: function (e) {
                    this.globe.terrainProvider = e
                }
            }, renderError: {
                get: function () {
                    return this._renderError
                }
            }, preRender: {
                get: function () {
                    return this._preRender
                }
            }, postRender: {
                get: function () {
                    return this._postRender
                }
            }, context: {
                get: function () {
                    return this._context
                }
            }, debugFrustumStatistics: {
                get: function () {
                    return this._debugFrustumStatistics
                }
            }, scene3DOnly: {
                get: function () {
                    return this._frameState.scene3DOnly
                }
            }, orderIndependentTranslucency: {
                get: function () {
                    return c(this._oit)
                }
            }, id: {
                get: function () {
                    return this._id
                }
            }, mode: {
                get: function () {
                    return this._mode
                }, set: function (e) {
                    this._mode = e
                }
            }, numberOfFrustums: {
                get: function () {
                    return this._frustumCommandsList.length
                }
            }
        });
        var Ne, Le = new r, Fe = new r, Be = new t, ze = new B, Ve = new E, Ue = new b(0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1);
        Ue = b.inverseTransformation(Ue, Ue);
        var ke = new Z, Ge = new K, He = new q;
        Oe.prototype.initializeFrame = function () {
            120 === this._shaderFrameCount++ && (this._shaderFrameCount = 0, this._context.shaderCache.destroyReleasedShaderPrograms()), this._tweens.update(), this._camera.update(this._mode), this._screenSpaceCameraController.update()
        }, Oe.prototype.render = function (e) {
            try {
                Pe(this, e)
            } catch (t) {
                if (this._renderError.raiseEvent(this, t), this.rethrowRenderErrors)throw t
            }
        }, Oe.prototype.clampLineWidth = function (e) {
            this._context;
            return Math.max(M.minimumAliasedLineWidth, Math.min(e, M.maximumAliasedLineWidth))
        };
        var We = new q, qe = new r, je = new r, Ye = new n, Xe = new n, Ze = new b, Ke = new K, Je = 3, Qe = 3, $e = new e(0, 0, Je, Qe), et = new a(0, 0, 0, 0), tt = new n;
        Oe.prototype.pick = function (e) {
            var t = this._context, i = t.uniformState, n = this._frameState, r = te.transformWindowToDrawingBuffer(this, e, tt);
            c(this._pickFramebuffer) || (this._pickFramebuffer = t.createPickFramebuffer()), this._jobScheduler.disableThisFrame(), ce(this, n.frameNumber, n.time), n.cullingVolume = Me(this, r, Je, Qe), n.passes.pick = !0, i.update(t, n), this._commandList.length = 0, xe(this), me(this), $e.x = r.x - .5 * (Je - 1), $e.y = this.drawingBufferHeight - r.y - .5 * (Qe - 1), Te(this, this._pickFramebuffer.begin($e), et, !0);
            var o = this._pickFramebuffer.end($e);
            return t.endFrame(), Ae(n), o
        };
        var it = (new r, new r, new o), nt = new o(1, 1 / 255, 1 / 65025, 1 / 160581375);
        return Oe.prototype.pickPosition = function (e, t) {
            if (!this.useDepthPicking)return void 0;
            var i = this._context, n = i.uniformState, r = te.transformWindowToDrawingBuffer(this, e, tt);
            r.y = this.drawingBufferHeight - r.y;
            var a, s = this._camera;
            c(s.frustum.fov) ? a = s.frustum.clone(ke) : c(s.frustum.infiniteProjectionMatrix) && (a = s.frustum.clone(Ge));
            for (var u = this.numberOfFrustums, l = 0; u > l; ++l) {
                var h = Se(this, l), d = i.readPixels({
                    x: r.x,
                    y: r.y,
                    width: 1,
                    height: 1,
                    framebuffer: h.framebuffer
                }), m = o.unpack(d, 0, it);
                o.divideByScalar(m, 255, m);
                var p = o.dot(m, nt);
                if (p > 0 && 1 > p) {
                    var f = this._frustumCommandsList[l];
                    return a.near = f.near * (0 !== l ? Re : 1), a.far = f.far, n.updateFrustum(a), te.drawingBufferToWgs84Coordinates(this, r, p, t)
                }
            }
            return void 0
        }, Oe.prototype.drillPick = function (e, t) {
            var i, n, r = [], o = [], a = [];
            c(t) || (t = Number.MAX_VALUE);
            for (var s = this.pick(e); c(s) && c(s.primitive) && (r.push(s), !(0 >= --t));) {
                var u = s.primitive, l = !1;
                "function" == typeof u.getGeometryInstanceAttributes && c(s.id) && (n = u.getGeometryInstanceAttributes(s.id), c(n) && c(n.show) && (l = !0, n.show = A.toValue(!1, n.show), a.push(n))), l || (u.show = !1, o.push(u)), s = this.pick(e)
            }
            for (i = 0; i < o.length; ++i)o[i].show = !0;
            for (i = 0; i < a.length; ++i)n = a[i], n.show = A.toValue(!0, n.show);
            return r
        }, Oe.prototype.completeMorph = function () {
            this._transitioner.completeMorph()
        }, Oe.prototype.morphTo2D = function (e) {
            var t, i = this.globe;
            t = c(i) ? i.ellipsoid : this.mapProjection.ellipsoid, e = l(e, 2), this._transitioner.morphTo2D(e, t)
        }, Oe.prototype.morphToColumbusView = function (e) {
            var t, i = this.globe;
            t = c(i) ? i.ellipsoid : this.mapProjection.ellipsoid, e = l(e, 2), this._transitioner.morphToColumbusView(e, t)
        }, Oe.prototype.morphTo3D = function (e) {
            var t, i = this.globe;
            t = c(i) ? i.ellipsoid : this.mapProjection.ellipsoid, e = l(e, 2), this._transitioner.morphTo3D(e, t)
        }, Oe.prototype.isDestroyed = function () {
            return !1
        }, Oe.prototype.destroy = function () {
            return this._tweens.removeAll(), this._computeEngine = this._computeEngine && this._computeEngine.destroy(), this._screenSpaceCameraController = this._screenSpaceCameraController && this._screenSpaceCameraController.destroy(), this._pickFramebuffer = this._pickFramebuffer && this._pickFramebuffer.destroy(), this._primitives = this._primitives && this._primitives.destroy(), this._groundPrimitives = this._groundPrimitives && this._groundPrimitives.destroy(), this._globe = this._globe && this._globe.destroy(), this.skyBox = this.skyBox && this.skyBox.destroy(), this.skyAtmosphere = this.skyAtmosphere && this.skyAtmosphere.destroy(), this._debugSphere = this._debugSphere && this._debugSphere.destroy(), this.sun = this.sun && this.sun.destroy(), this._sunPostProcess = this._sunPostProcess && this._sunPostProcess.destroy(), this._depthPlane = this._depthPlane && this._depthPlane.destroy(), this._transitioner.destroy(), c(this._globeDepth) && this._globeDepth.destroy(), c(this._oit) && this._oit.destroy(), this._fxaa.destroy(), this._context = this._context && this._context.destroy(), this._frameState.creditDisplay.destroy(), c(this._performanceDisplay) && (this._performanceDisplay = this._performanceDisplay && this._performanceDisplay.destroy(), this._performanceContainer.parentNode.removeChild(this._performanceContainer)), d(this)
        }, Oe
    }),define("Cesium/Shaders/SkyAtmosphereFS", [], function () {
        "use strict";
        return '/**\n * @license\n * Copyright (c) 2000-2005, Sean O\'Neil (s_p_oneil@hotmail.com)\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * \n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * * Neither the name of the project nor the names of its contributors may be\n *   used to endorse or promote products derived from this software without\n *   specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Modifications made by Analytical Graphics, Inc.\n */\n \n // Code:  http://sponeil.net/\n // GPU Gems 2 Article:  http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html\n \nconst float g = -0.95;\nconst float g2 = g * g;\n\nuniform float fCameraHeight;\nuniform float fInnerRadius;\n\nvarying vec3 v_rayleighColor;\nvarying vec3 v_mieColor;\nvarying vec3 v_toCamera;\nvarying vec3 v_positionEC;\n\nvoid main (void)\n{\n    // TODO: make arbitrary ellipsoid\n    czm_ellipsoid ellipsoid = czm_getWgs84EllipsoidEC();\n    \n    vec3 direction = normalize(v_positionEC);\n    czm_ray ray = czm_ray(vec3(0.0), direction);\n    \n    if (fCameraHeight > fInnerRadius) {\n	    czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid);\n	    if (!czm_isEmpty(intersection)) {\n	        discard;\n	    }\n	} else {\n	    // The ellipsoid test above will discard fragments when the ray origin is\n	    // inside the ellipsoid.\n	    vec3 radii = ellipsoid.radii;\n	    float maxRadius = max(radii.x, max(radii.y, radii.z));\n	    vec3 ellipsoidCenter = czm_modelView[3].xyz;\n	    \n	    float t1 = -1.0;\n	    float t2 = -1.0;\n	    \n	    float b = -2.0 * dot(direction, ellipsoidCenter);\n	    float c = dot(ellipsoidCenter, ellipsoidCenter) - maxRadius * maxRadius;\n	\n	    float discriminant = b * b - 4.0 * c;\n	    if (discriminant >= 0.0) {\n	        t1 = (-b - sqrt(discriminant)) * 0.5;\n	        t2 = (-b + sqrt(discriminant)) * 0.5;\n	    }\n	    \n	    if (t1 < 0.0 && t2 < 0.0) {\n	        // The ray through the fragment intersected the sphere approximating\n	        // the ellipsoid behind the ray origin.\n	        discard;\n	    }\n    }\n    \n    // Extra normalize added for Android\n    float fCos = dot(czm_sunDirectionWC, normalize(v_toCamera)) / length(v_toCamera);\n    float fRayleighPhase = 0.75 * (1.0 + fCos*fCos);\n    float fMiePhase = 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + fCos*fCos) / pow(1.0 + g2 - 2.0*g*fCos, 1.5);\n    \n    const float fExposure = 2.0;\n    \n    vec3 rgb = fRayleighPhase * v_rayleighColor + fMiePhase * v_mieColor;\n    rgb = vec3(1.0) - exp(-fExposure * rgb);\n    float l = czm_luminance(rgb);\n    gl_FragColor = vec4(rgb, min(smoothstep(0.0, 0.1, l), 1.0) * smoothstep(0.0, 1.0, czm_morphTime));\n}\n'
    }),define("Cesium/Shaders/SkyAtmosphereVS", [], function () {
        "use strict";
        return "/**\n * @license\n * Copyright (c) 2000-2005, Sean O'Neil (s_p_oneil@hotmail.com)\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * \n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * * Neither the name of the project nor the names of its contributors may be\n *   used to endorse or promote products derived from this software without\n *   specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Modifications made by Analytical Graphics, Inc.\n */\n \n // Code:  http://sponeil.net/\n // GPU Gems 2 Article:  http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html\n  \nattribute vec4 position;\n\nuniform float fCameraHeight;\nuniform float fCameraHeight2;\nuniform float fOuterRadius;     // The outer (atmosphere) radius\nuniform float fOuterRadius2;    // fOuterRadius^2\nuniform float fInnerRadius;     // The inner (planetary) radius\nuniform float fScale;           // 1 / (fOuterRadius - fInnerRadius)\nuniform float fScaleDepth;      // The scale depth (i.e. the altitude at which the atmosphere's average density is found)\nuniform float fScaleOverScaleDepth; // fScale / fScaleDepth\n\nconst float Kr = 0.0025;\nconst float fKr4PI = Kr * 4.0 * czm_pi;\nconst float Km = 0.0015;\nconst float fKm4PI = Km * 4.0 * czm_pi;\nconst float ESun = 15.0;\nconst float fKmESun = Km * ESun;\nconst float fKrESun = Kr * ESun;\nconst vec3 v3InvWavelength = vec3(\n    5.60204474633241,  // Red = 1.0 / Math.pow(0.650, 4.0)\n    9.473284437923038, // Green = 1.0 / Math.pow(0.570, 4.0)\n    19.643802610477206); // Blue = 1.0 / Math.pow(0.475, 4.0)\nconst float rayleighScaleDepth = 0.25;\n          \nconst int nSamples = 2;\nconst float fSamples = 2.0;\n\nvarying vec3 v_rayleighColor;\nvarying vec3 v_mieColor;\nvarying vec3 v_toCamera;\nvarying vec3 v_positionEC;\n\nfloat scale(float fCos)\n{\n    float x = 1.0 - fCos;\n    return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n}\n\nvoid main(void)\n{\n    // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n    vec3 v3Pos = position.xyz;\n    vec3 v3Ray = v3Pos - czm_viewerPositionWC;\n    float fFar = length(v3Ray);\n    v3Ray /= fFar;\n\n#ifdef SKY_FROM_SPACE\n    // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\n    float B = 2.0 * dot(czm_viewerPositionWC, v3Ray);\n    float C = fCameraHeight2 - fOuterRadius2;\n    float fDet = max(0.0, B*B - 4.0 * C);\n    float fNear = 0.5 * (-B - sqrt(fDet));\n\n    // Calculate the ray's starting position, then calculate its scattering offset\n    vec3 v3Start = czm_viewerPositionWC + v3Ray * fNear;\n    fFar -= fNear;\n    float fStartAngle = dot(v3Ray, v3Start) / fOuterRadius;\n    float fStartDepth = exp(-1.0 / fScaleDepth);\n    float fStartOffset = fStartDepth*scale(fStartAngle);\n#else // SKY_FROM_ATMOSPHERE\n    // Calculate the ray's starting position, then calculate its scattering offset\n    vec3 v3Start = czm_viewerPositionWC;\n    float fHeight = length(v3Start);\n    float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fCameraHeight));\n    float fStartAngle = dot(v3Ray, v3Start) / fHeight;\n    float fStartOffset = fDepth*scale(fStartAngle);\n#endif\n\n    // Initialize the scattering loop variables\n    float fSampleLength = fFar / fSamples;\n    float fScaledLength = fSampleLength * fScale;\n    vec3 v3SampleRay = v3Ray * fSampleLength;\n    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n    // Now loop through the sample rays\n    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\n    for(int i=0; i<nSamples; i++)\n    {\n        float fHeight = length(v3SamplePoint);\n        float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\n        vec3 lightPosition = normalize(czm_viewerPositionWC); // czm_sunDirectionWC\n        float fLightAngle = dot(lightPosition, v3SamplePoint) / fHeight;\n        float fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight;\n        float fScatter = (fStartOffset + fDepth*(scale(fLightAngle) - scale(fCameraAngle)));\n        vec3 v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\n        v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\n        v3SamplePoint += v3SampleRay;\n    }\n\n    // Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\n    v_mieColor = v3FrontColor * fKmESun;\n    v_rayleighColor = v3FrontColor * (v3InvWavelength * fKrESun);\n    v_toCamera = czm_viewerPositionWC - v3Pos;\n    v_positionEC = (czm_modelView * position).xyz;\n    gl_Position = czm_modelViewProjection * position;\n}\n"
    }),define("Cesium/Scene/SkyAtmosphere", ["../Core/Cartesian3", "../Core/defaultValue", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/Ellipsoid", "../Core/EllipsoidGeometry", "../Core/GeometryPipeline", "../Core/VertexFormat", "../Renderer/BufferUsage", "../Renderer/DrawCommand", "../Renderer/RenderState", "../Renderer/ShaderProgram", "../Renderer/ShaderSource", "../Renderer/VertexArray", "../Shaders/SkyAtmosphereFS", "../Shaders/SkyAtmosphereVS", "./BlendingState", "./CullFace", "./SceneMode"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y) {
        "use strict";
        var C = function (i) {
            i = t(i, o.WGS84), this.show = !0, this._ellipsoid = i, this._command = new c({owner: this}), this._spSkyFromSpace = void 0, this._spSkyFromAtmosphere = void 0, this._fCameraHeight = void 0, this._fCameraHeight2 = void 0, this._outerRadius = e.maximumComponent(e.multiplyByScalar(i.radii, 1.025, new e));
            var n = i.maximumRadius, r = .25, a = this;
            this._command.uniformMap = {
                fCameraHeight: function () {
                    return a._fCameraHeight
                }, fCameraHeight2: function () {
                    return a._fCameraHeight2
                }, fOuterRadius: function () {
                    return a._outerRadius
                }, fOuterRadius2: function () {
                    return a._outerRadius * a._outerRadius
                }, fInnerRadius: function () {
                    return n
                }, fScale: function () {
                    return 1 / (a._outerRadius - n)
                }, fScaleDepth: function () {
                    return r
                }, fScaleOverScaleDepth: function () {
                    return 1 / (a._outerRadius - n) / r
                }
            }
        };
        return n(C.prototype, {
            ellipsoid: {
                get: function () {
                    return this._ellipsoid
                }
            }
        }), C.prototype.update = function (t, n) {
            if (!this.show)return void 0;
            if (n.mode !== y.SCENE3D && n.mode !== y.MORPHING)return void 0;
            if (!n.passes.render)return void 0;
            var r = this._command;
            if (!i(r.vertexArray)) {
                var o = a.createGeometry(new a({
                    radii: e.multiplyByScalar(this._ellipsoid.radii, 1.025, new e),
                    slicePartitions: 256,
                    stackPartitions: 256,
                    vertexFormat: u.POSITION_ONLY
                }));
                r.vertexArray = p.fromGeometry({
                    context: t,
                    geometry: o,
                    attributeLocations: s.createAttributeLocations(o),
                    bufferUsage: l.STATIC_DRAW
                }), r.renderState = h.fromCache({cull: {enabled: !0, face: g.FRONT}, blending: v.ALPHA_BLEND});
                var c = new m({defines: ["SKY_FROM_SPACE"], sources: [_]});
                this._spSkyFromSpace = d.fromCache({
                    context: t,
                    vertexShaderSource: c,
                    fragmentShaderSource: f
                }), c = new m({
                    defines: ["SKY_FROM_ATMOSPHERE"],
                    sources: [_]
                }), this._spSkyFromAtmosphere = d.fromCache({
                    context: t,
                    vertexShaderSource: c,
                    fragmentShaderSource: f
                })
            }
            var C = n.camera.positionWC;
            return this._fCameraHeight2 = e.magnitudeSquared(C), this._fCameraHeight = Math.sqrt(this._fCameraHeight2), this._fCameraHeight > this._outerRadius ? r.shaderProgram = this._spSkyFromSpace : r.shaderProgram = this._spSkyFromAtmosphere, r
        }, C.prototype.isDestroyed = function () {
            return !1
        }, C.prototype.destroy = function () {
            var e = this._command;
            return e.vertexArray = e.vertexArray && e.vertexArray.destroy(), this._spSkyFromSpace = this._spSkyFromSpace && this._spSkyFromSpace.destroy(), this._spSkyFromAtmosphere = this._spSkyFromAtmosphere && this._spSkyFromAtmosphere.destroy(), r(this)
        }, C
    }),define("Cesium/Renderer/loadCubeMap", ["../Core/defined", "../Core/DeveloperError", "../Core/loadImage", "../ThirdParty/when", "./CubeMap"], function (e, t, i, n, r) {
        "use strict";
        var o = function (e, t, o) {
            var a = [i(t.positiveX, o), i(t.negativeX, o), i(t.positiveY, o), i(t.negativeY, o), i(t.positiveZ, o), i(t.negativeZ, o)];
            return n.all(a, function (t) {
                return new r({
                    context: e,
                    source: {
                        positiveX: t[0],
                        negativeX: t[1],
                        positiveY: t[2],
                        negativeY: t[3],
                        positiveZ: t[4],
                        negativeZ: t[5]
                    }
                })
            })
        };
        return o
    }),define("Cesium/Shaders/SkyBoxFS", [], function () {
        "use strict";
        return "uniform samplerCube u_cubeMap;\n\nvarying vec3 v_texCoord;\n\nvoid main()\n{\n    vec3 rgb = textureCube(u_cubeMap, normalize(v_texCoord)).rgb;\n    gl_FragColor = vec4(rgb, czm_morphTime);\n}\n"
    }),define("Cesium/Shaders/SkyBoxVS", [], function () {
        "use strict";
        return "attribute vec3 position;\n\nvarying vec3 v_texCoord;\n\nvoid main()\n{\n    vec3 p = czm_viewRotation * (czm_temeToPseudoFixed * (czm_entireFrustum.y * position));\n    gl_Position = czm_projection * vec4(p, 1.0);\n    v_texCoord = position.xyz;\n}\n"
    }),define("Cesium/Scene/SkyBox", ["../Core/BoxGeometry", "../Core/Cartesian3", "../Core/defaultValue", "../Core/defined", "../Core/destroyObject", "../Core/DeveloperError", "../Core/GeometryPipeline", "../Core/Matrix4", "../Core/VertexFormat", "../Renderer/BufferUsage", "../Renderer/CubeMap", "../Renderer/DrawCommand", "../Renderer/loadCubeMap", "../Renderer/RenderState", "../Renderer/ShaderProgram", "../Renderer/VertexArray", "../Shaders/SkyBoxFS", "../Shaders/SkyBoxVS", "./BlendingState", "./SceneMode"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y) {
        "use strict";
        var C = function (e) {
            this.sources = e.sources, this._sources = void 0, this.show = i(e.show, !0), this._command = new h({
                modelMatrix: s.clone(s.IDENTITY),
                owner: this
            }), this._cubeMap = void 0
        };
        return C.prototype.update = function (i, r) {
            if (!this.show)return void 0;
            if (r.mode !== y.SCENE3D && r.mode !== y.MORPHING)return void 0;
            if (!r.passes.render)return void 0;
            if (this._sources !== this.sources) {
                this._sources = this.sources;
                var o = this.sources;
                "string" == typeof o.positiveX ? d(i, this._sources).then(function (e) {
                    h._cubeMap = h._cubeMap && h._cubeMap.destroy(), h._cubeMap = e
                }) : (this._cubeMap = this._cubeMap && this._cubeMap.destroy(), this._cubeMap = new c({
                    context: i,
                    source: o
                }))
            }
            var s = this._command;
            if (!n(s.vertexArray)) {
                var h = this;
                s.uniformMap = {
                    u_cubeMap: function () {
                        return h._cubeMap
                    }
                };
                var C = e.createGeometry(e.fromDimensions({
                    dimensions: new t(2, 2, 2),
                    vertexFormat: u.POSITION_ONLY
                })), E = a.createAttributeLocations(C);
                s.vertexArray = f.fromGeometry({
                    context: i,
                    geometry: C,
                    attributeLocations: E,
                    bufferUsage: l.STATIC_DRAW
                }), s.shaderProgram = p.fromCache({
                    context: i,
                    vertexShaderSource: v,
                    fragmentShaderSource: _,
                    attributeLocations: E
                }), s.renderState = m.fromCache({blending: g.ALPHA_BLEND})
            }
            return n(this._cubeMap) ? s : void 0
        }, C.prototype.isDestroyed = function () {
            return !1
        }, C.prototype.destroy = function () {
            var e = this._command;
            return e.vertexArray = e.vertexArray && e.vertexArray.destroy(), e.shaderProgram = e.shaderProgram && e.shaderProgram.destroy(), this._cubeMap = this._cubeMap && this._cubeMap.destroy(), r(this)
        }, C
    }),define("Cesium/Shaders/SunFS", [], function () {
        "use strict";
        return "uniform sampler2D u_texture;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main()\n{\n    gl_FragColor = texture2D(u_texture, v_textureCoordinates);\n}\n"
    }),define("Cesium/Shaders/SunTextureFS", [], function () {
        "use strict";
        return "uniform float u_glowLengthTS;\nuniform float u_radiusTS;\n\nvarying vec2 v_textureCoordinates;\n\nvec2 rotate(vec2 p, vec2 direction)\n{\n    return vec2(p.x * direction.x - p.y * direction.y, p.x * direction.y + p.y * direction.x);\n}\n\nvec4 addBurst(vec2 position, vec2 direction)\n{\n    vec2 rotatedPosition = rotate(position, direction) * vec2(25.0, 0.75);\n    float radius = length(rotatedPosition);\n    float burst = 1.0 - smoothstep(0.0, 0.55, radius);\n\n    return vec4(burst);\n}\n\nvoid main()\n{\n    vec2 position = v_textureCoordinates - vec2(0.5);\n    float radius = length(position);\n    float surface = step(radius, u_radiusTS);\n    vec4 color = vec4(1.0, 1.0, surface + 0.2, surface);\n\n    float glow = 1.0 - smoothstep(0.0, 0.55, radius);\n    color.ba += mix(vec2(0.0), vec2(1.0), glow) * 0.75;\n\n    vec4 burst = vec4(0.0);\n\n    // The following loop has been manually unrolled for speed, to\n    // avoid sin() and cos().\n    //\n    //for (float i = 0.4; i < 3.2; i += 1.047) {\n    //    vec2 direction = vec2(sin(i), cos(i));\n    //    burst += 0.4 * addBurst(position, direction);\n    //\n    //    direction = vec2(sin(i - 0.08), cos(i - 0.08));\n    //    burst += 0.3 * addBurst(position, direction);\n    //}\n\n    burst += 0.4 * addBurst(position, vec2(0.38942,  0.92106));  // angle == 0.4\n    burst += 0.4 * addBurst(position, vec2(0.99235,  0.12348));  // angle == 0.4 + 1.047\n    burst += 0.4 * addBurst(position, vec2(0.60327, -0.79754));  // angle == 0.4 + 1.047 * 2.0\n\n    burst += 0.3 * addBurst(position, vec2(0.31457,  0.94924));  // angle == 0.4 - 0.08\n    burst += 0.3 * addBurst(position, vec2(0.97931,  0.20239));  // angle == 0.4 + 1.047 - 0.08\n    burst += 0.3 * addBurst(position, vec2(0.66507, -0.74678));  // angle == 0.4 + 1.047 * 2.0 - 0.08\n\n    // End of manual loop unrolling.\n\n    color += clamp(burst, vec4(0.0), vec4(1.0)) * 0.15;\n    \n    gl_FragColor = clamp(color, vec4(0.0), vec4(1.0));\n}\n"
    }),define("Cesium/Shaders/SunVS", [], function () {
        "use strict";
        return "attribute vec2 direction;\n\nuniform float u_size;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main() \n{\n    vec4 position;\n    if (czm_morphTime == 1.0)\n    {\n        position = vec4(czm_sunPositionWC, 1.0);\n    }\n    else\n    {\n        position = vec4(czm_sunPositionColumbusView.zxy, 1.0);\n    }\n    \n    vec4 positionEC = czm_view * position;\n    vec4 positionWC = czm_eyeToWindowCoordinates(positionEC);\n    \n    vec2 halfSize = vec2(u_size * 0.5);\n    halfSize *= ((direction * 2.0) - 1.0);\n    \n    gl_Position = czm_viewportOrthographic * vec4(positionWC.xy + halfSize, -positionWC.z, 1.0);\n    \n    v_textureCoordinates = direction;\n}\n"
    }),define("Cesium/Scene/Sun", ["../Core/BoundingRectangle", "../Core/BoundingSphere", "../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/Color", "../Core/ComponentDatatype", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/IndexDatatype", "../Core/Math", "../Core/Matrix4", "../Core/PixelFormat", "../Core/PrimitiveType", "../Renderer/Buffer", "../Renderer/BufferUsage", "../Renderer/ClearCommand", "../Renderer/ComputeCommand", "../Renderer/DrawCommand", "../Renderer/Framebuffer", "../Renderer/RenderState", "../Renderer/ShaderProgram", "../Renderer/Texture", "../Renderer/VertexArray", "../Shaders/SunFS", "../Shaders/SunTextureFS", "../Shaders/SunVS", "./BlendingState", "./SceneMode", "./SceneTransforms"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S, T, b, w, x, A, P, I, D) {
        "use strict";
        var M = function () {
            this.show = !0, this._drawCommand = new y({
                primitiveType: p.TRIANGLES,
                boundingVolume: new t,
                owner: this
            }), this._commands = {
                drawCommand: this._drawCommand,
                computeCommand: void 0
            }, this._boundingVolume = new t, this._boundingVolume2D = new t, this._texture = void 0, this._drawingBufferWidth = void 0, this._drawingBufferHeight = void 0, this._radiusTS = void 0, this._size = void 0, this.glowFactor = 1, this._glowFactorDirty = !1;
            var e = this;
            this._uniformMap = {
                u_texture: function () {
                    return e._texture
                }, u_size: function () {
                    return e._size
                }
            }
        };
        u(M.prototype, {
            glowFactor: {
                get: function () {
                    return this._glowFactor
                }, set: function (e) {
                    e = Math.max(e, 0), this._glowFactor = e, this._glowFactorDirty = !0
                }
            }
        });
        var O = new i, R = new i, N = new r, L = new r;
        return M.prototype.update = function (e) {
            var r = e.frameState, o = e.context;
            if (!this.show)return void 0;
            var u = r.mode;
            if (u === I.SCENE2D || u === I.MORPHING)return void 0;
            if (!r.passes.render)return void 0;
            var l = e.drawingBufferWidth, p = e.drawingBufferHeight;
            if (!s(this._texture) || l !== this._drawingBufferWidth || p !== this._drawingBufferHeight || this._glowFactorDirty) {
                this._texture = this._texture && this._texture.destroy(), this._drawingBufferWidth = l, this._drawingBufferHeight = p, this._glowFactorDirty = !1;
                var v = Math.max(l, p);
                v = Math.pow(2, Math.ceil(Math.log(v) / Math.log(2)) - 2), this._texture = new T({
                    context: o,
                    width: v,
                    height: v,
                    pixelFormat: m.RGBA
                }), this._glowLengthTS = 5 * this._glowFactor, this._radiusTS = 1 / (1 + 2 * this._glowLengthTS) * .5;
                var y = this;
                this._commands.computeCommand = new g({
                    fragmentShaderSource: x,
                    outputTexture: this._texture,
                    persists: !1,
                    owner: this,
                    postExecute: function () {
                        y._commands.computeCommand = void 0
                    }
                })
            }
            var C = this._drawCommand;
            if (!s(C.vertexArray)) {
                var M = {direction: 0}, F = new Uint8Array(8);
                F[0] = 0, F[1] = 0, F[2] = 255, F[3] = 0, F[4] = 255, F[5] = 255, F[6] = 0, F[7] = 255;
                var B = f.createVertexBuffer({
                    context: o,
                    typedArray: F,
                    usage: _.STATIC_DRAW
                }), z = [{
                    index: M.direction,
                    vertexBuffer: B,
                    componentsPerAttribute: 2,
                    normalize: !0,
                    componentDatatype: a.UNSIGNED_BYTE
                }], V = f.createIndexBuffer({
                    context: o,
                    typedArray: new Uint16Array([0, 1, 2, 0, 2, 3]),
                    usage: _.STATIC_DRAW,
                    indexDatatype: c.UNSIGNED_SHORT
                });
                C.vertexArray = new b({
                    context: o,
                    attributes: z,
                    indexBuffer: V
                }), C.shaderProgram = S.fromCache({
                    context: o,
                    vertexShaderSource: A,
                    fragmentShaderSource: w,
                    attributeLocations: M
                }), C.renderState = E.fromCache({blending: P.ALPHA_BLEND}), C.uniformMap = this._uniformMap
            }
            var U = o.uniformState.sunPositionWC, k = o.uniformState.sunPositionColumbusView, G = this._boundingVolume, H = this._boundingVolume2D;
            n.clone(U, G.center), H.center.x = k.z, H.center.y = k.x, H.center.z = k.y, G.radius = h.SOLAR_RADIUS + h.SOLAR_RADIUS * this._glowLengthTS, H.radius = G.radius, u === I.SCENE3D ? t.clone(G, C.boundingVolume) : u === I.COLUMBUS_VIEW && t.clone(H, C.boundingVolume);
            var W = D.computeActualWgs84Position(r, U, L), q = n.magnitude(n.subtract(W, e.camera.position, L)), j = o.uniformState.projection, Y = N;
            Y.x = 0, Y.y = 0, Y.z = -q, Y.w = 1;
            var X = d.multiplyByVector(j, Y, L), Z = D.clipToDrawingBufferCoordinates(e, X, O);
            Y.x = h.SOLAR_RADIUS;
            var K = d.multiplyByVector(j, Y, L), J = D.clipToDrawingBufferCoordinates(e, K, R);
            return this._size = Math.ceil(i.magnitude(i.subtract(J, Z, L))), this._size = 2 * this._size * (1 + 2 * this._glowLengthTS), this._commands
        }, M.prototype.isDestroyed = function () {
            return !1
        }, M.prototype.destroy = function () {
            var e = this._drawCommand;
            return e.vertexArray = e.vertexArray && e.vertexArray.destroy(), e.shaderProgram = e.shaderProgram && e.shaderProgram.destroy(), this._texture = this._texture && this._texture.destroy(), l(this)
        }, M
    }),define("Cesium/Widgets/CesiumWidget/CesiumWidget", ["../../Core/buildModuleUrl", "../../Core/Cartesian3", "../../Core/Clock", "../../Core/Credit", "../../Core/defaultValue", "../../Core/defined", "../../Core/defineProperties", "../../Core/destroyObject", "../../Core/DeveloperError", "../../Core/Ellipsoid", "../../Core/formatError", "../../Core/requestAnimationFrame", "../../Core/ScreenSpaceEventHandler", "../../Scene/BingMapsImageryProvider", "../../Scene/Globe", "../../Scene/Moon", "../../Scene/Scene", "../../Scene/SceneMode", "../../Scene/SkyAtmosphere", "../../Scene/SkyBox", "../../Scene/Sun", "../getElement"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E) {
        "use strict";
        function S(t) {
            return e("Assets/Textures/SkyBox/tycho2t3_80_" + t + ".jpg")
        }

        function T(e) {
            function t(n) {
                if (!e.isDestroyed())if (e._useDefaultRenderLoop)try {
                    var r = e._targetFrameRate;
                    if (o(r)) {
                        var a = 1e3 / r, s = n - i;
                        s > a && (e.resize(), e.render(), i = n - s % a), h(t)
                    } else e.resize(), e.render(), h(t)
                } catch (u) {
                    if (e._useDefaultRenderLoop = !1, e._renderLoopRunning = !1, e._showRenderLoopErrors) {
                        var l = "An error occurred while rendering.  Rendering has stopped.";
                        e.showErrorPanel(l, void 0, u)
                    }
                } else e._renderLoopRunning = !1
            }

            e._renderLoopRunning = !0;
            var i = 0;
            h(t)
        }

        function b(e) {
            var t = e._canvas, i = t.clientWidth, n = t.clientHeight, o = r(window.devicePixelRatio, 1) * e._resolutionScale;
            e._canvasWidth = i, e._canvasHeight = n, i *= o, n *= o, t.width = i, t.height = n, e._canRender = 0 !== i && 0 !== n
        }

        function w(e) {
            var t = e._canvas, i = t.width, n = t.height;
            if (0 !== i && 0 !== n) {
                var r = e._scene.camera.frustum;
                o(r.aspectRatio) ? r.aspectRatio = i / n : (r.top = r.right * (n / i), r.bottom = -r.top)
            }
        }

        var x = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHYAAAAaCAYAAABikagwAAAAAXNSR0IArs4c6QAAAAlwSFlzAAAN1wAADdcBQiibeAAAAAd0SU1FB9wGGRQyF371QVsAABOHSURBVGje7Vp5cFTHmf91v2Nm3owGnYMuEEJCOBiEjDlsDMYQjGMOOwmXcWxiLywpJ9iuTXZd612corJssFOxi8LerXizxEGUvWsivNxxHHCQ8WYBYSFzmUMCCXQjaUajOd/V+4f6Kc14kI/KZv/xq+p6M/PmO15/9/c1wa0vwpcMQAHgBuAFoPG7mz8jAGwASQBxADFhJQGYACwAjK+vrr/AJQ8jVMqfuwH4AGQByAaQnTNqXGHWqHGFbq8/g1BJsgw9GQ12Bds/qWsxEvEeAEEAfQDCAKKCgPGVcP//BOsIVQHgAZAJIACgsHTqvDvK7150T2bR2DFaZm6W4slwUypR20yaiUg4OtDbcaP36rlPPt6/7f2B3q5mAB0AeriAE18J9y93kVu4X4W73BwAhQBK5v/gZ98ZVXXvDG92IJMx569MQDEoK0tPmOHu1s4L7799sH7vtvcAXAPQCaCfu2qLu+7h+Eh3sS8Bcyt48iVgPos2+4J7jS+BIx2etDBSynfH/Xq46y0CUL70n3/zXMmUuXepWoZHFCQhFIQARCBFJYV6/Nn+QHnVBH9Ovq/51JFWADpfJhcqEzyDcx9ukTTr/xr2VnDpng0nuHR0h1u3wvWF6EspgBIAFYAfQAGAsuU/rfm7kePvvJ0QiTj6QSgBISS9ujEGSikkxaXklIwfK8uK2Xru2HVurWKspZyezGmmWwp/LqVsupPQub4grPQ5YIejKQvPJAGflLLJSBGmxPEqKXhU4XdJEBq7BR5Z+L+DKx3MTTHWEaybx9WCud/btCJQMeX2Qevk+NPoks0YPArF/RUj0NyXxOmO2CAy1a1OmL9yUVfTmatXTx52EildYFQVNlgRmBR1xQJgCBbPBAVUhcw8lTObLz0FVk4RIEmJJyJNZzFBiCTFBRL+f50rriFUATRFiZSU/XYEAw6X5LlIUghZqXvl5p8pfycRZsgjymlKGw1Adm7JbRUVs785nwGghP5pp9mfFMOxWstmuC3gwdcrRqA/buJUWwyKRMAYgydrZNZt9337623njn+ixyN9nAmdM5nBvYOPfxc3mnEmTQ4T5VZv8hfz8aUKnocJd5tvVhxAhOMADzNefleFjRUFa/D/xzi8LQhIEpTG4VXnNBzlZYISufk7juCfqaAoLkHYcZ6HBAEM8O+ObJz3HcFDpJfDJwWYfiHMMTklviocKHv6I3+zRFLdKhEEatmALBFIBIibNhQ6KFyJEjT2JHDoUj/a+nVIVIBhBGOnzptWXzhmTFfT2TZBOH4AgSeeeGJqRUVFqdfr9btcLnVQXwapmqZpJZPJRCgUCh47duzie++9dwWAXl5enrlp06bF0WhUM01TYYwRrmg2vzNKqS3Lsunz+Yy6urpTP//5z09blkVLSkryVq9ePT03NzegqqqbUnqTGyOEMNM0k319fX2///3vz9bW1l4DYD700EPFy5Ytm65pmvbBBx9c2rp166Wnnnqq7MEHH5zAGIu8/vrr+w8ePPgJVwrRO2gAcg8cOLA2mUx62tvbB9avX39s+fLlo++///5JXNiwbXugpqam9tChQ2cEj6NzuQwlsi+//PKSzMzMQtu2qcfjMZqbm09v2LDht4J3sQEQOU2Jo8mKKzt7VEU5lSgFBi3PZkBZrgv3lGbCo1Jc7I7iSGN40JcQgoGkhXdO94ESQJEoGI+1k/M9mDKqQHEv++akl186e45rNAAE3njjjccWLFhwfyAQyJEkiabGbcc7JJNJva2trX3Lli3vvPbaa+eKi4uLV6xY8d10cf5TcZ8x5OXl5b366qs9lFLtrbfeWldVVXW7pmkuxhjS0SSEIJlMGitXrrz2/PPPv1lTU3NtypQp0x955JG/kmVZdrlcR7du3WrOnTt33pIlS+YDwNGjR68ePHiwjVtukm+wI9ichQsXPgUAHR0d3evXr78xc+bMu9asWbOQUjpENz8/v/jQoUP/IiiH40UzAeQvW7Zs1rp16/7a5/NpDr/19fWlGzZsOM4tNsphkc5iPaXTvl6uuDUvY4MZLwNQ4Ffw+LR8+KQQTCuJSQUFcMsEe88FoSkSKCFwyWSISQbg9pEefHdGAJHIdUydVjFecL3K448/Pm3hwoUPBAKBHFGIlmU5pRCRpMGEze12q2PHjh2zatWqeTt37gwODAxkOQIJhUJ6Y2Njn6IojFJqE0KYsGyPx0POnTvXnUgkfGvXrr1j5syZU7iFsKampv5YLBZ34GzbJgAwatSo7MzMTE95eXnZT37yk0dramr+PRQKZSQSCdPn88nBYNADID8UCmkAYBiGGQ6Hna6cksbdZliWZUuSRKPRKAAUBINBfywWM30+n+yEtenTp9+5YsWKGTt37oxwz+a44RwARc8+++xSr9eriQrY398v8311CUncTTHN0Q7Vl1OQJymq4iBwyxQPT8qDVwri1d1/i8ttp/AP39mOBeMn41pQx9mOGFSZ3qT52ZqMR6aMRGvXKfzbgX9Ea3PnSLEdOWXKlK/5/X4/AFy8ePHG6tWr90QikS5VVaOEEIsxRhljngcffLBi8+bNjxBCUFJSMrKkpMRvGIbboXP27Nn+2bNn/3cgEIgSQmKEEAOARQixKKVxRVEioVAoYtu2dMcdd4x24Hbv3t3+ox/96ONoNBqklMa4ppNkMinNnz8///nnn6/y+Xw0mUxaANy6rrsdl28YhguAX9d1F98jwn9TUjJkJ5N1DWV0ti0ByDAMw+PsbzQatX0+Hy0oKMhcvnz5nP3791+IxWJRIUaPfO655+ZVVlaOA4BoNGprmkZ5uJJThZouKyYAqOrWVEKoE7cwszQDlQUK3jr8S5y++iEIIXh55/fwylOH8e3KHHSEdfQnLFBuRbJEsLQyF27Sh3eO/iuudV+EaSuqkJF6MjMzs9xutwIAv/rVr06eOHHiEwCtPBHQOaPaxYsXLxcXF8cKCwtzOzo6+ltbW4OFhYU+h2nDMAgAqbu7W8xkLSEBcsos1bbtocZIIBBQs7Ky5Pb2dkvXdV1wfaipqemsqak5yF1bFABljNEU4Sj87nia1LKHCJWGLLh6AkDhiksAoLq6um/VqlWZWVlZ8gMPPHDHwoULK2tqasJcYJ7y8vKyb33rW/f4/X43YwybNm26vnnz5pIUb0tvVe44maSVjEfizDJtmwFlOS4srczGiQvv4ncnd4ASAkIo+mN92LLrB/j7Vb/GQxOz8Z/1PTDsQXc6p3QEqopU7Dr6S5y8fAiKpCKhs6SQSUqyLKsO4d7e3j4AvbxD1csFQQF4EolEaP369TVCFjuiqKiogG8w5s6dm8sY++ZwcfbZZ5/dvHXr1isnT55scVz+rFmz8urr6xc4Ls22bZZIJExd181oNGr09PREDx06dPmFF144Ho/HTVGIjiE4guECoyl1LYTPcppGEAghDAAikUjixRdfbHnppZfKfD6fa82aNfMOHz7cHgwGbwBwr1ix4u677rqrgsfU4I4dO66lCPZTXSkqpOaMa60e7mjuosw0RmYoWHf3SLT3NOKt91+CbsZBeOlDCcX5luP4rw9fw4wSH+4p9cMlU3xtpAfLJmej/vIR7PnjLyDRwXeKhoxubokWAOYkDXxTLE5brB11oTZMCrWoNQgymJwZhsHC4bAZjUaNaDRqxGIx3VnxeDzJky8TQGLHjh3n9u3bd6ytrS3U2dkZ6e3tjfX398cHBgYS8XjcIIQQr9frKioq8ldWVhb88Ic/vHfbtm3zAXhs25aHUx7uEt1COeXEXM3JfAWLvWnSxRhLbNu2rampqSlMCME3vvGNyXPmzKkCUFZeXn776tWr72WMwbZtvPDCCx+5XK6wo6BcOdhwQ4Chuu/KR39onDGS9T80u9ivkgiqD/0UbT2NcKvelMaEhXfrqlGaPwEPT5qH0lwvqopcaOtpxPb3/gmGmYBEFRBC0HUlfp67tQQALxMKYsaYU+tlcSadNN8NIOO+++4bnZ2d7Q+Hw+zIkSNJxtiQ9TQ1NUW3bNnSmJWVlZBlWaeUWs5SVTUxYsSIRF1dXScAwzTN2MMPP7w3Pz//ZFVVVUFubq7L6/VKmqZRl8ulKIriVlVVmz59ev6cOXMCLpeLLliwYDyAOpGm08SglA659mQy6eHTrwiPtRYXbi6vP2/yjI61AoDL5Ur09vZ2bt++/ezGjRvvppSSjRs3Lti9e/fvnnzyyfHjx48fyRjDwYMHL9TW1jYWFhZ6xfIs3UhUTlPQRwGE9Gv/c/ba9YGi2rPv0FONf/iUUB3Lj8SDqD60GYtmdGBcYSVOnL+K39b9Gp19zVDkwZzBSpLY9Qv9Z3lKHgOgmaYZd9zg1KlTS994441L3G3lcD6oo/1btmxZFwgEctrb27vWrFlzwLIs2cmKW1pa4q+//vp1AbchdIKiPGZHAJDFixcHpk+ffnsoFNLefvvt3ra2Nl0YSDhdt4zy8vLwsWPHsl0ul6ooigSACuEZXKBJwzAMxhhUVZW8Xm8uH5hQ3mCwOf95VVVVYx03yQVhUEpNQbBxADfefPPN6NKlS8dUVlYWVlZW5r344osz1q1bV8IYQzAYjFVXV5+IxWIdkiTlpfDCUgcC6Sw2CqBvw4ZN+7/9d+Wzo1avT5HU9N1tMpj4dfU14z/efxletx9xPYpIPAhVccO2bVBKcf189I/h3mSLkBi5b9y40RWLxZJer9f12GOPTa6oqMjq6enpJYQYlFLGyx21tLQ0MGnSpDGEECQSCZMQIjuNCF6aqI8++mheVlZWJrdYkzcoLEVREj6fL1FfX39x165dzfPnzy/7/ve/v1LXdWvlypVde/bsuRKLxQyn1LEsS2aMeebNm1fs8/lkxhgsy7IAJBRF0Yc2TZZ1AANNTU0djoJt2rRpzqxZs/K6urq6JUnSCSHMMAxZ07SsxYsXV1JKCWMMAwMDMQBhVVWTjtU6gr1y5Yq1d+/ej8aNG5eraZr6zDPPjPV4PBJjDLW1ted27dr1MYCYqqpDcpMkyRIaEyydxToxNgagr7e3t+XEe0rNxPkjnvhTznNr4Sb0KBL6YO9BovJQnRXptTqaPgr9wTLsDgAhTkOurq4+unz58vs1TRvl9/vVuXPnljHGxgqxw2GcEjLYJLlw4cKV06dPd06bNo04+MePH+/ftm3bNNG1iW5KVVVl//79ew4cONC8d+/ey88884ysKIp85513jpo8eXJh2pHX4EUIITh58uRFAN1utzvHcb0ejycGoKuurk5vbW29u7i4ODB69OisJ5988i4xxDhsKIoiEUJgmqZ94MCBOgBdmqaVODxrmhbhiaP+4x//+N2lS5dOmjBhwhiPxyMBQFdXV191dfX7tm23AdBdLtdQzFYUxWmb3iRcmqbh7vQfOz9+v/PdjvP6kcHuE288MJZWuM4Smw1mgkQvHw/v6Wga+BjADY53AEDfmTNnLq9du/Znp06datB13RA3ROwGmaZphcPhgX379v326aefftO27Tafz9fJGGOmadqMMSbLMpEkiaZbjDFommYQQsK1tbWNr7zyymvhcLifEIJbwRBCmGVZ1vHjxz9atGjRLwA0Z2dndzpdHb/fHwTQcuLEiYann3761fPnz3+i67pBCCGUUkoIofwjpZQS27ZZd3f3ja1bt1Zv3LhxL4CrmZmZPYQQkxCCjIyMEIB2AG0Amrdv3/6beDweNwzD1nXdPHXq1Indu3cf48+7MjIyupw98ng8EW4wCWH4kHbQLgsnJ4oAlN332Ji1hbeps6lEaLohQLrhQCJi9zcei77TcLh9H4CrALp4rLN5LBvBE4scAP6JEyfmBQIBL6VUopSCMcYGBgYSly5dCvX19YW5QkQAmD6fz3PvvfeWxmIxr2EYHqFXPBRrKKWWJEmG1+uNtbW1dTU0NNzgz7wA/OXl5bkFBQV+XsYQwVpZMpk0jh8/3snpRQCYo0aN8k6YMCHX5XLRa9euBRsaGnr4Jnp458c7ceLEbK/X6xL5MQzDbGhoCNq2HeO4YgBYWVmZv6KiIkdVVbS0tHQ3NDR0CsORrDlz5oyllHoYY3p9ff31cDjczeGhaVrGkiVLSg3DkLu7u/s+/PDDFn4UKeJYLhnmAJvGs9QCAKOnLMhfNHqSNl/LlHOpTORbWa4et2ORXqv1wgf9NVfO9B7nTYcuPvlICq02t9CJ8ggjOJomodOF0ZQtHNvxCC08pBnbmcIhO53jdA7mpXaKUkOSWGoxYaaKlIa7IozT0uET+XDGehDGhhBGb6bTmBHezeb8OyNPCPQk/ptzeHConCSfcZDNI1hWQXaBVl5254hZmSPVce4MKUdxEQ+VJMnUbcNIWJFoyOzoa02eOX2k+yg/79TFNWkgZchOUobe4vA63WzUEmpYsa+dCoM0Izgz5aQkTUOPpGvUpKFJBaUR8Q03cLdT8NkppyEgPGOCYcnCiNASsn2SwrstDA2Gxnbkc5xSdHGrcmaBWYoqZ+YUe4pcXuqXJCobupWIhaze3vZohzAfdOaKN2mSwPxwR0ZSZ6uptZoIN9yxFCYIiqV5v3THStgwNNPhvtXxFgzDP9K8q52Cj6ZRNnaLffoUDfI5zhVLgrvxCN0Ux5URYXYYF84Wf2qqf4uDV591ZuiLHir7c8F+mZOU5M+Iazg8n3mYjnxORkV3I6dxg6KrMQW3Yaexlq+uv8D1v2IL+t4z3B/NAAAAAElFTkSuQmCC", A = function (e, a) {
            e = E(e), a = r(a, {});
            var s = document.createElement("div");
            s.className = "cesium-widget", e.appendChild(s);
            var u = document.createElement("canvas");
            u.oncontextmenu = function () {
                return !1
            }, u.onselectstart = function () {
                return !1
            }, s.appendChild(u);
            var c = document.createElement("div");
            c.className = "cesium-widget-credits";
            var h = o(a.creditContainer) ? E(a.creditContainer) : s;
            h.appendChild(c);
            var T = r(a.showRenderLoopErrors, !0);
            this._element = s, this._container = e, this._canvas = u, this._canvasWidth = 0, this._canvasHeight = 0, this._creditContainer = c, this._canRender = !1, this._renderLoopRunning = !1, this._showRenderLoopErrors = T, this._resolutionScale = 1, this._forceResize = !1, this._clock = o(a.clock) ? a.clock : new i, b(this);
            try {
                var A = new _({
                    canvas: u,
                    contextOptions: a.contextOptions,
                    creditContainer: c,
                    mapProjection: a.mapProjection,
                    orderIndependentTranslucency: a.orderIndependentTranslucency,
                    scene3DOnly: r(a.scene3DOnly, !1)
                });
                this._scene = A, A.camera.constrainedAxis = t.UNIT_Z, w(this);
                var P = r(A.mapProjection.ellipsoid, l.WGS84), I = A.frameState.creditDisplay, D = new n("Cesium", x, "http://cesiumjs.org/");
                I.addDefaultCredit(D);
                var M = a.globe;
                o(M) || (M = new p(P)), M !== !1 && (A.globe = M);
                var O = a.skyBox;
                o(O) || (O = new y({
                    sources: {
                        positiveX: S("px"),
                        negativeX: S("mx"),
                        positiveY: S("py"),
                        negativeY: S("my"),
                        positiveZ: S("pz"),
                        negativeZ: S("mz")
                    }
                })), O !== !1 && (A.skyBox = O, A.sun = new C, A.moon = new f);
                var R = a.skyAtmosphere;
                o(R) || (R = new g(P)), R !== !1 && (A.skyAtmosphere = R);
                var N = a.globe === !1 ? !1 : a.imageryProvider;
                o(N) || (N = new m({url: "//dev.virtualearth.net"})), N !== !1 && A.imageryLayers.addImageryProvider(N), o(a.terrainProvider) && a.globe !== !1 && (A.terrainProvider = a.terrainProvider), this._screenSpaceEventHandler = new d(u, !1), o(a.sceneMode) && (a.sceneMode === v.SCENE2D && this._scene.morphTo2D(0), a.sceneMode === v.COLUMBUS_VIEW && this._scene.morphToColumbusView(0)), this._useDefaultRenderLoop = void 0, this.useDefaultRenderLoop = r(a.useDefaultRenderLoop, !0), this._targetFrameRate = void 0, this.targetFrameRate = a.targetFrameRate;
                var L = this;
                A.renderError.addEventListener(function (e, t) {
                    if (L._useDefaultRenderLoop = !1, L._renderLoopRunning = !1, L._showRenderLoopErrors) {
                        var i = "An error occurred while rendering.  Rendering has stopped.";
                        L.showErrorPanel(i, void 0, t)
                    }
                })
            } catch (F) {
                if (T) {
                    var B = "Error constructing CesiumWidget.", z = 'Visit <a href="http://get.webgl.org">http://get.webgl.org</a> to verify that your web browser and hardware support WebGL.  Consider trying a different web browser or updating your video drivers.  Detailed error information is below:';
                    this.showErrorPanel(B, z, F)
                }
                throw F
            }
        };
        return a(A.prototype, {
            container: {
                get: function () {
                    return this._container
                }
            }, canvas: {
                get: function () {
                    return this._canvas
                }
            }, creditContainer: {
                get: function () {
                    return this._creditContainer
                }
            }, scene: {
                get: function () {
                    return this._scene
                }
            }, imageryLayers: {
                get: function () {
                    return this._scene.imageryLayers
                }
            }, terrainProvider: {
                get: function () {
                    return this._scene.terrainProvider
                }, set: function (e) {
                    this._scene.terrainProvider = e
                }
            }, camera: {
                get: function () {
                    return this._scene.camera
                }
            }, clock: {
                get: function () {
                    return this._clock
                }
            }, screenSpaceEventHandler: {
                get: function () {
                    return this._screenSpaceEventHandler
                }
            }, targetFrameRate: {
                get: function () {
                    return this._targetFrameRate
                }, set: function (e) {
                    if (0 >= e)throw new u("targetFrameRate must be greater than 0.");
                    this._targetFrameRate = e
                }
            }, useDefaultRenderLoop: {
                get: function () {
                    return this._useDefaultRenderLoop
                }, set: function (e) {
                    this._useDefaultRenderLoop !== e && (this._useDefaultRenderLoop = e, e && !this._renderLoopRunning && T(this))
                }
            }, resolutionScale: {
                get: function () {
                    return this._resolutionScale
                }, set: function (e) {
                    if (0 >= e)throw new u("resolutionScale must be greater than 0.");
                    this._resolutionScale = e, this._forceResize = !0
                }
            }
        }), A.prototype.showErrorPanel = function (e, t, i) {
            var n = this._element, r = document.createElement("div");
            r.className = "cesium-widget-errorPanel";
            var a = document.createElement("div");
            a.className = "cesium-widget-errorPanel-content", r.appendChild(a);
            var s = document.createElement("div");
            s.className = "cesium-widget-errorPanel-header", s.appendChild(document.createTextNode(e)), a.appendChild(s);
            var u = document.createElement("div");
            u.className = "cesium-widget-errorPanel-scroll", a.appendChild(u);
            var l = function () {
                u.style.maxHeight = Math.max(Math.round(.9 * n.clientHeight - 100), 30) + "px"
            };
            if (l(), o(window.addEventListener) && window.addEventListener("resize", l, !1), o(t)) {
                var h = document.createElement("div");
                h.className = "cesium-widget-errorPanel-message", h.innerHTML = "<p>" + t + "</p>", u.appendChild(h)
            }
            var d = "(no error details available)";
            o(i) && (d = c(i));
            var m = document.createElement("div");
            m.className = "cesium-widget-errorPanel-message", m.appendChild(document.createTextNode(d)), u.appendChild(m);
            var p = document.createElement("div");
            p.className = "cesium-widget-errorPanel-buttonPanel", a.appendChild(p);
            var f = document.createElement("button");
            f.setAttribute("type", "button"), f.className = "cesium-button", f.appendChild(document.createTextNode("OK")), f.onclick = function () {
                o(l) && o(window.removeEventListener) && window.removeEventListener("resize", l, !1), n.removeChild(r)
            }, p.appendChild(f), n.appendChild(r), "undefined" != typeof console && console.error(e + "\n" + t + "\n" + d)
        }, A.prototype.isDestroyed = function () {
            return !1
        }, A.prototype.destroy = function () {
            this._scene = this._scene && this._scene.destroy(), this._container.removeChild(this._element), s(this)
        }, A.prototype.resize = function () {
            var e = this._canvas, t = e.clientWidth, i = e.clientHeight;
            (this._forceResize || this._canvasWidth !== t || this._canvasHeight !== i) && (this._forceResize = !1, b(this), w(this))
        }, A.prototype.render = function () {
            if (this._canRender) {
                this._scene.initializeFrame();
                var e = this._clock.tick();
                this._scene.render(e)
            } else this._clock.tick()
        }, A
    }),define("Cesium/Widgets/ClockViewModel", ["../Core/Clock", "../Core/defined", "../Core/defineProperties", "../Core/destroyObject", "../Core/EventHelper", "../Core/JulianDate", "../ThirdParty/knockout"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = function (i) {
            t(i) || (i = new e), this._clock = i, this._eventHelper = new r, this._eventHelper.add(i.onTick, this.synchronize, this);
            var n = a.observable(i.startTime);
            n.equalityComparer = o.equals, this.systemTime = a.observable(o.now()), this.systemTime.equalityComparer = o.equals, a.track(this, ["systemTime"]), this.startTime = void 0, a.defineProperty(this, "startTime", {
                get: n,
                set: function (e) {
                    n(e), i.startTime = e
                }
            });
            var s = a.observable(i.stopTime);
            s.equalityComparer = o.equals, this.stopTime = void 0, a.defineProperty(this, "stopTime", {
                get: s,
                set: function (e) {
                    i.stopTime = e, s(e)
                }
            });
            var u = a.observable(i.currentTime);
            u.equalityComparer = o.equals, this.currentTime = void 0, a.defineProperty(this, "currentTime", {
                get: u,
                set: function (e) {
                    i.currentTime = e, u(e)
                }
            });
            var l = a.observable(i.multiplier);
            this.multiplier = void 0, a.defineProperty(this, "multiplier", {
                get: l, set: function (e) {
                    i.multiplier = e, l(e)
                }
            });
            var c = a.observable(i.clockStep);
            c.equalityComparer = function (e, t) {
                return e === t
            }, this.clockStep = void 0, a.defineProperty(this, "clockStep", {
                get: c, set: function (e) {
                    c(e), i.clockStep = e
                }
            });
            var h = a.observable(i.clockRange);
            h.equalityComparer = function (e, t) {
                return e === t
            }, this.clockRange = void 0, a.defineProperty(this, "clockRange", {
                get: h, set: function (e) {
                    h(e), i.clockRange = e
                }
            });
            var d = a.observable(i.canAnimate);
            this.canAnimate = void 0, a.defineProperty(this, "canAnimate", {
                get: d, set: function (e) {
                    d(e), i.canAnimate = e
                }
            });
            var m = a.observable(i.shouldAnimate);
            this.shouldAnimate = void 0, a.defineProperty(this, "shouldAnimate", {
                get: m, set: function (e) {
                    m(e), i.shouldAnimate = e
                }
            })
        };
        return i(s.prototype, {
            clock: {
                get: function () {
                    return this._clock
                }
            }
        }), s.prototype.synchronize = function () {
            var e = this._clock, t = e.startTime, i = e.stopTime, n = e.currentTime, r = e.multiplier, a = e.clockStep, s = e.clockRange, u = e.canAnimate, l = e.shouldAnimate;
            this.systemTime = o.now(), this.startTime = t, this.stopTime = i, this.currentTime = n, this.multiplier = r, this.clockStep = a, this.clockRange = s, this.canAnimate = u, this.shouldAnimate = l
        }, s.prototype.isDestroyed = function () {
            return !1
        }, s.prototype.destroy = function () {
            this._eventHelper.removeAll(), n(this)
        }, s
    }),define("Cesium/Widgets/FullscreenButton/FullscreenButtonViewModel", ["../../Core/defaultValue", "../../Core/defineProperties", "../../Core/destroyObject", "../../Core/DeveloperError", "../../Core/Fullscreen", "../../ThirdParty/knockout", "../createCommand", "../getElement"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        var u = function (t) {
            var i = this, n = o.observable(r.fullscreen), u = o.observable(r.enabled);
            this.isFullscreen = void 0, o.defineProperty(this, "isFullscreen", {
                get: function () {
                    return n()
                }
            }), this.isFullscreenEnabled = void 0, o.defineProperty(this, "isFullscreenEnabled", {
                get: function () {
                    return u()
                }, set: function (e) {
                    u(e && r.enabled)
                }
            }), this.tooltip = void 0, o.defineProperty(this, "tooltip", function () {
                return this.isFullscreenEnabled ? n() ? "Exit full screen" : "Full screen" : "Full screen unavailable"
            }), this._command = a(function () {
                r.fullscreen ? r.exitFullscreen() : r.requestFullscreen(i._fullscreenElement)
            }, o.getObservable(this, "isFullscreenEnabled")), this._fullscreenElement = e(s(t), document.body), this._callback = function () {
                n(r.fullscreen)
            }, document.addEventListener(r.changeEventName, this._callback)
        };
        return t(u.prototype, {
            fullscreenElement: {
                get: function () {
                    return this._fullscreenElement
                }, set: function (e) {
                    this._fullscreenElement = e
                }
            }, command: {
                get: function () {
                    return this._command
                }
            }
        }), u.prototype.isDestroyed = function () {
            return !1
        }, u.prototype.destroy = function () {
            document.removeEventListener(r.changeEventName, this._callback), i(this)
        }, u
    }),define("Cesium/Widgets/FullscreenButton/FullscreenButton", ["../../Core/defined", "../../Core/defineProperties", "../../Core/destroyObject", "../../Core/DeveloperError", "../../ThirdParty/knockout", "../getElement", "./FullscreenButtonViewModel"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = "M 83.96875 17.5625 L 83.96875 17.59375 L 76.65625 24.875 L 97.09375 24.96875 L 76.09375 45.96875 L 81.9375 51.8125 L 102.78125 30.9375 L 102.875 51.15625 L 110.15625 43.875 L 110.1875 17.59375 L 83.96875 17.5625 z M 44.125 17.59375 L 17.90625 17.625 L 17.9375 43.90625 L 25.21875 51.1875 L 25.3125 30.96875 L 46.15625 51.8125 L 52 45.96875 L 31 25 L 51.4375 24.90625 L 44.125 17.59375 z M 46.0625 76.03125 L 25.1875 96.875 L 25.09375 76.65625 L 17.8125 83.9375 L 17.8125 110.21875 L 44 110.25 L 51.3125 102.9375 L 30.90625 102.84375 L 51.875 81.875 L 46.0625 76.03125 z M 82 76.15625 L 76.15625 82 L 97.15625 103 L 76.71875 103.0625 L 84.03125 110.375 L 110.25 110.34375 L 110.21875 84.0625 L 102.9375 76.8125 L 102.84375 97 L 82 76.15625 z", u = "M 104.34375 17.5625 L 83.5 38.4375 L 83.40625 18.21875 L 76.125 25.5 L 76.09375 51.78125 L 102.3125 51.8125 L 102.3125 51.78125 L 109.625 44.5 L 89.1875 44.40625 L 110.1875 23.40625 L 104.34375 17.5625 z M 23.75 17.59375 L 17.90625 23.4375 L 38.90625 44.4375 L 18.5 44.53125 L 25.78125 51.8125 L 52 51.78125 L 51.96875 25.53125 L 44.6875 18.25 L 44.625 38.46875 L 23.75 17.59375 z M 25.6875 76.03125 L 18.375 83.3125 L 38.78125 83.40625 L 17.8125 104.40625 L 23.625 110.25 L 44.5 89.375 L 44.59375 109.59375 L 51.875 102.3125 L 51.875 76.0625 L 25.6875 76.03125 z M 102.375 76.15625 L 76.15625 76.1875 L 76.1875 102.4375 L 83.46875 109.71875 L 83.5625 89.53125 L 104.40625 110.375 L 110.25 104.53125 L 89.25 83.53125 L 109.6875 83.46875 L 102.375 76.15625 z", l = function (e, t) {
            e = o(e);
            var i = new a(t);
            i._exitFullScreenPath = u, i._enterFullScreenPath = s;
            var n = document.createElement("button");
            n.type = "button", n.className = "cesium-button cesium-fullscreenButton", n.setAttribute("data-bind", "attr: { title: tooltip },click: command,enable: isFullscreenEnabled,cesiumSvgPath: { path: isFullscreen ? _exitFullScreenPath : _enterFullScreenPath, width: 128, height: 128 }"), e.appendChild(n), r.applyBindings(i, n), this._container = e, this._viewModel = i, this._element = n
        };
        return t(l.prototype, {
            container: {
                get: function () {
                    return this._container
                }
            }, viewModel: {
                get: function () {
                    return this._viewModel
                }
            }
        }), l.prototype.isDestroyed = function () {
            return !1
        }, l.prototype.destroy = function () {
            return this._viewModel.destroy(), r.cleanNode(this._element), this._container.removeChild(this._element), i(this)
        }, l
    }),define("Cesium/Widgets/Geocoder/GeocoderViewModel", ["../../Core/BingMapsApi", "../../Core/Cartesian3", "../../Core/defaultValue", "../../Core/defined", "../../Core/defineProperties", "../../Core/DeveloperError", "../../Core/Event", "../../Core/jsonp", "../../Core/Matrix4", "../../Core/Rectangle", "../../ThirdParty/knockout", "../../ThirdParty/when", "../createCommand"], function (e, t, i, n, r, o, a, s, u, l, c, h, d) {
        "use strict";
        function m(e, t) {
            0 === e._flightDuration ? (e._scene.camera.setView({position: t}), e._complete.raiseEvent()) : e._scene.camera.flyTo({
                destination: t,
                complete: function () {
                    e._complete.raiseEvent()
                },
                duration: e._flightDuration,
                endTransform: u.IDENTITY,
                convert: !1
            })
        }

        function p(e) {
            var i = e.searchText;
            if (!/^\s*$/.test(i)) {
                var r = i.match(/[^\s,\n]+/g);
                if (2 === r.length || 3 === r.length) {
                    var o = +r[0], a = +r[1], u = 3 === r.length ? +r[2] : 300;
                    if (!isNaN(o) && !isNaN(a) && !isNaN(u))return void m(e, t.fromDegrees(o, a, u))
                }
                e._isSearchInProgress = !0;
                var c = s(e._url + "REST/v1/Locations", {
                    parameters: {query: i, key: e._key},
                    callbackParameterName: "jsonp"
                }), d = e._geocodeInProgress = h(c, function (t) {
                    if (!d.cancel) {
                        if (e._isSearchInProgress = !1, 0 === t.resourceSets.length)return void(e.searchText = e._searchText + " (not found)");
                        var i = t.resourceSets[0];
                        if (0 === i.resources.length)return void(e.searchText = e._searchText + " (not found)");
                        var r = i.resources[0];
                        e._searchText = r.name;
                        var o = r.bbox, a = o[0], s = o[1], u = o[2], c = o[3], h = l.fromDegrees(s, a, c, u), p = e._scene.camera, f = p.getRectangleCameraCoordinates(h);
                        n(f) && m(e, f)
                    }
                }, function () {
                    d.cancel || (e._isSearchInProgress = !1, e.searchText = e._searchText + " (error)")
                })
            }
        }

        function f(e) {
            e._isSearchInProgress = !1, n(e._geocodeInProgress) && (e._geocodeInProgress.cancel = !0, e._geocodeInProgress = void 0)
        }

        var _ = function (t) {
            this._url = i(t.url, "//dev.virtualearth.net/"), this._url.length > 0 && "/" !== this._url[this._url.length - 1] && (this._url += "/"), this._key = e.getKey(t.key), this._scene = t.scene, this._flightDuration = t.flightDuration, this._searchText = "", this._isSearchInProgress = !1, this._geocodeInProgress = void 0, this._complete = new a;
            var n = this;
            this._searchCommand = d(function () {
                n.isSearchInProgress ? f(n) : p(n)
            }), c.track(this, ["_searchText", "_isSearchInProgress"]), this.isSearchInProgress = void 0, c.defineProperty(this, "isSearchInProgress", {
                get: function () {
                    return this._isSearchInProgress
                }
            }), this.searchText = void 0, c.defineProperty(this, "searchText", {
                get: function () {
                    return this.isSearchInProgress ? "Searching..." : this._searchText
                }, set: function (e) {
                    this._searchText = e
                }
            }), this.flightDuration = void 0, c.defineProperty(this, "flightDuration", {
                get: function () {
                    return this._flightDuration
                }, set: function (e) {
                    this._flightDuration = e
                }
            })
        };
        return r(_.prototype, {
            url: {
                get: function () {
                    return this._url
                }
            }, key: {
                get: function () {
                    return this._key
                }
            }, complete: {
                get: function () {
                    return this._complete
                }
            }, scene: {
                get: function () {
                    return this._scene
                }
            }, search: {
                get: function () {
                    return this._searchCommand
                }
            }
        }), _
    }),define("Cesium/Widgets/Geocoder/Geocoder", ["../../Core/defined", "../../Core/defineProperties", "../../Core/destroyObject", "../../Core/DeveloperError", "../../Core/FeatureDetection", "../../ThirdParty/knockout", "../getElement", "./GeocoderViewModel"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        var u = "M29.772,26.433l-7.126-7.126c0.96-1.583,1.523-3.435,1.524-5.421C24.169,8.093,19.478,3.401,13.688,3.399C7.897,3.401,3.204,8.093,3.204,13.885c0,5.789,4.693,10.481,10.484,10.481c1.987,0,3.839-0.563,5.422-1.523l7.128,7.127L29.772,26.433zM7.203,13.885c0.006-3.582,2.903-6.478,6.484-6.486c3.579,0.008,6.478,2.904,6.484,6.486c-0.007,3.58-2.905,6.476-6.484,6.484C10.106,20.361,7.209,17.465,7.203,13.885z", l = "M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z", c = function (e) {
            var t = a(e.container), i = new s(e);
            i._startSearchPath = u, i._stopSearchPath = l;
            var n = document.createElement("form");
            n.setAttribute("data-bind", "submit: search");
            var c = document.createElement("input");
            c.type = "search", c.className = "cesium-geocoder-input", c.setAttribute("placeholder", "Enter an address or landmark..."), c.setAttribute("data-bind", 'value: searchText,valueUpdate: "afterkeydown",disable: isSearchInProgress,css: { "cesium-geocoder-input-wide" : searchText.length > 0 }'), n.appendChild(c);
            var h = document.createElement("span");
            h.className = "cesium-geocoder-searchButton", h.setAttribute("data-bind", "click: search,cesiumSvgPath: { path: isSearchInProgress ? _stopSearchPath : _startSearchPath, width: 32, height: 32 }"), n.appendChild(h), t.appendChild(n), o.applyBindings(i, n), this._container = t, this._viewModel = i, this._form = n, this._onInputBegin = function (e) {
                t.contains(e.target) || c.blur()
            }, this._onInputEnd = function (e) {
                t.contains(e.target) && c.focus()
            }, r.supportsPointerEvents() ? (document.addEventListener("pointerdown", this._onInputBegin, !0), document.addEventListener("pointerup", this._onInputEnd, !0)) : (document.addEventListener("mousedown", this._onInputBegin, !0), document.addEventListener("mouseup", this._onInputEnd, !0), document.addEventListener("touchstart", this._onInputBegin, !0), document.addEventListener("touchend", this._onInputEnd, !0))
        };
        return t(c.prototype, {
            container: {
                get: function () {
                    return this._container
                }
            }, viewModel: {
                get: function () {
                    return this._viewModel
                }
            }
        }), c.prototype.isDestroyed = function () {
            return !1
        }, c.prototype.destroy = function () {
            return r.supportsPointerEvents() ? (document.removeEventListener("pointerdown", this._onInputBegin, !0), document.removeEventListener("pointerup", this._onInputEnd, !0)) : (document.removeEventListener("mousedown", this._onInputBegin, !0), document.removeEventListener("mouseup", this._onInputEnd, !0), document.removeEventListener("touchstart", this._onInputBegin, !0), document.removeEventListener("touchend", this._onInputEnd, !0)), o.cleanNode(this._form), this._container.removeChild(this._form), i(this)
        }, c
    }),define("Cesium/Widgets/HomeButton/HomeButtonViewModel", ["../../Core/Cartesian3", "../../Core/defaultValue", "../../Core/defined", "../../Core/defineProperties", "../../Core/DeveloperError", "../../Core/Matrix4", "../../Core/Rectangle", "../../Scene/Camera", "../../Scene/SceneMode", "../../ThirdParty/knockout", "../createCommand"], function (e, t, i, n, r, o, a, s, u, l, c) {
        "use strict";
        function h(t, n) {
            var r = t.mode;
            if (i(t) && r === u.MORPHING && t.completeMorph(), r === u.SCENE2D)t.camera.flyTo({
                destination: a.MAX_VALUE,
                duration: n,
                endTransform: o.IDENTITY
            }); else if (r === u.SCENE3D) {
                var l = t.camera.getRectangleCameraCoordinates(s.DEFAULT_VIEW_RECTANGLE), c = e.magnitude(l);
                c += c * s.DEFAULT_VIEW_FACTOR, e.normalize(l, l), e.multiplyByScalar(l, c, l), t.camera.flyTo({
                    destination: l,
                    orientation: {heading: 0, pitch: .5 * -Math.PI, roll: 0},
                    duration: n,
                    endTransform: o.IDENTITY
                })
            } else if (r === u.COLUMBUS_VIEW) {
                var h = t.globe.ellipsoid.maximumRadius, d = new e(0, -1, 1);
                d = e.multiplyByScalar(e.normalize(d, d), 5 * h, d);
                var m = -Math.acos(e.normalize(d, new e).z);
                t.camera.flyTo({
                    destination: d,
                    duration: n,
                    orientation: {heading: 0, pitch: m, roll: 0},
                    endTransform: o.IDENTITY,
                    convert: !1
                })
            }
        }

        var d = function (e, t) {
            this._scene = e, this._duration = t;
            var i = this;
            this._command = c(function () {
                h(i._scene, i._duration)
            }), this.tooltip = "View Home", l.track(this, ["tooltip"])
        };
        return n(d.prototype, {
            scene: {
                get: function () {
                    return this._scene
                }
            }, command: {
                get: function () {
                    return this._command
                }
            }, duration: {
                get: function () {
                    return this._duration
                }, set: function (e) {
                    this._duration = e
                }
            }
        }), d
    }),define("Cesium/Widgets/HomeButton/HomeButton", ["../../Core/defined", "../../Core/defineProperties", "../../Core/destroyObject", "../../Core/DeveloperError", "../../ThirdParty/knockout", "../getElement", "./HomeButtonViewModel"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = function (e, t, i) {
            e = o(e);
            var n = new a(t, i);
            n._svgPath = "M14,4l-10,8.75h20l-4.25-3.7188v-4.6562h-2.812v2.1875l-2.938-2.5625zm-7.0938,9.906v10.094h14.094v-10.094h-14.094zm2.1876,2.313h3.3122v4.25h-3.3122v-4.25zm5.8442,1.281h3.406v6.438h-3.406v-6.438z";
            var s = document.createElement("button");
            s.type = "button", s.className = "cesium-button cesium-toolbar-button cesium-home-button", s.setAttribute("data-bind", "attr: { title: tooltip },click: command,cesiumSvgPath: { path: _svgPath, width: 28, height: 28 }"), e.appendChild(s), r.applyBindings(n, s), this._container = e, this._viewModel = n, this._element = s
        };
        return t(s.prototype, {
            container: {
                get: function () {
                    return this._container
                }
            }, viewModel: {
                get: function () {
                    return this._viewModel
                }
            }
        }), s.prototype.isDestroyed = function () {
            return !1
        }, s.prototype.destroy = function () {
            return r.cleanNode(this._element), this._container.removeChild(this._element), i(this)
        }, s
    }),define("Cesium/Widgets/InfoBox/InfoBoxViewModel", ["../../Core/defined", "../../Core/defineProperties", "../../Core/Event", "../../ThirdParty/knockout"], function (e, t, i, n) {
        "use strict";
        var r = "M 13.84375 7.03125 C 11.412798 7.03125 9.46875 8.975298 9.46875 11.40625 L 9.46875 11.59375 L 2.53125 7.21875 L 2.53125 24.0625 L 9.46875 19.6875 C 9.4853444 22.104033 11.423165 24.0625 13.84375 24.0625 L 25.875 24.0625 C 28.305952 24.0625 30.28125 22.087202 30.28125 19.65625 L 30.28125 11.40625 C 30.28125 8.975298 28.305952 7.03125 25.875 7.03125 L 13.84375 7.03125 z", o = "M 27.34375 1.65625 L 5.28125 27.9375 L 8.09375 30.3125 L 30.15625 4.03125 L 27.34375 1.65625 z M 13.84375 7.03125 C 11.412798 7.03125 9.46875 8.975298 9.46875 11.40625 L 9.46875 11.59375 L 2.53125 7.21875 L 2.53125 24.0625 L 9.46875 19.6875 C 9.4724893 20.232036 9.5676108 20.7379 9.75 21.21875 L 21.65625 7.03125 L 13.84375 7.03125 z M 28.21875 7.71875 L 14.53125 24.0625 L 25.875 24.0625 C 28.305952 24.0625 30.28125 22.087202 30.28125 19.65625 L 30.28125 11.40625 C 30.28125 9.8371439 29.456025 8.4902779 28.21875 7.71875 z", a = function () {
            this._cameraClicked = new i, this._closeClicked = new i, this.maxHeight = 500, this.enableCamera = !1, this.isCameraTracking = !1, this.showInfo = !1, this.titleText = "", this.description = "", n.track(this, ["showInfo", "titleText", "description", "maxHeight", "enableCamera", "isCameraTracking"]), this._loadingIndicatorHtml = '<div class="cesium-infoBox-loadingContainer"><span class="cesium-infoBox-loading"></span></div>', this.cameraIconPath = void 0, n.defineProperty(this, "cameraIconPath", {
                get: function () {
                    return !this.enableCamera || this.isCameraTracking ? o : r
                }
            }), n.defineProperty(this, "_bodyless", {
                get: function () {
                    return !e(this.description) || 0 === this.description.length
                }
            })
        };
        return a.prototype.maxHeightOffset = function (e) {
            return this.maxHeight - e + "px"
        }, t(a.prototype, {
            cameraClicked: {
                get: function () {
                    return this._cameraClicked
                }
            }, closeClicked: {
                get: function () {
                    return this._closeClicked
                }
            }
        }), a
    }),define("Cesium/Widgets/InfoBox/InfoBox", ["../../Core/buildModuleUrl", "../../Core/Color", "../../Core/defined", "../../Core/defineProperties", "../../Core/destroyObject", "../../Core/DeveloperError", "../../ThirdParty/knockout", "../getElement", "../subscribeAndEvaluate", "./InfoBoxViewModel"], function (e, t, i, n, r, o, a, s, u, l) {
        "use strict";
        var c = function (n) {
            n = s(n);
            var r = document.createElement("div");
            r.className = "cesium-infoBox", r.setAttribute("data-bind", 'css: { "cesium-infoBox-visible" : showInfo, "cesium-infoBox-bodyless" : _bodyless }'), n.appendChild(r);
            var o = document.createElement("div");
            o.className = "cesium-infoBox-title", o.setAttribute("data-bind", "text: titleText"), r.appendChild(o);
            var c = document.createElement("button");
            c.type = "button", c.className = "cesium-button cesium-infoBox-camera", c.setAttribute("data-bind", 'attr: { title: "Focus camera on object" },click: function () { cameraClicked.raiseEvent(this); },enable: enableCamera,cesiumSvgPath: { path: cameraIconPath, width: 32, height: 32 }'), r.appendChild(c);
            var h = document.createElement("button");
            h.type = "button", h.className = "cesium-infoBox-close", h.setAttribute("data-bind", "click: function () { closeClicked.raiseEvent(this); }"), h.innerHTML = "&times;", r.appendChild(h);
            var d = document.createElement("iframe");
            d.className = "cesium-infoBox-iframe", d.setAttribute("sandbox", "allow-same-origin allow-popups allow-forms"), d.setAttribute("data-bind", "style : { maxHeight : maxHeightOffset(40) }"), d.setAttribute("allowfullscreen", !0), r.appendChild(d);
            var m = new l;
            a.applyBindings(m, r), this._container = n, this._element = r, this._frame = d, this._viewModel = m, this._descriptionSubscription = void 0;
            var p = this;
            d.addEventListener("load", function () {
                var n = d.contentDocument, o = n.createElement("link");
                o.href = e("Widgets/InfoBox/InfoBoxDescription.css"), o.rel = "stylesheet", o.type = "text/css";
                var a = n.createElement("div");
                a.className = "cesium-infoBox-description", n.head.appendChild(o), n.body.appendChild(a), p._descriptionSubscription = u(m, "description", function (e) {
                    d.style.height = "5px", a.innerHTML = e;
                    var n = null, o = a.firstElementChild;
                    if (null !== o && 1 === a.childNodes.length) {
                        var s = window.getComputedStyle(o);
                        if (null !== s) {
                            var u = s["background-color"], l = t.fromCssColorString(u);
                            i(l) && 0 !== l.alpha && (n = s["background-color"])
                        }
                    }
                    r.style["background-color"] = n;
                    var c = a.getBoundingClientRect().height;
                    d.style.height = c + "px"
                })
            }), d.setAttribute("src", "about:blank")
        };
        return n(c.prototype, {
            container: {
                get: function () {
                    return this._container
                }
            }, viewModel: {
                get: function () {
                    return this._viewModel
                }
            }, frame: {
                get: function () {
                    return this._frame
                }
            }
        }), c.prototype.isDestroyed = function () {
            return !1
        }, c.prototype.destroy = function () {
            var e = this._container;
            return a.cleanNode(this._element), e.removeChild(this._element), i(this._descriptionSubscription) && this._descriptionSubscription.dispose(), r(this)
        }, c
    }),define("Cesium/Widgets/NavigationHelpButton/NavigationHelpButtonViewModel", ["../../Core/defineProperties", "../../ThirdParty/knockout", "../createCommand"], function (e, t, i) {
        "use strict";
        var n = function () {
            this.showInstructions = !1;
            var e = this;
            this._command = i(function () {
                e.showInstructions = !e.showInstructions
            }), this._showClick = i(function () {
                e._touch = !1
            }), this._showTouch = i(function () {
                e._touch = !0
            }), this._touch = !1, this.tooltip = "Navigation Instructions", t.track(this, ["tooltip", "showInstructions", "_touch"])
        };
        return e(n.prototype, {
            command: {
                get: function () {
                    return this._command
                }
            }, showClick: {
                get: function () {
                    return this._showClick
                }
            }, showTouch: {
                get: function () {
                    return this._showTouch
                }
            }
        }), n
    }),define("Cesium/Widgets/NavigationHelpButton/NavigationHelpButton", ["../../Core/buildModuleUrl", "../../Core/defaultValue", "../../Core/defined", "../../Core/defineProperties", "../../Core/destroyObject", "../../Core/DeveloperError", "../../Core/FeatureDetection", "../../ThirdParty/knockout", "../getElement", "./NavigationHelpButtonViewModel"], function (e, t, i, n, r, o, a, s, u, l) {
        "use strict";
        var c = function (i) {
            var n = u(i.container), r = new l, o = t(i.instructionsInitiallyVisible, !1);
            r.showInstructions = o, r._svgPath = "M16,1.466C7.973,1.466,1.466,7.973,1.466,16c0,8.027,6.507,14.534,14.534,14.534c8.027,0,14.534-6.507,14.534-14.534C30.534,7.973,24.027,1.466,16,1.466z M17.328,24.371h-2.707v-2.596h2.707V24.371zM17.328,19.003v0.858h-2.707v-1.057c0-3.19,3.63-3.696,3.63-5.963c0-1.034-0.924-1.826-2.134-1.826c-1.254,0-2.354,0.924-2.354,0.924l-1.541-1.915c0,0,1.519-1.584,4.137-1.584c2.487,0,4.796,1.54,4.796,4.136C21.156,16.208,17.328,16.627,17.328,19.003z";
            var c = document.createElement("span");
            c.className = "cesium-navigationHelpButton-wrapper", n.appendChild(c);
            var h = document.createElement("button");
            h.type = "button", h.className = "cesium-button cesium-toolbar-button cesium-navigation-help-button", h.setAttribute("data-bind", "attr: { title: tooltip },click: command,cesiumSvgPath: { path: _svgPath, width: 32, height: 32 }"), c.appendChild(h);
            var d = document.createElement("div");
            d.className = "cesium-navigation-help", d.setAttribute("data-bind", 'css: { "cesium-navigation-help-visible" : showInstructions}'), c.appendChild(d);
            var m = document.createElement("button");
            m.type = "button", m.className = "cesium-navigation-button cesium-navigation-button-left", m.setAttribute("data-bind", 'click: showClick, css: {"cesium-navigation-button-selected": !_touch, "cesium-navigation-button-unselected": _touch}');
            var p = document.createElement("img");
            p.src = e("Widgets/Images/NavigationHelp/Mouse.svg"), p.className = "cesium-navigation-button-icon", p.style.width = "25px", p.style.height = "25px", m.appendChild(p), m.appendChild(document.createTextNode("Mouse"));
            var f = document.createElement("button");
            f.type = "button", f.className = "cesium-navigation-button cesium-navigation-button-right", f.setAttribute("data-bind", 'click: showTouch, css: {"cesium-navigation-button-selected": _touch, "cesium-navigation-button-unselected": !_touch}');
            var _ = document.createElement("img");
            _.src = e("Widgets/Images/NavigationHelp/Touch.svg"), _.className = "cesium-navigation-button-icon", _.style.width = "25px", _.style.height = "25px", f.appendChild(_), f.appendChild(document.createTextNode("Touch")), d.appendChild(m), d.appendChild(f);
            var v = document.createElement("div");
            v.className = "cesium-click-navigation-help cesium-navigation-help-instructions", v.setAttribute("data-bind", 'css: { "cesium-click-navigation-help-visible" : !_touch}'), v.innerHTML = '            <table>                <tr>                    <td><img src="' + e("Widgets/Images/NavigationHelp/MouseLeft.svg") + '" width="48" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-pan">Pan view</div>                        <div class="cesium-navigation-help-details">Left click + drag</div>                    </td>                </tr>                <tr>                    <td><img src="' + e("Widgets/Images/NavigationHelp/MouseRight.svg") + '" width="48" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-zoom">Zoom view</div>                        <div class="cesium-navigation-help-details">Right click + drag, or</div>                        <div class="cesium-navigation-help-details">Mouse wheel scroll</div>                    </td>                </tr>                <tr>                    <td><img src="' + e("Widgets/Images/NavigationHelp/MouseMiddle.svg") + '" width="48" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-rotate">Rotate view</div>                        <div class="cesium-navigation-help-details">Middle click + drag, or</div>                        <div class="cesium-navigation-help-details">CTRL + Left/Right click + drag</div>                    </td>                </tr>            </table>', d.appendChild(v);
            var g = document.createElement("div");
            g.className = "cesium-touch-navigation-help cesium-navigation-help-instructions", g.setAttribute("data-bind", 'css: { "cesium-touch-navigation-help-visible" : _touch}'), g.innerHTML = '            <table>                <tr>                    <td><img src="' + e("Widgets/Images/NavigationHelp/TouchDrag.svg") + '" width="70" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-pan">Pan view</div>                        <div class="cesium-navigation-help-details">One finger drag</div>                    </td>                </tr>                <tr>                    <td><img src="' + e("Widgets/Images/NavigationHelp/TouchZoom.svg") + '" width="70" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-zoom">Zoom view</div>                        <div class="cesium-navigation-help-details">Two finger pinch</div>                    </td>                </tr>                <tr>                    <td><img src="' + e("Widgets/Images/NavigationHelp/TouchTilt.svg") + '" width="70" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-rotate">Tilt view</div>                        <div class="cesium-navigation-help-details">Two finger drag, same direction</div>                    </td>                </tr>                <tr>                    <td><img src="' + e("Widgets/Images/NavigationHelp/TouchRotate.svg") + '" width="70" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-tilt">Rotate view</div>                        <div class="cesium-navigation-help-details">Two finger drag, opposite direction</div>                    </td>                </tr>            </table>', d.appendChild(g), s.applyBindings(r, c), this._container = n, this._viewModel = r, this._wrapper = c, this._closeInstructions = function (e) {
                c.contains(e.target) || (r.showInstructions = !1)
            }, a.supportsPointerEvents() ? document.addEventListener("pointerdown", this._closeInstructions, !0) : (document.addEventListener("mousedown", this._closeInstructions, !0), document.addEventListener("touchstart", this._closeInstructions, !0));
        };
        return n(c.prototype, {
            container: {
                get: function () {
                    return this._container
                }
            }, viewModel: {
                get: function () {
                    return this._viewModel
                }
            }
        }), c.prototype.isDestroyed = function () {
            return !1
        }, c.prototype.destroy = function () {
            return a.supportsPointerEvents() ? document.removeEventListener("pointerdown", this._closeInstructions, !0) : (document.removeEventListener("mousedown", this._closeInstructions, !0), document.removeEventListener("touchstart", this._closeInstructions, !0)), s.cleanNode(this._wrapper), this._container.removeChild(this._wrapper), r(this)
        }, c
    }),define("Cesium/Widgets/SceneModePicker/SceneModePickerViewModel", ["../../Core/defaultValue", "../../Core/defined", "../../Core/defineProperties", "../../Core/destroyObject", "../../Core/DeveloperError", "../../Core/EventHelper", "../../Scene/SceneMode", "../../ThirdParty/knockout", "../createCommand"], function (e, t, i, n, r, o, a, s, u) {
        "use strict";
        var l = function (t, i) {
            this._scene = t;
            var n = this, r = function (e, t, i, r) {
                n.sceneMode = i, n.dropDownVisible = !1
            };
            this._eventHelper = new o, this._eventHelper.add(t.morphStart, r), this._duration = e(i, 2), this.sceneMode = t.mode, this.dropDownVisible = !1, this.tooltip2D = "2D", this.tooltip3D = "3D", this.tooltipColumbusView = "Columbus View", s.track(this, ["sceneMode", "dropDownVisible", "tooltip2D", "tooltip3D", "tooltipColumbusView"]), this.selectedTooltip = void 0, s.defineProperty(this, "selectedTooltip", function () {
                var e = n.sceneMode;
                return e === a.SCENE2D ? n.tooltip2D : e === a.SCENE3D ? n.tooltip3D : n.tooltipColumbusView
            }), this._toggleDropDown = u(function () {
                n.dropDownVisible = !n.dropDownVisible
            }), this._morphTo2D = u(function () {
                t.morphTo2D(n._duration)
            }), this._morphTo3D = u(function () {
                t.morphTo3D(n._duration)
            }), this._morphToColumbusView = u(function () {
                t.morphToColumbusView(n._duration)
            }), this._sceneMode = a
        };
        return i(l.prototype, {
            scene: {
                get: function () {
                    return this._scene
                }
            }, duration: {
                get: function () {
                    return this._duration
                }, set: function (e) {
                    this._duration = e
                }
            }, toggleDropDown: {
                get: function () {
                    return this._toggleDropDown
                }
            }, morphTo2D: {
                get: function () {
                    return this._morphTo2D
                }
            }, morphTo3D: {
                get: function () {
                    return this._morphTo3D
                }
            }, morphToColumbusView: {
                get: function () {
                    return this._morphToColumbusView
                }
            }
        }), l.prototype.isDestroyed = function () {
            return !1
        }, l.prototype.destroy = function () {
            this._eventHelper.removeAll(), n(this)
        }, l
    }),define("Cesium/Widgets/SceneModePicker/SceneModePicker", ["../../Core/defined", "../../Core/defineProperties", "../../Core/destroyObject", "../../Core/DeveloperError", "../../Core/FeatureDetection", "../../ThirdParty/knockout", "../getElement", "./SceneModePickerViewModel"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        var u = "m 32.401392,4.9330437 c -7.087603,0 -14.096095,2.884602 -19.10793,7.8946843 -5.0118352,5.010083 -7.9296167,11.987468 -7.9296167,19.072999 0,7.085531 2.9177815,14.097848 7.9296167,19.107931 4.837653,4.835961 11.541408,7.631372 18.374354,7.82482 0.05712,0.01231 0.454119,0.139729 0.454119,0.139729 l 0.03493,-0.104797 c 0.08246,7.84e-4 0.162033,0.03493 0.244525,0.03493 0.08304,0 0.161515,-0.03414 0.244526,-0.03493 l 0.03493,0.104797 c 0,0 0.309474,-0.129487 0.349323,-0.139729 6.867765,-0.168094 13.582903,-2.965206 18.444218,-7.82482 2.558195,-2.5573 4.551081,-5.638134 5.903547,-8.977584 1.297191,-3.202966 2.02607,-6.661489 2.02607,-10.130347 0,-6.237309 -2.366261,-12.31219 -6.322734,-17.116794 -0.0034,-0.02316 0.0049,-0.04488 0,-0.06986 -0.01733,-0.08745 -0.104529,-0.278855 -0.104797,-0.279458 -5.31e-4,-0.0012 -0.522988,-0.628147 -0.523984,-0.62878         -3.47e-4,-2.2e-4 -0.133444,-0.03532 -0.244525,-0.06987 C 51.944299,13.447603 51.751076,13.104317 51.474391,12.827728 46.462556,7.8176457 39.488996,4.9330437 32.401392,4.9330437 z m -2.130866,3.5281554 0.104797,9.6762289 c -4.111695,-0.08361 -7.109829,-0.423664 -9.257041,-0.943171 1.198093,-2.269271 2.524531,-4.124404 3.91241,-5.414496 2.167498,-2.0147811 3.950145,-2.8540169 5.239834,-3.3185619 z m 2.794579,0 c 1.280302,0.4754953 3.022186,1.3285948 5.065173,3.2486979 1.424667,1.338973 2.788862,3.303645 3.982275,5.728886 -2.29082,0.403367 -5.381258,0.621049 -8.942651,0.698645 L 33.065105,8.4611991 z m 5.728886,0.2445256 c 4.004072,1.1230822 7.793098,3.1481363 10.724195,6.0782083 0.03468,0.03466 0.07033,0.06991 0.104797,0.104797 -0.45375,0.313891 -0.923054,0.663002 -1.956205,1.082899 -0.647388,0.263114 -1.906242,0.477396 -2.829511,0.733577 -1.382296,-2.988132         -3.027146,-5.368585 -4.785716,-7.0213781 -0.422866,-0.397432 -0.835818,-0.6453247 -1.25756,-0.9781032 z m -15.33525,0.7685092 c -0.106753,0.09503 -0.207753,0.145402 -0.31439,0.244526 -1.684973,1.5662541 -3.298068,3.8232211 -4.680919,6.5672591 -0.343797,-0.14942 -1.035052,-0.273198 -1.292493,-0.419186 -0.956528,-0.542427 -1.362964,-1.022024 -1.537018,-1.292493 -0.0241,-0.03745 -0.01868,-0.0401 -0.03493,-0.06986 2.250095,-2.163342 4.948824,-3.869984 7.859752,-5.0302421 z m -9.641296,7.0912431 c 0.464973,0.571618 0.937729,1.169056 1.956205,1.746612 0.349907,0.198425 1.107143,0.335404 1.537018,0.523983 -1.20166,3.172984 -1.998037,7.051901 -2.165798,11.772162 C 14.256557,30.361384 12.934823,30.161483 12.280427,29.90959 10.644437,29.279855 9.6888882,28.674891 9.1714586,28.267775 8.6540289,27.860658 8.6474751,27.778724 8.6474751,27.778724 l -0.069864,0.03493 C 9.3100294,23.691285         11.163248,19.798527 13.817445,16.565477 z m 37.552149,0.523984 c 2.548924,3.289983 4.265057,7.202594 4.890513,11.318043 -0.650428,0.410896 -1.756876,1.001936 -3.563088,1.606882 -1.171552,0.392383 -3.163859,0.759153 -4.960377,1.117832 -0.04367,-4.752703 -0.784809,-8.591423 -1.88634,-11.807094 0.917574,-0.263678 2.170552,-0.486495 2.864443,-0.76851 1.274693,-0.518066 2.003942,-1.001558 2.654849,-1.467153 z m -31.439008,2.619917 c 2.487341,0.672766 5.775813,1.137775 10.479669,1.222628 l 0.104797,10.689263 0,0.03493 0,0.733577 c -5.435005,-0.09059 -9.512219,-0.519044 -12.610536,-1.117831 0.106127,-4.776683 0.879334,-8.55791 2.02607,-11.562569 z m 23.264866,0.31439 c 1.073459,3.067541 1.833795,6.821314 1.816476,11.702298 -3.054474,0.423245 -7.062018,0.648559 -11.702298,0.698644 l 0,-0.838373 -0.104796,-10.654331 c 4.082416,-0.0864 7.404468,-0.403886 9.990618,-0.908238 z         M 8.2632205,30.922625 c 0.7558676,0.510548 1.5529563,1.013339 3.0041715,1.57195 0.937518,0.360875 2.612202,0.647642 3.91241,0.978102 0.112814,3.85566 0.703989,7.107756 1.606883,9.920754 -1.147172,-0.324262 -2.644553,-0.640648 -3.423359,-0.978102 -1.516688,-0.657177 -2.386627,-1.287332 -2.864443,-1.71168 -0.477816,-0.424347 -0.489051,-0.489051 -0.489051,-0.489051 L 9.8002387,40.319395 C 8.791691,37.621767 8.1584238,34.769583 8.1584238,31.900727 c 0,-0.330153 0.090589,-0.648169 0.1047967,-0.978102 z m 48.2763445,0.419186 c 0.0047,0.188973 0.06986,0.36991 0.06986,0.558916 0,2.938869 -0.620228,5.873558 -1.676747,8.628261 -0.07435,0.07583 -0.06552,0.07411 -0.454119,0.349323 -0.606965,0.429857 -1.631665,1.042044 -3.318562,1.676747 -1.208528,0.454713 -3.204964,0.850894 -5.135038,1.25756 0.84593,-2.765726 1.41808,-6.005357 1.606883,-9.815957 2.232369,-0.413371 4.483758,-0.840201         5.938479,-1.327425 1.410632,-0.472457 2.153108,-0.89469 2.96924,-1.327425 z m -38.530252,2.864443 c 3.208141,0.56697 7.372279,0.898588 12.575603,0.978103 l 0.174662,9.885821 c -4.392517,-0.06139 -8.106722,-0.320566 -10.863925,-0.803441 -1.051954,-2.664695 -1.692909,-6.043794 -1.88634,-10.060483 z m 26.793022,0.31439 c -0.246298,3.923551 -0.877762,7.263679 -1.816476,9.885822 -2.561957,0.361954 -5.766249,0.560708 -9.431703,0.62878 l -0.174661,-9.815957 c 4.491734,-0.04969 8.334769,-0.293032 11.42284,-0.698645 z M 12.035901,44.860585 c 0.09977,0.04523 0.105535,0.09465 0.209594,0.139729 1.337656,0.579602 3.441099,1.058072 5.589157,1.537018 1.545042,3.399208 3.548524,5.969402 5.589157,7.789888 -3.034411,-1.215537 -5.871615,-3.007978 -8.174142,-5.309699 -1.245911,-1.245475 -2.271794,-2.662961 -3.213766,-4.156936 z m 40.69605,0 c -0.941972,1.493975 -1.967855,2.911461         -3.213765,4.156936 -2.74253,2.741571 -6.244106,4.696717 -9.955686,5.868615 0.261347,-0.241079 0.507495,-0.394491 0.768509,-0.663713 1.674841,-1.727516 3.320792,-4.181056 4.645987,-7.265904 2.962447,-0.503021 5.408965,-1.122293 7.161107,-1.781544 0.284034,-0.106865 0.337297,-0.207323 0.593848,-0.31439 z m -31.404076,2.305527 c 2.645807,0.376448 5.701178,0.649995 9.466635,0.698645 l 0.139729,7.789888 c -1.38739,-0.480844 -3.316218,-1.29837 -5.659022,-3.388427 -1.388822,-1.238993 -2.743668,-3.0113 -3.947342,-5.100106 z m 20.365491,0.104797 c -1.04872,2.041937 -2.174337,3.779068 -3.353494,4.995309 -1.853177,1.911459 -3.425515,2.82679 -4.611055,3.353494 l -0.139729,-7.789887 c 3.13091,-0.05714 5.728238,-0.278725 8.104278,-0.558916 z", l = "m 2.9825053,17.550598 0,1.368113 0,26.267766 0,1.368113 1.36811,0 54.9981397,0 1.36811,0 0,-1.368113 0,-26.267766 0,-1.368113 -1.36811,0 -54.9981397,0 -1.36811,0 z m 2.73623,2.736226 10.3292497,0 0,10.466063 -10.3292497,0 0,-10.466063 z m 13.0654697,0 11.69737,0 0,10.466063 -11.69737,0 0,-10.466063 z m 14.43359,0 11.69737,0 0,10.466063 -11.69737,0 0,-10.466063 z m 14.43359,0 10.32926,0 0,10.466063 -10.32926,0 0,-10.466063 z m -41.9326497,13.202288 10.3292497,0 0,10.329252 -10.3292497,0 0,-10.329252 z m 13.0654697,0 11.69737,0 0,10.329252 -11.69737,0 0,-10.329252 z m 14.43359,0 11.69737,0 0,10.329252 -11.69737,0 0,-10.329252 z m 14.43359,0 10.32926,0 0,10.329252 -10.32926,0 0,-10.329252 z", c = "m 14.723969,17.675598 -0.340489,0.817175 -11.1680536,26.183638 -0.817175,1.872692 2.076986,0 54.7506996,0 2.07698,0 -0.81717,-1.872692 -11.16805,-26.183638 -0.34049,-0.817175 -0.91933,0 -32.414586,0 -0.919322,0 z m 1.838643,2.723916 6.196908,0 -2.928209,10.418977 -7.729111,0 4.460412,-10.418977 z m 9.02297,0 4.903049,0 0,10.418977 -7.831258,0 2.928209,-10.418977 z m 7.626964,0 5.584031,0 2.62176,10.418977 -8.205791,0 0,-10.418977 z m 8.410081,0 5.51593,0 4.46042,10.418977 -7.38863,0 -2.58772,-10.418977 z m -30.678091,13.142892 8.103649,0 -2.89416,10.282782 -9.6018026,0 4.3923136,-10.282782 z m 10.929711,0 8.614384,0 0,10.282782 -11.508544,0 2.89416,-10.282782 z m 11.338299,0 8.852721,0 2.58772,10.282782 -11.440441,0 0,-10.282782 z m 11.678781,0 7.86531,0 4.39231,10.282782 -9.6699,0 -2.58772,-10.282782 z", h = function (e, t, i) {
            e = a(e);
            var n = new s(t, i);
            n._globePath = u, n._flatMapPath = l, n._columbusViewPath = c;
            var h = document.createElement("span");
            h.className = "cesium-sceneModePicker-wrapper cesium-toolbar-button", e.appendChild(h);
            var d = document.createElement("button");
            d.type = "button", d.className = "cesium-button cesium-toolbar-button", d.setAttribute("data-bind", 'css: { "cesium-sceneModePicker-button2D": sceneMode === _sceneMode.SCENE2D,       "cesium-sceneModePicker-button3D": sceneMode === _sceneMode.SCENE3D,       "cesium-sceneModePicker-buttonColumbusView": sceneMode === _sceneMode.COLUMBUS_VIEW,       "cesium-sceneModePicker-selected": dropDownVisible },attr: { title: selectedTooltip },click: toggleDropDown'), d.innerHTML = '<!-- ko cesiumSvgPath: { path: _globePath, width: 64, height: 64, css: "cesium-sceneModePicker-slide-svg cesium-sceneModePicker-icon3D" } --><!-- /ko --><!-- ko cesiumSvgPath: { path: _flatMapPath, width: 64, height: 64, css: "cesium-sceneModePicker-slide-svg cesium-sceneModePicker-icon2D" } --><!-- /ko --><!-- ko cesiumSvgPath: { path: _columbusViewPath, width: 64, height: 64, css: "cesium-sceneModePicker-slide-svg cesium-sceneModePicker-iconColumbusView" } --><!-- /ko -->', h.appendChild(d);
            var m = document.createElement("button");
            m.type = "button", m.className = "cesium-button cesium-toolbar-button cesium-sceneModePicker-dropDown-icon", m.setAttribute("data-bind", 'css: { "cesium-sceneModePicker-visible" : (dropDownVisible && (sceneMode !== _sceneMode.SCENE3D)) || (!dropDownVisible && (sceneMode === _sceneMode.SCENE3D)),       "cesium-sceneModePicker-none" : sceneMode === _sceneMode.SCENE3D,       "cesium-sceneModePicker-hidden" : !dropDownVisible },attr: { title: tooltip3D },click: morphTo3D,cesiumSvgPath: { path: _globePath, width: 64, height: 64 }'), h.appendChild(m);
            var p = document.createElement("button");
            p.type = "button", p.className = "cesium-button cesium-toolbar-button cesium-sceneModePicker-dropDown-icon", p.setAttribute("data-bind", 'css: { "cesium-sceneModePicker-visible" : (dropDownVisible && (sceneMode !== _sceneMode.SCENE2D)),       "cesium-sceneModePicker-none" : sceneMode === _sceneMode.SCENE2D,       "cesium-sceneModePicker-hidden" : !dropDownVisible },attr: { title: tooltip2D },click: morphTo2D,cesiumSvgPath: { path: _flatMapPath, width: 64, height: 64 }'), h.appendChild(p);
            var f = document.createElement("button");
            f.type = "button", f.className = "cesium-button cesium-toolbar-button cesium-sceneModePicker-dropDown-icon", f.setAttribute("data-bind", 'css: { "cesium-sceneModePicker-visible" : (dropDownVisible && (sceneMode !== _sceneMode.COLUMBUS_VIEW)) || (!dropDownVisible && (sceneMode === _sceneMode.COLUMBUS_VIEW)),       "cesium-sceneModePicker-none" : sceneMode === _sceneMode.COLUMBUS_VIEW,       "cesium-sceneModePicker-hidden" : !dropDownVisible},attr: { title: tooltipColumbusView },click: morphToColumbusView,cesiumSvgPath: { path: _columbusViewPath, width: 64, height: 64 }'), h.appendChild(f), o.applyBindings(n, h), this._viewModel = n, this._container = e, this._wrapper = h, this._closeDropDown = function (e) {
                h.contains(e.target) || (n.dropDownVisible = !1)
            }, r.supportsPointerEvents() ? document.addEventListener("pointerdown", this._closeDropDown, !0) : (document.addEventListener("mousedown", this._closeDropDown, !0), document.addEventListener("touchstart", this._closeDropDown, !0))
        };
        return t(h.prototype, {
            container: {
                get: function () {
                    return this._container
                }
            }, viewModel: {
                get: function () {
                    return this._viewModel
                }
            }
        }), h.prototype.isDestroyed = function () {
            return !1
        }, h.prototype.destroy = function () {
            return this._viewModel.destroy(), r.supportsPointerEvents() ? document.removeEventListener("pointerdown", this._closeDropDown, !0) : (document.removeEventListener("mousedown", this._closeDropDown, !0), document.removeEventListener("touchstart", this._closeDropDown, !0)), o.cleanNode(this._wrapper), this._container.removeChild(this._wrapper), i(this)
        }, h
    }),define("Cesium/Widgets/SelectionIndicator/SelectionIndicatorViewModel", ["../../Core/Cartesian2", "../../Core/defaultValue", "../../Core/defined", "../../Core/defineProperties", "../../Core/DeveloperError", "../../Core/EasingFunction", "../../Scene/SceneTransforms", "../../ThirdParty/knockout"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        var u = new e, l = "-1000px", c = function (e, n, r) {
            this._scene = e, this._screenPositionX = l, this._screenPositionY = l, this._tweens = e.tweens, this._container = t(r, document.body), this._selectionIndicatorElement = n, this._scale = 1, this.position = void 0, this.showSelection = !1, s.track(this, ["position", "_screenPositionX", "_screenPositionY", "_scale", "showSelection"]), this.isVisible = void 0, s.defineProperty(this, "isVisible", {
                get: function () {
                    return this.showSelection && i(this.position)
                }
            }), s.defineProperty(this, "_transform", {
                get: function () {
                    return "scale(" + this._scale + ")"
                }
            }), this.computeScreenSpacePosition = function (t, i) {
                return a.wgs84ToWindowCoordinates(e, t, i)
            }
        };
        return c.prototype.update = function () {
            if (this.showSelection && i(this.position)) {
                var e = this.computeScreenSpacePosition(this.position, u);
                if (i(e)) {
                    var t = this._container, n = t.parentNode.clientWidth, r = t.parentNode.clientHeight, o = this._selectionIndicatorElement.clientWidth, a = .5 * o;
                    e.x = Math.min(Math.max(e.x, -o), n + o) - a, e.y = Math.min(Math.max(e.y, -o), r + o) - a, this._screenPositionX = Math.floor(e.x + .25) + "px", this._screenPositionY = Math.floor(e.y + .25) + "px"
                } else this._screenPositionX = l, this._screenPositionY = l
            }
        }, c.prototype.animateAppear = function () {
            this._tweens.addProperty({
                object: this,
                property: "_scale",
                startValue: 2,
                stopValue: 1,
                duration: .8,
                easingFunction: o.EXPONENTIAL_OUT
            })
        }, c.prototype.animateDepart = function () {
            this._tweens.addProperty({
                object: this,
                property: "_scale",
                startValue: this._scale,
                stopValue: 1.5,
                duration: .8,
                easingFunction: o.EXPONENTIAL_OUT
            })
        }, n(c.prototype, {
            container: {
                get: function () {
                    return this._container
                }
            }, selectionIndicatorElement: {
                get: function () {
                    return this._selectionIndicatorElement
                }
            }, scene: {
                get: function () {
                    return this._scene
                }
            }
        }), c
    }),define("Cesium/Widgets/SelectionIndicator/SelectionIndicator", ["../../Core/defined", "../../Core/defineProperties", "../../Core/destroyObject", "../../Core/DeveloperError", "../../ThirdParty/knockout", "../getElement", "./SelectionIndicatorViewModel"], function (e, t, i, n, r, o, a) {
        "use strict";
        var s = function (e, t) {
            e = o(e), this._container = e;
            var i = document.createElement("div");
            i.className = "cesium-selection-wrapper", i.setAttribute("data-bind", 'style: { "top" : _screenPositionY, "left" : _screenPositionX },css: { "cesium-selection-wrapper-visible" : isVisible }'), e.appendChild(i), this._element = i;
            var n = "http://www.w3.org/2000/svg", s = "M -34 -34 L -34 -11.25 L -30 -15.25 L -30 -30 L -15.25 -30 L -11.25 -34 L -34 -34 z M 11.25 -34 L 15.25 -30 L 30 -30 L 30 -15.25 L 34 -11.25 L 34 -34 L 11.25 -34 z M -34 11.25 L -34 34 L -11.25 34 L -15.25 30 L -30 30 L -30 15.25 L -34 11.25 z M 34 11.25 L 30 15.25 L 30 30 L 15.25 30 L 11.25 34 L 34 34 L 34 11.25 z", u = document.createElementNS(n, "svg:svg");
            u.setAttribute("width", 160), u.setAttribute("height", 160), u.setAttribute("viewBox", "0 0 160 160");
            var l = document.createElementNS(n, "g");
            l.setAttribute("transform", "translate(80,80)"), u.appendChild(l);
            var c = document.createElementNS(n, "path");
            c.setAttribute("data-bind", "attr: { transform: _transform }"), c.setAttribute("d", s), l.appendChild(c), i.appendChild(u);
            var h = new a(t, this._element, this._container);
            this._viewModel = h, r.applyBindings(this._viewModel, this._element)
        };
        return t(s.prototype, {
            container: {
                get: function () {
                    return this._container
                }
            }, viewModel: {
                get: function () {
                    return this._viewModel
                }
            }
        }), s.prototype.isDestroyed = function () {
            return !1
        }, s.prototype.destroy = function () {
            var e = this._container;
            return r.cleanNode(this._element), e.removeChild(this._element), i(this)
        }, s
    }),define("Cesium/Widgets/Timeline/TimelineHighlightRange", ["../../Core/defaultValue", "../../Core/JulianDate"], function (e, t) {
        "use strict";
        function i(t, i, n) {
            this._color = t, this._height = i, this._base = e(n, 0)
        }

        return i.prototype.getHeight = function () {
            return this._height
        }, i.prototype.getBase = function () {
            return this._base
        }, i.prototype.getStartTime = function () {
            return this._start
        }, i.prototype.getStopTime = function () {
            return this._stop
        }, i.prototype.setRange = function (e, t) {
            this._start = e, this._stop = t
        }, i.prototype.render = function (e) {
            var i = "";
            if (this._start && this._stop && this._color) {
                var n = t.secondsDifference(this._start, e.epochJulian), r = Math.round(e.timeBarWidth * e.getAlpha(n)), o = t.secondsDifference(this._stop, e.epochJulian), a = Math.round(e.timeBarWidth * e.getAlpha(o)) - r;
                0 > r && (a += r, r = 0), r + a > e.timeBarWidth && (a = e.timeBarWidth - r), a > 0 && (i = '<span class="cesium-timeline-highlight" style="left: ' + r.toString() + "px; width: " + a.toString() + "px; bottom: " + this._base.toString() + "px; height: " + this._height + "px; background-color: " + this._color + ';"></span>')
            }
            return i
        }, i
    }),define("Cesium/Widgets/Timeline/TimelineTrack", ["../../Core/Color", "../../Core/defined", "../../Core/JulianDate"], function (e, t, i) {
        "use strict";
        function n(t, i, n, r) {
            this.interval = t, this.height = i, this.color = n || new e(.5, .5, .5, 1), this.backgroundColor = r || new e(0, 0, 0, 0)
        }

        return n.prototype.render = function (e, n) {
            var r = this.interval.start, o = this.interval.stop, a = n.startJulian, s = i.addSeconds(n.startJulian, n.duration, new i);
            if (i.lessThan(r, a) && i.greaterThan(o, s))e.fillStyle = this.color.toCssColorString(), e.fillRect(0, n.y, n.timeBarWidth, this.height); else if (i.lessThanOrEquals(r, s) && i.greaterThanOrEquals(o, a)) {
                var u, l, c;
                for (u = 0; u < n.timeBarWidth; ++u) {
                    var h = i.addSeconds(n.startJulian, u / n.timeBarWidth * n.duration, new i);
                    !t(l) && i.greaterThanOrEquals(h, r) ? l = u : !t(c) && i.greaterThanOrEquals(h, o) && (c = u)
                }
                e.fillStyle = this.backgroundColor.toCssColorString(), e.fillRect(0, n.y, n.timeBarWidth, this.height), t(l) && (t(c) || (c = n.timeBarWidth), e.fillStyle = this.color.toCssColorString(), e.fillRect(l, n.y, Math.max(c - l, 1), this.height))
            }
        }, n
    }),define("Cesium/Widgets/Timeline/Timeline", ["../../Core/ClockRange", "../../Core/defined", "../../Core/destroyObject", "../../Core/DeveloperError", "../../Core/JulianDate", "../getElement", "./TimelineHighlightRange", "./TimelineTrack"], function (e, t, i, n, r, o, a, s) {
        "use strict";
        function u(e) {
            return 10 > e ? "0" + e.toString() : e.toString()
        }

        function l(e) {
            return function (t) {
                e._mouseMode !== v.touchOnly && (0 === t.button ? (e._mouseMode = v.scrub, e._scrubElement && (e._scrubElement.style.backgroundPosition = "-16px 0"), e._onMouseMove(t)) : (e._mouseX = t.clientX, 2 === t.button ? e._mouseMode = v.zoom : e._mouseMode = v.slide)), t.preventDefault()
            }
        }

        function c(e) {
            return function (t) {
                e._mouseMode = v.none, e._scrubElement && (e._scrubElement.style.backgroundPosition = "0px 0px"), e._timelineDrag = 0, e._timelineDragLocation = void 0
            }
        }

        function h(e) {
            return function (t) {
                var i;
                if (e._mouseMode === v.scrub) {
                    t.preventDefault();
                    var n = t.clientX - e._topDiv.getBoundingClientRect().left;
                    0 > n ? (e._timelineDragLocation = 0, e._timelineDrag = -.01 * e._timeBarSecondsSpan) : n > e._topDiv.clientWidth ? (e._timelineDragLocation = e._topDiv.clientWidth, e._timelineDrag = .01 * e._timeBarSecondsSpan) : (e._timelineDragLocation = void 0, e._setTimeBarTime(n, n * e._timeBarSecondsSpan / e._topDiv.clientWidth))
                } else if (e._mouseMode === v.slide) {
                    if (i = e._mouseX - t.clientX, e._mouseX = t.clientX, 0 !== i) {
                        var o = i * e._timeBarSecondsSpan / e._topDiv.clientWidth;
                        e.zoomTo(r.addSeconds(e._startJulian, o, new r), r.addSeconds(e._endJulian, o, new r))
                    }
                } else e._mouseMode === v.zoom && (i = e._mouseX - t.clientX, e._mouseX = t.clientX, 0 !== i && e.zoomFrom(Math.pow(1.01, i)))
            }
        }

        function d(e) {
            return function (t) {
                var i = t.wheelDeltaY || t.wheelDelta || -t.detail;
                _ = Math.max(Math.min(Math.abs(i), _), 1), i /= _, e.zoomFrom(Math.pow(1.05, -i))
            }
        }

        function m(e) {
            return function (t) {
                var i, n, o = t.touches.length, a = e._topDiv.getBoundingClientRect().left;
                t.preventDefault(), e._mouseMode = v.touchOnly, 1 === o ? (i = r.secondsDifference(e._scrubJulian, e._startJulian), n = Math.round(i * e._topDiv.clientWidth / e._timeBarSecondsSpan + a), Math.abs(t.touches[0].clientX - n) < 50 ? (e._touchMode = g.scrub, e._scrubElement && (e._scrubElement.style.backgroundPosition = 1 === o ? "-16px 0" : "0 0")) : (e._touchMode = g.singleTap, e._touchState.centerX = t.touches[0].clientX - a)) : 2 === o ? (e._touchMode = g.slideZoom, e._touchState.centerX = .5 * (t.touches[0].clientX + t.touches[1].clientX) - a, e._touchState.spanX = Math.abs(t.touches[0].clientX - t.touches[1].clientX)) : e._touchMode = g.ignore
            }
        }

        function p(e) {
            return function (t) {
                var i = t.touches.length, n = e._topDiv.getBoundingClientRect().left;
                e._touchMode === g.singleTap ? (e._touchMode = g.scrub, e._handleTouchMove(t)) : e._touchMode === g.scrub && e._handleTouchMove(t), e._mouseMode = v.touchOnly, 1 !== i ? e._touchMode = i > 0 ? g.ignore : g.none : e._touchMode === g.slideZoom && (e._touchState.centerX = t.touches[0].clientX - n), e._scrubElement && (e._scrubElement.style.backgroundPosition = "0 0")
            }
        }

        function f(e) {
            return function (i) {
                var n, o, a, s, u, l, c = 1, h = e._topDiv.getBoundingClientRect().left;
                e._touchMode === g.singleTap && (e._touchMode = g.slideZoom), e._mouseMode = v.touchOnly, e._touchMode === g.scrub ? (i.preventDefault(), 1 === i.changedTouches.length && (o = i.changedTouches[0].clientX - h, o >= 0 && o <= e._topDiv.clientWidth && e._setTimeBarTime(o, o * e._timeBarSecondsSpan / e._topDiv.clientWidth))) : e._touchMode === g.slideZoom && (a = i.touches.length, 2 === a ? (s = .5 * (i.touches[0].clientX + i.touches[1].clientX) - h, u = Math.abs(i.touches[0].clientX - i.touches[1].clientX)) : 1 === a && (s = i.touches[0].clientX - h, u = 0), t(s) && (u > 0 && e._touchState.spanX > 0 ? (c = e._touchState.spanX / u, l = r.addSeconds(e._startJulian, (e._touchState.centerX * e._timeBarSecondsSpan - s * e._timeBarSecondsSpan * c) / e._topDiv.clientWidth, new r)) : (n = e._touchState.centerX - s, l = r.addSeconds(e._startJulian, n * e._timeBarSecondsSpan / e._topDiv.clientWidth, new r)), e.zoomTo(l, r.addSeconds(l, e._timeBarSecondsSpan * c, new r)), e._touchState.centerX = s, e._touchState.spanX = u))
            }
        }

        var _ = 1e12, v = {none: 0, scrub: 1, slide: 2, zoom: 3, touchOnly: 4}, g = {
            none: 0,
            scrub: 1,
            slideZoom: 2,
            singleTap: 3,
            ignore: 4
        }, y = [.001, .002, .005, .01, .02, .05, .1, .25, .5, 1, 2, 5, 10, 15, 30, 60, 120, 300, 600, 900, 1800, 3600, 7200, 14400, 21600, 43200, 86400, 172800, 345600, 604800, 1296e3, 2592e3, 5184e3, 7776e3, 15552e3, 31536e3, 63072e3, 126144e3, 15768e4, 31536e4, 63072e4, 126144e4, 15768e5, 31536e5, 63072e5, 126144e5, 15768e6, 31536e6], C = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], E = function (e, t) {
            e = o(e), this.container = e;
            var i = document.createElement("div");
            i.className = "cesium-timeline-main", e.appendChild(i), this._topDiv = i, this._endJulian = void 0, this._epochJulian = void 0, this._lastXPos = void 0, this._scrubElement = void 0, this._startJulian = void 0, this._timeBarSecondsSpan = void 0, this._clock = t, this._scrubJulian = t.currentTime, this._mainTicSpan = -1, this._mouseMode = v.none, this._touchMode = g.none, this._touchState = {
                centerX: 0,
                spanX: 0
            }, this._mouseX = 0, this._timelineDrag = 0, this._timelineDragLocation = void 0, this._lastHeight = void 0, this._lastWidth = void 0, this._topDiv.innerHTML = '<div class="cesium-timeline-bar"></div><div class="cesium-timeline-trackContainer"><canvas class="cesium-timeline-tracks" width="10" height="1"></canvas></div><div class="cesium-timeline-needle"></div><span class="cesium-timeline-ruler"></span>', this._timeBarEle = this._topDiv.childNodes[0], this._trackContainer = this._topDiv.childNodes[1], this._trackListEle = this._topDiv.childNodes[1].childNodes[0], this._needleEle = this._topDiv.childNodes[2], this._rulerEle = this._topDiv.childNodes[3], this._context = this._trackListEle.getContext("2d"), this._trackList = [], this._highlightRanges = [], this.zoomTo(t.startTime, t.stopTime), this._onMouseDown = l(this), this._onMouseUp = c(this), this._onMouseMove = h(this), this._onMouseWheel = d(this), this._onTouchStart = m(this), this._onTouchMove = f(this), this._onTouchEnd = p(this);
            var n = this._timeBarEle;
            document.addEventListener("mouseup", this._onMouseUp, !1), document.addEventListener("mousemove", this._onMouseMove, !1), n.addEventListener("mousedown", this._onMouseDown, !1), n.addEventListener("DOMMouseScroll", this._onMouseWheel, !1), n.addEventListener("mousewheel", this._onMouseWheel, !1), n.addEventListener("touchstart", this._onTouchStart, !1), n.addEventListener("touchmove", this._onTouchMove, !1), n.addEventListener("touchend", this._onTouchEnd, !1), this._topDiv.oncontextmenu = function () {
                return !1
            }, t.onTick.addEventListener(this.updateFromClock, this), this.updateFromClock()
        };
        return E.prototype.addEventListener = function (e, t, i) {
            this._topDiv.addEventListener(e, t, i)
        }, E.prototype.removeEventListener = function (e, t, i) {
            this._topDiv.removeEventListener(e, t, i)
        }, E.prototype.isDestroyed = function () {
            return !1
        }, E.prototype.destroy = function () {
            this._clock.onTick.removeEventListener(this.updateFromClock, this), document.removeEventListener("mouseup", this._onMouseUp, !1), document.removeEventListener("mousemove", this._onMouseMove, !1);
            var e = this._timeBarEle;
            e.removeEventListener("mousedown", this._onMouseDown, !1), e.removeEventListener("DOMMouseScroll", this._onMouseWheel, !1), e.removeEventListener("mousewheel", this._onMouseWheel, !1), e.removeEventListener("touchstart", this._onTouchStart, !1), e.removeEventListener("touchmove", this._onTouchMove, !1), e.removeEventListener("touchend", this._onTouchEnd, !1), this.container.removeChild(this._topDiv), i(this)
        }, E.prototype.addHighlightRange = function (e, t, i) {
            var n = new a(e, t, i);
            return this._highlightRanges.push(n), this.resize(), n
        }, E.prototype.addTrack = function (e, t, i, n) {
            var r = new s(e, t, i, n);
            return this._trackList.push(r), this._lastHeight = void 0, this.resize(), r
        }, E.prototype.zoomTo = function (t, i) {
            if (this._startJulian = t, this._endJulian = i, this._timeBarSecondsSpan = r.secondsDifference(i, t), this._clock && this._clock.clockRange !== e.UNBOUNDED) {
                var n = this._clock.startTime, o = this._clock.stopTime, a = r.secondsDifference(o, n), s = r.secondsDifference(n, this._startJulian), u = r.secondsDifference(o, this._endJulian);
                this._timeBarSecondsSpan >= a ? (this._timeBarSecondsSpan = a, this._startJulian = this._clock.startTime, this._endJulian = this._clock.stopTime) : s > 0 ? (this._endJulian = r.addSeconds(this._endJulian, s, new r), this._startJulian = n, this._timeBarSecondsSpan = r.secondsDifference(this._endJulian, this._startJulian)) : 0 > u && (this._startJulian = r.addSeconds(this._startJulian, u, new r), this._endJulian = o, this._timeBarSecondsSpan = r.secondsDifference(this._endJulian, this._startJulian))
            }
            this._makeTics();
            var l = document.createEvent("Event");
            l.initEvent("setzoom", !0, !0), l.startJulian = this._startJulian, l.endJulian = this._endJulian, l.epochJulian = this._epochJulian, l.totalSpan = this._timeBarSecondsSpan, l.mainTicSpan = this._mainTicSpan, this._topDiv.dispatchEvent(l)
        }, E.prototype.zoomFrom = function (e) {
            var t = r.secondsDifference(this._scrubJulian, this._startJulian);
            e > 1 || 0 > t || t > this._timeBarSecondsSpan ? t = .5 * this._timeBarSecondsSpan : t += t - .5 * this._timeBarSecondsSpan;
            var i = this._timeBarSecondsSpan - t;
            this.zoomTo(r.addSeconds(this._startJulian, t - t * e, new r), r.addSeconds(this._endJulian, i * e - i, new r))
        }, E.prototype.makeLabel = function (e) {
            var t = r.toGregorianDate(e), i = t.millisecond, n = " UTC";
            if (i > 0 && this._timeBarSecondsSpan < 3600) {
                for (n = Math.floor(i).toString(); n.length < 3;)n = "0" + n;
                n = "." + n
            }
            return C[t.month - 1] + " " + t.day + " " + t.year + " " + u(t.hour) + ":" + u(t.minute) + ":" + u(t.second) + n
        }, E.prototype.smallestTicInPixels = 7, E.prototype._makeTics = function () {
            function e(e) {
                return Math.floor(S / e) * e
            }

            function t(e, t) {
                return Math.ceil(e / t + .5) * t
            }

            function i(e) {
                return (e - S) / _
            }

            function n(e, t) {
                return e - t * Math.round(e / t)
            }

            var o, a = this._timeBarEle, s = r.secondsDifference(this._scrubJulian, this._startJulian), u = Math.round(s * this._topDiv.clientWidth / this._timeBarSecondsSpan), l = u - 8, c = this;
            this._needleEle.style.left = u.toString() + "px";
            var h = "", d = .01, m = 31536e6, p = 1e-10, f = 0, _ = this._timeBarSecondsSpan;
            d > _ ? (_ = d, this._timeBarSecondsSpan = d, this._endJulian = r.addSeconds(this._startJulian, d, new r)) : _ > m && (_ = m, this._timeBarSecondsSpan = m, this._endJulian = r.addSeconds(this._startJulian, m, new r));
            var v = this._timeBarEle.clientWidth;
            10 > v && (v = 10);
            var g, C = this._startJulian, E = Math.min(_ / v * 1e-5, .4);
            g = _ > 31536e4 ? r.fromIso8601(r.toDate(C).toISOString().substring(0, 2) + "00-01-01T00:00:00Z") : _ > 31536e3 ? r.fromIso8601(r.toDate(C).toISOString().substring(0, 3) + "0-01-01T00:00:00Z") : _ > 86400 ? r.fromIso8601(r.toDate(C).toISOString().substring(0, 4) + "-01-01T00:00:00Z") : r.fromIso8601(r.toDate(C).toISOString().substring(0, 10) + "T00:00:00Z");
            var S = r.secondsDifference(this._startJulian, r.addSeconds(g, E, new r)), T = S + _;
            this._epochJulian = g, this._rulerEle.innerHTML = this.makeLabel(r.addSeconds(this._endJulian, -d, new r));
            var b = this._rulerEle.offsetWidth + 20;
            30 > b && (b = 180);
            var w = f;
            f -= p;
            var x = {startTime: S, startJulian: C, epochJulian: g, duration: _, timeBarWidth: v, getAlpha: i};
            this._highlightRanges.forEach(function (e) {
                h += e.render(x)
            });
            var A = 0, P = 0, I = 0, D = b / v;
            D > 1 && (D = 1), D *= this._timeBarSecondsSpan;
            var M, O = -1, R = -1, N = y.length;
            for (M = 0; N > M; ++M) {
                var L = y[M];
                if (++O, A = L, L > D && L > f)break;
                0 > R && v * (L / this._timeBarSecondsSpan) >= this.smallestTicInPixels && (R = O)
            }
            if (O > 0) {
                for (; O > 0;)if (--O, Math.abs(n(A, y[O])) < 1e-5) {
                    y[O] >= f && (P = y[O]);
                    break
                }
                if (R >= 0)for (; O > R;) {
                    if (Math.abs(n(P, y[R])) < 1e-5 && y[R] >= f) {
                        I = y[R];
                        break
                    }
                    ++R
                }
            }
            f = w, f > p && 1e-5 > I && Math.abs(f - A) > p && (I = f, A + p >= f && (P = 0));
            var F, B = -999999;
            if (v * (I / this._timeBarSecondsSpan) >= 3)for (o = e(I); T >= o; o = t(o, I))h += '<span class="cesium-timeline-ticTiny" style="left: ' + Math.round(v * i(o)).toString() + 'px;"></span>';
            if (v * (P / this._timeBarSecondsSpan) >= 3)for (o = e(P); T >= o; o = t(o, P))h += '<span class="cesium-timeline-ticSub" style="left: ' + Math.round(v * i(o)).toString() + 'px;"></span>';
            if (v * (A / this._timeBarSecondsSpan) >= 2) {
                this._mainTicSpan = A, T += A, o = e(A);
                for (var z = r.computeTaiMinusUtc(g); T >= o;) {
                    var V = r.addSeconds(C, o - S, new r);
                    if (A > 2.1) {
                        var U = r.computeTaiMinusUtc(V);
                        Math.abs(U - z) > .1 && (o += U - z, V = r.addSeconds(C, o - S, new r))
                    }
                    var k = Math.round(v * i(o)), G = this.makeLabel(V);
                    this._rulerEle.innerHTML = G, F = this._rulerEle.offsetWidth, 10 > F && (F = b);
                    var H = k - (F / 2 - 1);
                    H > B ? (B = H + F + 5, h += '<span class="cesium-timeline-ticMain" style="left: ' + k.toString() + 'px;"></span><span class="cesium-timeline-ticLabel" style="left: ' + H.toString() + 'px;">' + G + "</span>") : h += '<span class="cesium-timeline-ticSub" style="left: ' + k.toString() + 'px;"></span>', o = t(o, A)
                }
            } else this._mainTicSpan = -1;
            h += '<span class="cesium-timeline-icon16" style="left:' + l + 'px;bottom:0;background-position: 0px 0px;"></span>', a.innerHTML = h, this._scrubElement = a.lastChild, this._context.clearRect(0, 0, this._trackListEle.width, this._trackListEle.height), x.y = 0, this._trackList.forEach(function (e) {
                e.render(c._context, x), x.y += e.height
            })
        }, E.prototype.updateFromClock = function () {
            this._scrubJulian = this._clock.currentTime;
            var e = this._scrubElement;
            if (t(this._scrubElement)) {
                var i = r.secondsDifference(this._scrubJulian, this._startJulian), n = Math.round(i * this._topDiv.clientWidth / this._timeBarSecondsSpan);
                this._lastXPos !== n && (this._lastXPos = n, e.style.left = n - 8 + "px", this._needleEle.style.left = n + "px")
            }
            t(this._timelineDragLocation) && (this._setTimeBarTime(this._timelineDragLocation, this._timelineDragLocation * this._timeBarSecondsSpan / this._topDiv.clientWidth), this.zoomTo(r.addSeconds(this._startJulian, this._timelineDrag, new r), r.addSeconds(this._endJulian, this._timelineDrag, new r)))
        }, E.prototype._setTimeBarTime = function (e, t) {
            if (e = Math.round(e), this._scrubJulian = r.addSeconds(this._startJulian, t, new r), this._scrubElement) {
                var i = e - 8;
                this._scrubElement.style.left = i.toString() + "px", this._needleEle.style.left = e.toString() + "px"
            }
            var n = document.createEvent("Event");
            n.initEvent("settime", !0, !0), n.clientX = e, n.timeSeconds = t, n.timeJulian = this._scrubJulian, n.clock = this._clock, this._topDiv.dispatchEvent(n)
        }, E.prototype.resize = function () {
            var e = this.container.clientWidth, t = this.container.clientHeight;
            if (e !== this._lastWidth || t !== this._lastHeight) {
                this._trackContainer.style.height = t + "px";
                var i = 1;
                this._trackList.forEach(function (e) {
                    i += e.height
                }), this._trackListEle.style.height = i.toString() + "px", this._trackListEle.width = this._trackListEle.clientWidth, this._trackListEle.height = i, this._makeTics(), this._lastWidth = e, this._lastHeight = t
            }
        }, E
    }),define("Cesium/Widgets/Viewer/Viewer", ["../../Core/BoundingSphere", "../../Core/Cartesian3", "../../Core/defaultValue", "../../Core/defined", "../../Core/definedNotNull", "../../Core/defineProperties", "../../Core/destroyObject", "../../Core/DeveloperError", "../../Core/EventHelper", "../../Core/isArray", "../../Core/Matrix4", "../../Core/ScreenSpaceEventType", "../../DataSources/BoundingSphereState", "../../DataSources/ConstantPositionProperty", "../../DataSources/DataSourceCollection", "../../DataSources/DataSourceDisplay", "../../DataSources/Entity", "../../DataSources/EntityView", "../../DataSources/Property", "../../Scene/SceneMode", "../../ThirdParty/knockout", "../../ThirdParty/when", "../Animation/Animation", "../Animation/AnimationViewModel", "../BaseLayerPicker/BaseLayerPicker", "../BaseLayerPicker/createDefaultImageryProviderViewModels", "../BaseLayerPicker/createDefaultTerrainProviderViewModels", "../CesiumWidget/CesiumWidget", "../ClockViewModel", "../FullscreenButton/FullscreenButton", "../Geocoder/Geocoder", "../getElement", "../HomeButton/HomeButton", "../InfoBox/InfoBox", "../NavigationHelpButton/NavigationHelpButton", "../SceneModePicker/SceneModePicker", "../SelectionIndicator/SelectionIndicator", "../subscribeAndEvaluate", "../Timeline/Timeline"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S, T, b, w, x, A, P, I, D, M, O, R, N, L, F, B, z) {
        "use strict";
        function V(e) {
            var t = e.clock;
            t.currentTime = e.timeJulian, t.shouldAnimate = !1
        }

        function U(e, t) {
            var r = e.scene.pick(t.position);
            if (n(r)) {
                var o = i(r.id, r.primitive.id);
                if (o instanceof _)return o
            }
            return n(e.scene.globe) ? G(e, t.position) : void 0
        }

        function k(e, t, i) {
            if (n(i)) {
                var r = i.clock;
                n(r) && (r.getValue(t), n(e) && (e.updateFromClock(), e.zoomTo(r.startTime, r.stopTime)))
            }
        }

        function G(e, t) {
            var i = e.scene, r = i.camera.getPickRay(t), o = i.imageryLayers.pickImageryLayerFeatures(r, i);
            if (n(o)) {
                var a = new _({id: "Loading...", description: "Loading feature information..."});
                return E(o, function (t) {
                    if (e.selectedEntity === a) {
                        if (!n(t) || 0 === t.length)return void(e.selectedEntity = H());
                        var i = t[0], r = new _({id: i.name, description: i.description});
                        if (n(i.position)) {
                            var o = e.scene.globe.ellipsoid.cartographicToCartesian(i.position, K);
                            r.position = new m(o)
                        }
                        e.selectedEntity = r
                    }
                }, function () {
                    e.selectedEntity === a && (e.selectedEntity = H())
                }), a
            }
        }

        function H() {
            return new _({id: "None", description: "No features found."})
        }

        function W(e, t, r, o) {
            j(e);
            var a = E.defer();
            return e._zoomPromise = a, e._zoomIsFlight = o, e._zoomOptions = r, E(t, function (t) {
                if (e._zoomPromise === a)if (t.isLoading && n(t.loadingEvent))var r = t.loadingEvent.addEventListener(function () {
                    r(), e._zoomPromise === a && (e._zoomTarget = t.entities.values.slice(0))
                }); else t = i(t.values, t), n(t.entities) && (t = t.entities.values), l(t) ? e._zoomTarget = t.slice(0) : e._zoomTarget = [t]
            }), a
        }

        function q(e) {
            e._zoomPromise = void 0, e._zoomTarget = void 0, e._zoomOptions = void 0
        }

        function j(e) {
            var t = e._zoomPromise;
            n(t) && (q(e), t.resolve(!1))
        }

        function Y(t) {
            var r = t._zoomTarget;
            if (n(r) && t.scene.mode !== y.MORPHING) {
                for (var o = t._zoomPromise, a = [], s = 0, u = r.length; u > s; s++) {
                    var l = t._dataSourceDisplay.getBoundingSphere(r[s], !1, Z);
                    if (l === d.PENDING)return;
                    l !== d.FAILED && a.push(e.clone(Z))
                }
                if (0 === a.length)return void j(t);
                t.trackedEntity = void 0;
                var h = t.scene, m = h.camera, p = e.fromBoundingSpheres(a), f = h.screenSpaceCameraController;
                if (f.minimumZoomDistance = Math.min(f.minimumZoomDistance, .5 * p.radius), t._zoomIsFlight) {
                    var _ = i(t._zoomOptions, {}), v = {
                        duration: _.duration,
                        maximumHeight: _.maximumHeight,
                        complete: function () {
                            o.resolve(!0)
                        },
                        cancel: function () {
                            o.resolve(!1)
                        },
                        offset: _.offset
                    };
                    q(t), m.flyToBoundingSphere(p, v)
                } else m.viewBoundingSphere(p, t._zoomOptions), m.lookAtTransform(c.IDENTITY), q(t), o.resolve(!0)
            }
        }

        function X(e) {
            if (e._needTrackedEntityUpdate) {
                var t = e._trackedEntity, i = e.clock.currentTime, r = g.getValueOrUndefined(t.position, i);
                if (n(r)) {
                    var o = e.scene, a = e._dataSourceDisplay.getBoundingSphere(t, !1, Z);
                    if (a !== d.PENDING) {
                        var s = o.mode;
                        (s === y.COLUMBUS_VIEW || s === y.SCENE2D) && (o.screenSpaceCameraController.enableTranslate = !1), (s === y.COLUMBUS_VIEW || s === y.SCENE3D) && (o.screenSpaceCameraController.enableTilt = !1);
                        var u = a !== d.FAILED ? Z : void 0;
                        e._entityView = new v(t, o, o.mapProjection.ellipsoid, u), e._entityView.update(i), e._needTrackedEntityUpdate = !1
                    }
                }
            }
        }

        var Z = new e, K = new t, J = function (e, t) {
            function o(e) {
                var t = U(Ce, e);
                n(t) && (g.getValueOrUndefined(t.position, Ce.clock.currentTime) ? Ce.trackedEntity = t : Ce.zoomTo(t))
            }

            function a(e) {
                Ce.selectedEntity = U(Ce, e)
            }

            e = M(e), t = i(t, i.EMPTY_OBJECT);
            var l = !(n(t.globe) && t.globe === !1 || n(t.baseLayerPicker) && t.baseLayerPicker === !1), c = document.createElement("div");
            c.className = "cesium-viewer", e.appendChild(c);
            var d = document.createElement("div");
            d.className = "cesium-viewer-cesiumWidgetContainer", c.appendChild(d);
            var m = document.createElement("div");
            m.className = "cesium-viewer-bottom", c.appendChild(m);
            var _ = i(t.scene3DOnly, !1), v = new A(d, {
                terrainProvider: t.terrainProvider,
                imageryProvider: l ? !1 : t.imageryProvider,
                clock: t.clock,
                skyBox: t.skyBox,
                skyAtmosphere: t.skyAtmosphere,
                sceneMode: t.sceneMode,
                mapProjection: t.mapProjection,
                globe: t.globe,
                orderIndependentTranslucency: t.orderIndependentTranslucency,
                contextOptions: t.contextOptions,
                useDefaultRenderLoop: t.useDefaultRenderLoop,
                targetFrameRate: t.targetFrameRate,
                showRenderLoopErrors: t.showRenderLoopErrors,
                creditContainer: n(t.creditContainer) ? t.creditContainer : m,
                scene3DOnly: _
            }), y = t.dataSources, E = !1;
            n(y) || (y = new p, E = !0);
            var k = new f({scene: v.scene, dataSourceCollection: y}), G = v.clock, H = new P(G), W = new u;
            W.add(G.onTick, J.prototype._onTick, this);
            var q;
            if (!n(t.selectionIndicator) || t.selectionIndicator !== !1) {
                var j = document.createElement("div");
                j.className = "cesium-viewer-selectionIndicatorContainer", c.appendChild(j), q = new F(j, v.scene)
            }
            var Y;
            if (!n(t.infoBox) || t.infoBox !== !1) {
                var X = document.createElement("div");
                X.className = "cesium-viewer-infoBoxContainer", c.appendChild(X), Y = new R(X);
                var Z = Y.viewModel;
                W.add(Z.cameraClicked, J.prototype._onInfoBoxCameraClicked, this), W.add(Z.closeClicked, J.prototype._onInfoBoxClockClicked, this)
            }
            var K = document.createElement("div");
            K.className = "cesium-viewer-toolbar", c.appendChild(K);
            var Q;
            if (!n(t.geocoder) || t.geocoder !== !1) {
                var $ = document.createElement("div");
                $.className = "cesium-viewer-geocoderContainer", K.appendChild($), Q = new D({
                    container: $,
                    scene: v.scene
                }), W.add(Q.viewModel.search.beforeExecute, J.prototype._clearObjects, this)
            }
            var ee;
            if (n(t.homeButton) && t.homeButton === !1 || (ee = new O(K, v.scene), n(Q) && W.add(ee.viewModel.command.afterExecute, function () {
                    var e = Q.viewModel;
                    e.searchText = "", e.isSearchInProgress && e.search()
                }), W.add(ee.viewModel.command.beforeExecute, J.prototype._clearTrackedObject, this)), t.sceneModePicker === !0 && _)throw new s("options.sceneModePicker is not available when options.scene3DOnly is set to true.");
            var te;
            _ || n(t.sceneModePicker) && t.sceneModePicker === !1 || (te = new L(K, v.scene));
            var ie, ne;
            if (l) {
                var re = i(t.imageryProviderViewModels, w()), oe = i(t.terrainProviderViewModels, x());
                ie = new b(K, {
                    globe: v.scene.globe,
                    imageryProviderViewModels: re,
                    selectedImageryProviderViewModel: t.selectedImageryProviderViewModel,
                    terrainProviderViewModels: oe,
                    selectedTerrainProviderViewModel: t.selectedTerrainProviderViewModel
                });
                var ae = K.getElementsByClassName("cesium-baseLayerPicker-dropDown");
                ne = ae[0]
            }
            var se;
            if (!n(t.navigationHelpButton) || t.navigationHelpButton !== !1) {
                var ue = !0;
                try {
                    if (r(window.localStorage)) {
                        var le = window.localStorage.getItem("cesium-hasSeenNavHelp");
                        n(le) && Boolean(le) ? ue = !1 : window.localStorage.setItem("cesium-hasSeenNavHelp", "true")
                    }
                } catch (ce) {
                }
                se = new N({
                    container: K,
                    instructionsInitiallyVisible: i(t.navigationInstructionsInitiallyVisible, ue)
                })
            }
            var he;
            if (!n(t.animation) || t.animation !== !1) {
                var de = document.createElement("div");
                de.className = "cesium-viewer-animationContainer", c.appendChild(de), he = new S(de, new T(H))
            }
            var me;
            if (!n(t.timeline) || t.timeline !== !1) {
                var pe = document.createElement("div");
                pe.className = "cesium-viewer-timelineContainer", c.appendChild(pe), me = new z(pe, G), me.addEventListener("settime", V, !1), me.zoomTo(G.startTime, G.stopTime)
            }
            var fe, _e;
            if (n(t.fullscreenButton) && t.fullscreenButton === !1)n(me) && (me.container.style.right = 0); else {
                var ve = document.createElement("div");
                ve.className = "cesium-viewer-fullscreenContainer", c.appendChild(ve), fe = new I(ve, t.fullscreenElement), _e = B(fe.viewModel, "isFullscreenEnabled", function (e) {
                    ve.style.display = e ? "block" : "none", n(me) && (me.container.style.right = ve.clientWidth + "px", me.resize())
                })
            }
            this._baseLayerPickerDropDown = ne, this._fullscreenSubscription = _e, this._dataSourceChangedListeners = {}, this._automaticallyTrackDataSourceClocks = i(t.automaticallyTrackDataSourceClocks, !0), this._container = e, this._bottomContainer = m, this._element = c, this._cesiumWidget = v, this._selectionIndicator = q, this._infoBox = Y, this._dataSourceCollection = y, this._destroyDataSourceCollection = E, this._dataSourceDisplay = k, this._clockViewModel = H, this._toolbar = K, this._homeButton = ee, this._sceneModePicker = te, this._baseLayerPicker = ie, this._navigationHelpButton = se, this._animation = he, this._timeline = me, this._fullscreenButton = fe, this._geocoder = Q, this._eventHelper = W, this._lastWidth = 0, this._lastHeight = 0, this._allowDataSourcesToSuspendAnimation = !0, this._entityView = void 0, this._enableInfoOrSelection = n(Y) || n(q), this._clockTrackedDataSource = void 0, this._trackedEntity = void 0, this._needTrackedEntityUpdate = !1, this._selectedEntity = void 0, this._clockTrackedDataSource = void 0, this._forceResize = !1, this._zoomIsFlight = !1, this._zoomTarget = void 0, this._zoomPromise = void 0, this._zoomOptions = void 0, C.track(this, ["_trackedEntity", "_selectedEntity", "_clockTrackedDataSource"]), W.add(y.dataSourceAdded, J.prototype._onDataSourceAdded, this), W.add(y.dataSourceRemoved, J.prototype._onDataSourceRemoved, this), W.add(v.scene.preRender, J.prototype.resize, this), W.add(v.scene.postRender, J.prototype._postRender, this);
            for (var ge = y.length, ye = 0; ge > ye; ye++)this._dataSourceAdded(y, y.get(ye));
            this._dataSourceAdded(void 0, k.defaultDataSource), W.add(y.dataSourceAdded, J.prototype._dataSourceAdded, this), W.add(y.dataSourceRemoved, J.prototype._dataSourceRemoved, this);
            var Ce = this;
            v.screenSpaceEventHandler.setInputAction(a, h.LEFT_CLICK), v.screenSpaceEventHandler.setInputAction(o, h.LEFT_DOUBLE_CLICK)
        };
        return o(J.prototype, {
            container: {
                get: function () {
                    return this._container
                }
            }, bottomContainer: {
                get: function () {
                    return this._bottomContainer
                }
            }, cesiumWidget: {
                get: function () {
                    return this._cesiumWidget
                }
            }, selectionIndicator: {
                get: function () {
                    return this._selectionIndicator
                }
            }, infoBox: {
                get: function () {
                    return this._infoBox
                }
            }, geocoder: {
                get: function () {
                    return this._geocoder
                }
            }, homeButton: {
                get: function () {
                    return this._homeButton
                }
            }, sceneModePicker: {
                get: function () {
                    return this._sceneModePicker
                }
            }, baseLayerPicker: {
                get: function () {
                    return this._baseLayerPicker
                }
            }, navigationHelpButton: {
                get: function () {
                    return this._navigationHelpButton
                }
            }, animation: {
                get: function () {
                    return this._animation
                }
            }, timeline: {
                get: function () {
                    return this._timeline
                }
            }, fullscreenButton: {
                get: function () {
                    return this._fullscreenButton
                }
            }, dataSourceDisplay: {
                get: function () {
                    return this._dataSourceDisplay
                }
            }, entities: {
                get: function () {
                    return this._dataSourceDisplay.defaultDataSource.entities
                }
            }, dataSources: {
                get: function () {
                    return this._dataSourceCollection
                }
            }, canvas: {
                get: function () {
                    return this._cesiumWidget.canvas
                }
            }, cesiumLogo: {
                get: function () {
                    return this._cesiumWidget.cesiumLogo
                }
            }, scene: {
                get: function () {
                    return this._cesiumWidget.scene
                }
            }, imageryLayers: {
                get: function () {
                    return this.scene.imageryLayers
                }
            }, terrainProvider: {
                get: function () {
                    return this.scene.terrainProvider
                }, set: function (e) {
                    this.scene.terrainProvider = e
                }
            }, camera: {
                get: function () {
                    return this.scene.camera
                }
            }, clock: {
                get: function () {
                    return this._cesiumWidget.clock
                }
            }, screenSpaceEventHandler: {
                get: function () {
                    return this._cesiumWidget.screenSpaceEventHandler
                }
            }, targetFrameRate: {
                get: function () {
                    return this._cesiumWidget.targetFrameRate
                }, set: function (e) {
                    this._cesiumWidget.targetFrameRate = e
                }
            }, useDefaultRenderLoop: {
                get: function () {
                    return this._cesiumWidget.useDefaultRenderLoop
                }, set: function (e) {
                    this._cesiumWidget.useDefaultRenderLoop = e
                }
            }, resolutionScale: {
                get: function () {
                    return this._cesiumWidget.resolutionScale
                }, set: function (e) {
                    this._cesiumWidget.resolutionScale = e, this._forceResize = !0
                }
            }, allowDataSourcesToSuspendAnimation: {
                get: function () {
                    return this._allowDataSourcesToSuspendAnimation
                }, set: function (e) {
                    this._allowDataSourcesToSuspendAnimation = e
                }
            }, trackedEntity: {
                get: function () {
                    return this._trackedEntity
                }, set: function (e) {
                    if (this._trackedEntity !== e) {
                        this._trackedEntity = e, j(this);
                        var t = this.scene, i = t.mode;
                        if (!n(e) || !n(e.position))return this._needTrackedEntityUpdate = !1, (i === y.COLUMBUS_VIEW || i === y.SCENE2D) && (t.screenSpaceCameraController.enableTranslate = !0), (i === y.COLUMBUS_VIEW || i === y.SCENE3D) && (t.screenSpaceCameraController.enableTilt = !0), this._entityView = void 0, void this.camera.lookAtTransform(c.IDENTITY);
                        this._needTrackedEntityUpdate = !0
                    }
                }
            }, selectedEntity: {
                get: function () {
                    return this._selectedEntity
                }, set: function (e) {
                    if (this._selectedEntity !== e) {
                        this._selectedEntity = e;
                        var t = n(this._selectionIndicator) ? this._selectionIndicator.viewModel : void 0;
                        n(e) ? n(t) && t.animateAppear() : n(t) && t.animateDepart()
                    }
                }
            }, clockTrackedDataSource: {
                get: function () {
                    return this._clockTrackedDataSource
                }, set: function (e) {
                    this._clockTrackedDataSource !== e && (this._clockTrackedDataSource = e, k(this._timeline, this.clock, e))
                }
            }
        }), J.prototype.extend = function (e, t) {
            e(this, t)
        }, J.prototype.resize = function () {
            var e = this._cesiumWidget, t = this._container, i = t.clientWidth, r = t.clientHeight, o = n(this._animation), a = n(this._timeline);
            if (this._forceResize || i !== this._lastWidth || r !== this._lastHeight) {
                e.resize(), this._forceResize = !1;
                var s = r - 125, u = this._baseLayerPickerDropDown;
                n(u) && (u.style.maxHeight = s + "px"), n(this._infoBox) && (this._infoBox.viewModel.maxHeight = s);
                var l, c = this._timeline, h = 0, d = 0, m = 0;
                if (o && "hidden" !== window.getComputedStyle(this._animation.container).visibility) {
                    var p = this._lastWidth;
                    l = this._animation.container, i > 900 ? (h = 169, 900 >= p && (l.style.width = "169px", l.style.height = "112px", this._animation.resize())) : i >= 600 ? (h = 136, (600 > p || p > 900) && (l.style.width = "136px", l.style.height = "90px", this._animation.resize())) : (h = 106, (p > 600 || 0 === p) && (l.style.width = "106px", l.style.height = "70px", this._animation.resize())), d = h + 5
                }
                if (a && "hidden" !== window.getComputedStyle(this._timeline.container).visibility) {
                    var f = this._fullscreenButton, _ = c.container, v = _.style;
                    m = _.clientHeight + 3, v.left = h + "px", n(f) && (v.right = f.container.clientWidth + "px"), c.resize()
                }
                this._bottomContainer.style.left = d + "px", this._bottomContainer.style.bottom = m + "px", this._lastWidth = i, this._lastHeight = r
            }
        }, J.prototype.forceResize = function () {
            this._lastWidth = 0, this.resize()
        }, J.prototype.render = function () {
            this._cesiumWidget.render()
        }, J.prototype.isDestroyed = function () {
            return !1
        }, J.prototype.destroy = function () {
            var e;
            this.screenSpaceEventHandler.removeInputAction(h.LEFT_CLICK), this.screenSpaceEventHandler.removeInputAction(h.LEFT_DOUBLE_CLICK);
            var t = this.dataSources, i = t.length;
            for (e = 0; i > e; e++)this._dataSourceRemoved(t, t.get(e));
            return this._dataSourceRemoved(void 0, this._dataSourceDisplay.defaultDataSource), this._container.removeChild(this._element), this._element.removeChild(this._toolbar), this._eventHelper.removeAll(), n(this._geocoder) && (this._geocoder = this._geocoder.destroy()), n(this._homeButton) && (this._homeButton = this._homeButton.destroy()), n(this._sceneModePicker) && (this._sceneModePicker = this._sceneModePicker.destroy()), n(this._baseLayerPicker) && (this._baseLayerPicker = this._baseLayerPicker.destroy()), n(this._animation) && (this._element.removeChild(this._animation.container), this._animation = this._animation.destroy()), n(this._timeline) && (this._timeline.removeEventListener("settime", V, !1), this._element.removeChild(this._timeline.container), this._timeline = this._timeline.destroy()), n(this._fullscreenButton) && (this._fullscreenSubscription.dispose(), this._element.removeChild(this._fullscreenButton.container), this._fullscreenButton = this._fullscreenButton.destroy()), n(this._infoBox) && (this._element.removeChild(this._infoBox.container), this._infoBox = this._infoBox.destroy()), n(this._selectionIndicator) && (this._element.removeChild(this._selectionIndicator.container), this._selectionIndicator = this._selectionIndicator.destroy()), this._clockViewModel = this._clockViewModel.destroy(), this._dataSourceDisplay = this._dataSourceDisplay.destroy(), this._cesiumWidget = this._cesiumWidget.destroy(), this._destroyDataSourceCollection && (this._dataSourceCollection = this._dataSourceCollection.destroy()), a(this)
        }, J.prototype._dataSourceAdded = function (e, t) {
            var i = t.entities;
            i.collectionChanged.addEventListener(J.prototype._onEntityCollectionChanged, this)
        }, J.prototype._dataSourceRemoved = function (e, t) {
            var i = t.entities;
            i.collectionChanged.removeEventListener(J.prototype._onEntityCollectionChanged, this), n(this.trackedEntity) && i.getById(this.trackedEntity.id) === this.trackedEntity && (this.trackedEntity = void 0), n(this.selectedEntity) && i.getById(this.selectedEntity.id) === this.selectedEntity && (this.selectedEntity = void 0)
        }, J.prototype._onTick = function (e) {
            var r = e.currentTime, o = this._dataSourceDisplay.update(r);
            this._allowDataSourcesToSuspendAnimation && (this._clockViewModel.canAnimate = o);
            var a = this._entityView;
            n(a) && a.update(r);
            var s, u = !1, l = this.selectedEntity, c = n(l) && this._enableInfoOrSelection;
            if (c && l.isShowing && l.isAvailable(r)) {
                var h = this._dataSourceDisplay.getBoundingSphere(l, !0, Z);
                h !== d.FAILED ? s = Z.center : n(l.position) && (s = l.position.getValue(r, s)), u = n(s)
            }
            var m = n(this._selectionIndicator) ? this._selectionIndicator.viewModel : void 0;
            n(m) && (m.position = t.clone(s, m.position), m.showSelection = c && u, m.update());
            var p = n(this._infoBox) ? this._infoBox.viewModel : void 0;
            n(p) && (p.showInfo = c, p.enableCamera = u, p.isCameraTracking = this.trackedEntity === this.selectedEntity, c ? (p.titleText = i(l.name, l.id), p.description = g.getValueOrDefault(l.description, r, "")) : (p.titleText = "", p.description = ""))
        }, J.prototype._onEntityCollectionChanged = function (e, t, i) {
            for (var n = i.length, r = 0; n > r; r++) {
                var o = i[r];
                this.trackedEntity === o && (this.trackedEntity = void 0), this.selectedEntity === o && (this.selectedEntity = void 0)
            }
        }, J.prototype._onInfoBoxCameraClicked = function (e) {
            if (e.isCameraTracking && this.trackedEntity === this.selectedEntity)this.trackedEntity = void 0; else {
                var t = this.selectedEntity, i = t.position;
                n(i) ? this.trackedEntity = this.selectedEntity : this.zoomTo(this.selectedEntity)
            }
        }, J.prototype._clearTrackedObject = function () {
            this.trackedEntity = void 0
        }, J.prototype._onInfoBoxClockClicked = function (e) {
            this.selectedEntity = void 0
        }, J.prototype._clearObjects = function () {
            this.trackedEntity = void 0, this.selectedEntity = void 0
        }, J.prototype._onDataSourceChanged = function (e) {
            this.clockTrackedDataSource === e && k(this.timeline, this.clock, e)
        }, J.prototype._onDataSourceAdded = function (e, t) {
            this._automaticallyTrackDataSourceClocks && (this.clockTrackedDataSource = t);
            var i = t.entities.id, n = this._eventHelper.add(t.changedEvent, J.prototype._onDataSourceChanged, this);
            this._dataSourceChangedListeners[i] = n
        }, J.prototype._onDataSourceRemoved = function (e, t) {
            var i = this.clockTrackedDataSource === t, n = t.entities.id;
            if (this._dataSourceChangedListeners[n](), this._dataSourceChangedListeners[n] = void 0, i) {
                var r = e.length;
                this._automaticallyTrackDataSourceClocks && r > 0 ? this.clockTrackedDataSource = e.get(r - 1) : this.clockTrackedDataSource = void 0
            }
        }, J.prototype.zoomTo = function (e, t) {
            return W(this, e, t, !1)
        }, J.prototype.flyTo = function (e, t) {
            return W(this, e, t, !0)
        }, J.prototype._postRender = function () {
            Y(this), X(this)
        }, J
    }),define("Widgets/createDomNode", [], function () {
        "use strict";
        function e(e) {
            var t = document.createElement("dov");
            if (t.innerHTML = e, 1 === t.children.length)return t.removeChild(t.firstChild);
            for (var i = document.createDocumentFragment(); null !== t.firstChild;)i.appendChild(t.removeChild(t.firstChild));
            return i
        }

        return e
    }),function () {
        var e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S, T, b, w, x, A, P, I, D, M, O, R, N, L, F, B, z, V, U, k, G, H, W, q, j, Y, X, Z, K, J, Q, $, ee, te, ie, ne, re, oe, ae, se, ue, le, ce, he, de, me, pe, fe, _e, ve, ge, ye, Ce, Ee, Se, Te = [].slice;
        ge = function () {
            var e, t, i, n, r;
            for (e = {}, r = "Boolean Number String Function Array Date RegExp Undefined Null".split(" "), n = 0, t = r.length; t > n; n++)i = r[n], e["[object " + i + "]"] = i.toLowerCase();
            return function (t) {
                var i;
                return i = Object.prototype.toString.call(t), e[i] || "object"
            }
        }(), G = function (e, t, i) {
            return null == t && (t = 0), null == i && (i = 1), t > e && (e = t), e > i && (e = i), e
        }, ye = function (e) {
            return e.length >= 3 ? [].slice.call(e) : e[0]
        }, v = function (e) {
            var t;
            for (t in e)3 > t ? (e[t] < 0 && (e[t] = 0), e[t] > 255 && (e[t] = 255)) : 3 === t && (e[t] < 0 && (e[t] = 0), e[t] > 1 && (e[t] = 1));
            return e
        }, i = Math.PI, me = Math.round, C = Math.cos, w = Math.floor, J = Math.pow, H = Math.log, fe = Math.sin, _e = Math.sqrt, c = Math.atan2, j = Math.max, l = Math.abs, r = 2 * i, n = i / 3, _ = function () {
            return arguments[0]instanceof e ? arguments[0] : function (e, t, i) {
                i.prototype = e.prototype;
                var n = new i, r = e.apply(n, t);
                return Object(r) === r ? r : n
            }(e, arguments, function () {
            })
        }, u = [], "undefined" != typeof module && null !== module && null != module.exports && (module.exports = _), "function" == typeof define && define.amd ? define("chroma", [], function () {
            return _
        }) : (de = "undefined" != typeof exports && null !== exports ? exports : this, de.chroma = _), _.version = "1.0.1", s = {}, o = [], a = !1, e = function () {
            function e() {
                var e, t, i, n, r, u, l, c, h;
                for (u = this, t = [], c = 0, n = arguments.length; n > c; c++)e = arguments[c], null != e && t.push(e);
                if (l = t[t.length - 1], null != s[l])u._rgb = v(s[l](ye(t.slice(0, -1)))); else {
                    for (a || (o = o.sort(function (e, t) {
                        return t.p - e.p
                    }), a = !0), h = 0, r = o.length; r > h && (i = o[h], !(l = i.test.apply(i, t))); h++);
                    l && (u._rgb = v(s[l].apply(s, t)))
                }
                null == u._rgb && console.warn("unknown format: " + t), null == u._rgb && (u._rgb = [0, 0, 0]), 3 === u._rgb.length && u._rgb.push(1)
            }

            return e.prototype.alpha = function (e) {
                return arguments.length ? (this._rgb[3] = e, this) : this._rgb[3]
            }, e.prototype.toString = function () {
                return this.name()
            }, e
        }(), _.brewer = p = {
            OrRd: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"],
            PuBu: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"],
            BuPu: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"],
            Oranges: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"],
            BuGn: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"],
            YlOrBr: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"],
            YlGn: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"],
            Reds: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"],
            RdPu: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"],
            Greens: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"],
            YlGnBu: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"],
            Purples: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"],
            GnBu: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"],
            Greys: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"],
            YlOrRd: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"],
            PuRd: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"],
            Blues: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"],
            PuBuGn: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"],
            Spectral: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
            RdYlGn: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
            RdBu: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
            PiYG: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
            PRGn: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
            RdYlBu: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
            BrBG: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
            RdGy: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
            PuOr: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
            Set2: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"],
            Accent: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"],
            Set1: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"],
            Set3: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"],
            Dark2: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"],
            Paired: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"],
            Pastel2: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"],
            Pastel1: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
        }, Ce = {
            indigo: "#4b0082",
            gold: "#ffd700",
            hotpink: "#ff69b4",
            firebrick: "#b22222",
            indianred: "#cd5c5c",
            yellow: "#ffff00",
            mistyrose: "#ffe4e1",
            darkolivegreen: "#556b2f",
            olive: "#808000",
            darkseagreen: "#8fbc8f",
            pink: "#ffc0cb",
            tomato: "#ff6347",
            lightcoral: "#f08080",
            orangered: "#ff4500",
            navajowhite: "#ffdead",
            lime: "#00ff00",
            palegreen: "#98fb98",
            darkslategrey: "#2f4f4f",
            greenyellow: "#adff2f",
            burlywood: "#deb887",
            seashell: "#fff5ee",
            mediumspringgreen: "#00fa9a",
            fuchsia: "#ff00ff",
            papayawhip: "#ffefd5",
            blanchedalmond: "#ffebcd",
            chartreuse: "#7fff00",
            dimgray: "#696969",
            black: "#000000",
            peachpuff: "#ffdab9",
            springgreen: "#00ff7f",
            aquamarine: "#7fffd4",
            white: "#ffffff",
            orange: "#ffa500",
            lightsalmon: "#ffa07a",
            darkslategray: "#2f4f4f",
            brown: "#a52a2a",
            ivory: "#fffff0",
            dodgerblue: "#1e90ff",
            peru: "#cd853f",
            lawngreen: "#7cfc00",
            chocolate: "#d2691e",
            crimson: "#dc143c",
            forestgreen: "#228b22",
            darkgrey: "#a9a9a9",
            lightseagreen: "#20b2aa",
            cyan: "#00ffff",
            mintcream: "#f5fffa",
            silver: "#c0c0c0",
            antiquewhite: "#faebd7",
            mediumorchid: "#ba55d3",
            skyblue: "#87ceeb",
            gray: "#808080",
            darkturquoise: "#00ced1",
            goldenrod: "#daa520",
            darkgreen: "#006400",
            floralwhite: "#fffaf0",
            darkviolet: "#9400d3",
            darkgray: "#a9a9a9",
            moccasin: "#ffe4b5",
            saddlebrown: "#8b4513",
            grey: "#808080",
            darkslateblue: "#483d8b",
            lightskyblue: "#87cefa",
            lightpink: "#ffb6c1",
            mediumvioletred: "#c71585",
            slategrey: "#708090",
            red: "#ff0000",
            deeppink: "#ff1493",
            limegreen: "#32cd32",
            darkmagenta: "#8b008b",
            palegoldenrod: "#eee8aa",
            plum: "#dda0dd",
            turquoise: "#40e0d0",
            lightgrey: "#d3d3d3",
            lightgoldenrodyellow: "#fafad2",
            darkgoldenrod: "#b8860b",
            lavender: "#e6e6fa",
            maroon: "#800000",
            yellowgreen: "#9acd32",
            sandybrown: "#f4a460",
            thistle: "#d8bfd8",
            violet: "#ee82ee",
            navy: "#000080",
            magenta: "#ff00ff",
            dimgrey: "#696969",
            tan: "#d2b48c",
            rosybrown: "#bc8f8f",
            olivedrab: "#6b8e23",
            blue: "#0000ff",
            lightblue: "#add8e6",
            ghostwhite: "#f8f8ff",
            honeydew: "#f0fff0",
            cornflowerblue: "#6495ed",
            slateblue: "#6a5acd",
            linen: "#faf0e6",
            darkblue: "#00008b",
            powderblue: "#b0e0e6",
            seagreen: "#2e8b57",
            darkkhaki: "#bdb76b",
            snow: "#fffafa",
            sienna: "#a0522d",
            mediumblue: "#0000cd",
            royalblue: "#4169e1",
            lightcyan: "#e0ffff",
            green: "#008000",
            mediumpurple: "#9370db",
            midnightblue: "#191970",
            cornsilk: "#fff8dc",
            paleturquoise: "#afeeee",
            bisque: "#ffe4c4",
            slategray: "#708090",
            darkcyan: "#008b8b",
            khaki: "#f0e68c",
            wheat: "#f5deb3",
            teal: "#008080",
            darkorchid: "#9932cc",
            deepskyblue: "#00bfff",
            salmon: "#fa8072",
            darkred: "#8b0000",
            steelblue: "#4682b4",
            palevioletred: "#db7093",
            lightslategray: "#778899",
            aliceblue: "#f0f8ff",
            lightslategrey: "#778899",
            lightgreen: "#90ee90",
            orchid: "#da70d6",
            gainsboro: "#dcdcdc",
            mediumseagreen: "#3cb371",
            lightgray: "#d3d3d3",
            mediumturquoise: "#48d1cc",
            lemonchiffon: "#fffacd",
            cadetblue: "#5f9ea0",
            lightyellow: "#ffffe0",
            lavenderblush: "#fff0f5",
            coral: "#ff7f50",
            purple: "#800080",
            aqua: "#00ffff",
            whitesmoke: "#f5f5f5",
            mediumslateblue: "#7b68ee",
            darkorange: "#ff8c00",
            mediumaquamarine: "#66cdaa",
            darksalmon: "#e9967a",
            beige: "#f5f5dc",
            blueviolet: "#8a2be2",
            azure: "#f0ffff",
            lightsteelblue: "#b0c4de",
            oldlace: "#fdf5e6",
            rebeccapurple: "#663399"
        }, _.colors = y = Ce, B = function () {
            var e, i, n, r, o, a, s, u, l, c, h;
            return a = ye(arguments), r = a[0], e = a[1], i = a[2], void 0 !== r && 3 === r.length && (s = r, r = s[0], e = s[1], i = s[2]), void 0 !== r && 3 === r.length && (u = r, r = u[0], e = u[1], i = u[2]), c = (r + 16) / 116, l = c + e / 500, h = c - i / 200, l = z(l) * t.X, c = z(c) * t.Y, h = z(h) * t.Z, o = Se(3.2404542 * l - 1.5371385 * c - .4985314 * h), n = Se(-.969266 * l + 1.8760108 * c + .041556 * h), i = Se(.0556434 * l - .2040259 * c + 1.0572252 * h), [G(o, 0, 255), G(n, 0, 255), G(i, 0, 255), 1]
        }, z = function (e) {
            return e > .206893034 ? e * e * e : (e - 4 / 29) / 7.787037
        }, Se = function (e) {
            return me(255 * (.00304 >= e ? 12.92 * e : 1.055 * J(e, 1 / 2.4) - .055))
        }, t = {K: 18, X: .95047, Y: 1, Z: 1.08883}, re = function () {
            var e, t, i, n, r, o, a, s;
            return n = ye(arguments), i = n[0], t = n[1], e = n[2], r = le(i, t, e), o = r[0], a = r[1], s = r[2], [116 * a - 16, 500 * (o - a), 200 * (a - s)]
        }, ce = function (e) {
            return (e /= 255) <= .04045 ? e / 12.92 : J((e + .055) / 1.055, 2.4)
        }, Ee = function (e) {
            return e > .008856 ? J(e, 1 / 3) : 7.787037 * e + 4 / 29
        }, le = function () {
            var e, i, n, r, o, a, s;
            return r = ye(arguments), n = r[0], i = r[1], e = r[2], n = ce(n), i = ce(i), e = ce(e), o = Ee((.4124564 * n + .3575761 * i + .1804375 * e) / t.X), a = Ee((.2126729 * n + .7151522 * i + .072175 * e) / t.Y), s = Ee((.0193339 * n + .119192 * i + .9503041 * e) / t.Z), [o, a, s]
        }, _.lab = function () {
            return function (e, t, i) {
                i.prototype = e.prototype;
                var n = new i, r = e.apply(n, t);
                return Object(r) === r ? r : n
            }(e, Te.call(arguments).concat(["lab"]), function () {
            })
        }, s.lab = B, e.prototype.lab = function () {
            return re(this._rgb)
        }, h = function (e) {
            var t, i, n, r, o, a, s, u, l, c, d;
            return e = function () {
                var t, i, n;
                for (n = [], i = 0, t = e.length; t > i; i++)r = e[i], n.push(_(r));
                return n
            }(), 2 === e.length ? (l = function () {
                var t, i, n;
                for (n = [], i = 0, t = e.length; t > i; i++)r = e[i], n.push(r.lab());
                return n
            }(), o = l[0], a = l[1], t = function (e) {
                var t, i;
                return i = function () {
                    var i, n;
                    for (n = [], t = i = 0; 2 >= i; t = ++i)n.push(o[t] + e * (a[t] - o[t]));
                    return n
                }(), _.lab.apply(_, i)
            }) : 3 === e.length ? (c = function () {
                var t, i, n;
                for (n = [], i = 0, t = e.length; t > i; i++)r = e[i], n.push(r.lab());
                return n
            }(), o = c[0], a = c[1], s = c[2], t = function (e) {
                var t, i;
                return i = function () {
                    var i, n;
                    for (n = [], t = i = 0; 2 >= i; t = ++i)n.push((1 - e) * (1 - e) * o[t] + 2 * (1 - e) * e * a[t] + e * e * s[t]);
                    return n
                }(), _.lab.apply(_, i)
            }) : 4 === e.length ? (d = function () {
                var t, i, n;
                for (n = [], i = 0, t = e.length; t > i; i++)r = e[i], n.push(r.lab());
                return n
            }(), o = d[0], a = d[1], s = d[2], u = d[3], t = function (e) {
                var t, i;
                return i = function () {
                    var i, n;
                    for (n = [], t = i = 0; 2 >= i; t = ++i)n.push((1 - e) * (1 - e) * (1 - e) * o[t] + 3 * (1 - e) * (1 - e) * e * a[t] + 3 * (1 - e) * e * e * s[t] + e * e * e * u[t]);
                    return n
                }(), _.lab.apply(_, i)
            }) : 5 === e.length && (i = h(e.slice(0, 3)), n = h(e.slice(2, 5)), t = function (e) {
                return .5 > e ? i(2 * e) : n(2 * (e - .5))
            }), t
        }, _.bezier = h, _.cubehelix = function (e, t, i, n, o) {
            var a, s;
            return null == e && (e = 300), null == t && (t = -1.5), null == i && (i = 1), null == n && (n = 1),
            null == o && (o = [0, 1]), s = o[1] - o[0], "array" === ge(i) ? (a = i[1] - i[0], 0 === a && (i = i[1])) : a = 0, function (u) {
                var l, c, h, d, m, p, f, g, y;
                return l = r * ((e + 120) / 360 + t * u), f = J(o[0] + s * u, n), p = 0 !== a ? i[0] + u * a : i, c = p * f * (1 - f) / 2, d = C(l), y = fe(l), g = f + c * (-.14861 * d + 1.78277 * y), m = f + c * (-.29227 * d - .90649 * y), h = f + 1.97294 * c * d, _(v([255 * g, 255 * m, 255 * h]))
            }
        }, _.random = function () {
            var t, i, n, r;
            for (i = "0123456789abcdef", t = "#", n = r = 0; 6 > r; n = ++r)t += i.charAt(w(16 * Math.random()));
            return new e(t)
        }, s.rgb = function () {
            var e, t, i, n;
            t = ye(arguments), i = [];
            for (e in t)n = t[e], i.push(n);
            return i
        }, _.rgb = function () {
            return function (e, t, i) {
                i.prototype = e.prototype;
                var n = new i, r = e.apply(n, t);
                return Object(r) === r ? r : n
            }(e, Te.call(arguments).concat(["rgb"]), function () {
            })
        }, e.prototype.rgb = function () {
            return this._rgb.slice(0, 3)
        }, e.prototype.rgba = function () {
            return this._rgb
        }, o.push({
            p: 15, test: function (e) {
                var t;
                return t = ye(arguments), "array" === ge(t) && 3 === t.length ? "rgb" : 4 === t.length && "number" === ge(t[3]) && t[3] >= 0 && t[3] <= 1 ? "rgb" : void 0
            }
        }), x = function (e) {
            var t, i, n, r, o, a;
            if (e.match(/^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/))return (4 === e.length || 7 === e.length) && (e = e.substr(1)), 3 === e.length && (e = e.split(""), e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2]), a = parseInt(e, 16), r = a >> 16, n = a >> 8 & 255, i = 255 & a, [r, n, i, 1];
            if (e.match(/^#?([A-Fa-f0-9]{8})$/))return 9 === e.length && (e = e.substr(1)), a = parseInt(e, 16), r = a >> 24 & 255, n = a >> 16 & 255, i = a >> 8 & 255, t = me((255 & a) / 255 * 100) / 100, [r, n, i, t];
            if (null != s.css && (o = s.css(e)))return o;
            throw"unknown color: " + e
        }, ee = function (e, t) {
            var i, n, r, o, a, s, u;
            return null == t && (t = "rgb"), a = e[0], r = e[1], n = e[2], i = e[3], u = a << 16 | r << 8 | n, s = "000000" + u.toString(16), s = s.substr(s.length - 6), o = "0" + me(255 * i).toString(16), o = o.substr(o.length - 2), "#" + function () {
                switch (t.toLowerCase()) {
                    case"rgba":
                        return s + o;
                    case"argb":
                        return o + s;
                    default:
                        return s
                }
            }()
        }, s.hex = function (e) {
            return x(e)
        }, _.hex = function () {
            return function (e, t, i) {
                i.prototype = e.prototype;
                var n = new i, r = e.apply(n, t);
                return Object(r) === r ? r : n
            }(e, Te.call(arguments).concat(["hex"]), function () {
            })
        }, e.prototype.hex = function (e) {
            return null == e && (e = "rgb"), ee(this._rgb, e)
        }, o.push({
            p: 10, test: function (e) {
                return 1 === arguments.length && "string" === ge(e) ? "hex" : void 0
            }
        }), I = function () {
            var e, t, i, n, r, o, a, s, u, l, c, h, d, m;
            if (u = ye(arguments), n = u[0], c = u[1], o = u[2], 0 === c)s = i = e = 255 * o; else {
                for (m = [0, 0, 0], t = [0, 0, 0], d = .5 > o ? o * (1 + c) : o + c - o * c, h = 2 * o - d, n /= 360, m[0] = n + 1 / 3, m[1] = n, m[2] = n - 1 / 3, r = a = 0; 2 >= a; r = ++a)m[r] < 0 && (m[r] += 1), m[r] > 1 && (m[r] -= 1), 6 * m[r] < 1 ? t[r] = h + 6 * (d - h) * m[r] : 2 * m[r] < 1 ? t[r] = d : 3 * m[r] < 2 ? t[r] = h + (d - h) * (2 / 3 - m[r]) * 6 : t[r] = h;
                l = [me(255 * t[0]), me(255 * t[1]), me(255 * t[2])], s = l[0], i = l[1], e = l[2]
            }
            return 4 === arguments.length ? [s, i, e, arguments[3]] : [s, i, e]
        }, ie = function (e, t, i) {
            var n, r, o, a, s;
            return void 0 !== e && e.length >= 3 && (a = e, e = a[0], t = a[1], i = a[2]), e /= 255, t /= 255, i /= 255, o = Math.min(e, t, i), j = Math.max(e, t, i), r = (j + o) / 2, j === o ? (s = 0, n = Number.NaN) : s = .5 > r ? (j - o) / (j + o) : (j - o) / (2 - j - o), e === j ? n = (t - i) / (j - o) : t === j ? n = 2 + (i - e) / (j - o) : i === j && (n = 4 + (e - t) / (j - o)), n *= 60, 0 > n && (n += 360), [n, s, r]
        }, _.hsl = function () {
            return function (e, t, i) {
                i.prototype = e.prototype;
                var n = new i, r = e.apply(n, t);
                return Object(r) === r ? r : n
            }(e, Te.call(arguments).concat(["hsl"]), function () {
            })
        }, s.hsl = I, e.prototype.hsl = function () {
            return ie(this._rgb)
        }, D = function () {
            var e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v;
            if (u = ye(arguments), n = u[0], f = u[1], v = u[2], v *= 255, 0 === f)s = i = e = v; else switch (360 === n && (n = 0), n > 360 && (n -= 360), 0 > n && (n += 360), n /= 60, r = w(n), t = n - r, o = v * (1 - f), a = v * (1 - f * t), _ = v * (1 - f * (1 - t)), r) {
                case 0:
                    l = [v, _, o], s = l[0], i = l[1], e = l[2];
                    break;
                case 1:
                    c = [a, v, o], s = c[0], i = c[1], e = c[2];
                    break;
                case 2:
                    h = [o, v, _], s = h[0], i = h[1], e = h[2];
                    break;
                case 3:
                    d = [o, a, v], s = d[0], i = d[1], e = d[2];
                    break;
                case 4:
                    m = [_, o, v], s = m[0], i = m[1], e = m[2];
                    break;
                case 5:
                    p = [v, o, a], s = p[0], i = p[1], e = p[2]
            }
            return s = me(s), i = me(i), e = me(e), [s, i, e]
        }, ne = function () {
            var e, t, i, n, r, o, a, s, u;
            return a = ye(arguments), o = a[0], i = a[1], e = a[2], r = Math.min(o, i, e), j = Math.max(o, i, e), t = j - r, u = j / 255, 0 === j ? (n = Number.NaN, s = 0) : (s = t / j, o === j && (n = (i - e) / t), i === j && (n = 2 + (e - o) / t), e === j && (n = 4 + (o - i) / t), n *= 60, 0 > n && (n += 360)), [n, s, u]
        }, _.hsv = function () {
            return function (e, t, i) {
                i.prototype = e.prototype;
                var n = new i, r = e.apply(n, t);
                return Object(r) === r ? r : n
            }(e, Te.call(arguments).concat(["hsv"]), function () {
            })
        }, s.hsv = D, e.prototype.hsv = function () {
            return ne(this._rgb)
        }, Z = function (e) {
            var t, i, n;
            return "number" === ge(e) && e >= 0 && 16777215 >= e ? (n = e >> 16, i = e >> 8 & 255, t = 255 & e, [n, i, t, 1]) : (console.warn("unknown num color: " + e), [0, 0, 0, 1])
        }, se = function () {
            var e, t, i, n;
            return n = ye(arguments), i = n[0], t = n[1], e = n[2], (i << 16) + (t << 8) + e
        }, _.num = function (t) {
            return new e(t, "num")
        }, e.prototype.num = function () {
            return se(this._rgb)
        }, s.num = Z, o.push({
            p: 10, test: function (e) {
                return 1 === arguments.length && "number" === ge(e) && e >= 0 && 16777215 >= e ? "num" : void 0
            }
        }), E = function (e) {
            var t, i, n, r, o, a, s, u;
            if (e = e.toLowerCase(), null != _.colors && _.colors[e])return x(_.colors[e]);
            if (o = e.match(/rgb\(\s*(\-?\d+),\s*(\-?\d+)\s*,\s*(\-?\d+)\s*\)/)) {
                for (s = o.slice(1, 4), r = a = 0; 2 >= a; r = ++a)s[r] = +s[r];
                s[3] = 1
            } else if (o = e.match(/rgba\(\s*(\-?\d+),\s*(\-?\d+)\s*,\s*(\-?\d+)\s*,\s*([01]|[01]?\.\d+)\)/))for (s = o.slice(1, 5), r = u = 0; 3 >= u; r = ++u)s[r] = +s[r]; else if (o = e.match(/rgb\(\s*(\-?\d+(?:\.\d+)?)%,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*\)/)) {
                for (s = o.slice(1, 4), r = t = 0; 2 >= t; r = ++t)s[r] = me(2.55 * s[r]);
                s[3] = 1
            } else if (o = e.match(/rgba\(\s*(\-?\d+(?:\.\d+)?)%,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)/)) {
                for (s = o.slice(1, 5), r = i = 0; 2 >= i; r = ++i)s[r] = me(2.55 * s[r]);
                s[3] = +s[3]
            } else(o = e.match(/hsl\(\s*(\-?\d+(?:\.\d+)?),\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*\)/)) ? (n = o.slice(1, 4), n[1] *= .01, n[2] *= .01, s = I(n), s[3] = 1) : (o = e.match(/hsla\(\s*(\-?\d+(?:\.\d+)?),\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)/)) && (n = o.slice(1, 4), n[1] *= .01, n[2] *= .01, s = I(n), s[3] = +o[4]);
            return s
        }, $ = function (e) {
            var t;
            return t = e[3] < 1 ? "rgba" : "rgb", "rgb" === t ? t + "(" + e.slice(0, 3).map(me).join(",") + ")" : "rgba" === t ? t + "(" + e.slice(0, 3).map(me).join(",") + "," + e[3] + ")" : void 0
        }, he = function (e) {
            return me(100 * e) / 100
        }, P = function (e, t) {
            var i;
            return i = 1 > t ? "hsla" : "hsl", e[0] = he(e[0] || 0), e[1] = he(100 * e[1]) + "%", e[2] = he(100 * e[2]) + "%", "hsla" === i && (e[3] = t), i + "(" + e.join(",") + ")"
        }, s.css = function (e) {
            return E(e)
        }, _.css = function () {
            return function (e, t, i) {
                i.prototype = e.prototype;
                var n = new i, r = e.apply(n, t);
                return Object(r) === r ? r : n
            }(e, Te.call(arguments).concat(["css"]), function () {
            })
        }, e.prototype.css = function (e) {
            return null == e && (e = "rgb"), "rgb" === e.slice(0, 3) ? $(this._rgb) : "hsl" === e.slice(0, 3) ? P(this.hsl(), this.alpha()) : void 0
        }, s.named = function (e) {
            return x(Ce[e])
        }, o.push({
            p: 20, test: function (e) {
                return 1 === arguments.length && null != Ce[e] ? "named" : void 0
            }
        }), e.prototype.name = function (e) {
            var t, i;
            arguments.length && (Ce[e] && (this._rgb = x(Ce[e])), this._rgb[3] = 1), t = this.hex();
            for (i in Ce)if (t === Ce[i])return i;
            return t
        }, V = function () {
            var e, t, n, r;
            return r = ye(arguments), n = r[0], e = r[1], t = r[2], t = t * i / 180, [n, C(t) * e, fe(t) * e]
        }, U = function () {
            var e, t, i, n, r, o, a, s, u, l, c;
            return u = ye(arguments), a = u[0], n = u[1], o = u[2], l = V(a, n, o), e = l[0], t = l[1], i = l[2], c = B(e, t, i), s = c[0], r = c[1], i = c[2], [G(s, 0, 255), G(r, 0, 255), G(i, 0, 255)]
        }, F = function () {
            var e, t, n, r, o, a;
            return a = ye(arguments), o = a[0], e = a[1], t = a[2], n = _e(e * e + t * t), r = (c(t, e) / i * 180 + 360) % 360, [o, n, r]
        }, oe = function () {
            var e, t, i, n, r, o, a;
            return o = ye(arguments), r = o[0], i = o[1], t = o[2], a = re(r, i, t), n = a[0], e = a[1], t = a[2], F(n, e, t)
        }, _.lch = function () {
            var t;
            return t = ye(arguments), new e(t, "lch")
        }, _.hcl = function () {
            var t;
            return t = ye(arguments), new e(t, "hcl")
        }, s.lch = U, s.hcl = function () {
            var e, t, i, n;
            return n = ye(arguments), t = n[0], e = n[1], i = n[2], U([i, e, t])
        }, e.prototype.lch = function () {
            return oe(this._rgb)
        }, e.prototype.hcl = function () {
            return oe(this._rgb).reverse()
        }, Q = function (e) {
            var t, i, n, r, o, a, s, u, l;
            return null == e && (e = "rgb"), u = ye(arguments), s = u[0], r = u[1], t = u[2], s /= 255, r /= 255, t /= 255, o = 1 - Math.max(s, Math.max(r, t)), n = 1 > o ? 1 / (1 - o) : 0, i = (1 - s - o) * n, a = (1 - r - o) * n, l = (1 - t - o) * n, [i, a, l, o]
        }, g = function () {
            var e, t, i, n, r, o, a, s;
            return a = ye(arguments), t = a[0], r = a[1], s = a[2], n = a[3], 1 === n ? [0, 0, 0] : (o = t >= 1 ? 0 : me(255 * (1 - t) * (1 - n)), i = r >= 1 ? 0 : me(255 * (1 - r) * (1 - n)), e = s >= 1 ? 0 : me(255 * (1 - s) * (1 - n)), [o, i, e])
        }, s.cmyk = function () {
            var e, t, i, n, r;
            return n = ye(arguments), e = n[0], i = n[1], r = n[2], t = n[3], g(e, i, r, t)
        }, _.cmyk = function () {
            return function (e, t, i) {
                i.prototype = e.prototype;
                var n = new i, r = e.apply(n, t);
                return Object(r) === r ? r : n
            }(e, Te.call(arguments).concat(["cmyk"]), function () {
            })
        }, e.prototype.cmyk = function () {
            return Q(this._rgb)
        }, s.gl = function () {
            var e, t, i, n, r;
            for (n = function () {
                var e, i;
                e = ye(arguments), i = [];
                for (t in e)r = e[t], i.push(r);
                return i
            }.apply(this, arguments), e = i = 0; 2 >= i; e = ++i)n[e] *= 255;
            return n
        }, _.gl = function () {
            return function (e, t, i) {
                i.prototype = e.prototype;
                var n = new i, r = e.apply(n, t);
                return Object(r) === r ? r : n
            }(e, Te.call(arguments).concat(["gl"]), function () {
            })
        }, e.prototype.gl = function () {
            var e;
            return e = this._rgb, [e[0] / 255, e[1] / 255, e[2] / 255, e[3]]
        }, ae = function (e, t, i) {
            var n;
            return n = ye(arguments), e = n[0], t = n[1], i = n[2], e = W(e), t = W(t), i = W(i), .2126 * e + .7152 * t + .0722 * i
        }, W = function (e) {
            return e /= 255, .03928 >= e ? e / 12.92 : J((e + .055) / 1.055, 2.4)
        },u = [],M = function (e, t, i, n) {
            var r, o, a, s;
            for (null == i && (i = .5), null == n && (n = "rgb"), "object" !== ge(e) && (e = _(e)), "object" !== ge(t) && (t = _(t)), a = 0, o = u.length; o > a; a++)if (r = u[a], n === r[0]) {
                s = r[1](e, t, i, n);
                break
            }
            if (null == s)throw"color mode " + n + " is not supported";
            return s.alpha(e.alpha() + i * (t.alpha() - e.alpha())), s
        },_.interpolate = M,e.prototype.interpolate = function (e, t, i) {
            return M(this, e, t, i)
        },_.mix = M,e.prototype.mix = e.prototype.interpolate,L = function (t, i, n, r) {
            var o, a;
            return o = t._rgb, a = i._rgb, new e(o[0] + n * (a[0] - o[0]), o[1] + n * (a[1] - o[1]), o[2] + n * (a[2] - o[2]), r)
        },u.push(["rgb", L]),e.prototype.luminance = function (e, t) {
            var i, n, r, o;
            return null == t && (t = "rgb"), arguments.length ? (0 === e ? this._rgb = [0, 0, 0, this._rgb[3]] : 1 === e ? this._rgb = [255, 255, 255, this._rgb[3]] : (n = 1e-7, r = 20, o = function (i, a) {
                var s, u;
                return u = i.interpolate(a, .5, t), s = u.luminance(), Math.abs(e - s) < n || !r-- ? u : s > e ? o(i, u) : o(u, a)
            }, i = ae(this._rgb), this._rgb = (i > e ? o(_("black"), this) : o(this, _("white"))).rgba()), this) : ae(this._rgb)
        },ve = function (e) {
            var t, i, n, r;
            return r = e / 100, 66 > r ? (n = 255, i = -155.25485562709179 - .44596950469579133 * (i = r - 2) + 104.49216199393888 * H(i), t = 20 > r ? 0 : -254.76935184120902 + .8274096064007395 * (t = r - 10) + 115.67994401066147 * H(t)) : (n = 351.97690566805693 + .114206453784165 * (n = r - 55) - 40.25366309332127 * H(n), i = 325.4494125711974 + .07943456536662342 * (i = r - 50) - 28.0852963507957 * H(i), t = 255), v([n, i, t])
        },ue = function () {
            var e, t, i, n, r, o, a, s, u;
            for (a = ye(arguments), o = a[0], i = a[1], e = a[2], r = 1e3, n = 4e4, t = .4; n - r > t;)u = .5 * (n + r), s = ve(u), s[2] / s[0] >= e / o ? n = u : r = u;
            return me(u)
        },_.temperature = _.kelvin = function () {
            return function (e, t, i) {
                i.prototype = e.prototype;
                var n = new i, r = e.apply(n, t);
                return Object(r) === r ? r : n
            }(e, Te.call(arguments).concat(["temperature"]), function () {
            })
        },s.temperature = s.kelvin = s.K = ve,e.prototype.temperature = function () {
            return ue(this._rgb)
        },e.prototype.kelvin = e.prototype.temperature,_.contrast = function (t, i) {
            var n, r, o, a;
            return ("string" === (o = ge(t)) || "number" === o) && (t = new e(t)), ("string" === (a = ge(i)) || "number" === a) && (i = new e(i)), n = t.luminance(), r = i.luminance(), n > r ? (n + .05) / (r + .05) : (r + .05) / (n + .05)
        },e.prototype.darken = function (e) {
            var t, i;
            return null == e && (e = 20), i = this, t = i.lch(), t[0] -= e, _.lch(t).alpha(i.alpha())
        },e.prototype.darker = e.prototype.darken,e.prototype.brighten = function (e) {
            return null == e && (e = 20), this.darken(-e)
        },e.prototype.brighter = e.prototype.brighten,e.prototype.saturate = function (e) {
            var t, i;
            return null == e && (e = 20), i = this, t = i.lch(), t[1] += e, t[1] < 0 && (t[1] = 0), _.lch(t).alpha(i.alpha())
        },e.prototype.desaturate = function (e) {
            return null == e && (e = 20), this.saturate(-e)
        },e.prototype.premultiply = function () {
            var e, t;
            return t = this.rgb(), e = this.alpha(), _(t[0] * e, t[1] * e, t[2] * e, e)
        },d = function (e, t, i) {
            if (!d[i])throw"unknown blend mode " + i;
            return d[i](e, t)
        },m = function (e) {
            return function (t, i) {
                var n, r;
                return n = _(i).rgb(), r = _(t).rgb(), _(e(n, r), "rgb")
            }
        },b = function (e) {
            return function (t, i) {
                var n, r, o;
                for (o = [], n = r = 0; 3 >= r; n = ++r)o[n] = e(t[n], i[n]);
                return o
            }
        },X = function (e, t) {
            return e
        },Y = function (e, t) {
            return e * t / 255
        },S = function (e, t) {
            return e > t ? t : e
        },k = function (e, t) {
            return e > t ? e : t
        },pe = function (e, t) {
            return 255 * (1 - (1 - e / 255) * (1 - t / 255))
        },K = function (e, t) {
            return 128 > t ? 2 * e * t / 255 : 255 * (1 - 2 * (1 - e / 255) * (1 - t / 255))
        },f = function (e, t) {
            return 255 * (1 - (1 - t / 255) / (e / 255))
        },T = function (e, t) {
            return 255 === e ? 255 : (e = 255 * (t / 255) / (1 - e / 255), e > 255 ? 255 : e)
        },d.normal = m(b(X)),d.multiply = m(b(Y)),d.screen = m(b(pe)),d.overlay = m(b(K)),d.darken = m(b(S)),d.lighten = m(b(k)),d.dodge = m(b(T)),d.burn = m(b(f)),_.blend = d,_.scale = function (e, t) {
            var i, n, r, o, a, s, u, l, c, h, d, m, p, f, v, g, y, C, E, S, T;
            return l = "rgb", c = _("#ccc"), p = 0, a = !1, o = [0, 1], n = [], d = !1, m = [], u = 0, s = 1, r = !1, h = 0, i = {}, E = function (e, t) {
                var i, r, o, a, s, u, l;
                if (null == e && (e = ["#ddd", "#222"]), null != e && "string" === ge(e) && null != (null != (a = _.brewer) ? a[e] : void 0) && (e = _.brewer[e]), "array" === ge(e)) {
                    for (e = e.slice(0), i = o = 0, s = e.length - 1; s >= 0 ? s >= o : o >= s; i = s >= 0 ? ++o : --o)r = e[i], "string" === ge(r) && (e[i] = _(r));
                    if (null != t)m = t; else for (m = [], i = l = 0, u = e.length - 1; u >= 0 ? u >= l : l >= u; i = u >= 0 ? ++l : --l)m.push(i / (e.length - 1))
                }
                return C(), n = e
            }, S = function (e) {
                return null == e && (e = []), o = e, u = e[0], s = e[e.length - 1], C(), h = 2 === e.length ? 0 : e.length - 1
            }, g = function (e) {
                var t, i;
                if (null != o) {
                    for (i = o.length - 1, t = 0; i > t && e >= o[t];)t++;
                    return t - 1
                }
                return 0
            }, T = function (e) {
                return e
            }, f = function (e) {
                var t, i, n, r, a;
                return a = e, o.length > 2 && (r = o.length - 1, t = g(e), n = o[0] + (o[1] - o[0]) * (0 + .5 * p), i = o[r - 1] + (o[r] - o[r - 1]) * (1 - .5 * p), a = u + (o[t] + .5 * (o[t + 1] - o[t]) - n) / (i - n) * (s - u)), a
            }, y = function (e, t) {
                var r, a, d, p, f, v, y, C, E;
                if (null == t && (t = !1), isNaN(e))return c;
                if (t ? E = e : o.length > 2 ? (r = g(e), E = r / (h - 1)) : (E = d = u !== s ? (e - u) / (s - u) : 0, E = d = (e - u) / (s - u), E = Math.min(1, Math.max(0, E))), t || (E = T(E)), f = Math.floor(1e4 * E), i[f])a = i[f]; else {
                    if ("array" === ge(n))for (p = v = 0, C = m.length - 1; C >= 0 ? C >= v : v >= C; p = C >= 0 ? ++v : --v) {
                        if (y = m[p], y >= E) {
                            a = n[p];
                            break
                        }
                        if (E >= y && p === m.length - 1) {
                            a = n[p];
                            break
                        }
                        if (E > y && E < m[p + 1]) {
                            E = (E - y) / (m[p + 1] - y), a = _.interpolate(n[p], n[p + 1], E, l);
                            break
                        }
                    } else"function" === ge(n) && (a = n(E));
                    i[f] = a
                }
                return a
            }, C = function () {
                return i = {}
            }, E(e, t), v = function (e) {
                var t;
                return t = y(e), d && t[d] ? t[d]() : t
            }, v.domain = function (e, t, i, n) {
                var r;
                return null == i && (i = "e"), arguments.length ? (null != t && (r = _.analyze(e, n), e = 0 === t ? [r.min, r.max] : _.limits(r, i, t)), S(e), v) : o
            }, v.mode = function (e) {
                return arguments.length ? (l = e, C(), v) : l
            }, v.range = function (e, t) {
                return E(e, t), v
            }, v.out = function (e) {
                return d = e, v
            }, v.spread = function (e) {
                return arguments.length ? (p = e, v) : p
            }, v.correctLightness = function (e) {
                return arguments.length ? (r = e, C(), T = r ? function (e) {
                    var t, i, n, r, o, a, s, u, l;
                    for (t = y(0, !0).lab()[0], i = y(1, !0).lab()[0], s = t > i, n = y(e, !0).lab()[0], o = t + (i - t) * e, r = n - o, u = 0, l = 1, a = 20; Math.abs(r) > .01 && a-- > 0;)!function () {
                        return s && (r *= -1), 0 > r ? (u = e, e += .5 * (l - e)) : (l = e, e += .5 * (u - e)), n = y(e, !0).lab()[0], r = n - o
                    }();
                    return e
                } : function (e) {
                    return e
                }, v) : r
            }, v.colors = function () {
                var t, i, n, r, a, s, u, l, c;
                if (r = 0, a = "hex", 1 === arguments.length && ("string" === ge(arguments[0]) ? a = arguments[0] : r = arguments[0]), 2 === arguments.length && (r = arguments[0], a = arguments[1]), r)return function () {
                    u = [];
                    for (var e = 0; r >= 0 ? r > e : e > r; r >= 0 ? e++ : e--)u.push(e);
                    return u
                }.apply(this).map(function (e) {
                    return v(e / (r - 1))[a]()
                });
                if (e = [], l = [], o.length > 2)for (i = c = 1, s = o.length; s >= 1 ? s > c : c > s; i = s >= 1 ? ++c : --c)l.push(.5 * (o[i - 1] + o[i])); else l = o;
                for (t = 0, n = l.length; n > t; t++)i = l[t], e.push(v(i)[a]());
                return e
            }, v
        },null == _.scales && (_.scales = {}),_.scales.cool = function () {
            return _.scale([_.hsl(180, 1, .9), _.hsl(250, .7, .4)])
        },_.scales.hot = function () {
            return _.scale(["#000", "#f00", "#ff0", "#fff"], [0, .25, .75, 1]).mode("rgb")
        },_.analyze = function (e, t, i) {
            var n, r, o, a, s, u, l;
            if (s = {
                    min: Number.MAX_VALUE,
                    max: -1 * Number.MAX_VALUE,
                    sum: 0,
                    values: [],
                    count: 0
                }, null == i && (i = function () {
                    return !0
                }), n = function (e) {
                    null == e || isNaN(e) || (s.values.push(e), s.sum += e, e < s.min && (s.min = e), e > s.max && (s.max = e), s.count += 1)
                }, l = function (e, r) {
                    return i(e, r) ? n(null != t && "function" === ge(t) ? t(e) : null != t && "string" === ge(t) || "number" === ge(t) ? e[t] : e) : void 0
                }, "array" === ge(e))for (a = 0, o = e.length; o > a; a++)u = e[a], l(u); else for (r in e)u = e[r], l(u, r);
            return s.domain = [s.min, s.max], s.limits = function (e, t) {
                return _.limits(s, e, t)
            }, s
        },_.limits = function (e, t, i) {
            var n, r, o, a, s, u, c, h, d, m, p, f, v, g, y, C, E, S, T, b, x, A, P, I, D, M, O, R, N, L, F, B, z, V, U, k, G, W, q, Y, X, Z, K, Q, $, ee, te, ie, ne, re, oe, ae, se, ue, le;
            if (null == t && (t = "equal"), null == i && (i = 7), "array" === ge(e) && (e = _.analyze(e)), D = e.min, j = e.max, oe = e.sum, ue = e.values.sort(function (e, t) {
                    return e - t
                }), P = [], "c" === t.substr(0, 1) && (P.push(D), P.push(j)), "e" === t.substr(0, 1)) {
                for (P.push(D), b = F = 1, U = i - 1; U >= 1 ? U >= F : F >= U; b = U >= 1 ? ++F : --F)P.push(D + b / i * (j - D));
                P.push(j)
            } else if ("l" === t.substr(0, 1)) {
                if (0 >= D)throw"Logarithmic scales are only possible for values > 0";
                for (M = Math.LOG10E * H(D), I = Math.LOG10E * H(j), P.push(D), b = le = 1, k = i - 1; k >= 1 ? k >= le : le >= k; b = k >= 1 ? ++le : --le)P.push(J(10, M + b / i * (I - M)));
                P.push(j)
            } else if ("q" === t.substr(0, 1)) {
                for (P.push(D), b = n = 1, Z = i - 1; Z >= 1 ? Z >= n : n >= Z; b = Z >= 1 ? ++n : --n)B = ue.length * b / i, z = w(B), z === B ? P.push(ue[z]) : (V = B - z, P.push(ue[z] * V + ue[z + 1] * (1 - V)));
                P.push(j)
            } else if ("k" === t.substr(0, 1)) {
                for (R = ue.length, g = new Array(R), S = new Array(i), re = !0, N = 0, C = null, C = [], C.push(D), b = r = 1, K = i - 1; K >= 1 ? K >= r : r >= K; b = K >= 1 ? ++r : --r)C.push(D + b / i * (j - D));
                for (C.push(j); re;) {
                    for (x = o = 0, Q = i - 1; Q >= 0 ? Q >= o : o >= Q; x = Q >= 0 ? ++o : --o)S[x] = 0;
                    for (b = a = 0, $ = R - 1; $ >= 0 ? $ >= a : a >= $; b = $ >= 0 ? ++a : --a) {
                        for (se = ue[b], O = Number.MAX_VALUE, x = s = 0, ee = i - 1; ee >= 0 ? ee >= s : s >= ee; x = ee >= 0 ? ++s : --s)T = l(C[x] - se), O > T && (O = T, y = x);
                        S[y]++, g[b] = y
                    }
                    for (L = new Array(i), x = u = 0, te = i - 1; te >= 0 ? te >= u : u >= te; x = te >= 0 ? ++u : --u)L[x] = null;
                    for (b = c = 0, ie = R - 1; ie >= 0 ? ie >= c : c >= ie; b = ie >= 0 ? ++c : --c)E = g[b], null === L[E] ? L[E] = ue[b] : L[E] += ue[b];
                    for (x = h = 0, ne = i - 1; ne >= 0 ? ne >= h : h >= ne; x = ne >= 0 ? ++h : --h)L[x] *= 1 / S[x];
                    for (re = !1, x = d = 0, G = i - 1; G >= 0 ? G >= d : d >= G; x = G >= 0 ? ++d : --d)if (L[x] !== C[b]) {
                        re = !0;
                        break
                    }
                    C = L, N++, N > 200 && (re = !1)
                }
                for (A = {}, x = m = 0, W = i - 1; W >= 0 ? W >= m : m >= W; x = W >= 0 ? ++m : --m)A[x] = [];
                for (b = p = 0, q = R - 1; q >= 0 ? q >= p : p >= q; b = q >= 0 ? ++p : --p)E = g[b], A[E].push(ue[b]);
                for (ae = [], x = f = 0, Y = i - 1; Y >= 0 ? Y >= f : f >= Y; x = Y >= 0 ? ++f : --f)ae.push(A[x][0]), ae.push(A[x][A[x].length - 1]);
                for (ae = ae.sort(function (e, t) {
                    return e - t
                }), P.push(ae[0]), b = v = 1, X = ae.length - 1; X >= v; b = v += 2)isNaN(ae[b]) || P.push(ae[b])
            }
            return P
        },A = function (e, t, i) {
            var o, a, s, u;
            return u = ye(arguments), e = u[0], t = u[1], i = u[2], e /= 360, 1 / 3 > e ? (o = (1 - t) / 3, s = (1 + t * C(r * e) / C(n - r * e)) / 3, a = 1 - (o + s)) : 2 / 3 > e ? (e -= 1 / 3, s = (1 - t) / 3, a = (1 + t * C(r * e) / C(n - r * e)) / 3, o = 1 - (s + a)) : (e -= 2 / 3, a = (1 - t) / 3, o = (1 + t * C(r * e) / C(n - r * e)) / 3, s = 1 - (a + o)), s = G(i * s * 3), a = G(i * a * 3), o = G(i * o * 3), [255 * s, 255 * a, 255 * o]
        },te = function () {
            var e, t, i, n, o, a, s, u;
            return s = ye(arguments), a = s[0], t = s[1], e = s[2], r = 2 * Math.PI, a /= 255, t /= 255, e /= 255, o = Math.min(a, t, e), n = (a + t + e) / 3, u = 1 - o / n, 0 === u ? i = 0 : (i = (a - t + (a - e)) / 2, i /= Math.sqrt((a - t) * (a - t) + (a - e) * (t - e)), i = Math.acos(i), e > t && (i = r - i), i /= r), [360 * i, u, n]
        },_.hsi = function () {
            return function (e, t, i) {
                i.prototype = e.prototype;
                var n = new i, r = e.apply(n, t);
                return Object(r) === r ? r : n
            }(e, Te.call(arguments).concat(["hsi"]), function () {
            })
        },s.hsi = A,e.prototype.hsi = function () {
            return te(this._rgb)
        },O = function (t, i, n, r) {
            var o, a, s, u, l, c, h, d, m, p, f, _, v;
            return "hsl" === r ? (_ = t.hsl(), v = i.hsl()) : "hsv" === r ? (_ = t.hsv(), v = i.hsv()) : "hsi" === r ? (_ = t.hsi(), v = i.hsi()) : "lch" === r && (_ = t.lch(), v = i.lch()), "h" === r.substr(0, 1) ? (s = _[0], p = _[1], c = _[2], u = v[0], f = v[1], h = v[2]) : (c = _[0], p = _[1], s = _[2], h = v[0], f = v[1], u = v[2]), isNaN(s) || isNaN(u) ? isNaN(s) ? isNaN(u) ? a = Number.NaN : (a = u, 1 !== c && 0 !== c || "hsv" === r || (m = f)) : (a = s, 1 !== h && 0 !== h || "hsv" === r || (m = p)) : (o = u > s && u - s > 180 ? u - (s + 360) : s > u && s - u > 180 ? u + 360 - s : u - s, a = s + n * o), null == m && (m = p + n * (f - p)), l = c + n * (h - c), d = "h" === r.substr(0, 1) ? new e(a, m, l, r) : new e(l, m, a, r)
        },u = u.concat(function () {
            var e, t, i, n;
            for (i = ["hsv", "hsl", "hsi", "lch"], n = [], t = 0, e = i.length; e > t; t++)q = i[t], n.push([q, O]);
            return n
        }()),N = function (e, t, i, n) {
            var r, o;
            return r = e.num(), o = t.num(), _.num(r + (o - r) * i, "num")
        },u.push(["num", N]),R = function (t, i, n, r) {
            var o, a, s;
            return a = t.lab(), s = i.lab(), o = new e(a[0] + n * (s[0] - a[0]), a[1] + n * (s[1] - a[1]), a[2] + n * (s[2] - a[2]), r)
        },u.push(["lab", R])
    }.call(this),define("text", ["module"], function (e) {
        "use strict";
        var t, i, n, r, o, a = ["Msxml2.XMLHTTP", "Microsoft.XMLHTTP", "Msxml2.XMLHTTP.4.0"], s = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im, u = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im, l = "undefined" != typeof location && location.href, c = l && location.protocol && location.protocol.replace(/\:/, ""), h = l && location.hostname, d = l && (location.port || void 0), m = {}, p = e.config && e.config() || {};
        return t = {
            version: "2.0.12", strip: function (e) {
                if (e) {
                    e = e.replace(s, "");
                    var t = e.match(u);
                    t && (e = t[1])
                } else e = "";
                return e
            }, jsEscape: function (e) {
                return e.replace(/(['\\])/g, "\\$1").replace(/[\f]/g, "\\f").replace(/[\b]/g, "\\b").replace(/[\n]/g, "\\n").replace(/[\t]/g, "\\t").replace(/[\r]/g, "\\r").replace(/[\u2028]/g, "\\u2028").replace(/[\u2029]/g, "\\u2029")
            }, createXhr: p.createXhr || function () {
                var e, t, i;
                if ("undefined" != typeof XMLHttpRequest)return new XMLHttpRequest;
                if ("undefined" != typeof ActiveXObject)for (t = 0; 3 > t; t += 1) {
                    i = a[t];
                    try {
                        e = new ActiveXObject(i)
                    } catch (n) {
                    }
                    if (e) {
                        a = [i];
                        break
                    }
                }
                return e
            }, parseName: function (e) {
                var t, i, n, r = !1, o = e.indexOf("."), a = 0 === e.indexOf("./") || 0 === e.indexOf("../");
                return -1 !== o && (!a || o > 1) ? (t = e.substring(0, o), i = e.substring(o + 1, e.length)) : t = e, n = i || t, o = n.indexOf("!"), -1 !== o && (r = "strip" === n.substring(o + 1), n = n.substring(0, o), i ? i = n : t = n), {
                    moduleName: t,
                    ext: i,
                    strip: r
                }
            }, xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/, useXhr: function (e, i, n, r) {
                var o, a, s, u = t.xdRegExp.exec(e);
                return u ? (o = u[2], a = u[3], a = a.split(":"), s = a[1], a = a[0], !(o && o !== i || a && a.toLowerCase() !== n.toLowerCase() || (s || a) && s !== r)) : !0
            }, finishLoad: function (e, i, n, r) {
                n = i ? t.strip(n) : n, p.isBuild && (m[e] = n), r(n)
            }, load: function (e, i, n, r) {
                if (r && r.isBuild && !r.inlineText)return void n();
                p.isBuild = r && r.isBuild;
                var o = t.parseName(e), a = o.moduleName + (o.ext ? "." + o.ext : ""), s = i.toUrl(a), u = p.useXhr || t.useXhr;
                return 0 === s.indexOf("empty:") ? void n() : void(!l || u(s, c, h, d) ? t.get(s, function (i) {
                    t.finishLoad(e, o.strip, i, n)
                }, function (e) {
                    n.error && n.error(e)
                }) : i([a], function (e) {
                    t.finishLoad(o.moduleName + "." + o.ext, o.strip, e, n)
                }))
            }, write: function (e, i, n, r) {
                if (m.hasOwnProperty(i)) {
                    var o = t.jsEscape(m[i]);
                    n.asModule(e + "!" + i, "define(function () { return '" + o + "';});\n")
                }
            }, writeFile: function (e, i, n, r, o) {
                var a = t.parseName(i), s = a.ext ? "." + a.ext : "", u = a.moduleName + s, l = n.toUrl(a.moduleName + s) + ".js";
                t.load(u, n, function (i) {
                    var n = function (e) {
                        return r(l, e)
                    };
                    n.asModule = function (e, t) {
                        return r.asModule(e, l, t)
                    }, t.write(e, u, n, o)
                }, o)
            }
        }, "node" === p.env || !p.env && "undefined" != typeof process && process.versions && process.versions.node && !process.versions["node-webkit"] ? (i = require.nodeRequire("fs"), t.get = function (e, t, n) {
            try {
                var r = i.readFileSync(e, "utf8");
                0 === r.indexOf("\ufeff") && (r = r.substring(1)), t(r)
            } catch (o) {
                n && n(o)
            }
        }) : "xhr" === p.env || !p.env && t.createXhr() ? t.get = function (e, i, n, r) {
            var o, a = t.createXhr();
            if (a.open("GET", e, !0), r)for (o in r)r.hasOwnProperty(o) && a.setRequestHeader(o.toLowerCase(), r[o]);
            p.onXhr && p.onXhr(a, e), a.onreadystatechange = function (t) {
                var r, o;
                4 === a.readyState && (r = a.status || 0, r > 399 && 600 > r ? (o = new Error(e + " HTTP status: " + r), o.xhr = a, n && n(o)) : i(a.responseText), p.onXhrComplete && p.onXhrComplete(a, e))
            }, a.send(null)
        } : "rhino" === p.env || !p.env && "undefined" != typeof Packages && "undefined" != typeof java ? t.get = function (e, t) {
            var i, n, r = "utf-8", o = new java.io.File(e), a = java.lang.System.getProperty("line.separator"), s = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(o), r)), u = "";
            try {
                for (i = new java.lang.StringBuffer, n = s.readLine(), n && n.length() && 65279 === n.charAt(0) && (n = n.substring(1)), null !== n && i.append(n); null !== (n = s.readLine());)i.append(a), i.append(n);
                u = String(i.toString())
            } finally {
                s.close()
            }
            t(u)
        } : ("xpconnect" === p.env || !p.env && "undefined" != typeof Components && Components.classes && Components.interfaces) && (n = Components.classes, r = Components.interfaces, Components.utils["import"]("resource://gre/modules/FileUtils.jsm"), o = "@mozilla.org/windows-registry-key;1"in n, t.get = function (e, t) {
            var i, a, s, u = {};
            o && (e = e.replace(/\//g, "\\")), s = new FileUtils.File(e);
            try {
                i = n["@mozilla.org/network/file-input-stream;1"].createInstance(r.nsIFileInputStream), i.init(s, 1, 0, !1), a = n["@mozilla.org/intl/converter-input-stream;1"].createInstance(r.nsIConverterInputStream), a.init(i, "utf-8", i.available(), r.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER), a.readString(i.available(), u), a.close(), i.close(), t(u.value)
            } catch (l) {
                throw new Error((s && s.path || "") + ": " + l)
            }
        }), t
    }),define("text!Widgets/PalettePicker/PalettePicker.html", [], function () {
        return "<button type=\"button\" class=\"palette-picker\"\r\n        data-bind=\"click: toggleDropDown, style: { backgroundImage: 'url(\\'' + selectedItem().image() + '\\')' }\"></button>\r\n<div class=\"palette-picker-dropDown\"\r\n     data-bind=\"css: { 'palette-picker-dropDown-visible' : dropDownVisible }, foreach: choices\">\r\n    <div class=\"palette-picker-choice\"\r\n         data-bind=\"click: $parent.select, style: { backgroundImage: 'url(\\'' + image() + '\\')' }\">\r\n    </div>\r\n</div>\r\n"
    }),define("Widgets/PalettePicker/PalettePicker", ["Cesium/Core/defined", "Cesium/Core/destroyObject", "Cesium/Core/DeveloperError", "Cesium/Core/FeatureDetection", "Cesium/Widgets/getElement", "../createDomNode", "chroma", "Cesium/ThirdParty/knockout", "text!./PalettePicker.html"], function (e, t, i, n, r, o, a, s, u) {
        "use strict";
        function l(e, t, i) {
            var n = document.createElement("canvas");
            n.style["padding-left"] = "5px", n.width = t, n.height = i;
            for (var r = n.getContext("2d"), o = e.colors(), a = Math.floor(t / o.length), s = 0; s < o.length; s++) {
                r.fillStyle = o[s];
                var u = s * a;
                r.fillRect(u, 0, u + a, i)
            }
            return n
        }

        var c = function (e, t) {
            this.image = s.observable(l(a.scale(e).domain([0, 5, 10, 25, 50, 100, 300, 301]), 50, 25).toDataURL()), this.name = e
        }, h = function (e) {
            e = r(e), e.appendChild(o(u));
            for (var t = s.observableArray(), i = Object.keys(a.brewer), l = 0; l < i.length; l++)t.push(new c(i[l], e));
            this.select = this.select.bind(this), this.dropDownVisible = s.observable(!1), this.choices = t, this.selectedItem = s.observable(t()[0]), this._container = e, s.applyBindings(this, e), this.closeOnInput = this.closeOnInput.bind(this), n.supportsPointerEvents() ? document.addEventListener("pointerdown", this.closeOnInput, !0) : (document.addEventListener("mousedown", this.closeOnInput, !0), document.addEventListener("touchstart", this.closeOnInput, !0))
        };
        return h.prototype.destroy = function () {
            n.supportsPointerEvents() ? document.removeEventListener("pointerdown", this.closeOnInput, !0) : (document.removeEventListener("mousedown", this.closeOnInput, !0), document.removeEventListener("touchstart", this.closeOnInput, !0));
            var e = this._container;
            for (s.cleanNode(this._container); e.firstChild;)e.removeChild(e.firstChild);
            return this.viewModel.destroy(), t(this)
        }, h.prototype.closeOnInput = function (e) {
            this._container.contains(e.target) || this.dropDownVisible(!1)
        }, h.prototype.toggleDropDown = function () {
            this.dropDownVisible(!this.dropDownVisible())
        }, h.prototype.select = function (e) {
            this.dropDownVisible(!1), this.selectedItem(e)
        }, h
    }),define("app", ["Cesium/Core/BingMapsApi", "Cesium/Core/BoundingSphere", "Cesium/Core/Cartesian3", "Cesium/Core/clone", "Cesium/Core/Color", "Cesium/Core/Credit", "Cesium/Core/defined", "Cesium/Core/definedNotNull", "Cesium/Core/formatError", "Cesium/Core/JulianDate", "Cesium/Core/loadXml", "Cesium/Core/loadWithXhr", "Cesium/Core/Math", "Cesium/Core/Matrix4", "Cesium/Core/objectToQuery", "Cesium/Core/queryToObject", "Cesium/Core/ScreenSpaceEventType", "Cesium/DataSources/Entity", "Cesium/Scene/Cesium3DTileset", "Cesium/ThirdParty/Autolinker", "Cesium/ThirdParty/when", "Cesium/Widgets/Viewer/Viewer", "Widgets/PalettePicker/PalettePicker", "chroma"], function (e, t, i, n, r, o, a, s, u, l, c, h, d, m, p, f, _, v, g, y, C, E, S, T) {
        "use strict";
        function b(e, t) {
            if (!a(e))return void 0;
            for (var i = e.childNodes, n = i.length, r = 0; n > r; r++) {
                var o = i[r];
                if (o.localName === t)return o
            }
            return void 0
        }

        function w(e, t) {
            if (!a(e))return void 0;
            for (var i = [], n = e.getElementsByTagName(t), r = n.length, o = 0; r > o; o++) {
                var s = n[o];
                s.localName === t && i.push(s)
            }
            return i
        }

        function x(e, t) {
            if (!a(e))return void 0;
            var i = e.getAttribute(t);
            return null !== i ? i : void 0
        }

        function A(e) {
            a(L.building) && (L.building.color = r.clone(L.originalColor, L.building.color), L.building = void 0);
            var t = N.scene.pick(e);
            if (!a(t))return !1;
            if (L.building === t)return !0;
            L.building = t, t === F.building ? (r.clone(F.originalColor, L.originalColor), F.building = void 0) : r.clone(t.color, L.originalColor), t.color = r.clone(r.LIME, t.color);
            var i = t.getProperty("id"), n = t.getProperty("type");
            B.name = i, B.description = 'Loading <div class="cesium-infoBox-loading"></div>', N.selectedEntity = B;
            var o = "https://www.openstreetmap.org/api/0.6/" + n + "/" + i;
            return c(o).then(function (e) {
                for (var t = b(e, "osm"), r = b(t, n), o = w(r, "tag"), s = {}, u = 0; u < o.length; u++)s[x(o[u], "k")] = x(o[u], "v");
                a(s.wikipedia) && (s.wikipedia = '<a target="_blank" href="https://en.wikipedia.org/wiki/' + s.wikipedia + '">' + s.wikipedia + "</a>"), a(s.wikidata) && (s.wikidata = '<a target="_blank" href="https://www.wikidata.org/wiki/' + s.wikidata + '">' + s.wikidata + "</a>");
                var l = '<a target="_blank" href="https://www.openstreetmap.org/' + n + "/" + i + '">' + n + ":" + i + "</a>";
                B.description = P(s, l), a(s.name) && (B.name = s.name)
            }).otherwise(function (e) {
                B.description = "Error loading data from " + o
            }), !0
        }

        function P(e, t) {
            var i = "";
            s(t) && (i += "<tr><th>OSM</th><td>" + t + "</td></tr>");
            for (var n in e)if (e.hasOwnProperty(n) && e.hasOwnProperty(n)) {
                var r = e[n];
                s(r) && (i += "object" == typeof r ? "<tr><th>" + n + "</th><td>" + P(r) + "</td></tr>" : "<tr><th>" + n + "</th><td>" + r + "</td></tr>")
            }
            return i.length > 0 && (i = '<table class="cesium-infoBox-defaultTable"><tbody>' + i + "</tbody></table>"), R.link(i)
        }

        function I(e) {
            for (var t = "", i = e.domain(), n = e.colors(), r = 0; r < n.length; r++)t += '<div><span class="legend-colorBlock" style="background: ' + n[r] + '"></span>', t += r !== n.length - 1 ? i[r] + " to " + i[r + 1] : "Above " + i[r], t += " meters</div>";
            var o = document.getElementById("legend-items");
            o.innerHTML = t
        }

        function D(e) {
            var t = e.split(/[ ,]+/);
            if (t.length > 1) {
                var n = isNaN(+t[0]) ? 0 : +t[0], r = isNaN(+t[1]) ? 0 : +t[1], o = t.length > 2 && !isNaN(+t[2]) ? +t[2] : 300, a = t.length > 3 && !isNaN(+t[3]) ? d.toRadians(+t[3]) : void 0, s = t.length > 4 && !isNaN(+t[4]) ? d.toRadians(+t[4]) : void 0, u = t.length > 5 && !isNaN(+t[5]) ? d.toRadians(+t[5]) : void 0;
                N.camera.flyTo({
                    destination: i.fromDegrees(n, r, o),
                    orientation: {heading: a, pitch: s, roll: u},
                    endTransform: m.IDENTITY,
                    duration: 1
                })
            }
        }

        function M() {
            var e = $.positionCartographic, t = "";
            a($.heading) && (t = "," + d.toDegrees($.heading) + "," + d.toDegrees($.pitch) + "," + d.toDegrees($.roll)), ne.view = d.toDegrees(e.longitude) + "," + d.toDegrees(e.latitude) + "," + e.height + t, history.replaceState(void 0, "", "?" + p(ne))
        }

        var O = new S("palette-picker-container"), R = new y({
            stripPrefix: !1,
            twitter: !1,
            email: !1,
            replaceFn: function (e, t) {
                return t.protocolUrlMatch ? void 0 : !1
            }
        });
        e.defaultKey = "AuQVSGKrGaAfsgpuGwkEd_JZRIBjlu8ZDSqa3AHbknlQ_2G8R55EM7TiJI7_fNkO";
        var N, L = {building: void 0, originalColor: new r}, F = {
            building: void 0,
            originalColor: new r
        }, B = new v, z = document.getElementById("loadingIndicator");
        try {
            N = new E("cesiumContainer", {
                animation: !1,
                terrainProviderViewModels: [],
                scene3DOnly: !0,
                selectionIndicator: !1
            }), N.infoBox.frame.removeAttribute("sandbox")
        } catch (V) {
            z.style.display = "none";
            var U = u(V);
            return console.error(U), void(document.querySelector(".cesium-widget-errorPanel") || window.alert(U))
        }
        N.scene.frameState.creditDisplay.addDefaultCredit(new o("Building data © OpenStreetMap contributors")), N.scene.frameState.creditDisplay.addDefaultCredit(new o("Download this 3D Tiles tileset", void 0, "https://s3.amazonaws.com/cesiumjs/downloads/NewYork.zip"));
        var k = new Date;
        k.setUTCHours(18), k.setUTCMinutes(0);
        var G = l.fromDate(k);
        N.clock.currentTime = G, N.timeline.zoomTo(l.addHours(G, -12, new l), l.addHours(G, 12, new l));
        var H = {leftDown: !1, middleDown: !1, rightDown: !1}, W = N.screenSpaceEventHandler;
        W.setInputAction(function () {
            H.leftDown = !0
        }, _.LEFT_DOWN), W.setInputAction(function () {
            H.middleDown = !0
        }, _.MIDDLE_DOWN), W.setInputAction(function () {
            H.rightDown = !0
        }, _.RIGHT_DOWN), W.setInputAction(function () {
            H.leftDown = !1
        }, _.LEFT_UP), W.setInputAction(function () {
            H.middleDown = !1
        }, _.MIDDLE_UP), W.setInputAction(function () {
            H.rightDown = !1
        }, _.RIGHT_UP);
        var q = "http://cybercity3d-env.elasticbeanstalk.com/", j = /cybercity3d-env\.elasticbeanstalk\.com/, Y = "v0.7";
        h.load = function (e, t, i, r, o, s, u) {
            j.test(e) && (o = a(o) ? n(o) : {}, o.Authorization = "Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI2MzFkYjAwYmFmMzk0NDRhOWIyOTU2NTFkZDQ2NjFjMCIsImlkIjoxLCJzY29wZXMiOlsiYmxkbmciXX0.uQHkqxIYxJiAtPBX0L9plhdOjcS-UOSuHPKrPKvjU5M", e = e + "?" + Y), h.defaultLoad(e, t, i, r, o, s, u)
        };
        var X = N.scene.primitives.add(new g({
            url: q + "api/buildings/OSM/NewYork",
            maximumScreenSpaceError: 16
        })), Z = N.canvas;
        Z.setAttribute("tabindex", "0"), Z.onclick = function () {
            Z.focus()
        };
        var K = document.createElement("div");
        N.container.appendChild(K), K.className = "backdrop", K.style.display = "none", K.style.position = "absolute", K.style.bottom = "0", K.style.left = "0", K.textContent = "", K.style["pointer-events"] = "none";
        var J = W.getInputAction(_.LEFT_CLICK), Q = W.getInputAction(_.LEFT_DOUBLE_CLICK);
        W.setInputAction(function (e) {
            if (H.leftDown || H.middleDown || H.rightDown)return void(K.style.display = "none");
            a(F.building) && (F.building.color = r.clone(F.originalColor, F.building.color), F.building = void 0);
            var t = N.scene.pick(e.endPosition);
            if (a(t)) {
                K.style.display = "block", K.style.bottom = N.canvas.clientHeight - e.endPosition.y + "px", K.style.left = e.endPosition.x + "px";
                var i = t.getProperty("name");
                s(i) || (i = t.getProperty("id")), K.textContent = i, t !== L.building && (F.building = t, r.clone(t.color, F.originalColor), t.color = r.clone(r.YELLOW, t.color))
            } else K.style.display = "none"
        }, _.MOUSE_MOVE), W.setInputAction(function (e) {
            A(e.position) || J(e)
        }, _.LEFT_CLICK), W.setInputAction(function (e) {
            var n = N.scene.pick(e.position);
            if (a(n)) {
                var r = d.toDegrees(parseFloat(n.getProperty("longitude"))), o = d.toDegrees(parseFloat(n.getProperty("latitude"))), s = parseFloat(n.getProperty("height")), u = parseFloat(n.getProperty("area")), l = i.fromDegrees(r, o, s / 2), c = Math.max(s, Math.sqrt(u));
                N.camera.flyToBoundingSphere(new t(l, c), {duration: 1})
            } else Q(e)
        }, _.LEFT_DOUBLE_CLICK), X.readyPromise.then(function () {
            function e(e) {
                if (e.lastUpdate !== o) {
                    e.lastUpdate = o;
                    for (var i = e.content, n = i.batchSize, u = 0; n > u; ++u) {
                        var l = i.getModel(u);
                        if (s) {
                            var c = l.getProperty("height");
                            a(l.originalColor) || (l.originalColor = r.clone(l.color));
                            var h = t(c).rgba(), d = r.fromBytes(h[0], h[1], h[2], 255 * h[3]);
                            l === L.building ? L.originalColor = d : l.color = d
                        } else a(l.originalColor) && (l === L.building ? L.originalColor = r.clone(l.originalColor) : l.color = r.clone(l.originalColor))
                    }
                }
            }

            for (var t = T.scale("PuOr").domain([0, 5, 10, 25, 50, 100, 200, 300, 999]), i = O.choices(), n = 0; n < i.length; n++)"PuOr" === i[n].name && O.selectedItem(i[n]);
            I(t);
            var o = 0, s = !1;
            document.getElementById("showBuildings").addEventListener("change", function (e) {
                N.selectedEntity = void 0, X.show = e.target.checked
            });
            var u = document.getElementById("legend");
            X.tileVisible.addEventListener(e), document.getElementById("colorByHeight").addEventListener("change", function (e) {
                s = e.target.checked, u.style.display = s ? "inline-block" : "none", o++
            }), O.selectedItem.subscribe(function () {
                t = t.range(T.brewer[O.selectedItem().name]), I(t), s && o++
            }), document.getElementById("cover").style.display = "none", document.getElementById("menu").style.display = "inline-block", u.style.display = s ? "inline-block" : "none", z.style.display = "none"
        }), document.getElementById("poi").addEventListener("change", function (e) {
            var t = e.target;
            D(t.options[t.selectedIndex].value)
        });
        var $ = N.camera;
        N.scene.screenSpaceCameraController.minimumZoomDistance = 1, $.setView({
            position: i.fromDegrees(-74.01881302800248, 40.69114333714821, 753.2406554180401),
            heading: d.toRadians(21.27879878293835),
            pitch: d.toRadians(-21.34390550872461),
            roll: d.toRadians(.0716951918898415)
        }), $.lookAtTransform(m.IDENTITY);
        var ee = i.clone($.position), te = i.clone($.direction), ie = i.clone($.up);
        N.homeButton.viewModel.command.beforeExecute.addEventListener(function (e) {
            e.cancel = !0, N.scene.screenSpaceCameraController.minimumZoomDistance = 1, $.flyTo({
                destination: ee,
                orientation: {direction: te, up: ie},
                endTransform: m.IDENTITY,
                duration: 1
            })
        });
        var ne = f(window.location.search.substring(1));
        a(ne.view) && D(ne.view);
        var re;
        "false" !== ne.saveCamera && ($.moveStart.addEventListener(function () {
            a(re) || (re = window.setInterval(M, 1e3))
        }), $.moveEnd.addEventListener(function () {
            a(re) && (window.clearInterval(re), re = void 0), M()
        }))
    }),function (e, t) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define("pep", t) : e.PointerEventsPolyfill = t()
    }(this, function () {
        "use strict";
        function e() {
            if (c) {
                var e = new Map;
                return e.pointers = h, e
            }
            this.keys = [], this.values = []
        }

        function t(e, t, i, n) {
            this.addCallback = e.bind(n), this.removeCallback = t.bind(n), this.changedCallback = i.bind(n), T && (this.observer = new T(this.mutationWatcher.bind(this)))
        }

        function i(e, t) {
            t = t || Object.create(null);
            var i = document.createEvent("Event");
            i.initEvent(e, t.bubbles || !1, t.cancelable || !1);
            for (var n, r = 2; r < A.length; r++)n = A[r], i[n] = t[n] || P[r];
            i.buttons = t.buttons || 0;
            var o = 0;
            return o = t.pressure ? t.pressure : i.buttons ? .5 : 0, i.x = i.clientX, i.y = i.clientY, i.pointerId = t.pointerId || 0, i.width = t.width || 0, i.height = t.height || 0, i.pressure = o, i.tiltX = t.tiltX || 0, i.tiltY = t.tiltY || 0, i.pointerType = t.pointerType || "", i.hwTimestamp = t.hwTimestamp || 0, i.isPrimary = t.isPrimary || !1, i
        }

        function n(e) {
            return "body /shadow-deep/ " + r(e)
        }

        function r(e) {
            return '[touch-action="' + e + '"]'
        }

        function o(e) {
            return "{ -ms-touch-action: " + e + "; touch-action: " + e + "; touch-action-delay: none; }"
        }

        function a() {
            if (O) {
                D.forEach(function (e) {
                    String(e) === e ? (M += r(e) + o(e) + "\n", R && (M += n(e) + o(e) + "\n")) : (M += e.selectors.map(r) + o(e.rule) + "\n", R && (M += e.selectors.map(n) + o(e.rule) + "\n"))
                });
                var e = document.createElement("style");
                e.textContent = M, document.head.appendChild(e)
            }
        }

        function s() {
            if (!window.PointerEvent) {
                if (window.PointerEvent = I, window.navigator.msPointerEnabled) {
                    var e = window.navigator.msMaxTouchPoints;
                    Object.defineProperty(window.navigator, "maxTouchPoints", {
                        value: e,
                        enumerable: !0
                    }), v.registerSource("ms", ne)
                } else v.registerSource("mouse", k), void 0 !== window.ontouchstart && v.registerSource("touch", $);
                v.register(document)
            }
        }

        function u(e) {
            if (!v.pointermap.has(e))throw new Error("InvalidPointerId")
        }

        function l() {
            window.Element && !Element.prototype.setPointerCapture && Object.defineProperties(Element.prototype, {
                setPointerCapture: {value: J},
                releasePointerCapture: {value: Q}
            })
        }

        var c = window.Map && window.Map.prototype.forEach, h = function () {
            return this.size
        };
        e.prototype = {
            set: function (e, t) {
                var i = this.keys.indexOf(e);
                i > -1 ? this.values[i] = t : (this.keys.push(e), this.values.push(t))
            }, has: function (e) {
                return this.keys.indexOf(e) > -1
            }, "delete": function (e) {
                var t = this.keys.indexOf(e);
                t > -1 && (this.keys.splice(t, 1), this.values.splice(t, 1))
            }, get: function (e) {
                var t = this.keys.indexOf(e);
                return this.values[t]
            }, clear: function () {
                this.keys.length = 0, this.values.length = 0
            }, forEach: function (e, t) {
                this.values.forEach(function (i, n) {
                    e.call(t, i, this.keys[n], this)
                }, this)
            }, pointers: function () {
                return this.keys.length
            }
        };
        var d = e, m = ["bubbles", "cancelable", "view", "detail", "screenX", "screenY", "clientX", "clientY", "ctrlKey", "altKey", "shiftKey", "metaKey", "button", "relatedTarget", "buttons", "pointerId", "width", "height", "pressure", "tiltX", "tiltY", "pointerType", "hwTimestamp", "isPrimary", "type", "target", "currentTarget", "which", "pageX", "pageY", "timeStamp"], p = [!1, !1, null, null, 0, 0, 0, 0, !1, !1, !1, !1, 0, null, 0, 0, 0, 0, 0, 0, 0, "", 0, !1, "", null, null, 0, 0, 0, 0], f = "undefined" != typeof SVGElementInstance, _ = {
            pointermap: new d,
            eventMap: Object.create(null),
            captureInfo: Object.create(null),
            eventSources: Object.create(null),
            eventSourceList: [],
            registerSource: function (e, t) {
                var i = t, n = i.events;
                n && (n.forEach(function (e) {
                    i[e] && (this.eventMap[e] = i[e].bind(i))
                }, this), this.eventSources[e] = i, this.eventSourceList.push(i))
            },
            register: function (e) {
                for (var t, i = this.eventSourceList.length, n = 0; i > n && (t = this.eventSourceList[n]); n++)t.register.call(t, e)
            },
            unregister: function (e) {
                for (var t, i = this.eventSourceList.length, n = 0; i > n && (t = this.eventSourceList[n]); n++)t.unregister.call(t, e)
            },
            contains: function (e, t) {
                return e.contains(t)
            },
            down: function (e) {
                e.bubbles = !0, this.fireEvent("pointerdown", e)
            },
            move: function (e) {
                e.bubbles = !0, this.fireEvent("pointermove", e)
            },
            up: function (e) {
                e.bubbles = !0, this.fireEvent("pointerup", e)
            },
            enter: function (e) {
                e.bubbles = !1, this.fireEvent("pointerenter", e)
            },
            leave: function (e) {
                e.bubbles = !1, this.fireEvent("pointerleave", e)
            },
            over: function (e) {
                e.bubbles = !0, this.fireEvent("pointerover", e)
            },
            out: function (e) {
                e.bubbles = !0, this.fireEvent("pointerout", e)
            },
            cancel: function (e) {
                e.bubbles = !0, this.fireEvent("pointercancel", e)
            },
            leaveOut: function (e) {
                this.out(e), this.contains(e.target, e.relatedTarget) || this.leave(e)
            },
            enterOver: function (e) {
                this.over(e), this.contains(e.target, e.relatedTarget) || this.enter(e)
            },
            eventHandler: function (e) {
                if (!e._handledByPE) {
                    var t = e.type, i = this.eventMap && this.eventMap[t];
                    i && i(e), e._handledByPE = !0
                }
            },
            listen: function (e, t) {
                t.forEach(function (t) {
                    this.addEvent(e, t)
                }, this)
            },
            unlisten: function (e, t) {
                t.forEach(function (t) {
                    this.removeEvent(e, t)
                }, this)
            },
            addEvent: function (e, t) {
                e.addEventListener(t, this.boundHandler)
            },
            removeEvent: function (e, t) {
                e.removeEventListener(t, this.boundHandler)
            },
            makeEvent: function (e, t) {
                this.captureInfo[t.pointerId] && (t.relatedTarget = null);
                var i = new PointerEvent(e, t);
                return t.preventDefault && (i.preventDefault = t.preventDefault), i._target = i._target || t.target, i
            },
            fireEvent: function (e, t) {
                var i = this.makeEvent(e, t);
                return this.dispatchEvent(i)
            },
            cloneEvent: function (e) {
                for (var t, i = Object.create(null), n = 0; n < m.length; n++)t = m[n], i[t] = e[t] || p[n], !f || "target" !== t && "relatedTarget" !== t || i[t]instanceof SVGElementInstance && (i[t] = i[t].correspondingUseElement);
                return e.preventDefault && (i.preventDefault = function () {
                    e.preventDefault()
                }), i
            },
            getTarget: function (e) {
                return this.captureInfo[e.pointerId] || e._target
            },
            setCapture: function (e, t) {
                this.captureInfo[e] && this.releaseCapture(e), this.captureInfo[e] = t;
                var i = document.createEvent("Event");
                i.initEvent("gotpointercapture", !0, !1), i.pointerId = e, this.implicitRelease = this.releaseCapture.bind(this, e), document.addEventListener("pointerup", this.implicitRelease), document.addEventListener("pointercancel", this.implicitRelease), i._target = t, this.asyncDispatchEvent(i)
            },
            releaseCapture: function (e) {
                var t = this.captureInfo[e];
                if (t) {
                    var i = document.createEvent("Event");
                    i.initEvent("lostpointercapture", !0, !1), i.pointerId = e, this.captureInfo[e] = void 0, document.removeEventListener("pointerup", this.implicitRelease), document.removeEventListener("pointercancel", this.implicitRelease), i._target = t, this.asyncDispatchEvent(i)
                }
            },
            dispatchEvent: function (e) {
                var t = this.getTarget(e);
                return t ? t.dispatchEvent(e) : void 0
            },
            asyncDispatchEvent: function (e) {
                requestAnimationFrame(this.dispatchEvent.bind(this, e))
            }
        };
        _.boundHandler = _.eventHandler.bind(_);
        var v = _, g = {
            shadow: function (e) {
                return e ? e.shadowRoot || e.webkitShadowRoot : void 0
            }, canTarget: function (e) {
                return e && Boolean(e.elementFromPoint)
            }, targetingShadow: function (e) {
                var t = this.shadow(e);
                return this.canTarget(t) ? t : void 0
            }, olderShadow: function (e) {
                var t = e.olderShadowRoot;
                if (!t) {
                    var i = e.querySelector("shadow");
                    i && (t = i.olderShadowRoot)
                }
                return t
            }, allShadows: function (e) {
                for (var t = [], i = this.shadow(e); i;)t.push(i), i = this.olderShadow(i);
                return t
            }, searchRoot: function (e, t, i) {
                if (e) {
                    var n, r, o = e.elementFromPoint(t, i);
                    for (r = this.targetingShadow(o); r;) {
                        if (n = r.elementFromPoint(t, i)) {
                            var a = this.targetingShadow(n);
                            return this.searchRoot(a, t, i) || n
                        }
                        r = this.olderShadow(r)
                    }
                    return o
                }
            }, owner: function (e) {
                for (var t = e; t.parentNode;)t = t.parentNode;
                return t.nodeType != Node.DOCUMENT_NODE && t.nodeType != Node.DOCUMENT_FRAGMENT_NODE && (t = document), t
            }, findTarget: function (e) {
                var t = e.clientX, i = e.clientY, n = this.owner(e.target);
                return n.elementFromPoint(t, i) || (n = document), this.searchRoot(n, t, i)
            }
        }, y = Array.prototype.forEach.call.bind(Array.prototype.forEach), C = Array.prototype.map.call.bind(Array.prototype.map), E = Array.prototype.slice.call.bind(Array.prototype.slice), S = Array.prototype.filter.call.bind(Array.prototype.filter), T = window.MutationObserver || window.WebKitMutationObserver, b = "[touch-action]", w = {
            subtree: !0,
            childList: !0,
            attributes: !0,
            attributeOldValue: !0,
            attributeFilter: ["touch-action"]
        };
        t.prototype = {
            watchSubtree: function (e) {
                g.canTarget(e) && this.observer.observe(e, w)
            }, enableOnSubtree: function (e) {
                this.watchSubtree(e), e === document && "complete" !== document.readyState ? this.installOnLoad() : this.installNewSubtree(e)
            }, installNewSubtree: function (e) {
                y(this.findElements(e), this.addElement, this)
            }, findElements: function (e) {
                return e.querySelectorAll ? e.querySelectorAll(b) : []
            }, removeElement: function (e) {
                this.removeCallback(e)
            }, addElement: function (e) {
                this.addCallback(e)
            }, elementChanged: function (e, t) {
                this.changedCallback(e, t)
            }, concatLists: function (e, t) {
                return e.concat(E(t))
            }, installOnLoad: function () {
                document.addEventListener("readystatechange", function () {
                    "complete" === document.readyState && this.installNewSubtree(document)
                }.bind(this))
            }, isElement: function (e) {
                return e.nodeType === Node.ELEMENT_NODE
            }, flattenMutationTree: function (e) {
                var t = C(e, this.findElements, this);
                return t.push(S(e, this.isElement)), t.reduce(this.concatLists, [])
            }, mutationWatcher: function (e) {
                e.forEach(this.mutationHandler, this)
            }, mutationHandler: function (e) {
                if ("childList" === e.type) {
                    var t = this.flattenMutationTree(e.addedNodes);
                    t.forEach(this.addElement, this);
                    var i = this.flattenMutationTree(e.removedNodes);
                    i.forEach(this.removeElement, this)
                } else"attributes" === e.type && this.elementChanged(e.target, e.oldValue)
            }
        }, T || (t.prototype.watchSubtree = function () {
            console.warn("PointerEventsPolyfill: MutationObservers not found, touch-action will not be dynamically detected")
        });
        var x = t, A = ["bubbles", "cancelable", "view", "detail", "screenX", "screenY", "clientX", "clientY", "ctrlKey", "altKey", "shiftKey", "metaKey", "button", "relatedTarget", "pageX", "pageY"], P = [!1, !1, null, null, 0, 0, 0, 0, !1, !1, !1, !1, 0, null, 0, 0], I = i, D = ["none", "auto", "pan-x", "pan-y", {
            rule: "pan-x pan-y",
            selectors: ["pan-x pan-y", "pan-y pan-x"]
        }], M = "", O = (document.head, window.PointerEvent || window.MSPointerEvent), R = !window.ShadowDOMPolyfill && document.head.createShadowRoot, N = v.pointermap, L = 25, F = [0, 1, 4, 2], B = !1;
        try {
            B = 1 === new MouseEvent("test", {buttons: 1}).buttons
        } catch (z) {
        }
        var V, U = {
            POINTER_ID: 1,
            POINTER_TYPE: "mouse",
            events: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout"],
            register: function (e) {
                v.listen(e, this.events)
            },
            unregister: function (e) {
                v.unlisten(e, this.events)
            },
            lastTouches: [],
            isEventSimulatedFromTouch: function (e) {
                for (var t, i = this.lastTouches, n = e.clientX, r = e.clientY, o = 0, a = i.length; a > o && (t = i[o]); o++) {
                    var s = Math.abs(n - t.x), u = Math.abs(r - t.y);
                    if (L >= s && L >= u)return !0
                }
            },
            prepareEvent: function (e) {
                var t = v.cloneEvent(e), i = t.preventDefault;
                return t.preventDefault = function () {
                    e.preventDefault(), i()
                }, t.pointerId = this.POINTER_ID, t.isPrimary = !0, t.pointerType = this.POINTER_TYPE, B || (t.buttons = F[t.which] || 0), t
            },
            mousedown: function (e) {
                if (!this.isEventSimulatedFromTouch(e)) {
                    var t = N.has(this.POINTER_ID);
                    t && this.cancel(e);
                    var i = this.prepareEvent(e);
                    N.set(this.POINTER_ID, e), v.down(i)
                }
            },
            mousemove: function (e) {
                if (!this.isEventSimulatedFromTouch(e)) {
                    var t = this.prepareEvent(e);
                    v.move(t)
                }
            },
            mouseup: function (e) {
                if (!this.isEventSimulatedFromTouch(e)) {
                    var t = N.get(this.POINTER_ID);
                    if (t && t.button === e.button) {
                        var i = this.prepareEvent(e);
                        v.up(i), this.cleanupMouse()
                    }
                }
            },
            mouseover: function (e) {
                if (!this.isEventSimulatedFromTouch(e)) {
                    var t = this.prepareEvent(e);
                    v.enterOver(t)
                }
            },
            mouseout: function (e) {
                if (!this.isEventSimulatedFromTouch(e)) {
                    var t = this.prepareEvent(e);
                    v.leaveOut(t)
                }
            },
            cancel: function (e) {
                var t = this.prepareEvent(e);
                v.cancel(t), this.cleanupMouse()
            },
            cleanupMouse: function () {
                N["delete"](this.POINTER_ID)
            }
        }, k = U, G = v.captureInfo, H = g.findTarget.bind(g), W = g.allShadows.bind(g), q = v.pointermap, j = (Array.prototype.map.call.bind(Array.prototype.map), 2500), Y = 200, X = "touch-action", Z = !1, K = {
            events: ["touchstart", "touchmove", "touchend", "touchcancel"],
            register: function (e) {
                Z ? v.listen(e, this.events) : V.enableOnSubtree(e)
            },
            unregister: function (e) {
                Z && v.unlisten(e, this.events)
            },
            elementAdded: function (e) {
                var t = e.getAttribute(X), i = this.touchActionToScrollType(t);
                i && (e._scrollType = i, v.listen(e, this.events), W(e).forEach(function (e) {
                    e._scrollType = i, v.listen(e, this.events)
                }, this))
            },
            elementRemoved: function (e) {
                e._scrollType = void 0, v.unlisten(e, this.events), W(e).forEach(function (e) {
                    e._scrollType = void 0, v.unlisten(e, this.events)
                }, this)
            },
            elementChanged: function (e, t) {
                var i = e.getAttribute(X), n = this.touchActionToScrollType(i), r = this.touchActionToScrollType(t);
                n && r ? (e._scrollType = n, W(e).forEach(function (e) {
                    e._scrollType = n
                }, this)) : r ? this.elementRemoved(e) : n && this.elementAdded(e)
            },
            scrollTypes: {
                EMITTER: "none",
                XSCROLLER: "pan-x",
                YSCROLLER: "pan-y",
                SCROLLER: /^(?:pan-x pan-y)|(?:pan-y pan-x)|auto$/
            },
            touchActionToScrollType: function (e) {
                var t = e, i = this.scrollTypes;
                return "none" === t ? "none" : t === i.XSCROLLER ? "X" : t === i.YSCROLLER ? "Y" : i.SCROLLER.exec(t) ? "XY" : void 0
            },
            POINTER_TYPE: "touch",
            firstTouch: null,
            isPrimaryTouch: function (e) {
                return this.firstTouch === e.identifier
            },
            setPrimaryTouch: function (e) {
                (0 === q.pointers() || 1 === q.pointers() && q.has(1)) && (this.firstTouch = e.identifier, this.firstXY = {
                    X: e.clientX,
                    Y: e.clientY
                }, this.scrolling = !1, this.cancelResetClickCount())
            },
            removePrimaryPointer: function (e) {
                e.isPrimary && (this.firstTouch = null, this.firstXY = null, this.resetClickCount())
            },
            clickCount: 0,
            resetId: null,
            resetClickCount: function () {
                var e = function () {
                    this.clickCount = 0, this.resetId = null
                }.bind(this);
                this.resetId = setTimeout(e, Y)
            },
            cancelResetClickCount: function () {
                this.resetId && clearTimeout(this.resetId)
            },
            typeToButtons: function (e) {
                var t = 0;
                return ("touchstart" === e || "touchmove" === e) && (t = 1), t
            },
            touchToPointer: function (e) {
                var t = this.currentTouchEvent, i = v.cloneEvent(e), n = i.pointerId = e.identifier + 2;
                i.target = G[n] || H(i), i.bubbles = !0, i.cancelable = !0, i.detail = this.clickCount, i.button = 0, i.buttons = this.typeToButtons(t.type), i.width = e.webkitRadiusX || e.radiusX || 0, i.height = e.webkitRadiusY || e.radiusY || 0, i.pressure = e.webkitForce || e.force || .5, i.isPrimary = this.isPrimaryTouch(e), i.pointerType = this.POINTER_TYPE;
                var r = this;
                return i.preventDefault = function () {
                    r.scrolling = !1, r.firstXY = null, t.preventDefault()
                }, i
            },
            processTouches: function (e, t) {
                var i = e.changedTouches;
                this.currentTouchEvent = e;
                for (var n, r = 0; r < i.length; r++)n = i[r], t.call(this, this.touchToPointer(n))
            },
            shouldScroll: function (e) {
                if (this.firstXY) {
                    var t, i = e.currentTarget._scrollType;
                    if ("none" === i)t = !1; else if ("XY" === i)t = !0; else {
                        var n = e.changedTouches[0], r = i, o = "Y" === i ? "X" : "Y", a = Math.abs(n["client" + r] - this.firstXY[r]), s = Math.abs(n["client" + o] - this.firstXY[o]);
                        t = a >= s
                    }
                    return this.firstXY = null, t
                }
            },
            findTouch: function (e, t) {
                for (var i, n = 0, r = e.length; r > n && (i = e[n]); n++)if (i.identifier === t)return !0
            },
            vacuumTouches: function (e) {
                var t = e.touches;
                if (q.pointers() >= t.length) {
                    var i = [];
                    q.forEach(function (e, n) {
                        if (1 !== n && !this.findTouch(t, n - 2)) {
                            var r = e.out;
                            i.push(r)
                        }
                    }, this), i.forEach(this.cancelOut, this)
                }
            },
            touchstart: function (e) {
                this.vacuumTouches(e), this.setPrimaryTouch(e.changedTouches[0]), this.dedupSynthMouse(e), this.scrolling || (this.clickCount++, this.processTouches(e, this.overDown))
            },
            overDown: function (e) {
                q.set(e.pointerId, {target: e.target, out: e, outTarget: e.target});
                v.over(e), v.enter(e), v.down(e)
            },
            touchmove: function (e) {
                this.scrolling || (this.shouldScroll(e) ? (this.scrolling = !0, this.touchcancel(e)) : (e.preventDefault(), this.processTouches(e, this.moveOverOut)))
            },
            moveOverOut: function (e) {
                var t = e, i = q.get(t.pointerId);
                if (i) {
                    var n = i.out, r = i.outTarget;
                    v.move(t), n && r !== t.target && (n.relatedTarget = t.target, t.relatedTarget = r, n.target = r, t.target ? (v.leaveOut(n), v.enterOver(t)) : (t.target = r, t.relatedTarget = null, this.cancelOut(t))), i.out = t, i.outTarget = t.target
                }
            },
            touchend: function (e) {
                this.dedupSynthMouse(e), this.processTouches(e, this.upOut)
            },
            upOut: function (e) {
                this.scrolling || (v.up(e), v.out(e), v.leave(e)), this.cleanUpPointer(e)
            },
            touchcancel: function (e) {
                this.processTouches(e, this.cancelOut)
            },
            cancelOut: function (e) {
                v.cancel(e), v.out(e), v.leave(e), this.cleanUpPointer(e)
            },
            cleanUpPointer: function (e) {
                q["delete"](e.pointerId), this.removePrimaryPointer(e)
            },
            dedupSynthMouse: function (e) {
                var t = k.lastTouches, i = e.changedTouches[0];
                if (this.isPrimaryTouch(i)) {
                    var n = {x: i.clientX, y: i.clientY};
                    t.push(n);
                    var r = function (e, t) {
                        var i = e.indexOf(t);
                        i > -1 && e.splice(i, 1)
                    }.bind(null, t, n);
                    setTimeout(r, j)
                }
            }
        };
        Z || (V = new x(K.elementAdded, K.elementRemoved, K.elementChanged, K));
        var J, Q, $ = K, ee = v.pointermap, te = window.MSPointerEvent && "number" == typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE, ie = {
            events: ["MSPointerDown", "MSPointerMove", "MSPointerUp", "MSPointerOut", "MSPointerOver", "MSPointerCancel", "MSGotPointerCapture", "MSLostPointerCapture"],
            register: function (e) {
                v.listen(e, this.events)
            },
            unregister: function (e) {
                v.unlisten(e, this.events)
            },
            POINTER_TYPES: ["", "unavailable", "touch", "pen", "mouse"],
            prepareEvent: function (e) {
                var t = e;
                return te && (t = v.cloneEvent(e), t.pointerType = this.POINTER_TYPES[e.pointerType]), t
            },
            cleanup: function (e) {
                ee["delete"](e)
            },
            MSPointerDown: function (e) {
                ee.set(e.pointerId, e);
                var t = this.prepareEvent(e);
                v.down(t)
            },
            MSPointerMove: function (e) {
                var t = this.prepareEvent(e);
                v.move(t)
            },
            MSPointerUp: function (e) {
                var t = this.prepareEvent(e);
                v.up(t), this.cleanup(e.pointerId)
            },
            MSPointerOut: function (e) {
                var t = this.prepareEvent(e);
                v.leaveOut(t)
            },
            MSPointerOver: function (e) {
                var t = this.prepareEvent(e);
                v.enterOver(t)
            },
            MSPointerCancel: function (e) {
                var t = this.prepareEvent(e);
                v.cancel(t), this.cleanup(e.pointerId)
            },
            MSLostPointerCapture: function (e) {
                var t = v.makeEvent("lostpointercapture", e);
                v.dispatchEvent(t)
            },
            MSGotPointerCapture: function (e) {
                var t = v.makeEvent("gotpointercapture", e);
                v.dispatchEvent(t)
            }
        }, ne = ie, re = window.navigator;
        re.msPointerEnabled ? (J = function (e) {
            u(e), this.msSetPointerCapture(e)
        }, Q = function (e) {
            u(e), this.msReleasePointerCapture(e)
        }) : (J = function (e) {
            u(e), v.setCapture(e, this)
        }, Q = function (e) {
            u(e), v.releaseCapture(e, this)
        }), a(), s(), l();
        var oe = {dispatcher: v, Installer: x, PointerEvent: I, PointerMap: d, targetFinding: g};
        return oe
    }),require({
        baseUrl: ".",
        paths: {
            text: "ThirdParty/requirejs-2.1.18/text",
            Cesium: "Cesium",
            chroma: "ThirdParty/chroma",
            pep: "ThirdParty/pep"
        },
        shim: {chroma: {exports: "chroma"}}
    }, ["app", "pep"], function () {
    }),define("index", function () {
    })
}();
/**
 * Created by chet on 15/10/19.
 */
